(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["main"],{

/***/ "./node_modules/raw-loader/dist/cjs.js!./src/app/app.component.html":
/*!**************************************************************************!*\
  !*** ./node_modules/raw-loader/dist/cjs.js!./src/app/app.component.html ***!
  \**************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("<!-- <div *ngIf=\"!files.length\" class=\"col-12 rmpm dropzone\" appDrag (files)=\"filesDropped($event)\">\n\t<div class=\"text-wrapper\">\n\t\t<div class=\"centered\">Drop your file here!</div>\n\t</div>\n</div> -->\n<div class='viewers-container' appDrag (files)=\"filesDropped($event)\">\n    <div class='content__panel'>\n        <gi-viewer [data]=model></gi-viewer>\n    </div>\n</div>");

/***/ }),

/***/ "./node_modules/raw-loader/dist/cjs.js!./src/app/gi-viewer/attribute/attribute.component.html":
/*!****************************************************************************************************!*\
  !*** ./node_modules/raw-loader/dist/cjs.js!./src/app/gi-viewer/attribute/attribute.component.html ***!
  \****************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("<div class = 'attrib--container'>\r\n  <my-tabs id=\"attribTab\" (selectedTab) = \"_setDataSource($event)\" (selectedTopology) = \"_setDataSource($event)\" [hidden]=\"dataSource === undefined\">\r\n    <my-tab *ngFor=\"let tab of tabs; let i = index\" tabTitle=\"{{tab.title}}\" index=\"{{i}}\">\r\n      <div class=\"mat-elevation-z1\">\r\n        <div class = \"table--container\">\r\n          <!-- <dl id='attribLabel'>\r\n              <dd *ngFor=\"let label of displayedColumns;\">\r\n                <span [class]='label'></span>\r\n              </dd>\r\n          </dl> -->\r\n          <table mat-table [dataSource]=\"dataSource\" matSort [class] = 'columnItalic' id = 'attribTable'>\r\n            <ng-container *ngFor=\"let column of displayedColumns;\" [matColumnDef]=\"column\" [sticky] = 'column === \"_id\"'>\r\n                <th mat-header-cell *matHeaderCellDef mat-sort-header (click)=\"updateSortHeader($event, column)\"> {{column}} \r\n                    <!-- <i class=\"material-icons\" (click)=\"showAttribLabel($event, column)\" [class.active]=\"currentShowingCol === column\">visibility</i> -->\r\n                    <mat-icon class=\"material-icons\" svgIcon=\"cVisibility\" (click)=\"showAttribLabel($event, column)\" [class.active]=\"currentShowingCol === column\"></mat-icon>\r\n                </th>\r\n                <td mat-cell *matCellDef=\"let element\"> {{element[column]}} </td>\r\n            </ng-container>\r\n            <tr mat-header-row *matHeaderRowDef=\"displayedColumns; sticky: true\"></tr>\r\n            <tr mat-row *matRowDef=\"let row; columns: displayedColumns;\" [class.selected-row]='row.selected?row.selected:false' (click)=\"selectRow(row._id, $event)\"></tr>\r\n          </table>\r\n          <div *ngIf=\"dataSource && dataSource.data.length === 0\" id=\"emptyMessage\">\r\n            No Data\r\n          </div>\r\n           \r\n        </div>\r\n        <div class = 'btm--container'>\r\n          <div id=\"displaySelected\">\r\n            <label class=\"container\">Show Selected\r\n              <input type=\"checkbox\" id=\"switch\" (click)=\"showSelectedSwitch();\" [checked]=\"showSelected\"/>\r\n              <span class=\"checkmark\"></span>\r\n            </label>\r\n          </div>\r\n          <div class = 'paginator--container'>\r\n            <mat-paginator id=\"matPaginator\" [pageSizeOptions]=\"[20, 50, 100]\" showFirstLastButtons></mat-paginator>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    </my-tab>\r\n  </my-tabs>\r\n</div>\r\n  ");

/***/ }),

/***/ "./node_modules/raw-loader/dist/cjs.js!./src/app/gi-viewer/attribute/tabs.component.html":
/*!***********************************************************************************************!*\
  !*** ./node_modules/raw-loader/dist/cjs.js!./src/app/gi-viewer/attribute/tabs.component.html ***!
  \***********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("<ul class=\"nav nav-tabs\">\r\n    <li (click)=\"selectTab(0)\" [class.active]=\"tab_active===0\"><span>Positions</span></li>\r\n    <li\r\n        [class.active]=\"tab_active===1\"\r\n        [class.open]='topology_open'\r\n    >\r\n        <div class=\"dropdown\">\r\n            <button class=\"dropbtn\" (click) = 'showTDropdown()' title=\"Topology{{topology_text!=='Topology'?(': '+topology_text):''}}\">{{topology_text}}</button>\r\n            <div class=\"dropdown-content\" id='topology_dropdown'>\r\n                <div *ngFor=\"let option of topology;\" (click)=\"selectTopology(option.tab, $event);\">{{option.title}}</div>\r\n            </div>\r\n        </div>\r\n    </li>\r\n    <li\r\n        [class.active]=\"tab_active===2\"\r\n        [class.open]='object_open'\r\n    >\r\n        <div class=\"dropdown\">\r\n            <button class=\"dropbtn\" (click) = 'showODropdown()' title=\"Object{{object_text!=='Object'?(': '+object_text):''}}\">{{object_text}}</button>\r\n            <div class=\"dropdown-content\" id='object_dropdown'>\r\n                <div *ngFor=\"let option of object;\" (click)=\"selectObject(option.tab, $event);\">{{option.title}}</div>\r\n            </div>\r\n        </div>\r\n    </li>\r\n    <li (click)=\"selectTab(8)\" [class.active]=\"tab_active===8\"><span>Collections</span></li>\r\n    <li (click)=\"selectTab(9)\" [class.active]=\"tab_active===9\"><span>Model</span></li>\r\n</ul>\r\n<ng-content></ng-content>\r\n\r\n<ng-template #topoTemplate>\r\n    \r\n</ng-template>\r\n\r\n<ng-template #objectTemplate>\r\n    \r\n</ng-template>\r\n\r\n");

/***/ }),

/***/ "./node_modules/raw-loader/dist/cjs.js!./src/app/gi-viewer/gi-viewer.component.html":
/*!******************************************************************************************!*\
  !*** ./node_modules/raw-loader/dist/cjs.js!./src/app/gi-viewer/gi-viewer.component.html ***!
  \******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("<div id=\"gi-viewer-container\">\r\n\t<as-split #viewerSplit direction=\"vertical\" (dragEnd)='dragSplitEnd($event)' [disabled]='checkPublish()'>\r\n\t\t<as-split-area [size]=\"100 - getSplit()\" id=\"three-js\">\r\n\t\t\t<threejs-viewer [model]='data'\r\n\t\t\t(action)=\"threejsAction($event)\"\r\n\t\t\t\t[attr_table_select]='attrTableSelect'\r\n\t\t\t\t[selectSwitch] = 'selectSwitchOnOff'\r\n\t\t\t\t[attribLabel] = 'attribLabelVal'\r\n\t\t\t></threejs-viewer>\r\n\t\t\t<button class='btn' id=\"settings_button\" mat-icon-button (click)=\"openModal('settings_modal')\" title=\"Settings\"><mat-icon svgIcon=\"settings\"></mat-icon></button>\r\n\t\t</as-split-area>\r\n\t\t<as-split-area [size]='getSplit()' id=\"attrib\">\r\n\t\t\t<attribute [model]=\"data\"\r\n\t\t\t\t[refresh]=\"clickedEvent\"\r\n\t\t\t\t[reset]=\"attrTableReset\"\r\n\t\t\t\t(attrTableSelect) = \"attribTableSelected($event)\"\r\n\t\t\t\t(selectSwitch) = \"selectSwitch($event)\"\r\n\t\t\t\t(attribLabel) = \"attribLabel($event)\"\r\n\t\t\t>\r\n\t\t\t</attribute>\r\n\t\t</as-split-area>\r\n\t</as-split>\r\n    <modal-window id=\"settings_modal\" (closeModal) = 'onCloseModal()'>\r\n        <h1>3D Viewer Settings</h1>\r\n        <tabs id=\"settingsTab\">\r\n            <tab tabTitle=\"Scene\">\r\n                <div class=\"mat-elevation-z1\">\r\n                    <dl>\r\n                        <!-- <dd [title] = \"!normalsEnabled?'No models available':''\">\r\n                            <div class=\"label\">Normals</div>\r\n                            <div class=\"onoffswitch\">\r\n                                <input type=\"checkbox\"\r\n                                name=\"onoffswitch\"\r\n                                class=\"onoffswitch-checkbox\"\r\n                                id=\"normalsOnOff\"\r\n                                [checked]='settings.normals.show'\r\n                                [disabled] = \"!normalsEnabled\"\r\n                                (change)=\"settingOnChange('normals.show')\"\r\n                                >\r\n                                <label class=\"onoffswitch-label\" for=\"normalsOnOff\">\r\n                                    <span class=\"onoffswitch-inner\"></span>\r\n                                    <span class=\"onoffswitch-switch\"></span>\r\n                                </label>\r\n                            </div>\r\n                            <div class=\"slidecontainer\">\r\n                                <input type=\"range\" min=\"1\" max=\"100\" step=\"1\"\r\n                                [value]=\"settings.normals.size\"\r\n                                class=\"slider\" id=\"normalSize\"\r\n                                (input)=\"settingOnChange('normals.size', $event.target.value)\"\r\n                                [disabled] = \"!normalsEnabled\">\r\n                                <input type=\"text\" [value]=\"settings.normals.size\" disabled>\r\n                            </div>\r\n                        </dd> -->\r\n                        <dd>\r\n                            <div class=\"label\">Axes</div>\r\n                            <div class=\"onoffswitch\">\r\n                                <input type=\"checkbox\"\r\n                                name=\"onoffswitch\"\r\n                                class=\"onoffswitch-checkbox\"\r\n                                id=\"axesOnOff\"\r\n                                [checked]=\"settings.axes.show\"\r\n                                (change)=\"settingOnChange('axes.show')\">\r\n                                <label class=\"onoffswitch-label\" for=\"axesOnOff\">\r\n                                    <span class=\"onoffswitch-inner\"></span>\r\n                                    <span class=\"onoffswitch-switch\"></span>\r\n                                </label>\r\n                            </div>\r\n                            <div class=\"slidecontainer\">\r\n                                <input type=\"range\" min=\"1\" max=\"1000\" step=\"1\" \r\n                                [value]=\"settings.axes.size\" class=\"slider\" id=\"axesSize\" \r\n                                (input)=\"settingOnChange('axes.size', $event.target.value)\">\r\n                                <input type=\"text\" [value]=\"settings.axes.size\" \r\n                                (input)=\"settingOnChange('axes.size', $event.target.value)\">\r\n                            </div>\r\n                        </dd>\r\n                        <dd>\r\n                            <div class=\"label\">Positions</div>\r\n                            <div class=\"onoffswitch\">\r\n                                <input type=\"checkbox\"\r\n                                name=\"onoffswitch\"\r\n                                class=\"onoffswitch-checkbox\"\r\n                                id=\"positionsOnOff\"\r\n                                [checked]='settings.positions.show'\r\n                                (change)=\"settingOnChange('positions.show')\"\r\n                                >\r\n                                <label class=\"onoffswitch-label\" for=\"positionsOnOff\">\r\n                                    <span class=\"onoffswitch-inner\"></span>\r\n                                    <span class=\"onoffswitch-switch\"></span>\r\n                                </label>\r\n                            </div>\r\n                            <div class=\"slidecontainer\">\r\n                                <input type=\"range\" min=\"0.1\" max=\"10\" step=\"0.1\" [value]=\"settings.positions.size\" class=\"slider\" id=\"positionsSize\" (input)=\"settingOnChange('positions.size', $event.target.value)\">\r\n                                <input type=\"text\" [value]=\"settings.positions.size\" disabled>\r\n                            </div>\r\n                        </dd>\r\n                        <dd>\r\n                            <div class=\"label\">Wireframe</div>\r\n                            <div class=\"onoffswitch\">\r\n                                <input type=\"checkbox\"\r\n                                name=\"onoffswitch\"\r\n                                class=\"onoffswitch-checkbox\"\r\n                                id=\"wireframeOnOff\"\r\n                                [checked]='settings.wireframe.show'\r\n                                (change)=\"settingOnChange('wireframe.show')\"\r\n                                >\r\n                                <label class=\"onoffswitch-label\" for=\"wireframeOnOff\">\r\n                                    <span class=\"onoffswitch-inner\"></span>\r\n                                    <span class=\"onoffswitch-switch\"></span>\r\n                                </label>\r\n                            </div>\r\n                        </dd>\r\n                        <dd>\r\n                            <div class=\"label\">GI Summary</div>\r\n                            <div class=\"onoffswitch\">\r\n                                <input type=\"checkbox\"\r\n                                name=\"onoffswitch\"\r\n                                class=\"onoffswitch-checkbox\"\r\n                                id=\"gi_summaryOnOff\"\r\n                                [checked]='settings.gi_summary.show'\r\n                                (change)=\"settingOnChange('gi_summary.show')\"\r\n                                >\r\n                                <label class=\"onoffswitch-label\" for=\"gi_summaryOnOff\">\r\n                                    <span class=\"onoffswitch-inner\"></span>\r\n                                    <span class=\"onoffswitch-switch\"></span>\r\n                                </label>\r\n                            </div>\r\n                        </dd>\r\n                        <dd>\r\n                            <div class=\"label\">Threejs Summary</div>\r\n                            <div class=\"onoffswitch\">\r\n                                <input type=\"checkbox\"\r\n                                name=\"onoffswitch\"\r\n                                class=\"onoffswitch-checkbox\"\r\n                                id=\"tjs_summaryOnOff\"\r\n                                [checked]='settings.tjs_summary.show'\r\n                                (change)=\"settingOnChange('tjs_summary.show')\"\r\n                                >\r\n                                <label class=\"onoffswitch-label\" for=\"tjs_summaryOnOff\">\r\n                                    <span class=\"onoffswitch-inner\"></span>\r\n                                    <span class=\"onoffswitch-switch\"></span>\r\n                                </label>\r\n                            </div>\r\n                        </dd>\r\n                        <dd><hr></dd>\r\n                        <dd id='camera'>\r\n                            <div class=\"label\">Camera Position</div>\r\n                            <input type=\"number\"\r\n                            (change)=\"settingOnChange('camera.pos_x', $event.target.value)\" \r\n                            [value]=\"formatNumber(settings.camera.pos.x)\">\r\n                            <input type=\"number\"\r\n                            (change)=\"settingOnChange('camera.pos_y', $event.target.value)\" \r\n                            [value]=\"formatNumber(settings.camera.pos.y)\">\r\n                            <input type=\"number\"\r\n                            (change)=\"settingOnChange('camera.pos_z', $event.target.value)\" \r\n                            [value]=\"formatNumber(settings.camera.pos.z)\">\r\n                            <button (click)=\"settingOnChange('camera.get_camera_pos')\" class=\"filebtn getbtn\">Get</button>\r\n                        </dd>\r\n                        <dd id='camera_target'>\r\n                            <div class=\"label\">Camera Target</div>\r\n                            <input type=\"number\"\r\n                            (change)=\"settingOnChange('camera.target_x', $event.target.value)\" \r\n                            [value]=\"formatNumber(settings.camera.target.x)\">\r\n                            <input type=\"number\" \r\n                            (change)=\"settingOnChange('camera.target_y', $event.target.value)\"\r\n                            [value]=\"formatNumber(settings.camera.target.y)\">\r\n                            <input type=\"number\" \r\n                            (change)=\"settingOnChange('camera.target_z', $event.target.value)\"\r\n                            [value]=\"formatNumber(settings.camera.target.z)\">\r\n                            <button (click)=\"settingOnChange('camera.get_target_pos')\" class=\"filebtn getbtn\">Get</button>\r\n                        </dd>\r\n                        <dd><hr></dd>\r\n                        <dd>\r\n                            <div class=\"label\">Grid</div>\r\n                            <div class=\"onoffswitch\">\r\n                                <input type=\"checkbox\"\r\n                                name=\"onoffswitch\"\r\n                                class=\"onoffswitch-checkbox\"\r\n                                id=\"gridOnOff\"\r\n                                [checked]='settings.grid.show'\r\n                                (change)=\"settingOnChange('grid.show')\"\r\n                                >\r\n                                <label class=\"onoffswitch-label\" for=\"gridOnOff\">\r\n                                    <span class=\"onoffswitch-inner\"></span>\r\n                                    <span class=\"onoffswitch-switch\"></span>\r\n                                </label>\r\n\r\n                            </div>\r\n                        </dd>\r\n                        <dd>\r\n                            <div class=\"label\">Grid Size</div>\r\n                            <!-- <div class=\"onoffswitch\">\r\n                            </div> -->\r\n                            <div class=\"slidecontainer light\">\r\n                                <input type=\"range\" min=\"10\" max=\"10000\" step=\"10\" [value]=\"settings.grid.size\" class=\"slider\" id=\"gridSize\" (input)=\"settingOnChange('grid.size', $event.target.value)\">\r\n                                <input type=\"text\" [value]=\"settings.grid.size\" disabled>\r\n                            </div>\r\n                        </dd>\r\n\r\n                        <dd id='grid_pos'>\r\n                            <div class=\"label\">Grid Position</div>\r\n                            <input type=\"number\"\r\n                            [value]=\"formatNumber(settings.grid.pos_x)\"\r\n                            (change)=\"settingOnChange('grid.update_pos_x', $event.target.value)\">\r\n                            <input type=\"number\"\r\n                            [value]=\"formatNumber(settings.grid.pos_y)\"\r\n                            (change)=\"settingOnChange('grid.update_pos_y', $event.target.value)\">\r\n                            <input type=\"number\"\r\n                            [value]=\"formatNumber(settings.grid.pos_z)\"\r\n                            (change)=\"settingOnChange('grid.update_pos_z', $event.target.value)\">\r\n                            <button (click)=\"settingOnChange('grid.update_pos')\" class=\"filebtn getbtn\">Get</button>\r\n                        </dd>\r\n                        <dd><hr></dd>\r\n                        <dd>\r\n                            <div class=\"label\">Preset Background</div>\r\n                            <div class=\"onoffswitch\">\r\n                                <input type=\"checkbox\"\r\n                                name=\"onoffswitch\"\r\n                                class=\"onoffswitch-checkbox\"\r\n                                id=\"backgroundOnOff\"\r\n                                [checked]='settings.background.show'\r\n                                (change)=\"settingOnChange('background.show')\"\r\n                                >\r\n                                <label class=\"onoffswitch-label\" for=\"backgroundOnOff\">\r\n                                    <span class=\"onoffswitch-inner\"></span>\r\n                                    <span class=\"onoffswitch-switch\"></span>\r\n                                </label>\r\n                            </div>\r\n                        </dd>\r\n                        <dd>\r\n                            <div class=\"label\">Background Set</div>\r\n                            <select value={{settings.background.background_set}}\r\n                            (change)=\"settingOnChange('background.set', $event.target.value)\">\r\n                            <!--\r\n                                background folder: \"\\src\\assets\\img\\background\\\"\r\n                                each background corresponds to a folder in the directory:\r\n                                    option value = 0 -> folder bg0\r\n                                    option value = 1 -> folder bg1\r\n                                    ...\r\n                            -->\r\n                                <option value=0>Sky 1</option>\r\n                                <option value=1>Sky 2</option>\r\n                                <option value=2>Sky 3</option>\r\n                                <option value=3>Sky 4</option>\r\n                                <option value=4>Sky 5</option>\r\n                                <option value=5>Sky 6</option>\r\n                                <option value=6>Sky 7</option>\r\n                            </select>\r\n                            \r\n\r\n                            <!-- <div class=\"onoffswitch\">\r\n                                <input type=\"checkbox\"\r\n                                name=\"onoffswitch\"\r\n                                class=\"onoffswitch-checkbox\"\r\n                                id=\"backgroundSelect\"\r\n                                [checked]='settings.grid.show'\r\n                                (change)=\"settingOnChange('grid.show')\"\r\n                                >\r\n                                <label class=\"onoffswitch-label\" for=\"backgroundSelect\">\r\n                                    <span class=\"onoffswitch-inner\"></span>\r\n                                    <span class=\"onoffswitch-switch\"></span>\r\n                                </label>\r\n                            </div> -->\r\n                        </dd>\r\n\r\n                    </dl>\r\n                </div>\r\n            </tab>\r\n            <tab tabTitle=\"Colors\">\r\n                <div class=\"mat-elevation-z1\">\r\n                    <dl>\r\n                        <dd class='colors' *ngFor=\"let item of setting_colors; let i = index\">\r\n                            <div class=\"label\">{{item.label}}</div>\r\n                            <input\r\n                            [(colorPicker)]=\"settings.colors[item.setting]\"\r\n                            [style.background]=\"settings.colors[item.setting]\"\r\n                            [value]=\"settings.colors[item.setting]\"\r\n                            [class.light] = \"checkColor(this.settings.colors[item.setting])\"\r\n                            />\r\n                            <!-- <button *ngIf=\"item.default\" (click)=\"resetDefault('colors.viewer_bg','#E6E6E6');\" class='filebtn closebtn'>Default</button> -->\r\n                            <hr [hidden]=\"i % 2 === 1\">\r\n                        </dd>\r\n                    </dl>\r\n                </div>\r\n            </tab>\r\n            <tab tabTitle=\"Light & Shadow\">\r\n                <div class=\"mat-elevation-z1\">\r\n                    <dl>\r\n                        <dd>\r\n                            <div class=\"label\">Ambient Light</div>\r\n                            <div class=\"onoffswitch\">\r\n                                <input type=\"checkbox\"\r\n                                name=\"onoffswitch\"\r\n                                class=\"onoffswitch-checkbox\"\r\n                                id=\"AmbientOnOff\"\r\n                                [checked]='settings.ambient_light.show'\r\n                                (change)=\"settingOnChange('ambient_light.show')\"\r\n                                >\r\n                                <label class=\"onoffswitch-label\" for=\"AmbientOnOff\">\r\n                                    <span class=\"onoffswitch-inner\"></span>\r\n                                    <span class=\"onoffswitch-switch\"></span>\r\n                                </label>\r\n                            </div>\r\n                        </dd>\r\n                        <dd class='colors'>\r\n                            <div class=\"label\">Color</div>\r\n                            <input\r\n                            [(colorPicker)]=\"settings.ambient_light.color\"\r\n                            [style.background]=\"settings.ambient_light.color\"\r\n                            [value]=\"settings.ambient_light.color\"\r\n                            [class.light] = \"checkColor(settings.ambient_light.color)\"\r\n                            />\r\n                            <!-- <button (click)=\"resetDefault('ambient_light.color','#FFFFFF');\" class='filebtn closebtn'>Default</button> -->\r\n                        </dd>\r\n                        <dd>\r\n                            <div class=\"label\">Intensity</div>\r\n                            <div class=\"slidecontainer light\">\r\n                                <input type=\"range\" min=\"0\" max=\"1\" step=\"0.01\" [value]=\"settings.ambient_light.intensity\" class=\"slider\" (input)=\"settingOnChange('ambient_light.intensity', $event.target.value)\">\r\n                                <input type=\"text\" [value]=\"settings.ambient_light.intensity\" disabled>\r\n                            </div>\r\n                        </dd>\r\n                        <dd><hr></dd>\r\n                        <dd>\r\n                            <div class=\"label\">Hemisphere Light</div>\r\n                            <div class=\"onoffswitch\">\r\n                                <input type=\"checkbox\"\r\n                                name=\"onoffswitch\"\r\n                                class=\"onoffswitch-checkbox\"\r\n                                id=\"HemisphereOnOff\"\r\n                                [checked]='settings.hemisphere_light.show'\r\n                                (change)=\"settingOnChange('hemisphere_light.show')\"\r\n                                >\r\n                                <label class=\"onoffswitch-label\" for=\"HemisphereOnOff\">\r\n                                    <span class=\"onoffswitch-inner\"></span>\r\n                                    <span class=\"onoffswitch-switch\"></span>\r\n                                </label>\r\n                            </div>\r\n                            <div class=\"label\" style=\"margin-left:90px\">Helper</div>\r\n                            <div class=\"onoffswitch\">\r\n                                <input type=\"checkbox\"\r\n                                name=\"onoffswitch\"\r\n                                class=\"onoffswitch-checkbox\"\r\n                                id=\"HemisphereLightHelperOnOff\"\r\n                                [checked]='settings.hemisphere_light.helper'\r\n                                (change)=\"settingOnChange('hemisphere_light.helper')\"\r\n                                >\r\n                                <label class=\"onoffswitch-label\" for=\"HemisphereLightHelperOnOff\">\r\n                                    <span class=\"onoffswitch-inner\"></span>\r\n                                    <span class=\"onoffswitch-switch\"></span>\r\n                                </label>\r\n                            </div>\r\n                        </dd>\r\n                        <dd class='colors'>\r\n                            <div class=\"label\">Sky Color</div>\r\n                            <input\r\n                            [(colorPicker)]=\"settings.hemisphere_light.skyColor\"\r\n                            [style.background]=\"settings.hemisphere_light.skyColor\"\r\n                            [value]=\"settings.hemisphere_light.skyColor\"\r\n                            [class.light] = \"checkColor(settings.hemisphere_light.skyColor)\"\r\n                            />\r\n                            <!-- <button (click)=\"resetDefault('hemisphere_light.skyColor','#FFFFFF');\" class='filebtn closebtn'>Default</button> -->\r\n                        </dd>\r\n                        <dd class='colors'>\r\n                            <div class=\"label\">Ground Color</div>\r\n                            <input\r\n                            [(colorPicker)]=\"settings.hemisphere_light.groundColor\"\r\n                            [style.background]=\"settings.hemisphere_light.groundColor\"\r\n                            [value]=\"settings.hemisphere_light.groundColor\"\r\n                            [class.light] = \"checkColor(settings.hemisphere_light.groundColor)\"\r\n                            />\r\n                            <!-- <button (click)=\"resetDefault('hemisphere_light.groundColor','#FFFFFF');\" class='filebtn closebtn'>Default</button> -->\r\n                        </dd>\r\n                        <dd>\r\n                            <div class=\"label\">Intensity</div>\r\n                            <div class=\"slidecontainer light\">\r\n                                <input type=\"range\" min=\"0\" max=\"1\" step=\"0.01\" [value]=\"settings.hemisphere_light.intensity\" class=\"slider\" (input)=\"settingOnChange('hemisphere_light.intensity', $event.target.value)\">\r\n                                <input type=\"text\" [value]=\"settings.hemisphere_light.intensity\" disabled>\r\n                            </div>\r\n                        </dd>\r\n                        <dd><hr></dd>\r\n                        <dd>\r\n                            <div class=\"label\" title='directional_light'>Directional Light</div>\r\n                            <div class=\"onoffswitch\">\r\n                                <input type=\"checkbox\"\r\n                                name=\"onoffswitch\"\r\n                                class=\"onoffswitch-checkbox\"\r\n                                id=\"DirectionalOnOff\"\r\n                                [checked]='settings.directional_light.show'\r\n                                (change)=\"settingOnChange('directional_light.show')\"\r\n                                >\r\n                                <label class=\"onoffswitch-label\" for=\"DirectionalOnOff\">\r\n                                    <span class=\"onoffswitch-inner\"></span>\r\n                                    <span class=\"onoffswitch-switch\"></span>\r\n                                </label>\r\n                            </div>\r\n                            <div class=\"label\" style=\"margin-left:90px\">Helper</div>\r\n                            <div class=\"onoffswitch\">\r\n                                <input type=\"checkbox\"\r\n                                name=\"onoffswitch\"\r\n                                class=\"onoffswitch-checkbox\"\r\n                                id=\"DaylightHelperOnOff\"\r\n                                [checked]='settings.directional_light.helper'\r\n                                (change)=\"settingOnChange('directional_light.helper')\"\r\n                                >\r\n                                <label class=\"onoffswitch-label\" for=\"DaylightHelperOnOff\">\r\n                                    <span class=\"onoffswitch-inner\"></span>\r\n                                    <span class=\"onoffswitch-switch\"></span>\r\n                                </label>\r\n                            </div>\r\n                        </dd>\r\n                        <!-- <dd>\r\n                            <div class=\"label\">Light Type</div>\r\n                            <div class=\"label\">Directional Light</div>\r\n                            <div class=\"onoffswitch radio\">\r\n                                <input type=\"checkbox\"\r\n                                name=\"onoffswitch\"\r\n                                class=\"onoffswitch-checkbox\"\r\n                                id=\"DirectionalTypeDir\"\r\n                                [checked]='settings.directional_light.type == \"directional\"'\r\n                                (change)=\"settingOnChange('directional_light.type')\"\r\n                                >\r\n                                <label class=\"onoffswitch-label\" for=\"DirectionalTypeDir\">\r\n                                    <span class=\"onoffswitch-inner\"></span>\r\n                                    <span class=\"onoffswitch-switch\"></span>\r\n                                </label>\r\n                            </div>\r\n                        </dd>\r\n                        <dd>\r\n                            <div class=\"label\" style=\"margin-left:120px\">Point Light</div>\r\n                            <div class=\"onoffswitch radio\">\r\n                                <input type=\"checkbox\"\r\n                                name=\"onoffswitch\"\r\n                                class=\"onoffswitch-checkbox\"\r\n                                id=\"DirectionalTypePoint\"\r\n                                [checked]='settings.directional_light.type == \"point\"'\r\n                                (change)=\"settingOnChange('directional_light.type')\"\r\n                                >\r\n                                <label class=\"onoffswitch-label\" for=\"DirectionalTypePoint\">\r\n                                    <span class=\"onoffswitch-inner\"></span>\r\n                                    <span class=\"onoffswitch-switch\"></span>\r\n                                </label>\r\n                            </div>\r\n                        </dd> -->\r\n                        <dd class='colors'>\r\n                            <div class=\"label\">Color</div>\r\n                            <input\r\n                            [(colorPicker)]=\"settings.directional_light.color\"\r\n                            [style.background]=\"settings.directional_light.color\"\r\n                            [value]=\"settings.directional_light.color\"\r\n                            [class.light] = \"checkColor(settings.directional_light.color)\"\r\n                            />\r\n                            <!-- <button (click)=\"resetDefault('directional_light.color','#FFFFFF');\" class='filebtn closebtn'>Default</button> -->\r\n                        </dd>\r\n                        <dd>\r\n                            <div class=\"label\">Intensity</div>\r\n                            <div class=\"slidecontainer light\">\r\n                                <input type=\"range\" min=\"0\" max=\"1\" step=\"0.01\" [value]=\"settings.directional_light.intensity\" class=\"slider\" (input)=\"settingOnChange('directional_light.intensity', $event.target.value)\">\r\n                                <input type=\"text\" [value]=\"settings.directional_light.intensity\" disabled>\r\n                            </div>\r\n                        </dd>\r\n                        <dd>\r\n                            <div class=\"label\">Shadow</div>\r\n                            <div class=\"onoffswitch\">\r\n                                <input type=\"checkbox\"\r\n                                name=\"onoffswitch\"\r\n                                class=\"onoffswitch-checkbox\"\r\n                                id=\"DirectionalShadowOnOff\"\r\n                                [checked]='settings.directional_light.shadow'\r\n                                (change)=\"settingOnChange('directional_light.shadow')\"\r\n                                >\r\n                                <label class=\"onoffswitch-label\" for=\"DirectionalShadowOnOff\">\r\n                                    <span class=\"onoffswitch-inner\"></span>\r\n                                    <span class=\"onoffswitch-switch\"></span>\r\n                                </label>\r\n                            </div>\r\n                        </dd>\r\n                        <dd>\r\n                            <div class=\"label\">Shadow Intensity</div>\r\n                            <div class=\"slidecontainer light\">\r\n                                <input type=\"range\" min=\"1024\" max=\"5120\" step=\"512\" [value]=\"settings.directional_light.shadowSize\" class=\"slider\" (input)=\"settingOnChange('directional_light.shadowSize', $event.target.value)\">\r\n                                <input type=\"text\" [value]=\"settings.directional_light.shadowSize\" disabled>\r\n                            </div>\r\n                        </dd>\r\n                        <dd>\r\n                            <div class=\"label\" title='directional_light.azimuth'>Azimuth</div>\r\n                            <div class=\"slidecontainer light\">\r\n                                <input type=\"range\" min=\"0\" max=\"360\" step=\"1\" [value]=\"settings.directional_light.azimuth\" class=\"slider\" (input)=\"settingOnChange('directional_light.azimuth', $event.target.value)\">\r\n                                <input type=\"number\" disabled [value]=\"settings.directional_light.azimuth\" class=\"number\">\r\n                            </div>\r\n                        </dd>\r\n                        <dd>\r\n                            <div class=\"label\" title='directional_light.altitude'>Altitude</div>\r\n                            <div class=\"slidecontainer light\">\r\n                                <input type=\"range\" min=\"0\" max=\"90\" step=\"1\" [value]=\"settings.directional_light.altitude\" class=\"slider\" (input)=\"settingOnChange('directional_light.altitude', $event.target.value)\">\r\n                                <input type=\"number\" disabled [value]=\"settings.directional_light.altitude\" class=\"number\">\r\n                            </div>\r\n                        </dd>\r\n                        <!-- <dd>\r\n                            <div class=\"label\">Distance</div>\r\n                            <div class=\"slidecontainer light\">\r\n                                <input type=\"range\" min=\"100\" max=\"1000\" step=\"10\" [value]=\"settings.directional_light.distance\" class=\"slider\" (input)=\"settingOnChange('directional_light.distance', $event.target.value)\">\r\n                                <input type=\"text\" [value]=\"settings.directional_light.distance\" disabled>\r\n                            </div>\r\n                        </dd> -->\r\n                    </dl>\r\n                </div>\r\n            </tab>\r\n            <tab tabTitle=\"Environment\">\r\n                <div class=\"mat-elevation-z1\">\r\n                    <dl>\r\n                        <dd>\r\n                            <div class=\"label\">Ground</div>\r\n                            <div class=\"onoffswitch\">\r\n                                <input type=\"checkbox\"\r\n                                name=\"onoffswitch\"\r\n                                class=\"onoffswitch-checkbox\"\r\n                                id=\"GroundOnOff\"\r\n                                [checked]='settings.ground.show'\r\n                                (change)=\"settingOnChange('ground.show')\"\r\n                                >\r\n                                <label class=\"onoffswitch-label\" for=\"GroundOnOff\">\r\n                                    <span class=\"onoffswitch-inner\"></span>\r\n                                    <span class=\"onoffswitch-switch\"></span>\r\n                                </label>\r\n                            </div>\r\n                        </dd>\r\n                        <dd>\r\n                            <div class=\"label\">Width</div>\r\n                            <div class=\"slidecontainer light\">\r\n                                <input type=\"range\" min=\"0\" max=\"100000\" step=\"100\" [value]=\"settings.ground.width\" class=\"slider\" (input)=\"settingOnChange('ground.width', $event.target.value)\">\r\n                                <input type=\"number\" [value]=\"settings.ground.width\" min=\"0\" max=\"100000\" class=\"number\" (input)=\"settingOnChange('ground.width', $event.target.value)\">\r\n                            </div>\r\n                        </dd>\r\n                        <dd>\r\n                            <div class=\"label\">Length</div>\r\n                            <div class=\"slidecontainer light\">\r\n                                <input type=\"range\" min=\"0\" max=\"100000\" step=\"100\" [value]=\"settings.ground.length\" class=\"slider\" (input)=\"settingOnChange('ground.length', $event.target.value)\">\r\n                                <input type=\"number\" [value]=\"settings.ground.length\" min=\"0\" max=\"100000\" class=\"number\" (input)=\"settingOnChange('ground.length', $event.target.value)\">\r\n                            </div>\r\n                        </dd>\r\n                        <dd>\r\n                            <div class=\"label\">Height</div>\r\n                            <div class=\"slidecontainer light\">\r\n                                <input type=\"range\" min=\"-10\" max=\"10\" step=\"0.1\" [value]=\"settings.ground.height\" class=\"slider\" (input)=\"settingOnChange('ground.height', $event.target.value)\">\r\n                                <input type=\"number\" [value]=\"settings.ground.height\" min=\"-10\" max=\"10\" class=\"number\" (input)=\"settingOnChange('ground.height', $event.target.value)\">\r\n                            </div>\r\n                        </dd>\r\n                        <dd class='colors'>\r\n                            <div class=\"label\">Color</div>\r\n                            <input\r\n                            [(colorPicker)]=\"settings.ground.color\"\r\n                            [style.background]=\"settings.ground.color\"\r\n                            [value]=\"settings.ground.color\"\r\n                            [class.light] = \"checkColor(settings.ground.color)\"\r\n                            />\r\n                            <!-- <button (click)=\"resetDefault('ground.color','#FFFFFF');\" class='filebtn closebtn'>Default</button> -->\r\n                        </dd>\r\n                        <dd>\r\n                            <div class=\"label\">Shininess</div>\r\n                            <div class=\"slidecontainer light\">\r\n                                <input type=\"range\" min=\"0\" max=\"100\" step=\"1\" [value]=\"settings.ground.shininess\" class=\"slider\" (input)=\"settingOnChange('ground.shininess', $event.target.value)\">\r\n                                <input type=\"number\" min=\"0\" max=\"100\" [value]=\"settings.ground.shininess\" class=\"number\" (input)=\"settingOnChange('ground.shininess', $event.target.value)\">\r\n                            </div>\r\n                        </dd>\r\n                    </dl>\r\n                    \r\n                </div>\r\n            </tab>\r\n            <tab tabTitle=\"Entity selection\">\r\n                <div class=\"mat-elevation-z1\">\r\n                    <dl>\r\n                        <dd>\r\n                            <div class=\"label\">Positions (ps)</div>\r\n                            <div class=\"onoffswitch\">\r\n                                <input type=\"checkbox\"\r\n                                name=\"onoffswitch\"\r\n                                class=\"onoffswitch-checkbox\"\r\n                                id=\"psOnOff\"\r\n                                [checked]='settings.select.enabledselector.ps'\r\n                                (change)=\"settingOnChange('select.ps')\"\r\n                                >\r\n                                <label class=\"onoffswitch-label\" for=\"psOnOff\">\r\n                                    <span class=\"onoffswitch-inner\"></span>\r\n                                    <span class=\"onoffswitch-switch\"></span>\r\n                                </label>\r\n                            </div>\r\n                        </dd>\r\n                        <dd>\r\n                            <div class=\"label\">Vertices (_v)</div>\r\n                            <div class=\"onoffswitch\">\r\n                                <input type=\"checkbox\"\r\n                                name=\"onoffswitch\"\r\n                                class=\"onoffswitch-checkbox\"\r\n                                id=\"_vOnOff\"\r\n                                [checked]='settings.select.enabledselector._v'\r\n                                (change)=\"settingOnChange('select._v')\"\r\n                                >\r\n                                <label class=\"onoffswitch-label\" for=\"_vOnOff\">\r\n                                    <span class=\"onoffswitch-inner\"></span>\r\n                                    <span class=\"onoffswitch-switch\"></span>\r\n                                </label>\r\n                            </div>\r\n                        </dd>\r\n                        <dd>\r\n                            <div class=\"label\">Edges (_e)</div>\r\n                            <div class=\"onoffswitch\">\r\n                                <input type=\"checkbox\"\r\n                                name=\"onoffswitch\"\r\n                                class=\"onoffswitch-checkbox\"\r\n                                id=\"_eOnOff\"\r\n                                [checked]='settings.select.enabledselector._e'\r\n                                (change)=\"settingOnChange('select._e')\"\r\n                                >\r\n                                <label class=\"onoffswitch-label\" for=\"_eOnOff\">\r\n                                    <span class=\"onoffswitch-inner\"></span>\r\n                                    <span class=\"onoffswitch-switch\"></span>\r\n                                </label>\r\n                            </div>\r\n                        </dd>\r\n                        <dd>\r\n                            <div class=\"label\">Wires (_w)</div>\r\n                            <div class=\"onoffswitch\">\r\n                                <input type=\"checkbox\"\r\n                                name=\"onoffswitch\"\r\n                                class=\"onoffswitch-checkbox\"\r\n                                id=\"_wOnOff\"\r\n                                [checked]='settings.select.enabledselector._w'\r\n                                (change)=\"settingOnChange('select._w')\"\r\n                                >\r\n                                <label class=\"onoffswitch-label\" for=\"_wOnOff\">\r\n                                    <span class=\"onoffswitch-inner\"></span>\r\n                                    <span class=\"onoffswitch-switch\"></span>\r\n                                </label>\r\n                            </div>\r\n                        </dd>\r\n                        <dd>\r\n                            <div class=\"label\">Faces (_f)</div>\r\n                            <div class=\"onoffswitch\">\r\n                                <input type=\"checkbox\"\r\n                                name=\"onoffswitch\"\r\n                                class=\"onoffswitch-checkbox\"\r\n                                id=\"_fOnOff\"\r\n                                [checked]='settings.select.enabledselector._f'\r\n                                (change)=\"settingOnChange('select._f')\"\r\n                                >\r\n                                <label class=\"onoffswitch-label\" for=\"_fOnOff\">\r\n                                    <span class=\"onoffswitch-inner\"></span>\r\n                                    <span class=\"onoffswitch-switch\"></span>\r\n                                </label>\r\n                            </div>\r\n                        </dd>\r\n                        <dd>\r\n                            <div class=\"label\">Points (pt)</div>\r\n                            <div class=\"onoffswitch\">\r\n                                <input type=\"checkbox\"\r\n                                name=\"onoffswitch\"\r\n                                class=\"onoffswitch-checkbox\"\r\n                                id=\"ptOnOff\"\r\n                                [checked]='settings.select.enabledselector.pt'\r\n                                (change)=\"settingOnChange('select.pt')\"\r\n                                >\r\n                                <label class=\"onoffswitch-label\" for=\"ptOnOff\">\r\n                                    <span class=\"onoffswitch-inner\"></span>\r\n                                    <span class=\"onoffswitch-switch\"></span>\r\n                                </label>\r\n                            </div>\r\n                        </dd>\r\n                        <dd>\r\n                            <div class=\"label\">Polylines (pl)</div>\r\n                            <div class=\"onoffswitch\">\r\n                                <input type=\"checkbox\"\r\n                                name=\"onoffswitch\"\r\n                                class=\"onoffswitch-checkbox\"\r\n                                id=\"plOnOff\"\r\n                                [checked]='settings.select.enabledselector.pl'\r\n                                (change)=\"settingOnChange('select.pl')\"\r\n                                >\r\n                                <label class=\"onoffswitch-label\" for=\"plOnOff\">\r\n                                    <span class=\"onoffswitch-inner\"></span>\r\n                                    <span class=\"onoffswitch-switch\"></span>\r\n                                </label>\r\n                            </div>\r\n                        </dd>\r\n                        <dd>\r\n                            <div class=\"label\">Polygons (pg)</div>\r\n                            <div class=\"onoffswitch\">\r\n                                <input type=\"checkbox\"\r\n                                name=\"onoffswitch\"\r\n                                class=\"onoffswitch-checkbox\"\r\n                                id=\"pgOnOff\"\r\n                                [checked]='settings.select.enabledselector.pg'\r\n                                (change)=\"settingOnChange('select.pg')\"\r\n                                >\r\n                                <label class=\"onoffswitch-label\" for=\"pgOnOff\">\r\n                                    <span class=\"onoffswitch-inner\"></span>\r\n                                    <span class=\"onoffswitch-switch\"></span>\r\n                                </label>\r\n                            </div>\r\n                        </dd>\r\n                        <dd>\r\n                            <div class=\"label\">Collections (co)</div>\r\n                            <div class=\"onoffswitch\">\r\n                                <input type=\"checkbox\"\r\n                                name=\"onoffswitch\"\r\n                                class=\"onoffswitch-checkbox\"\r\n                                id=\"coOnOff\"\r\n                                [checked]='settings.select.enabledselector.co'\r\n                                (change)=\"settingOnChange('select.co')\"\r\n                                >\r\n                                <label class=\"onoffswitch-label\" for=\"coOnOff\">\r\n                                    <span class=\"onoffswitch-inner\"></span>\r\n                                    <span class=\"onoffswitch-switch\"></span>\r\n                                </label>\r\n                            </div>\r\n                        </dd>\r\n                    </dl>\r\n                    \r\n                </div>\r\n            </tab>\r\n        </tabs>\r\n        \r\n        <button (click)=\"closeModal('settings_modal', true);\" class=\"filebtn closebtn setting\">Apply</button>\r\n        <button (click)=\"closeModal('settings_modal');\" class='filebtn closebtn setting'>Cancel</button>\r\n        <button (click)=\"resetToDefault();\" class='filebtn closebtn setting' style=\"float: right;\">Default</button>\r\n    </modal-window>\r\n</div>\r\n");

/***/ }),

/***/ "./node_modules/raw-loader/dist/cjs.js!./src/app/gi-viewer/html/dropdown-menu.component.html":
/*!***************************************************************************************************!*\
  !*** ./node_modules/raw-loader/dist/cjs.js!./src/app/gi-viewer/html/dropdown-menu.component.html ***!
  \***************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("<div\r\n    [hidden]=\"!visible\"\r\n    [style.left.px]='position.x'\r\n    [style.top.px]='position.y'\r\n>\r\n    <ul>\r\n        <ol>Please choose:</ol>\r\n        <ol *ngFor=\"let item of items\" (click)=\"selectItem(item)\">{{item.label}}</ol>\r\n    </ul>\r\n</div>\r\n");

/***/ }),

/***/ "./node_modules/raw-loader/dist/cjs.js!./src/app/gi-viewer/html/modal-window.component.html":
/*!**************************************************************************************************!*\
  !*** ./node_modules/raw-loader/dist/cjs.js!./src/app/gi-viewer/html/modal-window.component.html ***!
  \**************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("<div class=\"modal-window\" id=\"modal-window\">\r\n    <div class=\"modal-body\">\r\n        <ng-content></ng-content>\r\n    </div>\r\n</div>\r\n<div class=\"modal-background\"></div>");

/***/ }),

/***/ "./node_modules/raw-loader/dist/cjs.js!./src/app/gi-viewer/html/tabs.component.html":
/*!******************************************************************************************!*\
  !*** ./node_modules/raw-loader/dist/cjs.js!./src/app/gi-viewer/html/tabs.component.html ***!
  \******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("<ul class=\"nav nav-tabs\">\r\n    <li\r\n        *ngFor=\"let tab of tabs;\"\r\n        (click)=\"selectTab(tab)\"\r\n        [class.active]=\"tab.active\"\r\n    >\r\n        <div>\r\n            <span>{{tab.title}}</span>\r\n        </div>\r\n    </li>\r\n    \r\n</ul>\r\n<ng-content></ng-content>\r\n");

/***/ }),

/***/ "./node_modules/raw-loader/dist/cjs.js!./src/app/gi-viewer/threejs/threejs-viewer.component.html":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/raw-loader/dist/cjs.js!./src/app/gi-viewer/threejs/threejs-viewer.component.html ***!
  \*******************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("<div\r\n    id=\"threejs-container\"\r\n    (window:mousedown)=\"onMouseDown($event)\"\r\n    (window:mouseup)=\"onMouseUp($event)\"\r\n>\r\n    <div\r\n        *ngIf=\"_model_error\"\r\n        style=\"position:absolute;color:red;margin-top: 50px;left:40%;text-align: center;font-family:sans-serif;font-size: 14px;background-color: white;\"\r\n    >\r\n        Error displaying model:{{text}}\r\n    </div>\r\n    <div\r\n        *ngIf=\"_no_model\"\r\n        style=\"position:absolute;color:red;margin-top: 50px;left:40%;text-align: center;font-family:sans-serif;font-size: 14px;background-color: white;\"\r\n    >\r\n        Model or Scene not defined.\r\n    </div>\r\n    <div class = \"messages\"\r\n        *ngIf=\"messageVisible\"\r\n    >\r\n        {{message}}\r\n    </div>\r\n\r\n    <button\r\n        id=\"zoomingfit\"\r\n        mat-icon-button\r\n        (click)=\"zoomfit()\"\r\n        title='Zoom to Fit Model'\r\n    >\r\n        <mat-icon svgIcon=\"cZoom\"></mat-icon>\r\n    </button>\r\n\r\n    <span\r\n        class=\"switchCameraButton\"\r\n        mat-icon-button\r\n        (click)=\"switchCamera()\"\r\n        title='Switch Camera'\r\n    >\r\n        <mat-icon svgIcon=\"cControlCam\"></mat-icon>\r\n        <p>{{_data_threejs.currentCamera}}</p>\r\n    </span>\r\n    <ng-container *ngIf=\"enableSelect()\">\r\n        <button\r\n            id=\"EntitySelection\"\r\n            mat-icon-button\r\n            (click)=\"selectDropdownVisible = !selectDropdownVisible\"\r\n            title='Selection Type'\r\n        >\r\n            <mat-icon svgIcon=\"select\"></mat-icon>\r\n        </button>\r\n        <span\r\n            *ngIf=\"!selectDropdownVisible\"\r\n            id=\"SelectingEntityType\"\r\n            matTooltip=\"Selecting {{SelectingEntityType.name}}\"\r\n            (click)=\"selectDropdownVisible = !selectDropdownVisible; needSelect=false\"\r\n        >\r\n            {{EntTypeToStr(SelectingEntityType.id)}}\r\n        </span>\r\n        <div id=\"selectDropdown\" *ngIf=\"selectDropdownVisible == true\" >\r\n            <button\r\n                *ngFor=\"let selection of selections\"\r\n                (click)=\"selectEntityType(selection); needSelect=false\"\r\n                [class.active]=\"SelectingEntityType.id === selection.id\"\r\n            >\r\n                <span matTooltip=\"Select {{selection.name}}\">{{EntTypeToStr(selection.id)}}</span>\r\n            </button>\r\n        </div>\r\n    </ng-container>\r\n\r\n    <div id=\"giSummary\" [hidden]='!this._data_threejs.settings.gi_summary.show'>\r\n        <tbody>\r\n            <tr *ngFor=\"let item of giSummary\">\r\n                <td style=\"width: 80px;\">{{item.title}}</td><td>{{item.val}}</td>\r\n            </tr>\r\n        </tbody>\r\n    </div>\r\n    <div id=\"tjsSummary\" [hidden]='!this._data_threejs.settings.tjs_summary.show'>\r\n        <tbody>\r\n            <tr>\r\n                <td\r\n                    align=left\r\n                    style=\"width: 80px;\"\r\n                >\r\n                    3js Triangles:\r\n                </td>\r\n                <td\r\n                    align=left\r\n                    style=\"width: 20px;\"\r\n                >\r\n                    {{_threejs_nums[2]}}\r\n                </td>\r\n            </tr>\r\n            <tr>\r\n                <td\r\n                    align=left\r\n                    style=\"width: 80px;\"\r\n                >\r\n                    3js Edges:\r\n                </td>\r\n                <td\r\n                    align=left\r\n                    style=\"width: 20px;\"\r\n                >\r\n                    {{_threejs_nums[1]}}\r\n                </td>\r\n            </tr>\r\n            <tr>\r\n                <td\r\n                    align=left\r\n                    style=\"width: 80px;\"\r\n                >\r\n                    3js Points:\r\n                </td>\r\n                <td\r\n                    align=left\r\n                    style=\"width: 20px;\"\r\n                >\r\n                    {{_threejs_nums[0]}}\r\n                </td>\r\n            </tr>\r\n        </tbody>\r\n    </div>\r\n\r\n    <div id=\"nodeSelect_slider\" *ngIf='this._data_threejs.timelineEnabled == 1'>\r\n        <input type=\"range\" id=\"nodeSelect_slider_input\"\r\n            min=\"0\" [max]=getMaxNodeSelect() step=\"1\"\r\n            [style.width]=getSliderWidth()\r\n            [value]=_data_threejs.timelineIndex (change)='changeNodeSlider($event)'\r\n            list=\"nodeSelect_datalist\">\r\n        <datalist id=\"nodeSelect_datalist\">\r\n            <option *ngFor='let time_point of _data_threejs.timeline_groups' value={{time_point}} label={{time_point}}></option>\r\n        </datalist>\r\n    </div>\r\n    <div id=\"nodeSelect_dropdown\" *ngIf='this._data_threejs.timelineEnabled == 2'>\r\n        <select  type=\"range\" id=\"nodeSelect_dropdown_input\" [value]=_data_threejs.timelineValue (change)='changeNodeDropdown($event)'>\r\n            <option *ngFor='let time_point of _data_threejs.timeline_groups' value={{time_point}} label={{time_point}}></option>\r\n        </select>\r\n    </div>\r\n\r\n    <dropdown-menu (selected)='selectEntity($event)'></dropdown-menu>\r\n</div>\r\n");

/***/ }),

/***/ "./src/$$_lazy_route_resource lazy recursive":
/*!**********************************************************!*\
  !*** ./src/$$_lazy_route_resource lazy namespace object ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function webpackEmptyAsyncContext(req) {
	// Here Promise.resolve().then() is used instead of new Promise() to prevent
	// uncaught exception popping up in devtools
	return Promise.resolve().then(function() {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	});
}
webpackEmptyAsyncContext.keys = function() { return []; };
webpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext;
module.exports = webpackEmptyAsyncContext;
webpackEmptyAsyncContext.id = "./src/$$_lazy_route_resource lazy recursive";

/***/ }),

/***/ "./src/app/app.component.scss":
/*!************************************!*\
  !*** ./src/app/app.component.scss ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("p {\n  font-family: Lato;\n}\n\n.dropzone {\n  min-height: 400px;\n  min-width: 400px;\n  display: table;\n  width: 100%;\n  background-color: #eee;\n  border: dotted 1px #aaa;\n}\n\n.text-wrapper {\n  display: table-cell;\n  vertical-align: middle;\n}\n\n.centered {\n  font-family: sans-serif;\n  font-size: 1.3em;\n  font-weight: bold;\n  text-align: center;\n}\n\n.viewers-container {\n  position: relative;\n  display: block;\n  height: 100%;\n  overflow: hidden;\n}\n\n.viewers-container .container__header {\n  position: absolute;\n  left: 0;\n  top: 0;\n  display: flex;\n  background-color: transparent;\n  height: 40px;\n  padding: 0px;\n  margin: 0px;\n}\n\n.viewers-container .container__header .header-btn-group {\n  height: 40px;\n  padding: 0px;\n  margin: 0px;\n  overflow: hidden;\n  background-color: transparent;\n  z-index: 1;\n}\n\n.viewers-container .content__panel {\n  background-color: transparent;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n  padding: 0px;\n  margin: 0px;\n}\n\n.viewers-container button {\n  display: inline-block;\n  vertical-align: bottom;\n  background-color: transparent;\n  color: #808080;\n  border: none;\n  outline: none;\n  cursor: pointer;\n  padding: 0px;\n  width: 34px;\n  height: 34px;\n  transition: 0.3s;\n  font-size: 14px;\n}\n\n.viewers-container button:hover {\n  color: #00006d;\n}\n\n.viewers-container button.active {\n  color: #00006d;\n}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9hcHAvQzpcXFVzZXJzXFxha2liZHB0XFxEb2N1bWVudHNcXEFuZ3VsYXJcXG1vYml1cy12aWV3ZXIvc3JjXFxhcHBcXGFwcC5jb21wb25lbnQuc2NzcyIsInNyYy9hcHAvYXBwLmNvbXBvbmVudC5zY3NzIiwic3JjL2FwcC9DOlxcVXNlcnNcXGFraWJkcHRcXERvY3VtZW50c1xcQW5ndWxhclxcbW9iaXVzLXZpZXdlci9zcmNcXHNjc3NcXHZhcmlhYmxlcy5zY3NzIiwic3JjL2FwcC9DOlxcVXNlcnNcXGFraWJkcHRcXERvY3VtZW50c1xcQW5ndWxhclxcbW9iaXVzLXZpZXdlci9zcmNcXHNjc3NcXGNvbG9ycy5zY3NzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUlBO0VBQ0ksaUJBQUE7QUNISjs7QURLQTtFQUNJLGlCQUFBO0VBQ0EsZ0JBQUE7RUFDQSxjQUFBO0VBQ0EsV0FBQTtFQUNBLHNCQUFBO0VBQ0EsdUJBQUE7QUNGSjs7QURLQTtFQUNJLG1CQUFBO0VBQ0Esc0JBQUE7QUNGSjs7QURLQTtFQUNJLHVCQUFBO0VBQ0EsZ0JBQUE7RUFDQSxpQkFBQTtFQUNBLGtCQUFBO0FDRko7O0FETUE7RUFDSSxrQkFBQTtFQUNBLGNBQUE7RUFDQSxZQUFBO0VBQ0EsZ0JBQUE7QUNISjs7QURLSTtFQUNJLGtCQUFBO0VBQ0EsT0FBQTtFQUNBLE1BQUE7RUFDQSxhQUFBO0VBQ0EsNkJBQUE7RUFDQSxZRXZDUTtFRndDUixZQUFBO0VBQ0EsV0FBQTtBQ0hSOztBREtRO0VBRUksWUU3Q0k7RUY4Q0osWUFBQTtFQUNBLFdBQUE7RUFDQSxnQkFBQTtFQUNBLDZCQUFBO0VBQ0EsVUFBQTtBQ0paOztBRE9JO0VBQ0ksNkJBQUE7RUFDQSxXQUFBO0VBQ0EsWUFBQTtFQUNBLGdCQUFBO0VBQ0EsWUFBQTtFQUNBLFdBQUE7QUNMUjs7QURTSTtFQUNJLHFCQUFBO0VBQ0Esc0JBQUE7RUFDQSw2QkFBQTtFQUNBLGNHcEVDO0VIcUVELFlBQUE7RUFDQSxhQUFBO0VBQ0EsZUFBQTtFQUNBLFlBQUE7RUFDQSxXQUFBO0VBQ0EsWUFBQTtFQUNBLGdCQUFBO0VBQ0EsZUFBQTtBQ1BSOztBRFFRO0VBQ0ksY0duRUs7QUY2RGpCOztBRFFRO0VBQ0ksY0d0RUs7QUZnRWpCIiwiZmlsZSI6InNyYy9hcHAvYXBwLmNvbXBvbmVudC5zY3NzIiwic291cmNlc0NvbnRlbnQiOlsiQGltcG9ydCAnfnNjc3MvY29sb3JzJztcclxuQGltcG9ydCAnfnNjc3MvdmFyaWFibGVzJztcclxuXHJcbi8vIHRoZSBob3N0XHJcbnAge1xyXG4gICAgZm9udC1mYW1pbHk6IExhdG87XHJcbn1cclxuLmRyb3B6b25lIHtcclxuICAgIG1pbi1oZWlnaHQ6IDQwMHB4O1xyXG4gICAgbWluLXdpZHRoOiA0MDBweDtcclxuICAgIGRpc3BsYXk6IHRhYmxlO1xyXG4gICAgd2lkdGg6IDEwMCU7XHJcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZWVlO1xyXG4gICAgYm9yZGVyOiBkb3R0ZWQgMXB4ICNhYWE7XHJcbn1cclxuICBcclxuLnRleHQtd3JhcHBlciB7XHJcbiAgICBkaXNwbGF5OiB0YWJsZS1jZWxsO1xyXG4gICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcclxufVxyXG4gIFxyXG4uY2VudGVyZWQge1xyXG4gICAgZm9udC1mYW1pbHk6IHNhbnMtc2VyaWY7XHJcbiAgICBmb250LXNpemU6IDEuM2VtO1xyXG4gICAgZm9udC13ZWlnaHQ6IGJvbGQ7XHJcbiAgICB0ZXh0LWFsaWduOmNlbnRlcjtcclxufVxyXG5cclxuXHJcbi52aWV3ZXJzLWNvbnRhaW5lcntcclxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcclxuICAgIGRpc3BsYXk6IGJsb2NrO1xyXG4gICAgaGVpZ2h0OiAxMDAlO1xyXG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcclxuXHJcbiAgICAuY29udGFpbmVyX19oZWFkZXJ7XHJcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xyXG4gICAgICAgIGxlZnQ6IDA7XHJcbiAgICAgICAgdG9wOiAwO1xyXG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XHJcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XHJcbiAgICAgICAgaGVpZ2h0OiAkaGVhZGVyLWhlaWdodDtcclxuICAgICAgICBwYWRkaW5nOiAwcHg7XHJcbiAgICAgICAgbWFyZ2luOiAwcHg7XHJcbiAgICBcclxuICAgICAgICAuaGVhZGVyLWJ0bi1ncm91cCB7XHJcbiAgICAgICAgICAgIC8vZGlzcGxheTogaW5saW5lO1xyXG4gICAgICAgICAgICBoZWlnaHQ6ICRoZWFkZXItaGVpZ2h0O1xyXG4gICAgICAgICAgICBwYWRkaW5nOiAwcHg7XHJcbiAgICAgICAgICAgIG1hcmdpbjogMHB4O1xyXG4gICAgICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcclxuICAgICAgICAgICAgei1pbmRleDogMTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAuY29udGVudF9fcGFuZWx7XHJcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XHJcbiAgICAgICAgd2lkdGg6IDEwMCU7XHJcbiAgICAgICAgaGVpZ2h0OiAxMDAlOyBcclxuICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xyXG4gICAgICAgIHBhZGRpbmc6IDBweDtcclxuICAgICAgICBtYXJnaW46IDBweDtcclxuICAgIFxyXG4gICAgICAgIC8vcGFkZGluZzogMTBweCAxNXB4O1xyXG4gICAgfVxyXG4gICAgYnV0dG9uIHtcclxuICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XHJcbiAgICAgICAgdmVydGljYWwtYWxpZ246IGJvdHRvbTtcclxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcclxuICAgICAgICBjb2xvcjogJGNvbG9yMTtcclxuICAgICAgICBib3JkZXI6IG5vbmU7XHJcbiAgICAgICAgb3V0bGluZTogbm9uZTtcclxuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XHJcbiAgICAgICAgcGFkZGluZzogMHB4O1xyXG4gICAgICAgIHdpZHRoOiAzNHB4O1xyXG4gICAgICAgIGhlaWdodDogMzRweDtcclxuICAgICAgICB0cmFuc2l0aW9uOiAwLjNzO1xyXG4gICAgICAgIGZvbnQtc2l6ZTogMTRweDtcclxuICAgICAgICAmOmhvdmVyIHtcclxuICAgICAgICAgICAgY29sb3I6JHNlbGVjdGVkLWNvbG9yO1xyXG4gICAgICAgIH1cclxuICAgICAgICAmLmFjdGl2ZSB7XHJcbiAgICAgICAgICAgIGNvbG9yOiAkc2VsZWN0ZWQtY29sb3I7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxufVxyXG5cclxuXHJcbiIsInAge1xuICBmb250LWZhbWlseTogTGF0bztcbn1cblxuLmRyb3B6b25lIHtcbiAgbWluLWhlaWdodDogNDAwcHg7XG4gIG1pbi13aWR0aDogNDAwcHg7XG4gIGRpc3BsYXk6IHRhYmxlO1xuICB3aWR0aDogMTAwJTtcbiAgYmFja2dyb3VuZC1jb2xvcjogI2VlZTtcbiAgYm9yZGVyOiBkb3R0ZWQgMXB4ICNhYWE7XG59XG5cbi50ZXh0LXdyYXBwZXIge1xuICBkaXNwbGF5OiB0YWJsZS1jZWxsO1xuICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xufVxuXG4uY2VudGVyZWQge1xuICBmb250LWZhbWlseTogc2Fucy1zZXJpZjtcbiAgZm9udC1zaXplOiAxLjNlbTtcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gIHRleHQtYWxpZ246IGNlbnRlcjtcbn1cblxuLnZpZXdlcnMtY29udGFpbmVyIHtcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xuICBkaXNwbGF5OiBibG9jaztcbiAgaGVpZ2h0OiAxMDAlO1xuICBvdmVyZmxvdzogaGlkZGVuO1xufVxuLnZpZXdlcnMtY29udGFpbmVyIC5jb250YWluZXJfX2hlYWRlciB7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgbGVmdDogMDtcbiAgdG9wOiAwO1xuICBkaXNwbGF5OiBmbGV4O1xuICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcbiAgaGVpZ2h0OiA0MHB4O1xuICBwYWRkaW5nOiAwcHg7XG4gIG1hcmdpbjogMHB4O1xufVxuLnZpZXdlcnMtY29udGFpbmVyIC5jb250YWluZXJfX2hlYWRlciAuaGVhZGVyLWJ0bi1ncm91cCB7XG4gIGhlaWdodDogNDBweDtcbiAgcGFkZGluZzogMHB4O1xuICBtYXJnaW46IDBweDtcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XG4gIHotaW5kZXg6IDE7XG59XG4udmlld2Vycy1jb250YWluZXIgLmNvbnRlbnRfX3BhbmVsIHtcbiAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XG4gIHdpZHRoOiAxMDAlO1xuICBoZWlnaHQ6IDEwMCU7XG4gIG92ZXJmbG93OiBoaWRkZW47XG4gIHBhZGRpbmc6IDBweDtcbiAgbWFyZ2luOiAwcHg7XG59XG4udmlld2Vycy1jb250YWluZXIgYnV0dG9uIHtcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICB2ZXJ0aWNhbC1hbGlnbjogYm90dG9tO1xuICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcbiAgY29sb3I6ICM4MDgwODA7XG4gIGJvcmRlcjogbm9uZTtcbiAgb3V0bGluZTogbm9uZTtcbiAgY3Vyc29yOiBwb2ludGVyO1xuICBwYWRkaW5nOiAwcHg7XG4gIHdpZHRoOiAzNHB4O1xuICBoZWlnaHQ6IDM0cHg7XG4gIHRyYW5zaXRpb246IDAuM3M7XG4gIGZvbnQtc2l6ZTogMTRweDtcbn1cbi52aWV3ZXJzLWNvbnRhaW5lciBidXR0b246aG92ZXIge1xuICBjb2xvcjogIzAwMDA2ZDtcbn1cbi52aWV3ZXJzLWNvbnRhaW5lciBidXR0b24uYWN0aXZlIHtcbiAgY29sb3I6ICMwMDAwNmQ7XG59IiwiJHBhZGRpbmc6IDQwcHg7IC8vID8gbm90IHVzZWRcclxuJHNtYWxsLXBhZGRpbmc6IDE1cHg7XHJcbiRoZWFkZXItaGVpZ2h0OiA0MHB4O1xyXG5cclxuJGZzaXplMTogMTVweDtcclxuJGZzaXplMjogMTJweDtcclxuJGZzaXplMzogMzBweDtcclxuXHJcbiRwb3J0LXNpemU6IDE1cHg7XHJcbiRkZWZhdWx0LXNpZGUtcGFkZGluZzogMTVweDtcclxuXHJcbiRkaXNhYmxlZC1vcGFjaXR5OiAwLjQ7IiwiXHJcbiRjb2xvcjE6ICM4MDgwODA7XHJcbiRjb2xvcjI6ICM5OTk5OTk7XHJcbiRjb2xvcjM6ICNCM0IzQjM7IFxyXG4kY29sb3I0OiAjQ0NDQ0NDO1xyXG4kY29sb3I1OiAjRTZFNkU2O1xyXG4kY29sb3I1LTU6IHJnYigyNDUsIDI0NSwgMjQ1KTtcclxuJGNvbG9yNjogcmdiKDI1MCwgMjUwLCAyNTEpO1xyXG5cclxuJGNvbG9yNzogd2hpdGU7XHJcbiRjb2xvcjg6ICMzNzM3Mzc7XHJcblxyXG4kc2VsZWN0ZWQtY29sb3I6IHJnYigwLCAwLCAxMDkpO1xyXG4kc2VsZWN0ZWQtY29sb3IxOiByZ2IoMjI4LCAyMjgsIDI0Nyk7XHJcbiRzZWxlY3RlZC1jb2xvcjI6IHJnYigyMTUsIDIxNSwgMjU1KTtcclxuJGhvdmVyLWNvbG9yOiAkY29sb3IyO1xyXG5cclxuJGVycm9yLWNvbG9yOiAjRTk0ODU4OyAvL3BpbmstcmVkXHJcbiRlcnJvci1jb2xvci1sdDogcmdiKDI1NSwgMjIwLCAyMjQpO1xyXG4kcGNvbG9yMjogI0YzQTMyQTsgLy9vcmFuZ2UteWVsbG93XHJcbiRwcmludC1jb2xvcjogcmdiKDEzMCwgMTkxLCAxMTApOyAvL2xpZ2h0Z3JlZW5cclxuJHByaW50LWNvbG9yLWx0OiByZ2IoMjMwLCAyNTUsIDIyMSk7XHJcbiRwcmludC1jb2xvci1kazogcmdiKDYzLCA5OSwgNTEpOyAvL2xpZ2h0Z3JlZW5cclxuJHNlbGVjdEdlb20tY29sb3I6IHJnYigyNTUsIDE3NCwgMCk7IC8vIGxpZ2h0IG9yYW5nZVxyXG4kc2VsZWN0R2VvbS1jb2xvci1sdDogcmdiKDI1NSwgMjI1LCAxNjApO1xyXG5cclxuLy8gJHByb2QtYmFja2dyb3VuZC1jb2xvcjogcmdiKDI1MCwyNTAsMjUwKTtcclxuLy8gJGJhY2tncm91bmQtY29sb3I6IHJnYigyMjAsMjIwLDIyMCk7XHJcbiRmdW5jdGlvbi10ZXh0LWNvbG9yOiByZ2IoMTkwLCAxNDAsIDMwKTtcclxuJGZ1bmN0aW9uLXRleHQtY29sb3IyOiByZ2IoMTgsIDEyNiwgMTM2KTtcclxuJGZ1bmN0aW9uLXRleHQtY29sb3IzOiByZ2IoMTkwLCAxNDAsIDMwKTtcclxuJGJhc2ljLWZ1bmN0aW9uLXRleHQtY29sb3I6IHJnYigyMDAsIDcwLCAxNTApO1xyXG4kY29tbWVudC1jb2xvcjogZGFya2dyZWVuO1xyXG4iXX0= */");

/***/ }),

/***/ "./src/app/app.component.ts":
/*!**********************************!*\
  !*** ./src/app/app.component.ts ***!
  \**********************************/
/*! exports provided: AppComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AppComponent", function() { return AppComponent; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
/* harmony import */ var _angular_material__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/material */ "./node_modules/@angular/material/esm2015/material.js");
/* harmony import */ var _angular_platform_browser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/platform-browser */ "./node_modules/@angular/platform-browser/fesm2015/platform-browser.js");
/* harmony import */ var _assets_core_modules__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @assets/core/modules */ "./src/assets/core/modules/index.ts");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};




let AppComponent = class AppComponent {
    constructor(matIconRegistry, domSanitizer) {
        this.matIconRegistry = matIconRegistry;
        this.domSanitizer = domSanitizer;
        this.model = null;
        this.files = [];
        // this.matIconRegistry.addSvgIcon('printDis', this.domSanitizer.bypassSecurityTrustResourceUrl('assets/Icons/Print_disabled.svg'));
        // this.matIconRegistry.addSvgIcon('print', this.domSanitizer.bypassSecurityTrustResourceUrl('assets/Icons/iconPrint.svg'));
        // this.matIconRegistry.addSvgIcon('disabled', this.domSanitizer.bypassSecurityTrustResourceUrl('assets/Icons/iconDisabled.svg'));
        this.matIconRegistry.addSvgIcon('settings', this.domSanitizer.bypassSecurityTrustResourceUrl('assets/Icons/Settings.svg'));
        this.matIconRegistry.addSvgIcon('select', this.domSanitizer.bypassSecurityTrustResourceUrl('assets/Icons/Select.svg'));
        // this.matIconRegistry.addSvgIcon('c3D Viewer', this.domSanitizer.bypassSecurityTrustResourceUrl('assets/Icons/3D2.svg'));
        // this.matIconRegistry.addSvgIcon('cGeo Viewer', this.domSanitizer.bypassSecurityTrustResourceUrl('assets/Icons/Geo.svg'));
        // this.matIconRegistry.addSvgIcon('cCytoscape Viewer', this.domSanitizer.bypassSecurityTrustResourceUrl('assets/Icons/cyto.svg'));
        // this.matIconRegistry.addSvgIcon('cMobius Cesium', this.domSanitizer.bypassSecurityTrustResourceUrl('assets/Icons/Geo2.svg'));
        // this.matIconRegistry.addSvgIcon('cConsole', this.domSanitizer.bypassSecurityTrustResourceUrl('assets/Icons/Console.svg'));
        // this.matIconRegistry.addSvgIcon('cHelp', this.domSanitizer.bypassSecurityTrustResourceUrl('assets/Icons/Help.svg'));
        // this.matIconRegistry.addSvgIcon('cSummary', this.domSanitizer.bypassSecurityTrustResourceUrl('assets/Icons/Summary.svg'));
        this.matIconRegistry.addSvgIcon('cZoom', this.domSanitizer.bypassSecurityTrustResourceUrl('assets/Icons/Zoom.svg'));
        // this.matIconRegistry.addSvgIcon('cfv', this.domSanitizer.bypassSecurityTrustResourceUrl('assets/Icons/Mobius favicon.svg'));
        // this.matIconRegistry.addSvgIcon('cMenu', this.domSanitizer.bypassSecurityTrustResourceUrl('assets/Icons/Three Lines Menu.svg'));
        // this.matIconRegistry.addSvgIcon('cGallery', this.domSanitizer.bypassSecurityTrustResourceUrl('assets/Icons/Home.svg'));
        // this.matIconRegistry.addSvgIcon('cDashboard', this.domSanitizer.bypassSecurityTrustResourceUrl('assets/Icons/Dashboard.svg'));
        // this.matIconRegistry.addSvgIcon('cFlowchart', this.domSanitizer.bypassSecurityTrustResourceUrl('assets/Icons/Flowchart.svg'));
        // this.matIconRegistry.addSvgIcon('cEditor', this.domSanitizer.bypassSecurityTrustResourceUrl('assets/Icons/Node.svg'));
        // this.matIconRegistry.addSvgIcon('cAdd', this.domSanitizer.bypassSecurityTrustResourceUrl('assets/Icons/add.svg'));
        // this.matIconRegistry.addSvgIcon('cRemove', this.domSanitizer.bypassSecurityTrustResourceUrl('assets/Icons/remove.svg'));
        // this.matIconRegistry.addSvgIcon('cCredits', this.domSanitizer.bypassSecurityTrustResourceUrl('assets/Icons/Credits.svg'));
        // this.matIconRegistry.addSvgIcon('cUpArrow', this.domSanitizer.bypassSecurityTrustResourceUrl('assets/Icons/arrowup.svg'));
        // this.matIconRegistry.addSvgIcon('cDnArrow', this.domSanitizer.bypassSecurityTrustResourceUrl('assets/Icons/arrowdown.svg'));
        this.matIconRegistry.addSvgIcon('cControlCam', this.domSanitizer.bypassSecurityTrustResourceUrl('assets/Icons/ControlCam.svg'));
        this.matIconRegistry.addSvgIcon('cVisibility', this.domSanitizer.bypassSecurityTrustResourceUrl('assets/Icons/visibility.svg'));
    }
    filesDropped(files) {
        return __awaiter(this, void 0, void 0, function* () {
            if (files.length === 0) {
                return;
            }
            const f = files[0];
            try {
                const fileReader = new FileReader();
                fileReader.onload = (e) => {
                    this.model = _assets_core_modules__WEBPACK_IMPORTED_MODULE_3__["_parameterTypes"].newFn();
                    this.model.setJSONStr(fileReader.result);
                };
                fileReader.readAsText(f.file, 'json/applications');
            }
            catch (ex) {
                return;
            }
        });
    }
};
AppComponent.ctorParameters = () => [
    { type: _angular_material__WEBPACK_IMPORTED_MODULE_1__["MatIconRegistry"] },
    { type: _angular_platform_browser__WEBPACK_IMPORTED_MODULE_2__["DomSanitizer"] }
];
AppComponent = __decorate([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"])({
        selector: 'app-root',
        template: __importDefault(__webpack_require__(/*! raw-loader!./app.component.html */ "./node_modules/raw-loader/dist/cjs.js!./src/app/app.component.html")).default,
        styles: [__importDefault(__webpack_require__(/*! ./app.component.scss */ "./src/app/app.component.scss")).default]
    }),
    __metadata("design:paramtypes", [_angular_material__WEBPACK_IMPORTED_MODULE_1__["MatIconRegistry"], _angular_platform_browser__WEBPACK_IMPORTED_MODULE_2__["DomSanitizer"]])
], AppComponent);



/***/ }),

/***/ "./src/app/app.module.ts":
/*!*******************************!*\
  !*** ./src/app/app.module.ts ***!
  \*******************************/
/*! exports provided: AppModule */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AppModule", function() { return AppModule; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
/* harmony import */ var _angular_platform_browser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/platform-browser */ "./node_modules/@angular/platform-browser/fesm2015/platform-browser.js");
/* harmony import */ var _angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/platform-browser/animations */ "./node_modules/@angular/platform-browser/fesm2015/animations.js");
/* harmony import */ var _angular_common_http__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/common/http */ "./node_modules/@angular/common/fesm2015/http.js");
/* harmony import */ var _app_component__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./app.component */ "./src/app/app.component.ts");
/* harmony import */ var _gi_viewer_gi_viewer_component__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./gi-viewer/gi-viewer.component */ "./src/app/gi-viewer/gi-viewer.component.ts");
/* harmony import */ var _gi_viewer_gi_viewer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./gi-viewer/gi-viewer */ "./src/app/gi-viewer/gi-viewer.ts");
/* harmony import */ var _gi_viewer_data_data_service__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./gi-viewer/data/data.service */ "./src/app/gi-viewer/data/data.service.ts");
/* harmony import */ var _directives_dragDropDirective__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./directives/dragDropDirective */ "./src/app/directives/dragDropDirective.ts");
/* harmony import */ var _angular_material_icon__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @angular/material/icon */ "./node_modules/@angular/material/esm2015/icon.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};










let AppModule = class AppModule {
};
AppModule = __decorate([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["NgModule"])({
        declarations: [
            _app_component__WEBPACK_IMPORTED_MODULE_4__["AppComponent"],
            _directives_dragDropDirective__WEBPACK_IMPORTED_MODULE_8__["DragDirective"]
        ],
        imports: [
            _angular_common_http__WEBPACK_IMPORTED_MODULE_3__["HttpClientModule"],
            _angular_platform_browser__WEBPACK_IMPORTED_MODULE_1__["BrowserModule"],
            _angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_2__["BrowserAnimationsModule"],
            _angular_material_icon__WEBPACK_IMPORTED_MODULE_9__["MatIconModule"],
            _gi_viewer_gi_viewer__WEBPACK_IMPORTED_MODULE_6__["GIViewerModule"]
        ],
        entryComponents: [
            _gi_viewer_gi_viewer_component__WEBPACK_IMPORTED_MODULE_5__["GIViewerComponent"]
        ],
        providers: [_gi_viewer_data_data_service__WEBPACK_IMPORTED_MODULE_7__["DataService"]],
        bootstrap: [_app_component__WEBPACK_IMPORTED_MODULE_4__["AppComponent"]]
    })
], AppModule);



/***/ }),

/***/ "./src/app/directives/dragDropDirective.ts":
/*!*************************************************!*\
  !*** ./src/app/directives/dragDropDirective.ts ***!
  \*************************************************/
/*! exports provided: DragDirective */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DragDirective", function() { return DragDirective; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
/* harmony import */ var _angular_platform_browser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/platform-browser */ "./node_modules/@angular/platform-browser/fesm2015/platform-browser.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};


let DragDirective = class DragDirective {
    constructor(sanitizer) {
        this.sanitizer = sanitizer;
        this.files = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this.background = '#eee';
    }
    onDragOver(evt) {
        evt.preventDefault();
        evt.stopPropagation();
        this.background = '#999';
    }
    onDragLeave(evt) {
        evt.preventDefault();
        evt.stopPropagation();
        this.background = '#eee';
    }
    onDrop(evt) {
        evt.preventDefault();
        evt.stopPropagation();
        this.background = '#eee';
        const files = [];
        for (let i = 0; i < evt.dataTransfer.files.length; i++) {
            const file = evt.dataTransfer.files[i];
            const url = this.sanitizer.bypassSecurityTrustUrl(window.URL.createObjectURL(file));
            files.push({ file, url });
        }
        if (files.length > 0) {
            this.files.emit(files);
        }
    }
};
DragDirective.ctorParameters = () => [
    { type: _angular_platform_browser__WEBPACK_IMPORTED_MODULE_1__["DomSanitizer"] }
];
__decorate([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"])(),
    __metadata("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"])
], DragDirective.prototype, "files", void 0);
__decorate([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["HostBinding"])('style.background'),
    __metadata("design:type", Object)
], DragDirective.prototype, "background", void 0);
__decorate([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["HostListener"])('dragover', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [DragEvent]),
    __metadata("design:returntype", void 0)
], DragDirective.prototype, "onDragOver", null);
__decorate([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["HostListener"])('dragleave', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [DragEvent]),
    __metadata("design:returntype", void 0)
], DragDirective.prototype, "onDragLeave", null);
__decorate([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["HostListener"])('drop', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [DragEvent]),
    __metadata("design:returntype", void 0)
], DragDirective.prototype, "onDrop", null);
DragDirective = __decorate([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"])({
        selector: '[appDrag]'
    }),
    __metadata("design:paramtypes", [_angular_platform_browser__WEBPACK_IMPORTED_MODULE_1__["DomSanitizer"]])
], DragDirective);



/***/ }),

/***/ "./src/app/gi-viewer/attribute/attribute.component.scss":
/*!**************************************************************!*\
  !*** ./src/app/gi-viewer/attribute/attribute.component.scss ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (".table--container {\n  overflow-y: auto;\n  overflow-x: auto;\n}\n\n.mat-table {\n  background-color: whitesmoke;\n  border-bottom: 1px solid #CCCCCC;\n}\n\n#attribLabel {\n  margin: 0;\n  padding: 0;\n}\n\n#attribLabel dd {\n  float: left;\n  margin: 0;\n}\n\n#attribLabel dd span {\n  background: #00006d;\n  height: 5px;\n  width: calc(100% - 1px);\n  display: block;\n  border-right: 1px solid #bfbfbf;\n}\n\ntable {\n  width: 100%;\n  font-family: sans-serif;\n  background-color: transparent;\n}\n\ntable th i {\n  color: rgba(117, 117, 117, 0.5);\n  font-size: 16px;\n  margin-left: 5px;\n}\n\ntable th i.active {\n  color: #00006d;\n  background: unset;\n}\n\ntable th .material-icons {\n  color: rgba(117, 117, 117, 0.5);\n  width: 16px;\n  height: 16px;\n  margin-left: 5px;\n}\n\ntable th .material-icons.active {\n  color: #00006d;\n  background: unset;\n}\n\ntable th.mat-header-cell:not(:first-of-type) {\n  padding: 0px 5px;\n}\n\ntable th.mat-header-cell {\n  border-right: 1px solid #B3B3B3;\n}\n\ntable th.mat-header-cell:first-of-type {\n  width: 40px !important;\n  padding-left: 12px;\n}\n\ntable th:nth-child(2) {\n  width: 100px;\n}\n\ntable th:last-child {\n  width: 2000px;\n}\n\ntable tr.mat-header-row {\n  background-color: whitesmoke;\n  height: 27px;\n}\n\ntable tr.mat-row {\n  height: 24px;\n}\n\ntable tr.mat-row.selected-row .mat-cell {\n  background-color: #e6e6e6;\n}\n\ntable tr.mat-row .mat-cell {\n  -webkit-touch-callout: none;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n  font-size: 12px;\n  color: #373737;\n  background-color: #fafafb;\n  border-bottom: 1px solid #B3B3B3;\n  border-left: 1px solid transparent;\n  border-right: 1px solid #B3B3B3;\n}\n\ntable tr.mat-row .mat-cell:not(:first-of-type) {\n  padding: 0px 5px;\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  max-width: 380px;\n}\n\ntable tr.mat-row .mat-cell:first-of-type {\n  width: 40px !important;\n  padding-left: 12px;\n}\n\ntable tr.mat-row .mat-cell:nth-child(2) {\n  width: 100px;\n}\n\ntable tr.mat-row .mat-cell:last-child {\n  width: 2000px;\n}\n\ntable tr.mat-row:last-child .mat-cell {\n  border-bottom-color: transparent;\n}\n\ntable td.mat-cell:first-of-type, table td.mat-footer-cell:first-of-type, table th.mat-header-cell:first-of-type {\n  width: 10%;\n}\n\ntable.c2 tr.mat-row .mat-cell:nth-child(2), table.c2 th:nth-child(2) {\n  font-style: italic;\n}\n\n::ng-deep table th:last-child .mat-sort-header-container {\n  display: none;\n}\n\n::ng-deep #attribTab {\n  height: 100%;\n  width: 100%;\n  overflow-x: scroll;\n}\n\n::ng-deep #attribTab ul {\n  background-color: transparent;\n  margin: 0;\n  padding-left: 11px;\n  white-space: nowrap;\n  height: 20px;\n  position: absolute;\n  top: 1px;\n  width: 100%;\n  min-width: -webkit-fit-content;\n  min-width: -moz-fit-content;\n  min-width: fit-content;\n  display: inline-flex;\n}\n\n::ng-deep #attribTab ul li {\n  list-style: none;\n  float: left;\n  width: 90px;\n  color: #808080;\n  overflow: visible;\n  cursor: pointer;\n  position: relative;\n  height: inherit;\n  padding: 0px;\n}\n\n::ng-deep #attribTab ul li span {\n  font-family: sans-serif;\n  margin-right: 2px;\n  font-weight: 550;\n  font-size: 12px;\n  line-height: 15px;\n  border: 1px solid transparent;\n  position: relative;\n  display: block;\n  padding: 2px;\n  text-align: center;\n  position: absolute;\n  width: inherit;\n  box-sizing: border-box;\n  width: 100%;\n  margin-top: -1px;\n  height: 21px;\n}\n\n::ng-deep #attribTab ul li:hover {\n  background-color: transparent;\n}\n\n::ng-deep #attribTab ul li:hover span {\n  color: #00006d;\n  background-color: transparent;\n}\n\n::ng-deep #attribTab ul li.active {\n  background-color: transparent;\n}\n\n::ng-deep #attribTab ul li.active span {\n  color: #00006d;\n  cursor: default;\n  background-color: whitesmoke;\n  border: 1px solid #B3B3B3;\n  border-bottom: 2px solid whitesmoke;\n}\n\n::ng-deep #attribTab ul li:nth-child(2) {\n  width: 85px;\n}\n\n::ng-deep #attribTab .pane {\n  margin-top: 20px;\n  height: calc(100% - 31px);\n}\n\n::ng-deep #attribTab .pane .mat-elevation-z1 {\n  display: flex;\n  flex-flow: column nowrap;\n  height: 100%;\n  justify-content: space-between;\n  box-shadow: none;\n  border-top: 1px solid #B3B3B3;\n}\n\n.attrib--container {\n  height: calc(100% - 30px);\n}\n\n.attrib--container #attribTab {\n  height: 100%;\n}\n\n.attrib--container #attribTab my-tab {\n  height: 100%;\n}\n\n#emptyMessage {\n  text-align: left;\n  margin-top: -20px;\n  margin-left: 10px;\n  color: #888888;\n}\n\n.btm--container {\n  position: relative;\n  height: 30px;\n  position: absolute;\n  display: flex;\n  flex-flow: row nowrap;\n  justify-content: flex-end;\n  width: 100%;\n  bottom: 0px;\n}\n\n.btm--container #displaySelected {\n  padding-left: 10px;\n  position: absolute;\n  z-index: 1;\n  bottom: 13px;\n  left: 5px;\n}\n\n.btm--container #displaySelected .container {\n  display: block;\n  position: relative;\n  padding-left: 18px;\n  cursor: pointer;\n  font-size: 12px;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n  /* On mouse-over, add a grey background color */\n  /* When the checkbox is checked, add a blue background */\n  /* Create the checkmark/indicator (hidden when not checked) */\n  /* Show the checkmark when checked */\n  /* Style the checkmark/indicator */\n}\n\n.btm--container #displaySelected .container input[type=checkbox] {\n  position: absolute;\n  opacity: 0;\n  cursor: pointer;\n  height: 0;\n  width: 0;\n}\n\n.btm--container #displaySelected .container .checkmark {\n  position: absolute;\n  top: 1;\n  left: 0;\n  height: 10px;\n  width: 10px;\n  border: 1px solid #ccc;\n}\n\n.btm--container #displaySelected .container:hover input ~ .checkmark {\n  background-color: #eee;\n}\n\n.btm--container #displaySelected .container input:checked ~ .checkmark {\n  border: 1px solid #00006d;\n}\n\n.btm--container #displaySelected .container .checkmark:after {\n  content: \"\";\n  position: absolute;\n  display: none;\n}\n\n.btm--container #displaySelected .container input:checked ~ .checkmark:after {\n  display: block;\n}\n\n.btm--container #displaySelected .container .checkmark:after {\n  left: 4px;\n  top: -3px;\n  width: 4px;\n  height: 11px;\n  border: solid #00006d;\n  border-width: 0 1px 1px 0;\n  transform: rotate(45deg);\n}\n\n.btm--container .paginator--container {\n  position: relative;\n  width: 80%;\n  display: flex;\n  flex-flow: row nowrap;\n  justify-content: flex-end;\n}\n\n.btm--container #matPaginator {\n  position: absolute;\n  top: -20px;\n  background-color: transparent;\n  width: 100%;\n}\n\n.btm--container #matPaginator.hide {\n  display: none;\n}\n\n.btm--container #matPaginator .mat-paginator-outer-container .mat-paginator-container {\n  width: inherit;\n  min-height: 30px !important;\n  position: absolute;\n  bottom: 8px;\n  height: 20px;\n  display: flex;\n  flex-flow: row nowrap;\n  flex-shrink: 0;\n  font-family: sans-serif;\n}\n\n.btm--container #matPaginator .mat-paginator-outer-container .mat-paginator-container .mat-paginator-page-size, .btm--container #matPaginator .mat-paginator-outer-container .mat-paginator-container .mat-paginator-range-actions {\n  height: inherit;\n  align-items: baseline;\n  padding-right: 15px;\n}\n\n.btm--container #matPaginator .mat-paginator-outer-container .mat-paginator-container .mat-paginator-page-size-label, .btm--container #matPaginator .mat-paginator-outer-container .mat-paginator-container .mat-paginator-range-label {\n  white-space: nowrap;\n}\n\n.btm--container #matPaginator .mat-paginator-outer-container .mat-paginator-container .mat-paginator-page-size-select {\n  margin: 0;\n}\n\n.btm--container #matPaginator .mat-paginator-outer-container .mat-paginator-container .mat-paginator-page-size-select .mat-form-field-wrapper {\n  padding-bottom: 0.95em;\n}\n\n.btm--container #matPaginator .mat-paginator-outer-container .mat-paginator-container .mat-paginator-page-size-select .mat-form-field-wrapper .mat-form-field-flex .mat-form-field-infix .mat-select .mat-select-trigger .mat-select-value {\n  font-family: sans-serif;\n  color: #808080;\n}\n\n.btm--container #matPaginator .mat-paginator-outer-container .mat-paginator-container .mat-icon-button:hover .mat-paginator-icon {\n  fill: #00006d;\n}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9hcHAvZ2ktdmlld2VyL2F0dHJpYnV0ZS9DOlxcVXNlcnNcXGFraWJkcHRcXERvY3VtZW50c1xcQW5ndWxhclxcbW9iaXVzLXZpZXdlci9zcmNcXGFwcFxcZ2ktdmlld2VyXFxhdHRyaWJ1dGVcXGF0dHJpYnV0ZS5jb21wb25lbnQuc2NzcyIsInNyYy9hcHAvZ2ktdmlld2VyL2F0dHJpYnV0ZS9hdHRyaWJ1dGUuY29tcG9uZW50LnNjc3MiLCJzcmMvYXBwL2dpLXZpZXdlci9hdHRyaWJ1dGUvQzpcXFVzZXJzXFxha2liZHB0XFxEb2N1bWVudHNcXEFuZ3VsYXJcXG1vYml1cy12aWV3ZXIvc3JjXFxzY3NzXFxjb2xvcnMuc2NzcyIsInNyYy9hcHAvZ2ktdmlld2VyL2F0dHJpYnV0ZS9DOlxcVXNlcnNcXGFraWJkcHRcXERvY3VtZW50c1xcQW5ndWxhclxcbW9iaXVzLXZpZXdlci9zcmNcXHNjc3NcXHZhcmlhYmxlcy5zY3NzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUdBO0VBRUUsZ0JBQUE7RUFDQSxnQkFBQTtBQ0hGOztBRE1BO0VBQ0UsNEJFSlM7RUZNVCxnQ0FBQTtBQ0pGOztBRFFBO0VBQ0UsU0FBQTtFQUNBLFVBQUE7QUNMRjs7QURNRTtFQUNFLFdBQUE7RUFDQSxTQUFBO0FDSko7O0FES0k7RUFDRSxtQkVYVztFRllYLFdBQUE7RUFDQSx1QkFBQTtFQUNBLGNBQUE7RUFDQSwrQkFBQTtBQ0hOOztBRFFBO0VBQ0UsV0FBQTtFQUNBLHVCQUFBO0VBQ0EsNkJBQUE7QUNMRjs7QURPSTtFQUNFLCtCQUFBO0VBQ0EsZUFBQTtFQUNBLGdCQUFBO0FDTE47O0FETU07RUFDRSxjQUFBO0VBQ0EsaUJBQUE7QUNKUjs7QURPSTtFQUNJLCtCQUFBO0VBQ0EsV0FBQTtFQUNBLFlBQUE7RUFDQSxnQkFBQTtBQ0xSOztBRE1RO0VBQ0ksY0FBQTtFQUNBLGlCQUFBO0FDSlo7O0FEUUU7RUFDRSxnQkFBQTtBQ05KOztBRFFFO0VBQ0UsK0JBQUE7QUNOSjs7QURRRTtFQUVFLHNCQUFBO0VBQ0Esa0JBQUE7QUNQSjs7QURTRTtFQUVFLFlBQUE7QUNSSjs7QURjRTtFQUNFLGFBQUE7QUNaSjs7QURjRTtFQUNFLDRCRTFFTztFRjJFUCxZQUFBO0FDWko7O0FEY0U7RUFDRSxZQUFBO0FDWko7O0FEY007RUFDRSx5QkFBQTtBQ1pSOztBRGVJO0VBQ0UsMkJBQUE7RUFDQSx5QkFBQTtFQUNBLHNCQUFBO0VBQ0EscUJBQUE7RUFDQSxpQkFBQTtFQUVBLGVBQUE7RUFDQSxjRXhGRztFRnlGSCx5QkU1Rkc7RUY2RkgsZ0NBQUE7RUFDQSxrQ0FBQTtFQUNBLCtCQUFBO0FDZE47O0FEZU07RUFDRSxnQkFBQTtFQUNBLG1CQUFBO0VBQ0EsZ0JBQUE7RUFDQSx1QkFBQTtFQUNBLGdCQUFBO0FDYlI7O0FEZU07RUFDRSxzQkFBQTtFQUNBLGtCQUFBO0FDYlI7O0FEa0JNO0VBQ0UsWUFBQTtBQ2hCUjs7QURzQk07RUFDRSxhQUFBO0FDcEJSOztBRDJCTTtFQUNFLGdDQUFBO0FDekJSOztBRDZCRTtFQUNFLFVBQUE7QUMzQko7O0FEaUNJO0VBQW1ELGtCQUFBO0FDN0J2RDs7QUR3Q0k7RUFDRSxhQUFBO0FDckNOOztBRDJDQTtFQUNFLFlBQUE7RUFDQSxXQUFBO0VBQ0Esa0JBQUE7QUN4Q0Y7O0FEeUNFO0VBQ0UsNkJBQUE7RUFDQSxTQUFBO0VBQ0Esa0JBQUE7RUFFQSxtQkFBQTtFQUNBLFlBQUE7RUFDQSxrQkFBQTtFQUNBLFFBQUE7RUFDQSxXQUFBO0VBQ0EsOEJBQUE7RUFBQSwyQkFBQTtFQUFBLHNCQUFBO0VBQ0Esb0JBQUE7QUN4Q0o7O0FEeUNJO0VBQ0UsZ0JBQUE7RUFFQSxXQUFBO0VBQ0EsV0FBQTtFQUNBLGNFdExHO0VGdUxILGlCQUFBO0VBQ0EsZUFBQTtFQUNBLGtCQUFBO0VBQ0EsZUFBQTtFQUNBLFlBQUE7QUN4Q047O0FEeUNNO0VBQ0UsdUJBQUE7RUFDQSxpQkFBQTtFQUNBLGdCQUFBO0VBQ0EsZUc1TEM7RUg2TEQsaUJHOUxDO0VIK0xELDZCQUFBO0VBQ0Esa0JBQUE7RUFDQSxjQUFBO0VBQ0EsWUFBQTtFQUNBLGtCQUFBO0VBQ0Esa0JBQUE7RUFDQSxjQUFBO0VBQ0Esc0JBQUE7RUFDQSxXQUFBO0VBQ0EsZ0JBQUE7RUFDQSxZQUFBO0FDdkNSOztBRHlDTTtFQUNFLDZCQUFBO0FDdkNSOztBRHdDUTtFQUNFLGNFdE1PO0VGdU1QLDZCQUFBO0FDdENWOztBRHlDTTtFQUNFLDZCQUFBO0FDdkNSOztBRHdDUTtFQUNFLGNFN01PO0VGOE1QLGVBQUE7RUFDQSw0QkVyTkM7RUZzTkQseUJBQUE7RUFDQSxtQ0FBQTtBQ3RDVjs7QUR5Q007RUFDRSxXQUFBO0FDdkNSOztBRDRDRTtFQUNFLGdCQUFBO0VBQ0EseUJBQUE7QUMxQ0o7O0FEMkNJO0VBQ0UsYUFBQTtFQUNBLHdCQUFBO0VBQ0EsWUFBQTtFQUNBLDhCQUFBO0VBQ0EsZ0JBQUE7RUFDQSw2QkFBQTtBQ3pDTjs7QUQ4Q0E7RUFDRSx5QkFBQTtBQzNDRjs7QUQ0Q0U7RUFDRSxZQUFBO0FDMUNKOztBRDJDSTtFQUNBLFlBQUE7QUN6Q0o7O0FEOENBO0VBQ0UsZ0JBQUE7RUFDQSxpQkFBQTtFQUNBLGlCQUFBO0VBQ0EsY0FBQTtBQzNDRjs7QUQ4Q0E7RUFDRSxrQkFBQTtFQUNBLFlHalFPO0VIa1FQLGtCQUFBO0VBQ0EsYUFBQTtFQUNBLHFCQUFBO0VBQ0EseUJBQUE7RUFDQSxXQUFBO0VBQ0EsV0FBQTtBQzNDRjs7QUQ0Q0U7RUFDRSxrQkFBQTtFQUVBLGtCQUFBO0VBQ0EsVUFBQTtFQUNBLFlBQUE7RUFDQSxTQUFBO0FDM0NKOztBRDRDSTtFQUNFLGNBQUE7RUFDQSxrQkFBQTtFQUNBLGtCQUFBO0VBQ0EsZUFBQTtFQUNBLGVBQUE7RUFDQSx5QkFBQTtFQUNBLHNCQUFBO0VBQ0EscUJBQUE7RUFDQSxpQkFBQTtFQWtCQSwrQ0FBQTtFQUtBLHdEQUFBO0VBTUEsNkRBQUE7RUFPQSxvQ0FBQTtFQUtBLGtDQUFBO0FDOUVOOztBRHVDTTtFQUNFLGtCQUFBO0VBQ0EsVUFBQTtFQUNBLGVBQUE7RUFDQSxTQUFBO0VBQ0EsUUFBQTtBQ3JDUjs7QUR3Q007RUFDRSxrQkFBQTtFQUNBLE1BQUE7RUFDQSxPQUFBO0VBQ0EsWUFBQTtFQUNBLFdBQUE7RUFDQSxzQkFBQTtBQ3RDUjs7QUR5Q007RUFDRSxzQkFBQTtBQ3ZDUjs7QUQyQ007RUFFRSx5QkFBQTtBQzFDUjs7QUQ4Q007RUFDRSxXQUFBO0VBQ0Esa0JBQUE7RUFDQSxhQUFBO0FDNUNSOztBRGdETTtFQUNFLGNBQUE7QUM5Q1I7O0FEa0RNO0VBQ0UsU0FBQTtFQUNBLFNBQUE7RUFDQSxVQUFBO0VBQ0EsWUFBQTtFQUNBLHFCQUFBO0VBQ0EseUJBQUE7RUFHQSx3QkFBQTtBQ2hEUjs7QURvREU7RUFDRSxrQkFBQTtFQUNBLFVBQUE7RUFDQSxhQUFBO0VBQ0EscUJBQUE7RUFDQSx5QkFBQTtBQ2xESjs7QURvREU7RUFJRSxrQkFBQTtFQUNBLFVBQUE7RUFDQSw2QkFBQTtFQUNBLFdBQUE7QUNyREo7O0FEK0NJO0VBQ0UsYUFBQTtBQzdDTjs7QURxRE07RUFDRSxjQUFBO0VBQ0EsMkJBQUE7RUFDQSxrQkFBQTtFQUNBLFdBQUE7RUFDQSxZQUFBO0VBQ0EsYUFBQTtFQUNBLHFCQUFBO0VBQ0EsY0FBQTtFQUNBLHVCQUFBO0FDbkRSOztBRHFEUTtFQUNFLGVBQUE7RUFDQSxxQkFBQTtFQUNBLG1CR25YTTtBRmdVaEI7O0FEcURRO0VBQ0UsbUJBQUE7QUNuRFY7O0FEdURRO0VBQ0UsU0FBQTtBQ3JEVjs7QURzRFU7RUFDRSxzQkFBQTtBQ3BEWjs7QURxRFk7RUFDRSx1QkFBQTtFQUNBLGNFaFlMO0FENlVUOztBRHlEUTtFQUNFLGFFNVhPO0FEcVVqQiIsImZpbGUiOiJzcmMvYXBwL2dpLXZpZXdlci9hdHRyaWJ1dGUvYXR0cmlidXRlLmNvbXBvbmVudC5zY3NzIiwic291cmNlc0NvbnRlbnQiOlsiQGltcG9ydCAnfnNjc3MvY29sb3JzJztcclxuQGltcG9ydCAnfnNjc3MvdmFyaWFibGVzJztcclxuXHJcbi50YWJsZS0tY29udGFpbmVye1xyXG4gIC8vIGhlaWdodDogMTAwJTtcclxuICBvdmVyZmxvdy15OiBhdXRvO1xyXG4gIG92ZXJmbG93LXg6IGF1dG87XHJcbn1cclxuXHJcbi5tYXQtdGFibGV7XHJcbiAgYmFja2dyb3VuZC1jb2xvcjogJGNvbG9yNS01O1xyXG4gIC8vIGJvcmRlci10b3A6IDFweCBzb2xpZCAkY29sb3IzO1xyXG4gIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAkY29sb3I0O1xyXG4gIC8vIGhlaWdodDogMTAwJTtcclxufVxyXG5cclxuI2F0dHJpYkxhYmVse1xyXG4gIG1hcmdpbjogMDtcclxuICBwYWRkaW5nOiAwO1xyXG4gIGRke1xyXG4gICAgZmxvYXQ6IGxlZnQ7XHJcbiAgICBtYXJnaW46IDA7XHJcbiAgICBzcGFue1xyXG4gICAgICBiYWNrZ3JvdW5kOiAkc2VsZWN0ZWQtY29sb3I7XHJcbiAgICAgIGhlaWdodDogNXB4O1xyXG4gICAgICB3aWR0aDogY2FsYygxMDAlIC0gMXB4KTtcclxuICAgICAgZGlzcGxheTogYmxvY2s7XHJcbiAgICAgIGJvcmRlci1yaWdodDogMXB4IHNvbGlkICNiZmJmYmY7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG50YWJsZSB7XHJcbiAgd2lkdGg6IDEwMCU7XHJcbiAgZm9udC1mYW1pbHk6IHNhbnMtc2VyaWY7XHJcbiAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XHJcbiAgdGh7XHJcbiAgICBpIHtcclxuICAgICAgY29sb3I6IHJnYmEoMTE3LDExNywxMTcsMC41KTtcclxuICAgICAgZm9udC1zaXplOiAxNnB4O1xyXG4gICAgICBtYXJnaW4tbGVmdDogNXB4O1xyXG4gICAgICAmLmFjdGl2ZXtcclxuICAgICAgICBjb2xvcjogIzAwMDA2ZDtcclxuICAgICAgICBiYWNrZ3JvdW5kOiB1bnNldDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgLm1hdGVyaWFsLWljb25zIHtcclxuICAgICAgICBjb2xvcjogcmdiYSgxMTcsMTE3LDExNywwLjUpO1xyXG4gICAgICAgIHdpZHRoOiAxNnB4O1xyXG4gICAgICAgIGhlaWdodDogMTZweDtcclxuICAgICAgICBtYXJnaW4tbGVmdDogNXB4O1xyXG4gICAgICAgICYuYWN0aXZlIHtcclxuICAgICAgICAgICAgY29sb3I6ICMwMDAwNmQ7XHJcbiAgICAgICAgICAgIGJhY2tncm91bmQ6IHVuc2V0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgdGgubWF0LWhlYWRlci1jZWxsOm5vdCg6Zmlyc3Qtb2YtdHlwZSl7XHJcbiAgICBwYWRkaW5nOiAwcHggNXB4O1xyXG4gIH1cclxuICB0aC5tYXQtaGVhZGVyLWNlbGx7XHJcbiAgICBib3JkZXItcmlnaHQ6IDFweCBzb2xpZCAkY29sb3IzO1xyXG4gIH1cclxuICB0aC5tYXQtaGVhZGVyLWNlbGw6Zmlyc3Qtb2YtdHlwZXtcclxuICAgIC8vIGJvcmRlci1yaWdodDogbm9uZTtcclxuICAgIHdpZHRoOiA0MHB4ICFpbXBvcnRhbnQ7XHJcbiAgICBwYWRkaW5nLWxlZnQ6IDEycHg7XHJcbiAgfVxyXG4gIHRoOm50aC1jaGlsZCgyKXtcclxuICAgIC8vIHdpZHRoOiA1NXB4ICFpbXBvcnRhbnQ7XHJcbiAgICB3aWR0aDogMTAwcHg7XHJcbiAgICAvLyBmb250LXN0eWxlOiBpdGFsaWM7XHJcbiAgfVxyXG4gIHRoOm50aC1jaGlsZChuKzMpe1xyXG4gICAgLy8gd2lkdGg6IDUwcHg7XHJcbiAgfVxyXG4gIHRoOmxhc3QtY2hpbGR7XHJcbiAgICB3aWR0aDogMjAwMHB4O1xyXG4gIH1cclxuICB0ci5tYXQtaGVhZGVyLXJvd3tcclxuICAgIGJhY2tncm91bmQtY29sb3I6ICRjb2xvcjUtNTtcclxuICAgIGhlaWdodDogMjdweDtcclxuICB9XHJcbiAgdHIubWF0LXJvd3tcclxuICAgIGhlaWdodDogMjRweDtcclxuICAgICYuc2VsZWN0ZWQtcm93e1xyXG4gICAgICAubWF0LWNlbGx7XHJcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2U2ZTZlNjtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgLm1hdC1jZWxse1xyXG4gICAgICAtd2Via2l0LXRvdWNoLWNhbGxvdXQ6IG5vbmU7XHJcbiAgICAgIC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7XHJcbiAgICAgIC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XHJcbiAgICAgIC1tcy11c2VyLXNlbGVjdDogbm9uZTtcclxuICAgICAgdXNlci1zZWxlY3Q6IG5vbmU7XHJcbiAgICAgIFxyXG4gICAgICBmb250LXNpemU6IDEycHg7XHJcbiAgICAgIGNvbG9yOiAkY29sb3I4O1xyXG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkY29sb3I2O1xyXG4gICAgICBib3JkZXItYm90dG9tOiAxcHggc29saWQgJGNvbG9yMztcclxuICAgICAgYm9yZGVyLWxlZnQ6IDFweCBzb2xpZCB0cmFuc3BhcmVudDtcclxuICAgICAgYm9yZGVyLXJpZ2h0OiAxcHggc29saWQgJGNvbG9yMztcclxuICAgICAgJjpub3QoOmZpcnN0LW9mLXR5cGUpe1xyXG4gICAgICAgIHBhZGRpbmc6IDBweCA1cHg7XHJcbiAgICAgICAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcclxuICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xyXG4gICAgICAgIHRleHQtb3ZlcmZsb3c6IGVsbGlwc2lzO1xyXG4gICAgICAgIG1heC13aWR0aDogMzgwcHg7XHJcbiAgICAgIH1cclxuICAgICAgJjpmaXJzdC1vZi10eXBle1xyXG4gICAgICAgIHdpZHRoOiA0MHB4ICFpbXBvcnRhbnQ7XHJcbiAgICAgICAgcGFkZGluZy1sZWZ0OiAxMnB4O1xyXG4gICAgICB9XHJcbiAgICAgICY6bGFzdC1vZi10eXBle1xyXG4gICAgICAgIC8vIGJvcmRlci1yaWdodDpub25lO1xyXG4gICAgICB9XHJcbiAgICAgICY6bnRoLWNoaWxkKDIpe1xyXG4gICAgICAgIHdpZHRoOiAxMDBweDtcclxuICAgICAgICAvLyBmb250LXN0eWxlOiBpdGFsaWM7XHJcbiAgICAgIH1cclxuICAgICAgJjpudGgtY2hpbGQobiszKXtcclxuICAgICAgICAvLyB3aWR0aDogNTBweDtcclxuICAgICAgfVxyXG4gICAgICAmOmxhc3QtY2hpbGR7XHJcbiAgICAgICAgd2lkdGg6IDIwMDBweDtcclxuICAgICAgfVxyXG4gICAgICAvLyBvdmVyZmxvdzogaGlkZGVuO1xyXG4gICAgICAvLyB0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcclxuICAgICAgLy8gd2hpdGUtc3BhY2U6IG5vd3JhcDtcclxuICAgIH1cclxuICAgICY6bGFzdC1jaGlsZHtcclxuICAgICAgLm1hdC1jZWxse1xyXG4gICAgICAgIGJvcmRlci1ib3R0b20tY29sb3I6IHRyYW5zcGFyZW50O1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIHRkLm1hdC1jZWxsOmZpcnN0LW9mLXR5cGUsIHRkLm1hdC1mb290ZXItY2VsbDpmaXJzdC1vZi10eXBlLCB0aC5tYXQtaGVhZGVyLWNlbGw6Zmlyc3Qtb2YtdHlwZXtcclxuICAgIHdpZHRoOiAxMCU7XHJcbiAgfVxyXG59XHJcblxyXG50YWJsZXtcclxuICAmLmMye1xyXG4gICAgdHIubWF0LXJvdyAubWF0LWNlbGw6bnRoLWNoaWxkKDIpLCB0aDpudGgtY2hpbGQoMil7Zm9udC1zdHlsZTogaXRhbGljfVxyXG4gIH1cclxufVxyXG5cclxuOjpuZy1kZWVwIHRhYmxle1xyXG4gIHRoOmZpcnN0LWNoaWxke1xyXG4gICAgaXtcclxuICAgICAgLy8gZGlzcGxheTogbm9uZTtcclxuICAgIH1cclxuICB9XHJcbiAgdGg6bGFzdC1jaGlsZHtcclxuICAgIC5tYXQtc29ydC1oZWFkZXItY29udGFpbmVye1xyXG4gICAgICBkaXNwbGF5OiBub25lO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuXHJcbjo6bmctZGVlcCAjYXR0cmliVGFie1xyXG4gIGhlaWdodDogMTAwJTtcclxuICB3aWR0aDogMTAwJTtcclxuICBvdmVyZmxvdy14OiBzY3JvbGw7XHJcbiAgdWx7XHJcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcclxuICAgIG1hcmdpbjogMDtcclxuICAgIHBhZGRpbmctbGVmdDogMTFweDtcclxuICAgIC8vIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAkY29sb3IzO1xyXG4gICAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcclxuICAgIGhlaWdodDogMjBweDtcclxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcclxuICAgIHRvcDoxcHg7XHJcbiAgICB3aWR0aDogMTAwJTtcclxuICAgIG1pbi13aWR0aDogZml0LWNvbnRlbnQ7XHJcbiAgICBkaXNwbGF5OiBpbmxpbmUtZmxleDtcclxuICAgIGxpe1xyXG4gICAgICBsaXN0LXN0eWxlOiBub25lO1xyXG4gICAgICAvLyBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XHJcbiAgICAgIGZsb2F0OiBsZWZ0O1xyXG4gICAgICB3aWR0aDogOTBweDtcclxuICAgICAgY29sb3I6ICRjb2xvcjE7XHJcbiAgICAgIG92ZXJmbG93OnZpc2libGU7XHJcbiAgICAgIGN1cnNvcjogcG9pbnRlcjtcclxuICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xyXG4gICAgICBoZWlnaHQ6IGluaGVyaXQ7XHJcbiAgICAgIHBhZGRpbmc6IDBweDtcclxuICAgICAgc3BhbntcclxuICAgICAgICBmb250LWZhbWlseTogc2Fucy1zZXJpZjtcclxuICAgICAgICBtYXJnaW4tcmlnaHQ6IDJweDtcclxuICAgICAgICBmb250LXdlaWdodDogNTUwO1xyXG4gICAgICAgIGZvbnQtc2l6ZTogJGZzaXplMjtcclxuICAgICAgICBsaW5lLWhlaWdodDogJGZzaXplMTtcclxuICAgICAgICBib3JkZXI6IDFweCBzb2xpZCB0cmFuc3BhcmVudDtcclxuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XHJcbiAgICAgICAgZGlzcGxheTogYmxvY2s7XHJcbiAgICAgICAgcGFkZGluZzogMnB4O1xyXG4gICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcclxuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XHJcbiAgICAgICAgd2lkdGg6IGluaGVyaXQ7XHJcbiAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcclxuICAgICAgICB3aWR0aDogMTAwJTtcclxuICAgICAgICBtYXJnaW4tdG9wOiAtMXB4O1xyXG4gICAgICAgIGhlaWdodDogMjFweDtcclxuICAgICAgfVxyXG4gICAgICAmOmhvdmVye1xyXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xyXG4gICAgICAgIHNwYW57XHJcbiAgICAgICAgICBjb2xvcjogJHNlbGVjdGVkLWNvbG9yO1xyXG4gICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgICYuYWN0aXZle1xyXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xyXG4gICAgICAgIHNwYW57XHJcbiAgICAgICAgICBjb2xvcjogJHNlbGVjdGVkLWNvbG9yO1xyXG4gICAgICAgICAgY3Vyc29yOiBkZWZhdWx0O1xyXG4gICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogJGNvbG9yNS01O1xyXG4gICAgICAgICAgYm9yZGVyOiAxcHggc29saWQgJGNvbG9yMztcclxuICAgICAgICAgIGJvcmRlci1ib3R0b206IDJweCBzb2xpZCAkY29sb3I1LTU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgICY6bnRoLWNoaWxkKDIpe1xyXG4gICAgICAgIHdpZHRoOiA4NXB4O1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIC8vIGNvbnRhaW5zIGV2ZXJ5dGhpbmdcclxuICAucGFuZXtcclxuICAgIG1hcmdpbi10b3A6IDIwcHg7XHJcbiAgICBoZWlnaHQ6IGNhbGMoMTAwJSAtIDMxcHgpO1xyXG4gICAgLm1hdC1lbGV2YXRpb24tejF7XHJcbiAgICAgIGRpc3BsYXk6IGZsZXg7XHJcbiAgICAgIGZsZXgtZmxvdzogY29sdW1uIG5vd3JhcDtcclxuICAgICAgaGVpZ2h0OiAxMDAlO1xyXG4gICAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XHJcbiAgICAgIGJveC1zaGFkb3c6IG5vbmU7XHJcbiAgICAgIGJvcmRlci10b3A6IDFweCBzb2xpZCAkY29sb3IzO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLmF0dHJpYi0tY29udGFpbmVye1xyXG4gIGhlaWdodDogY2FsYygxMDAlIC0gMzBweCk7IC8vICRmc2l6ZTMgYnRtIGNvbnRhaW5lciBoZWlnaHRcclxuICAjYXR0cmliVGFie1xyXG4gICAgaGVpZ2h0OiAxMDAlO1xyXG4gICAgbXktdGFie1xyXG4gICAgaGVpZ2h0OiAxMDAlO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuI2VtcHR5TWVzc2FnZXtcclxuICB0ZXh0LWFsaWduOiBsZWZ0O1xyXG4gIG1hcmdpbi10b3A6IC0yMHB4O1xyXG4gIG1hcmdpbi1sZWZ0OiAxMHB4O1xyXG4gIGNvbG9yOiAjODg4ODg4O1xyXG59XHJcblxyXG4uYnRtLS1jb250YWluZXJ7XHJcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xyXG4gIGhlaWdodDogJGZzaXplMztcclxuICBwb3NpdGlvbjogYWJzb2x1dGU7XHJcbiAgZGlzcGxheTogZmxleDtcclxuICBmbGV4LWZsb3c6IHJvdyBub3dyYXA7XHJcbiAganVzdGlmeS1jb250ZW50OiBmbGV4LWVuZDtcclxuICB3aWR0aDogMTAwJTtcclxuICBib3R0b206IDBweDtcclxuICAjZGlzcGxheVNlbGVjdGVke1xyXG4gICAgcGFkZGluZy1sZWZ0OiAxMHB4O1xyXG4gICAgLy8gd2lkdGg6IDMwJTtcclxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcclxuICAgIHotaW5kZXg6IDE7XHJcbiAgICBib3R0b206IDEzcHg7XHJcbiAgICBsZWZ0OiA1cHg7XHJcbiAgICAuY29udGFpbmVyIHtcclxuICAgICAgZGlzcGxheTogYmxvY2s7XHJcbiAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcclxuICAgICAgcGFkZGluZy1sZWZ0OiAxOHB4O1xyXG4gICAgICBjdXJzb3I6IHBvaW50ZXI7XHJcbiAgICAgIGZvbnQtc2l6ZTogMTJweDtcclxuICAgICAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTtcclxuICAgICAgLW1vei11c2VyLXNlbGVjdDogbm9uZTtcclxuICAgICAgLW1zLXVzZXItc2VsZWN0OiBub25lO1xyXG4gICAgICB1c2VyLXNlbGVjdDogbm9uZTtcclxuXHJcbiAgICAgIGlucHV0W3R5cGU9Y2hlY2tib3hde1xyXG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcclxuICAgICAgICBvcGFjaXR5OiAwO1xyXG4gICAgICAgIGN1cnNvcjogcG9pbnRlcjtcclxuICAgICAgICBoZWlnaHQ6IDA7XHJcbiAgICAgICAgd2lkdGg6IDA7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC5jaGVja21hcmsge1xyXG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcclxuICAgICAgICB0b3A6IDE7XHJcbiAgICAgICAgbGVmdDogMDtcclxuICAgICAgICBoZWlnaHQ6IDEwcHg7XHJcbiAgICAgICAgd2lkdGg6IDEwcHg7XHJcbiAgICAgICAgYm9yZGVyOiAxcHggc29saWQgI2NjYztcclxuICAgICAgfVxyXG4gICAgICAvKiBPbiBtb3VzZS1vdmVyLCBhZGQgYSBncmV5IGJhY2tncm91bmQgY29sb3IgKi9cclxuICAgICAgJjpob3ZlciBpbnB1dCB+IC5jaGVja21hcmsge1xyXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICNlZWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8qIFdoZW4gdGhlIGNoZWNrYm94IGlzIGNoZWNrZWQsIGFkZCBhIGJsdWUgYmFja2dyb3VuZCAqL1xyXG4gICAgICBpbnB1dDpjaGVja2VkIH4gLmNoZWNrbWFyayB7XHJcbiAgICAgICAgLy8gYmFja2dyb3VuZC1jb2xvcjogIzIxOTZGMztcclxuICAgICAgICBib3JkZXI6IDFweCBzb2xpZCAjMDAwMDZkO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvKiBDcmVhdGUgdGhlIGNoZWNrbWFyay9pbmRpY2F0b3IgKGhpZGRlbiB3aGVuIG5vdCBjaGVja2VkKSAqL1xyXG4gICAgICAuY2hlY2ttYXJrOmFmdGVyIHtcclxuICAgICAgICBjb250ZW50OiBcIlwiO1xyXG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcclxuICAgICAgICBkaXNwbGF5OiBub25lO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvKiBTaG93IHRoZSBjaGVja21hcmsgd2hlbiBjaGVja2VkICovXHJcbiAgICAgIGlucHV0OmNoZWNrZWQgfiAuY2hlY2ttYXJrOmFmdGVyIHtcclxuICAgICAgICBkaXNwbGF5OiBibG9jaztcclxuICAgICAgfVxyXG5cclxuICAgICAgLyogU3R5bGUgdGhlIGNoZWNrbWFyay9pbmRpY2F0b3IgKi9cclxuICAgICAgLmNoZWNrbWFyazphZnRlciB7XHJcbiAgICAgICAgbGVmdDogNHB4O1xyXG4gICAgICAgIHRvcDogLTNweDtcclxuICAgICAgICB3aWR0aDogNHB4O1xyXG4gICAgICAgIGhlaWdodDogMTFweDtcclxuICAgICAgICBib3JkZXI6IHNvbGlkICMwMDAwNmQ7XHJcbiAgICAgICAgYm9yZGVyLXdpZHRoOiAwIDFweCAxcHggMDtcclxuICAgICAgICAtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKDQ1ZGVnKTtcclxuICAgICAgICAtbXMtdHJhbnNmb3JtOiByb3RhdGUoNDVkZWcpO1xyXG4gICAgICAgIHRyYW5zZm9ybTogcm90YXRlKDQ1ZGVnKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICAucGFnaW5hdG9yLS1jb250YWluZXJ7XHJcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XHJcbiAgICB3aWR0aDogODAlO1xyXG4gICAgZGlzcGxheTogZmxleDtcclxuICAgIGZsZXgtZmxvdzogcm93IG5vd3JhcDtcclxuICAgIGp1c3RpZnktY29udGVudDogZmxleC1lbmQ7XHJcbiAgfVxyXG4gICNtYXRQYWdpbmF0b3J7XHJcbiAgICAmLmhpZGV7XHJcbiAgICAgIGRpc3BsYXk6IG5vbmU7XHJcbiAgICB9XHJcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XHJcbiAgICB0b3A6IC0yMHB4O1xyXG4gICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XHJcbiAgICB3aWR0aDogMTAwJTtcclxuICAgIC8vIHBhZ2luYXRvclxyXG4gICAgLm1hdC1wYWdpbmF0b3Itb3V0ZXItY29udGFpbmVye1xyXG4gICAgICAubWF0LXBhZ2luYXRvci1jb250YWluZXJ7XHJcbiAgICAgICAgd2lkdGg6IGluaGVyaXQ7XHJcbiAgICAgICAgbWluLWhlaWdodDogJGZzaXplMyAhaW1wb3J0YW50O1xyXG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcclxuICAgICAgICBib3R0b206IDhweDtcclxuICAgICAgICBoZWlnaHQ6IDIwcHg7XHJcbiAgICAgICAgZGlzcGxheTogZmxleDtcclxuICAgICAgICBmbGV4LWZsb3c6IHJvdyBub3dyYXA7XHJcbiAgICAgICAgZmxleC1zaHJpbms6IDA7XHJcbiAgICAgICAgZm9udC1mYW1pbHk6IHNhbnMtc2VyaWY7XHJcblxyXG4gICAgICAgIC5tYXQtcGFnaW5hdG9yLXBhZ2Utc2l6ZSwgLm1hdC1wYWdpbmF0b3ItcmFuZ2UtYWN0aW9uc3tcclxuICAgICAgICAgIGhlaWdodDogaW5oZXJpdDsgIFxyXG4gICAgICAgICAgYWxpZ24taXRlbXM6IGJhc2VsaW5lO1xyXG4gICAgICAgICAgcGFkZGluZy1yaWdodDogJHNtYWxsLXBhZGRpbmc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC5tYXQtcGFnaW5hdG9yLXBhZ2Utc2l6ZS1sYWJlbCwgLm1hdC1wYWdpbmF0b3ItcmFuZ2UtbGFiZWx7XHJcbiAgICAgICAgICB3aGl0ZS1zcGFjZTogbm93cmFwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gaXRlbXMvcGFnZSBzZWxlY3RvclxyXG4gICAgICAgIC5tYXQtcGFnaW5hdG9yLXBhZ2Utc2l6ZS1zZWxlY3R7XHJcbiAgICAgICAgICBtYXJnaW46IDA7XHJcbiAgICAgICAgICAubWF0LWZvcm0tZmllbGQtd3JhcHBlcntcclxuICAgICAgICAgICAgcGFkZGluZy1ib3R0b206IDAuOTVlbTtcclxuICAgICAgICAgICAgLm1hdC1mb3JtLWZpZWxkLWZsZXggLm1hdC1mb3JtLWZpZWxkLWluZml4IC5tYXQtc2VsZWN0IC5tYXQtc2VsZWN0LXRyaWdnZXIgLm1hdC1zZWxlY3QtdmFsdWV7XHJcbiAgICAgICAgICAgICAgZm9udC1mYW1pbHk6IHNhbnMtc2VyaWY7XHJcbiAgICAgICAgICAgICAgY29sb3I6ICRjb2xvcjE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHBhZ2UgY2hhbmdlIGljb25zXHJcbiAgICAgICAgLm1hdC1pY29uLWJ1dHRvbjpob3ZlciAubWF0LXBhZ2luYXRvci1pY29ue1xyXG4gICAgICAgICAgZmlsbDogJHNlbGVjdGVkLWNvbG9yO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgfVxyXG59XHJcbiIsIi50YWJsZS0tY29udGFpbmVyIHtcbiAgb3ZlcmZsb3cteTogYXV0bztcbiAgb3ZlcmZsb3cteDogYXV0bztcbn1cblxuLm1hdC10YWJsZSB7XG4gIGJhY2tncm91bmQtY29sb3I6IHdoaXRlc21va2U7XG4gIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjQ0NDQ0NDO1xufVxuXG4jYXR0cmliTGFiZWwge1xuICBtYXJnaW46IDA7XG4gIHBhZGRpbmc6IDA7XG59XG4jYXR0cmliTGFiZWwgZGQge1xuICBmbG9hdDogbGVmdDtcbiAgbWFyZ2luOiAwO1xufVxuI2F0dHJpYkxhYmVsIGRkIHNwYW4ge1xuICBiYWNrZ3JvdW5kOiAjMDAwMDZkO1xuICBoZWlnaHQ6IDVweDtcbiAgd2lkdGg6IGNhbGMoMTAwJSAtIDFweCk7XG4gIGRpc3BsYXk6IGJsb2NrO1xuICBib3JkZXItcmlnaHQ6IDFweCBzb2xpZCAjYmZiZmJmO1xufVxuXG50YWJsZSB7XG4gIHdpZHRoOiAxMDAlO1xuICBmb250LWZhbWlseTogc2Fucy1zZXJpZjtcbiAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XG59XG50YWJsZSB0aCBpIHtcbiAgY29sb3I6IHJnYmEoMTE3LCAxMTcsIDExNywgMC41KTtcbiAgZm9udC1zaXplOiAxNnB4O1xuICBtYXJnaW4tbGVmdDogNXB4O1xufVxudGFibGUgdGggaS5hY3RpdmUge1xuICBjb2xvcjogIzAwMDA2ZDtcbiAgYmFja2dyb3VuZDogdW5zZXQ7XG59XG50YWJsZSB0aCAubWF0ZXJpYWwtaWNvbnMge1xuICBjb2xvcjogcmdiYSgxMTcsIDExNywgMTE3LCAwLjUpO1xuICB3aWR0aDogMTZweDtcbiAgaGVpZ2h0OiAxNnB4O1xuICBtYXJnaW4tbGVmdDogNXB4O1xufVxudGFibGUgdGggLm1hdGVyaWFsLWljb25zLmFjdGl2ZSB7XG4gIGNvbG9yOiAjMDAwMDZkO1xuICBiYWNrZ3JvdW5kOiB1bnNldDtcbn1cbnRhYmxlIHRoLm1hdC1oZWFkZXItY2VsbDpub3QoOmZpcnN0LW9mLXR5cGUpIHtcbiAgcGFkZGluZzogMHB4IDVweDtcbn1cbnRhYmxlIHRoLm1hdC1oZWFkZXItY2VsbCB7XG4gIGJvcmRlci1yaWdodDogMXB4IHNvbGlkICNCM0IzQjM7XG59XG50YWJsZSB0aC5tYXQtaGVhZGVyLWNlbGw6Zmlyc3Qtb2YtdHlwZSB7XG4gIHdpZHRoOiA0MHB4ICFpbXBvcnRhbnQ7XG4gIHBhZGRpbmctbGVmdDogMTJweDtcbn1cbnRhYmxlIHRoOm50aC1jaGlsZCgyKSB7XG4gIHdpZHRoOiAxMDBweDtcbn1cbnRhYmxlIHRoOmxhc3QtY2hpbGQge1xuICB3aWR0aDogMjAwMHB4O1xufVxudGFibGUgdHIubWF0LWhlYWRlci1yb3cge1xuICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZXNtb2tlO1xuICBoZWlnaHQ6IDI3cHg7XG59XG50YWJsZSB0ci5tYXQtcm93IHtcbiAgaGVpZ2h0OiAyNHB4O1xufVxudGFibGUgdHIubWF0LXJvdy5zZWxlY3RlZC1yb3cgLm1hdC1jZWxsIHtcbiAgYmFja2dyb3VuZC1jb2xvcjogI2U2ZTZlNjtcbn1cbnRhYmxlIHRyLm1hdC1yb3cgLm1hdC1jZWxsIHtcbiAgLXdlYmtpdC10b3VjaC1jYWxsb3V0OiBub25lO1xuICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xuICAtbW96LXVzZXItc2VsZWN0OiBub25lO1xuICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7XG4gIHVzZXItc2VsZWN0OiBub25lO1xuICBmb250LXNpemU6IDEycHg7XG4gIGNvbG9yOiAjMzczNzM3O1xuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmFmYWZiO1xuICBib3JkZXItYm90dG9tOiAxcHggc29saWQgI0IzQjNCMztcbiAgYm9yZGVyLWxlZnQ6IDFweCBzb2xpZCB0cmFuc3BhcmVudDtcbiAgYm9yZGVyLXJpZ2h0OiAxcHggc29saWQgI0IzQjNCMztcbn1cbnRhYmxlIHRyLm1hdC1yb3cgLm1hdC1jZWxsOm5vdCg6Zmlyc3Qtb2YtdHlwZSkge1xuICBwYWRkaW5nOiAwcHggNXB4O1xuICB3aGl0ZS1zcGFjZTogbm93cmFwO1xuICBvdmVyZmxvdzogaGlkZGVuO1xuICB0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcbiAgbWF4LXdpZHRoOiAzODBweDtcbn1cbnRhYmxlIHRyLm1hdC1yb3cgLm1hdC1jZWxsOmZpcnN0LW9mLXR5cGUge1xuICB3aWR0aDogNDBweCAhaW1wb3J0YW50O1xuICBwYWRkaW5nLWxlZnQ6IDEycHg7XG59XG50YWJsZSB0ci5tYXQtcm93IC5tYXQtY2VsbDpudGgtY2hpbGQoMikge1xuICB3aWR0aDogMTAwcHg7XG59XG50YWJsZSB0ci5tYXQtcm93IC5tYXQtY2VsbDpsYXN0LWNoaWxkIHtcbiAgd2lkdGg6IDIwMDBweDtcbn1cbnRhYmxlIHRyLm1hdC1yb3c6bGFzdC1jaGlsZCAubWF0LWNlbGwge1xuICBib3JkZXItYm90dG9tLWNvbG9yOiB0cmFuc3BhcmVudDtcbn1cbnRhYmxlIHRkLm1hdC1jZWxsOmZpcnN0LW9mLXR5cGUsIHRhYmxlIHRkLm1hdC1mb290ZXItY2VsbDpmaXJzdC1vZi10eXBlLCB0YWJsZSB0aC5tYXQtaGVhZGVyLWNlbGw6Zmlyc3Qtb2YtdHlwZSB7XG4gIHdpZHRoOiAxMCU7XG59XG5cbnRhYmxlLmMyIHRyLm1hdC1yb3cgLm1hdC1jZWxsOm50aC1jaGlsZCgyKSwgdGFibGUuYzIgdGg6bnRoLWNoaWxkKDIpIHtcbiAgZm9udC1zdHlsZTogaXRhbGljO1xufVxuXG46Om5nLWRlZXAgdGFibGUgdGg6bGFzdC1jaGlsZCAubWF0LXNvcnQtaGVhZGVyLWNvbnRhaW5lciB7XG4gIGRpc3BsYXk6IG5vbmU7XG59XG5cbjo6bmctZGVlcCAjYXR0cmliVGFiIHtcbiAgaGVpZ2h0OiAxMDAlO1xuICB3aWR0aDogMTAwJTtcbiAgb3ZlcmZsb3cteDogc2Nyb2xsO1xufVxuOjpuZy1kZWVwICNhdHRyaWJUYWIgdWwge1xuICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcbiAgbWFyZ2luOiAwO1xuICBwYWRkaW5nLWxlZnQ6IDExcHg7XG4gIHdoaXRlLXNwYWNlOiBub3dyYXA7XG4gIGhlaWdodDogMjBweDtcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICB0b3A6IDFweDtcbiAgd2lkdGg6IDEwMCU7XG4gIG1pbi13aWR0aDogZml0LWNvbnRlbnQ7XG4gIGRpc3BsYXk6IGlubGluZS1mbGV4O1xufVxuOjpuZy1kZWVwICNhdHRyaWJUYWIgdWwgbGkge1xuICBsaXN0LXN0eWxlOiBub25lO1xuICBmbG9hdDogbGVmdDtcbiAgd2lkdGg6IDkwcHg7XG4gIGNvbG9yOiAjODA4MDgwO1xuICBvdmVyZmxvdzogdmlzaWJsZTtcbiAgY3Vyc29yOiBwb2ludGVyO1xuICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gIGhlaWdodDogaW5oZXJpdDtcbiAgcGFkZGluZzogMHB4O1xufVxuOjpuZy1kZWVwICNhdHRyaWJUYWIgdWwgbGkgc3BhbiB7XG4gIGZvbnQtZmFtaWx5OiBzYW5zLXNlcmlmO1xuICBtYXJnaW4tcmlnaHQ6IDJweDtcbiAgZm9udC13ZWlnaHQ6IDU1MDtcbiAgZm9udC1zaXplOiAxMnB4O1xuICBsaW5lLWhlaWdodDogMTVweDtcbiAgYm9yZGVyOiAxcHggc29saWQgdHJhbnNwYXJlbnQ7XG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgZGlzcGxheTogYmxvY2s7XG4gIHBhZGRpbmc6IDJweDtcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIHdpZHRoOiBpbmhlcml0O1xuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICB3aWR0aDogMTAwJTtcbiAgbWFyZ2luLXRvcDogLTFweDtcbiAgaGVpZ2h0OiAyMXB4O1xufVxuOjpuZy1kZWVwICNhdHRyaWJUYWIgdWwgbGk6aG92ZXIge1xuICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcbn1cbjo6bmctZGVlcCAjYXR0cmliVGFiIHVsIGxpOmhvdmVyIHNwYW4ge1xuICBjb2xvcjogIzAwMDA2ZDtcbiAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XG59XG46Om5nLWRlZXAgI2F0dHJpYlRhYiB1bCBsaS5hY3RpdmUge1xuICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcbn1cbjo6bmctZGVlcCAjYXR0cmliVGFiIHVsIGxpLmFjdGl2ZSBzcGFuIHtcbiAgY29sb3I6ICMwMDAwNmQ7XG4gIGN1cnNvcjogZGVmYXVsdDtcbiAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGVzbW9rZTtcbiAgYm9yZGVyOiAxcHggc29saWQgI0IzQjNCMztcbiAgYm9yZGVyLWJvdHRvbTogMnB4IHNvbGlkIHdoaXRlc21va2U7XG59XG46Om5nLWRlZXAgI2F0dHJpYlRhYiB1bCBsaTpudGgtY2hpbGQoMikge1xuICB3aWR0aDogODVweDtcbn1cbjo6bmctZGVlcCAjYXR0cmliVGFiIC5wYW5lIHtcbiAgbWFyZ2luLXRvcDogMjBweDtcbiAgaGVpZ2h0OiBjYWxjKDEwMCUgLSAzMXB4KTtcbn1cbjo6bmctZGVlcCAjYXR0cmliVGFiIC5wYW5lIC5tYXQtZWxldmF0aW9uLXoxIHtcbiAgZGlzcGxheTogZmxleDtcbiAgZmxleC1mbG93OiBjb2x1bW4gbm93cmFwO1xuICBoZWlnaHQ6IDEwMCU7XG4gIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcbiAgYm94LXNoYWRvdzogbm9uZTtcbiAgYm9yZGVyLXRvcDogMXB4IHNvbGlkICNCM0IzQjM7XG59XG5cbi5hdHRyaWItLWNvbnRhaW5lciB7XG4gIGhlaWdodDogY2FsYygxMDAlIC0gMzBweCk7XG59XG4uYXR0cmliLS1jb250YWluZXIgI2F0dHJpYlRhYiB7XG4gIGhlaWdodDogMTAwJTtcbn1cbi5hdHRyaWItLWNvbnRhaW5lciAjYXR0cmliVGFiIG15LXRhYiB7XG4gIGhlaWdodDogMTAwJTtcbn1cblxuI2VtcHR5TWVzc2FnZSB7XG4gIHRleHQtYWxpZ246IGxlZnQ7XG4gIG1hcmdpbi10b3A6IC0yMHB4O1xuICBtYXJnaW4tbGVmdDogMTBweDtcbiAgY29sb3I6ICM4ODg4ODg7XG59XG5cbi5idG0tLWNvbnRhaW5lciB7XG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgaGVpZ2h0OiAzMHB4O1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGZsZXgtZmxvdzogcm93IG5vd3JhcDtcbiAganVzdGlmeS1jb250ZW50OiBmbGV4LWVuZDtcbiAgd2lkdGg6IDEwMCU7XG4gIGJvdHRvbTogMHB4O1xufVxuLmJ0bS0tY29udGFpbmVyICNkaXNwbGF5U2VsZWN0ZWQge1xuICBwYWRkaW5nLWxlZnQ6IDEwcHg7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgei1pbmRleDogMTtcbiAgYm90dG9tOiAxM3B4O1xuICBsZWZ0OiA1cHg7XG59XG4uYnRtLS1jb250YWluZXIgI2Rpc3BsYXlTZWxlY3RlZCAuY29udGFpbmVyIHtcbiAgZGlzcGxheTogYmxvY2s7XG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgcGFkZGluZy1sZWZ0OiAxOHB4O1xuICBjdXJzb3I6IHBvaW50ZXI7XG4gIGZvbnQtc2l6ZTogMTJweDtcbiAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTtcbiAgLW1vei11c2VyLXNlbGVjdDogbm9uZTtcbiAgLW1zLXVzZXItc2VsZWN0OiBub25lO1xuICB1c2VyLXNlbGVjdDogbm9uZTtcbiAgLyogT24gbW91c2Utb3ZlciwgYWRkIGEgZ3JleSBiYWNrZ3JvdW5kIGNvbG9yICovXG4gIC8qIFdoZW4gdGhlIGNoZWNrYm94IGlzIGNoZWNrZWQsIGFkZCBhIGJsdWUgYmFja2dyb3VuZCAqL1xuICAvKiBDcmVhdGUgdGhlIGNoZWNrbWFyay9pbmRpY2F0b3IgKGhpZGRlbiB3aGVuIG5vdCBjaGVja2VkKSAqL1xuICAvKiBTaG93IHRoZSBjaGVja21hcmsgd2hlbiBjaGVja2VkICovXG4gIC8qIFN0eWxlIHRoZSBjaGVja21hcmsvaW5kaWNhdG9yICovXG59XG4uYnRtLS1jb250YWluZXIgI2Rpc3BsYXlTZWxlY3RlZCAuY29udGFpbmVyIGlucHV0W3R5cGU9Y2hlY2tib3hdIHtcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICBvcGFjaXR5OiAwO1xuICBjdXJzb3I6IHBvaW50ZXI7XG4gIGhlaWdodDogMDtcbiAgd2lkdGg6IDA7XG59XG4uYnRtLS1jb250YWluZXIgI2Rpc3BsYXlTZWxlY3RlZCAuY29udGFpbmVyIC5jaGVja21hcmsge1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIHRvcDogMTtcbiAgbGVmdDogMDtcbiAgaGVpZ2h0OiAxMHB4O1xuICB3aWR0aDogMTBweDtcbiAgYm9yZGVyOiAxcHggc29saWQgI2NjYztcbn1cbi5idG0tLWNvbnRhaW5lciAjZGlzcGxheVNlbGVjdGVkIC5jb250YWluZXI6aG92ZXIgaW5wdXQgfiAuY2hlY2ttYXJrIHtcbiAgYmFja2dyb3VuZC1jb2xvcjogI2VlZTtcbn1cbi5idG0tLWNvbnRhaW5lciAjZGlzcGxheVNlbGVjdGVkIC5jb250YWluZXIgaW5wdXQ6Y2hlY2tlZCB+IC5jaGVja21hcmsge1xuICBib3JkZXI6IDFweCBzb2xpZCAjMDAwMDZkO1xufVxuLmJ0bS0tY29udGFpbmVyICNkaXNwbGF5U2VsZWN0ZWQgLmNvbnRhaW5lciAuY2hlY2ttYXJrOmFmdGVyIHtcbiAgY29udGVudDogXCJcIjtcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICBkaXNwbGF5OiBub25lO1xufVxuLmJ0bS0tY29udGFpbmVyICNkaXNwbGF5U2VsZWN0ZWQgLmNvbnRhaW5lciBpbnB1dDpjaGVja2VkIH4gLmNoZWNrbWFyazphZnRlciB7XG4gIGRpc3BsYXk6IGJsb2NrO1xufVxuLmJ0bS0tY29udGFpbmVyICNkaXNwbGF5U2VsZWN0ZWQgLmNvbnRhaW5lciAuY2hlY2ttYXJrOmFmdGVyIHtcbiAgbGVmdDogNHB4O1xuICB0b3A6IC0zcHg7XG4gIHdpZHRoOiA0cHg7XG4gIGhlaWdodDogMTFweDtcbiAgYm9yZGVyOiBzb2xpZCAjMDAwMDZkO1xuICBib3JkZXItd2lkdGg6IDAgMXB4IDFweCAwO1xuICAtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKDQ1ZGVnKTtcbiAgLW1zLXRyYW5zZm9ybTogcm90YXRlKDQ1ZGVnKTtcbiAgdHJhbnNmb3JtOiByb3RhdGUoNDVkZWcpO1xufVxuLmJ0bS0tY29udGFpbmVyIC5wYWdpbmF0b3ItLWNvbnRhaW5lciB7XG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgd2lkdGg6IDgwJTtcbiAgZGlzcGxheTogZmxleDtcbiAgZmxleC1mbG93OiByb3cgbm93cmFwO1xuICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtZW5kO1xufVxuLmJ0bS0tY29udGFpbmVyICNtYXRQYWdpbmF0b3Ige1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIHRvcDogLTIwcHg7XG4gIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xuICB3aWR0aDogMTAwJTtcbn1cbi5idG0tLWNvbnRhaW5lciAjbWF0UGFnaW5hdG9yLmhpZGUge1xuICBkaXNwbGF5OiBub25lO1xufVxuLmJ0bS0tY29udGFpbmVyICNtYXRQYWdpbmF0b3IgLm1hdC1wYWdpbmF0b3Itb3V0ZXItY29udGFpbmVyIC5tYXQtcGFnaW5hdG9yLWNvbnRhaW5lciB7XG4gIHdpZHRoOiBpbmhlcml0O1xuICBtaW4taGVpZ2h0OiAzMHB4ICFpbXBvcnRhbnQ7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgYm90dG9tOiA4cHg7XG4gIGhlaWdodDogMjBweDtcbiAgZGlzcGxheTogZmxleDtcbiAgZmxleC1mbG93OiByb3cgbm93cmFwO1xuICBmbGV4LXNocmluazogMDtcbiAgZm9udC1mYW1pbHk6IHNhbnMtc2VyaWY7XG59XG4uYnRtLS1jb250YWluZXIgI21hdFBhZ2luYXRvciAubWF0LXBhZ2luYXRvci1vdXRlci1jb250YWluZXIgLm1hdC1wYWdpbmF0b3ItY29udGFpbmVyIC5tYXQtcGFnaW5hdG9yLXBhZ2Utc2l6ZSwgLmJ0bS0tY29udGFpbmVyICNtYXRQYWdpbmF0b3IgLm1hdC1wYWdpbmF0b3Itb3V0ZXItY29udGFpbmVyIC5tYXQtcGFnaW5hdG9yLWNvbnRhaW5lciAubWF0LXBhZ2luYXRvci1yYW5nZS1hY3Rpb25zIHtcbiAgaGVpZ2h0OiBpbmhlcml0O1xuICBhbGlnbi1pdGVtczogYmFzZWxpbmU7XG4gIHBhZGRpbmctcmlnaHQ6IDE1cHg7XG59XG4uYnRtLS1jb250YWluZXIgI21hdFBhZ2luYXRvciAubWF0LXBhZ2luYXRvci1vdXRlci1jb250YWluZXIgLm1hdC1wYWdpbmF0b3ItY29udGFpbmVyIC5tYXQtcGFnaW5hdG9yLXBhZ2Utc2l6ZS1sYWJlbCwgLmJ0bS0tY29udGFpbmVyICNtYXRQYWdpbmF0b3IgLm1hdC1wYWdpbmF0b3Itb3V0ZXItY29udGFpbmVyIC5tYXQtcGFnaW5hdG9yLWNvbnRhaW5lciAubWF0LXBhZ2luYXRvci1yYW5nZS1sYWJlbCB7XG4gIHdoaXRlLXNwYWNlOiBub3dyYXA7XG59XG4uYnRtLS1jb250YWluZXIgI21hdFBhZ2luYXRvciAubWF0LXBhZ2luYXRvci1vdXRlci1jb250YWluZXIgLm1hdC1wYWdpbmF0b3ItY29udGFpbmVyIC5tYXQtcGFnaW5hdG9yLXBhZ2Utc2l6ZS1zZWxlY3Qge1xuICBtYXJnaW46IDA7XG59XG4uYnRtLS1jb250YWluZXIgI21hdFBhZ2luYXRvciAubWF0LXBhZ2luYXRvci1vdXRlci1jb250YWluZXIgLm1hdC1wYWdpbmF0b3ItY29udGFpbmVyIC5tYXQtcGFnaW5hdG9yLXBhZ2Utc2l6ZS1zZWxlY3QgLm1hdC1mb3JtLWZpZWxkLXdyYXBwZXIge1xuICBwYWRkaW5nLWJvdHRvbTogMC45NWVtO1xufVxuLmJ0bS0tY29udGFpbmVyICNtYXRQYWdpbmF0b3IgLm1hdC1wYWdpbmF0b3Itb3V0ZXItY29udGFpbmVyIC5tYXQtcGFnaW5hdG9yLWNvbnRhaW5lciAubWF0LXBhZ2luYXRvci1wYWdlLXNpemUtc2VsZWN0IC5tYXQtZm9ybS1maWVsZC13cmFwcGVyIC5tYXQtZm9ybS1maWVsZC1mbGV4IC5tYXQtZm9ybS1maWVsZC1pbmZpeCAubWF0LXNlbGVjdCAubWF0LXNlbGVjdC10cmlnZ2VyIC5tYXQtc2VsZWN0LXZhbHVlIHtcbiAgZm9udC1mYW1pbHk6IHNhbnMtc2VyaWY7XG4gIGNvbG9yOiAjODA4MDgwO1xufVxuLmJ0bS0tY29udGFpbmVyICNtYXRQYWdpbmF0b3IgLm1hdC1wYWdpbmF0b3Itb3V0ZXItY29udGFpbmVyIC5tYXQtcGFnaW5hdG9yLWNvbnRhaW5lciAubWF0LWljb24tYnV0dG9uOmhvdmVyIC5tYXQtcGFnaW5hdG9yLWljb24ge1xuICBmaWxsOiAjMDAwMDZkO1xufSIsIlxyXG4kY29sb3IxOiAjODA4MDgwO1xyXG4kY29sb3IyOiAjOTk5OTk5O1xyXG4kY29sb3IzOiAjQjNCM0IzOyBcclxuJGNvbG9yNDogI0NDQ0NDQztcclxuJGNvbG9yNTogI0U2RTZFNjtcclxuJGNvbG9yNS01OiByZ2IoMjQ1LCAyNDUsIDI0NSk7XHJcbiRjb2xvcjY6IHJnYigyNTAsIDI1MCwgMjUxKTtcclxuXHJcbiRjb2xvcjc6IHdoaXRlO1xyXG4kY29sb3I4OiAjMzczNzM3O1xyXG5cclxuJHNlbGVjdGVkLWNvbG9yOiByZ2IoMCwgMCwgMTA5KTtcclxuJHNlbGVjdGVkLWNvbG9yMTogcmdiKDIyOCwgMjI4LCAyNDcpO1xyXG4kc2VsZWN0ZWQtY29sb3IyOiByZ2IoMjE1LCAyMTUsIDI1NSk7XHJcbiRob3Zlci1jb2xvcjogJGNvbG9yMjtcclxuXHJcbiRlcnJvci1jb2xvcjogI0U5NDg1ODsgLy9waW5rLXJlZFxyXG4kZXJyb3ItY29sb3ItbHQ6IHJnYigyNTUsIDIyMCwgMjI0KTtcclxuJHBjb2xvcjI6ICNGM0EzMkE7IC8vb3JhbmdlLXllbGxvd1xyXG4kcHJpbnQtY29sb3I6IHJnYigxMzAsIDE5MSwgMTEwKTsgLy9saWdodGdyZWVuXHJcbiRwcmludC1jb2xvci1sdDogcmdiKDIzMCwgMjU1LCAyMjEpO1xyXG4kcHJpbnQtY29sb3ItZGs6IHJnYig2MywgOTksIDUxKTsgLy9saWdodGdyZWVuXHJcbiRzZWxlY3RHZW9tLWNvbG9yOiByZ2IoMjU1LCAxNzQsIDApOyAvLyBsaWdodCBvcmFuZ2VcclxuJHNlbGVjdEdlb20tY29sb3ItbHQ6IHJnYigyNTUsIDIyNSwgMTYwKTtcclxuXHJcbi8vICRwcm9kLWJhY2tncm91bmQtY29sb3I6IHJnYigyNTAsMjUwLDI1MCk7XHJcbi8vICRiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMjIwLDIyMCwyMjApO1xyXG4kZnVuY3Rpb24tdGV4dC1jb2xvcjogcmdiKDE5MCwgMTQwLCAzMCk7XHJcbiRmdW5jdGlvbi10ZXh0LWNvbG9yMjogcmdiKDE4LCAxMjYsIDEzNik7XHJcbiRmdW5jdGlvbi10ZXh0LWNvbG9yMzogcmdiKDE5MCwgMTQwLCAzMCk7XHJcbiRiYXNpYy1mdW5jdGlvbi10ZXh0LWNvbG9yOiByZ2IoMjAwLCA3MCwgMTUwKTtcclxuJGNvbW1lbnQtY29sb3I6IGRhcmtncmVlbjtcclxuIiwiJHBhZGRpbmc6IDQwcHg7IC8vID8gbm90IHVzZWRcclxuJHNtYWxsLXBhZGRpbmc6IDE1cHg7XHJcbiRoZWFkZXItaGVpZ2h0OiA0MHB4O1xyXG5cclxuJGZzaXplMTogMTVweDtcclxuJGZzaXplMjogMTJweDtcclxuJGZzaXplMzogMzBweDtcclxuXHJcbiRwb3J0LXNpemU6IDE1cHg7XHJcbiRkZWZhdWx0LXNpZGUtcGFkZGluZzogMTVweDtcclxuXHJcbiRkaXNhYmxlZC1vcGFjaXR5OiAwLjQ7Il19 */");

/***/ }),

/***/ "./src/app/gi-viewer/attribute/attribute.component.ts":
/*!************************************************************!*\
  !*** ./src/app/gi-viewer/attribute/attribute.component.ts ***!
  \************************************************************/
/*! exports provided: AttributeComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AttributeComponent", function() { return AttributeComponent; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
/* harmony import */ var _angular_material_paginator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/material/paginator */ "./node_modules/@angular/material/esm2015/paginator.js");
/* harmony import */ var _angular_material_sort__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/material/sort */ "./node_modules/@angular/material/esm2015/sort.js");
/* harmony import */ var _angular_material_table__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/material/table */ "./node_modules/@angular/material/esm2015/table.js");
/* harmony import */ var _libs_geo_info_GIModel__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @libs/geo-info/GIModel */ "./src/assets/libs/geo-info/GIModel.ts");
/* harmony import */ var _data_data_service__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../data/data.service */ "./src/app/gi-viewer/data/data.service.ts");
/* harmony import */ var _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @libs/geo-info/common */ "./src/assets/libs/geo-info/common.ts");
/* harmony import */ var _libs_geo_info_GIAttribsThreejs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @libs/geo-info/GIAttribsThreejs */ "./src/assets/libs/geo-info/GIAttribsThreejs.ts");
/* harmony import */ var _tabs_component__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./tabs.component */ "./src/app/gi-viewer/attribute/tabs.component.ts");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};









var SORT_STATE;
(function (SORT_STATE) {
    SORT_STATE[SORT_STATE["DEFAULT"] = 0] = "DEFAULT";
    SORT_STATE[SORT_STATE["ASCENDING"] = 1] = "ASCENDING";
    SORT_STATE[SORT_STATE["DESCENDING"] = 2] = "DESCENDING";
})(SORT_STATE || (SORT_STATE = {}));
let AttributeComponent = class AttributeComponent {
    constructor(injector) {
        this.attrTableSelect = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this.selectSwitch = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this.attribLabel = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this.showSelected = false;
        this.currentShowingCol = '';
        this.shiftKeyPressed = false;
        this.tabs = [
            { type: _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_6__["EEntType"].POSI, title: 'Positions' },
            { type: _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_6__["EEntType"].VERT, title: 'Vertices' },
            { type: _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_6__["EEntType"].EDGE, title: 'Edges' },
            { type: _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_6__["EEntType"].WIRE, title: 'Wires' },
            { type: _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_6__["EEntType"].FACE, title: 'Faces' },
            { type: _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_6__["EEntType"].POINT, title: 'Points' },
            { type: _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_6__["EEntType"].PLINE, title: 'Polylines' },
            { type: _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_6__["EEntType"].PGON, title: 'Polygons' },
            { type: _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_6__["EEntType"].COLL, title: 'Collections' },
            { type: _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_6__["EEntType"].MOD, title: 'Model' }
        ];
        this.displayedColumns = [];
        this.displayData = [];
        this.selected_ents = new Map();
        this.multi_selection = new Map();
        this.table_scroll = null;
        this.sorting_header = null;
        this.sorting_state = SORT_STATE.DEFAULT;
        this.paginator = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["QueryList"]();
        this.sort = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["QueryList"]();
        this.tab_map = {
            0: _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_6__["EEntType"].POSI,
            1: _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_6__["EEntType"].VERT,
            2: _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_6__["EEntType"].EDGE,
            3: _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_6__["EEntType"].WIRE,
            4: _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_6__["EEntType"].FACE,
            5: _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_6__["EEntType"].POINT,
            6: _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_6__["EEntType"].PLINE,
            7: _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_6__["EEntType"].PGON,
            8: _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_6__["EEntType"].COLL,
            9: _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_6__["EEntType"].MOD
        };
        this.tab_rev_map = {
            0: 0,
            2: 1,
            3: 2,
            4: 3,
            5: 4,
            6: 5,
            7: 6,
            8: 7,
            9: 8,
            10: 9
        };
        this.columnItalic = 'c2';
        this.dataService = injector.get(_data_data_service__WEBPACK_IMPORTED_MODULE_5__["DataService"]);
        if (localStorage.getItem('mpm_attrib_current_tab') === null) {
            localStorage.setItem('mpm_attrib_current_tab', '0');
        }
    }
    // ngDoCheck() {
    //     const attrib = document.getElementById('attribTable');
    //     if (attrib) {
    //         const paginators = document.getElementsByClassName('mat-paginator');
    //         const l = paginators.length;
    //         if (attrib.clientWidth < 600) {
    //             let index = 0;
    //             for (; index < l; index++) {
    //                 const p = paginators[index];
    //                 p.className = 'mat-paginator '; // hide
    //             }
    //         } else {
    //             let index = 0;
    //             for (; index < l; index++) {
    //                 const p = paginators[index];
    //                 p.className = 'mat-paginator';
    //             }
    //         }
    //     }
    // }
    ngOnChanges(changes) {
        if (changes['data'] && this.model) {
            this.refreshTable();
        }
        if (changes['reset']) {
            this.resetTable();
        }
        if (changes['refresh']) {
            if (document.getElementsByClassName('table--container')[this.getCurrentTab()]) {
                this.table_scroll = document.getElementsByClassName('table--container')[this.getCurrentTab()].scrollTop;
            }
            this.refreshTable();
        }
    }
    generateTable(tabIndex) {
        if (this.model) {
            const ThreeJSData = this.model.modeldata.attribs.threejs;
            if (Number(tabIndex) === 9) {
                this.displayData = ThreeJSData.getModelAttribsForTable();
            }
            else {
                const ready = this.model.modeldata.attribs.threejs instanceof _libs_geo_info_GIAttribsThreejs__WEBPACK_IMPORTED_MODULE_7__["GIAttribsThreejs"];
                this.selected_ents = this.dataService.selected_ents.get(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_6__["EEntTypeStr"][this.tab_map[tabIndex]]);
                if (!ready) {
                    return;
                }
                if (this.showSelected) {
                    const SelectedAttribData = ThreeJSData.getEntsVals(this.selected_ents, this.tab_map[tabIndex]);
                    SelectedAttribData.map(row => {
                        if (this.selected_ents.has(row._id)) {
                            return row.selected = true;
                        }
                    });
                    this.displayData = SelectedAttribData;
                }
                else {
                    const AllAttribData = ThreeJSData.getAttribsForTable(this.tab_map[tabIndex]).data;
                    AllAttribData.map(row => {
                        if (this.selected_ents.has(row._id)) {
                            return row.selected = true;
                        }
                    });
                    this.displayData = AllAttribData;
                }
            }
            if (this.displayData.length > 0) {
                const columns = Object.keys(this.displayData[0]).filter(e => e !== 'selected');
                let new_columns;
                if (Number(tabIndex) === 9) {
                    new_columns = columns;
                }
                else {
                    const first = columns.shift();
                    // const second = columns.shift();
                    const selected = columns.find(column => column.substr(0, 1) === '_');
                    const rest_of_columns = columns.filter(column => column.substr(0, 1) !== '_');
                    // new_columns = selected ? [first, second, selected, ...rest_of_columns, ' ']
                    // : [first, second, ...rest_of_columns, ' '];
                    new_columns = selected ? [first, selected, ...rest_of_columns, ' '] : [first, ...rest_of_columns, ' '];
                }
                this.displayedColumns = new_columns;
                this.dataSource = new _angular_material_table__WEBPACK_IMPORTED_MODULE_3__["MatTableDataSource"](this.displayData);
            }
            else {
                this.displayedColumns = [];
                this.dataSource = new _angular_material_table__WEBPACK_IMPORTED_MODULE_3__["MatTableDataSource"]();
            }
            this.dataSource.sortingDataAccessor = this._sortingDataAccessor;
            this.dataSource.paginator = this.paginator.toArray()[tabIndex];
            this.dataSource.sort = this.sort.toArray()[tabIndex];
            if (this.table_scroll) {
                setTimeout(() => {
                    document.getElementsByClassName('table--container')[this.getCurrentTab()].scrollTop = this.table_scroll;
                    this.table_scroll = null;
                }, 0);
            }
        }
        return tabIndex;
    }
    _sortingDataAccessor(data, headerID) {
        if (headerID === '_id') {
            return Number(data[headerID].slice(2));
        }
        else if (headerID === '_parent') {
            if (data[headerID] === '') {
                return -1;
            }
            return Number(data[headerID].slice(2));
        }
        return data[headerID];
    }
    _setDataSource(tabIndex) {
        setTimeout(() => {
            localStorage.setItem('mpm_attrib_current_tab', tabIndex.toString());
            const settings = JSON.parse(localStorage.getItem('mpm_settings'));
            if (settings !== undefined) {
                if (settings.select !== undefined) {
                    settings.select.tab = tabIndex.toString();
                }
                else {
                    settings.select = { selector: { id: '_f', name: 'Faces' }, tab: '0' };
                }
                localStorage.setItem('mpm_settings', JSON.stringify(settings));
            }
            if (tabIndex === 999) {
                this.displayedColumns = [];
                this.dataSource = new _angular_material_table__WEBPACK_IMPORTED_MODULE_3__["MatTableDataSource"]();
                this.dataSource.sortingDataAccessor = this._sortingDataAccessor;
            }
            else {
                this.generateTable(tabIndex);
            }
            this.last_selected = undefined;
        });
        sessionStorage.setItem('mpm_showSelected', JSON.stringify(this.showSelected));
    }
    getCurrentTab() {
        if (localStorage.getItem('mpm_attrib_current_tab') !== null) {
            return Number(localStorage.getItem('mpm_attrib_current_tab'));
        }
        else {
            return 0;
        }
    }
    showSelectedSwitch() {
        this.showSelected = !this.showSelected;
        sessionStorage.setItem('mpm_showSelected', JSON.stringify(this.showSelected));
        sessionStorage.setItem('mpm_changetab', 'false');
        this.selectSwitch.emit(this.showSelected);
        this.refreshTable();
    }
    refreshTable() {
        const currentTab = this.getCurrentTab();
        setTimeout(() => {
            if (sessionStorage.getItem('mpm_showSelected')) {
                this.showSelected = JSON.parse(sessionStorage.getItem('mpm_showSelected'));
            }
            let changeTab;
            if (sessionStorage.getItem('mpm_changetab')) {
                changeTab = JSON.parse(sessionStorage.getItem('mpm_changetab'));
            }
            // sessionStorage.setItem('mpm_changetab', 'true');
            if (changeTab) {
                if (this.model) {
                    if (currentTab === 0 || currentTab === 8 || currentTab === 9) {
                        this.child.selectTab(this.tab_rev_map[currentTab]);
                    }
                    else if (currentTab === 1 || currentTab === 2 || currentTab === 3 || currentTab === 4) {
                        this.child.selectTopology(currentTab, event);
                    }
                    else if (currentTab === 5 || currentTab === 6 || currentTab === 7) {
                        this.child.selectObject(currentTab, event);
                    }
                }
            }
            this.generateTable(currentTab);
        }, 0);
    }
    resetTable() {
        const rows = document.querySelectorAll('.selected-row');
        rows.forEach(row => row.classList.remove('selected-row'));
        this.selected_ents.clear();
        this.multi_selection.clear();
    }
    //   selectRow(ent_id: string, event) {
    //     const currentTab = this.getCurrentTab();
    //     if (currentTab === 9) {
    //       return;
    //     }
    //     const id = Number(ent_id.substr(2));
    //     // Multiple row selection
    //     const ThreeJSData = this.data.attribs.threejs;
    //     const attrib_table_ents = ThreeJSData.getAttribsForTable(this.tab_map[currentTab]).ents;
    //     this.current_selected = id;
    //     const s = this.multi_selection;
    //     if (event.ctrlKey) {
    //       this.last_selected = this.current_selected;
    //       s.set(this.current_selected, this.current_selected);
    //     } else {
    //       if (!event.shiftKey) {
    //         s.clear();
    //         s.set(this.current_selected, this.current_selected);
    //         this.last_selected = this.current_selected;
    //       } else {
    //         if (this.last_selected === undefined) {
    //           this.last_selected = ThreeJSData.getAttribsForTable(this.tab_map[currentTab]).ents[0];
    //         }
    //         s.clear();
    //         if (this.current_selected < this.last_selected) { // select upper row
    //           attrib_table_ents.filter(ents => ents > this.current_selected && ents < this.last_selected).forEach(item => {
    //             s.set(item, item);
    //           });
    //           s.set(this.current_selected, this.current_selected);
    //           s.set(this.last_selected, this.last_selected);
    //         } else if (this.current_selected > this.last_selected) { // select lower row
    //           attrib_table_ents.filter(ents => ents < this.current_selected && ents > this.last_selected).forEach(item => {
    //             s.set(item, item);
    //           });
    //           s.set(this.current_selected, this.current_selected);
    //           s.set(this.last_selected, this.last_selected);
    //         }
    //       }
    //     }
    //     const ent_type = ent_id.substr(0, 2);
    //     const target = event.target;
    //     if (s.size === 1) {
    //       if (this.selected_ents.has(ent_id)) {
    //         this.attrTableSelect.emit({ action: 'unselect', ent_type: ent_type, id: id });
    //         this.selected_ents.delete(ent_id);
    //         target.parentNode.classList.remove('selected-row');
    //       } else {
    //         this.attrTableSelect.emit({ action: 'select', ent_type: ent_type, id: id });
    //         this.selected_ents.set(ent_id, id);
    //         target.parentNode.classList.add('selected-row');
    //       }
    //     } else {
    //       this.attrTableSelect.emit({ action: 'select', ent_type: ent_type, id: s });
    //       s.forEach(_id => {
    //         this.selected_ents.set(ent_id, id);
    //       });
    //     }
    //   }
    selectRow(ent_id, event) {
        const currentTab = this.getCurrentTab();
        if (currentTab === 9) {
            return;
        }
        const id = Number(ent_id.substr(2));
        // Multiple row selection
        const ThreeJSData = this.model.modeldata.attribs.threejs;
        const attrib_table = ThreeJSData.getAttribsForTable(this.tab_map[currentTab]);
        this.current_selected = id;
        const s = this.multi_selection;
        // ctrl + click -> multiple selection: if already selected then deselect, if not selected then select
        if (event.ctrlKey || event.metaKey) {
            if (s.has(this.current_selected)) {
                s.delete(this.current_selected);
            }
            else {
                this.last_selected = this.current_selected;
                s.set(this.current_selected, this.current_selected);
            }
            // shift + click -> multiple selection, select all in between
        }
        else if (event.shiftKey) {
            // clear all selected
            s.clear();
            // if there is no last selected row -> select only the currently selected, set it as last selected for the next selection
            if (this.last_selected === undefined) {
                this.last_selected = this.current_selected;
                s.set(this.current_selected, this.current_selected);
                // if there is a last selected row -> select all in between current and last
            }
            else {
                // if sort state is based on "_id" -> filter based on table entities' index
                if (this.sorting_header === null || this.sorting_header === '_id' || this.sorting_state === SORT_STATE.DEFAULT) {
                    if (this.current_selected < this.last_selected) { // select upper row
                        attrib_table.ents.filter(ents => ents > this.current_selected && ents < this.last_selected).forEach(item => {
                            s.set(item, item);
                        });
                        s.set(this.current_selected, this.current_selected);
                        s.set(this.last_selected, this.last_selected);
                    }
                    else if (this.current_selected > this.last_selected) { // select lower row
                        attrib_table.ents.filter(ents => ents < this.current_selected && ents > this.last_selected).forEach(item => {
                            s.set(item, item);
                        });
                        s.set(this.current_selected, this.current_selected);
                        s.set(this.last_selected, this.last_selected);
                    }
                    // if sort state is not based on "_id"
                    // -> filter based on the sorting values, if the sorting values are the same as current or last,
                    // base it on the entities' index according whether the sorting is ascending or descending
                }
                else {
                    const lastIndex = attrib_table.ents.indexOf(this.last_selected);
                    const lastVal = attrib_table.data[lastIndex][this.sorting_header];
                    const currentIndex = attrib_table.ents.indexOf(this.current_selected);
                    const currentVal = attrib_table.data[currentIndex][this.sorting_header];
                    // if same values between last and current, filtered values must be the same
                    // while their index must be between last and current indices
                    if (lastVal === currentVal) {
                        if (this.current_selected < this.last_selected) { // select upper row
                            for (let i = 0; i < attrib_table.data.length; i++) {
                                const compare_val = attrib_table.data[i][this.sorting_header];
                                if (compare_val === currentVal && i >= currentIndex && i <= lastIndex) {
                                    s.set(attrib_table.ents[i], attrib_table.ents[i]);
                                }
                            }
                        }
                        else if (this.current_selected > this.last_selected) { // select lower row
                            for (let i = 0; i < attrib_table.data.length; i++) {
                                const compare_val = attrib_table.data[i][this.sorting_header];
                                if (compare_val === currentVal && i >= lastIndex && i <= currentIndex) {
                                    s.set(attrib_table.ents[i], attrib_table.ents[i]);
                                }
                            }
                        }
                        // filter down the row (last_selected is before current_selected in ordering) if:
                        //  _ descending and lastVal > currentVal
                        //  _ ascending and lastVal < currentVal
                        // ==> include rows with value = lastVal with index > lastIndex
                        // and rows with value = currentVal with index < currentIndex
                    }
                    else if ((this.sorting_state === SORT_STATE.DESCENDING && lastVal > currentVal) ||
                        (this.sorting_state === SORT_STATE.ASCENDING && lastVal < currentVal)) {
                        const lowerVal = Math.min(currentVal, lastVal);
                        const upperVal = Math.max(currentVal, lastVal);
                        for (let i = 0; i < attrib_table.data.length; i++) {
                            const compare_val = attrib_table.data[i][this.sorting_header];
                            if ((compare_val > lowerVal && compare_val < upperVal)
                                || (compare_val === lastVal && i >= lastIndex)
                                || (compare_val === currentVal && i <= currentIndex)) {
                                s.set(attrib_table.ents[i], attrib_table.ents[i]);
                            }
                        }
                        // filter up the row (last_selected is after current_selected in ordering) if:
                        //  _ descending and lastVal < currentVal
                        //  _ ascending and lastVal > currentVal
                        // ==> include rows with value = lastVal with index < lastIndex
                        // and rows with value = currentVal with index > currentIndex
                    }
                    else {
                        const lowerVal = Math.min(currentVal, lastVal);
                        const upperVal = Math.max(currentVal, lastVal);
                        for (let i = 0; i < attrib_table.data.length; i++) {
                            const compare_val = attrib_table.data[i][this.sorting_header];
                            if ((compare_val > lowerVal && compare_val < upperVal)
                                || (compare_val === lastVal && i <= lastIndex)
                                || (compare_val === currentVal && i >= currentIndex)) {
                                s.set(attrib_table.ents[i], attrib_table.ents[i]);
                            }
                        }
                    }
                }
            }
        }
        else {
            this.last_selected = this.current_selected;
            s.clear();
            s.set(this.current_selected, this.current_selected);
        }
        const ent_type = ent_id.substr(0, 2);
        const target = event.target;
        this.selected_ents.clear();
        if (s.size === 1) {
            this.attrTableSelect.emit({ action: 'select', ent_type: ent_type, id: id });
            this.selected_ents.set(ent_id, id);
            target.parentNode.classList.add('selected-row');
        }
        else {
            this.attrTableSelect.emit({ action: 'select', ent_type: ent_type, id: s });
            s.forEach(_id => {
                this.selected_ents.set(ent_id, id);
            });
        }
    }
    add_remove_selected(ent_id, event) {
        const ent_type = ent_id.substr(0, 2);
        const id = Number(ent_id.substr(2));
        const target = event.target || event.srcElement || event.currentTarget;
        if (this.selected_ents.has(ent_id)) {
            this.attrTableSelect.emit({ action: 'unselect', ent_type: ent_type, id: id });
            this.selected_ents.delete(ent_id);
            // @ts-ignore
            target.parentNode.classList.remove('selected-row');
        }
        else {
            if (event.shiftKey) {
                this.shiftKeyPressed = true;
                // console.log(ent_id);
            }
            this.attrTableSelect.emit({ action: 'select', ent_type: ent_type, id: id });
            this.selected_ents.set(ent_id, id);
            // @ts-ignore
            target.parentNode.classList.add('selected-row');
        }
    }
    showAttribLabel($event, column) {
        $event.stopPropagation();
        if (column === this.currentShowingCol) {
            this.currentShowingCol = '';
            this.attribLabel.emit('');
        }
        else {
            this.currentShowingCol = column;
            this.attribLabel.emit(column);
        }
    }
    updateSortHeader($event, column) {
        if (this.sorting_header === column) {
            this.sorting_state = (this.sorting_state + 1) % 3;
        }
        else {
            this.sorting_state = SORT_STATE.ASCENDING;
            this.sorting_header = column;
        }
    }
};
AttributeComponent.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Injector"] }
];
__decorate([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"])(_tabs_component__WEBPACK_IMPORTED_MODULE_8__["ATabsComponent"], { static: true }),
    __metadata("design:type", _tabs_component__WEBPACK_IMPORTED_MODULE_8__["ATabsComponent"])
], AttributeComponent.prototype, "child", void 0);
__decorate([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(),
    __metadata("design:type", _libs_geo_info_GIModel__WEBPACK_IMPORTED_MODULE_4__["GIModel"])
], AttributeComponent.prototype, "model", void 0);
__decorate([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(),
    __metadata("design:type", Event)
], AttributeComponent.prototype, "refresh", void 0);
__decorate([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(),
    __metadata("design:type", Event)
], AttributeComponent.prototype, "reset", void 0);
__decorate([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"])(),
    __metadata("design:type", Object)
], AttributeComponent.prototype, "attrTableSelect", void 0);
__decorate([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"])(),
    __metadata("design:type", Object)
], AttributeComponent.prototype, "selectSwitch", void 0);
__decorate([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"])(),
    __metadata("design:type", Object)
], AttributeComponent.prototype, "attribLabel", void 0);
__decorate([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChildren"])(_angular_material_paginator__WEBPACK_IMPORTED_MODULE_1__["MatPaginator"]),
    __metadata("design:type", Object)
], AttributeComponent.prototype, "paginator", void 0);
__decorate([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChildren"])(_angular_material_sort__WEBPACK_IMPORTED_MODULE_2__["MatSort"]),
    __metadata("design:type", Object)
], AttributeComponent.prototype, "sort", void 0);
AttributeComponent = __decorate([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"])({
        selector: 'attribute',
        template: __importDefault(__webpack_require__(/*! raw-loader!./attribute.component.html */ "./node_modules/raw-loader/dist/cjs.js!./src/app/gi-viewer/attribute/attribute.component.html")).default,
        styles: [__importDefault(__webpack_require__(/*! ./attribute.component.scss */ "./src/app/gi-viewer/attribute/attribute.component.scss")).default]
    }),
    __metadata("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_0__["Injector"]])
], AttributeComponent);



/***/ }),

/***/ "./src/app/gi-viewer/attribute/attribute.module.ts":
/*!*********************************************************!*\
  !*** ./src/app/gi-viewer/attribute/attribute.module.ts ***!
  \*********************************************************/
/*! exports provided: AttributeModule */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AttributeModule", function() { return AttributeModule; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
/* harmony import */ var _angular_material_icon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/material/icon */ "./node_modules/@angular/material/esm2015/icon.js");
/* harmony import */ var _angular_material_paginator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/material/paginator */ "./node_modules/@angular/material/esm2015/paginator.js");
/* harmony import */ var _angular_material_sort__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/material/sort */ "./node_modules/@angular/material/esm2015/sort.js");
/* harmony import */ var _angular_material_table__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/material/table */ "./node_modules/@angular/material/esm2015/table.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};





let AttributeModule = class AttributeModule {
};
AttributeModule = __decorate([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["NgModule"])({
        imports: [
            _angular_material_table__WEBPACK_IMPORTED_MODULE_4__["MatTableModule"],
            _angular_material_sort__WEBPACK_IMPORTED_MODULE_3__["MatSortModule"],
            _angular_material_paginator__WEBPACK_IMPORTED_MODULE_2__["MatPaginatorModule"],
            _angular_material_icon__WEBPACK_IMPORTED_MODULE_1__["MatIconModule"]
        ],
        exports: [
            _angular_material_table__WEBPACK_IMPORTED_MODULE_4__["MatTableModule"],
            _angular_material_sort__WEBPACK_IMPORTED_MODULE_3__["MatSortModule"],
            _angular_material_paginator__WEBPACK_IMPORTED_MODULE_2__["MatPaginatorModule"]
        ]
    })
], AttributeModule);



/***/ }),

/***/ "./src/app/gi-viewer/attribute/tab.component.ts":
/*!******************************************************!*\
  !*** ./src/app/gi-viewer/attribute/tab.component.ts ***!
  \******************************************************/
/*! exports provided: ATabComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ATabComponent", function() { return ATabComponent; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};

let ATabComponent = class ATabComponent {
    constructor() {
        this.active = false;
    }
};
__decorate([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])('tabTitle'),
    __metadata("design:type", String)
], ATabComponent.prototype, "title", void 0);
__decorate([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(),
    __metadata("design:type", Object)
], ATabComponent.prototype, "active", void 0);
__decorate([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])('index'),
    __metadata("design:type", Number)
], ATabComponent.prototype, "index", void 0);
ATabComponent = __decorate([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"])({
        selector: 'my-tab',
        template: `
    <div [hidden]="!active" class="pane">
      <ng-content></ng-content>
    </div>
  `,
        styles: ["\n    .pane{\n      padding: 0;\n    }\n  "]
    })
], ATabComponent);



/***/ }),

/***/ "./src/app/gi-viewer/attribute/tabs.component.scss":
/*!*********************************************************!*\
  !*** ./src/app/gi-viewer/attribute/tabs.component.scss ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("/* Style The Dropdown Button */\n.dropbtn {\n  background-color: transparent;\n  color: #808080;\n  border: 1px solid transparent;\n  cursor: pointer;\n  font-family: sans-serif;\n  font-weight: 550;\n  font-size: 12px;\n  line-height: 15px;\n  outline: none;\n  text-align: center;\n  width: 100%;\n  height: 21px;\n  margin-top: -1px;\n  padding-right: 10px;\n  border-bottom: 2px solid transparent;\n}\n.dropbtn::after {\n  content: \"\";\n  width: 0;\n  height: 0;\n  border-left: 4px solid transparent;\n  border-right: 4px solid transparent;\n  border-top: 4px solid #505050;\n  border-bottom: none;\n  position: absolute;\n  top: 7px;\n  right: 6px;\n}\n/* The container <div> - needed to position the dropdown content */\n.dropdown {\n  position: absolute;\n  display: inline-block;\n  left: 0px;\n  width: 100%;\n}\n/* Dropdown Content (Hidden by Default) */\n.dropdown-content {\n  display: none;\n  position: absolute;\n  background-color: #ececec;\n  min-width: 85px;\n  box-shadow: 0px 8px 16px 0px rgba(0, 0, 0, 0.2);\n  z-index: 500;\n  top: 19px;\n}\n/* Links inside the dropdown */\n.dropdown-content div {\n  color: black;\n  padding: 6px 8px;\n  text-decoration: none;\n}\n/* Change color of dropdown links on hover */\n.dropdown-content div:hover {\n  background-color: #fefefe;\n}\n/* Show the dropdown menu on hover */\n/* Change the background color of the dropdown button when the dropdown content is shown */\n.dropdown:hover .dropbtn {\n  color: #00006d;\n}\n.nav-tabs li.active .dropbtn {\n  color: #00006d;\n  background-color: whitesmoke;\n  border: 1px solid #B3B3B3;\n  border-bottom: 2px solid whitesmoke;\n}\n.nav-tabs li.open .dropbtn::after {\n  content: \"\";\n  border-top: none;\n  border-bottom: 4px solid #505050;\n}\n#topology_dropdown, #object_dropdown {\n  display: none;\n  position: absolute;\n  width: -webkit-fit-content;\n  width: -moz-fit-content;\n  width: fit-content;\n  transition: display 0.4s;\n  z-index: 99999999;\n  background-color: #fafafb;\n  border: 1px solid #808080;\n  box-shadow: none;\n}\n#topology_dropdown div, #object_dropdown div {\n  cursor: pointer;\n  display: block;\n  min-width: 100px;\n  max-width: 300px;\n  overflow: hidden;\n  line-height: 20px;\n  background-color: #fafafb;\n  border: 0px;\n  margin: 0px;\n  padding: 0px 10px 0px 10px;\n  line-height: 30px;\n  height: 30px;\n  font-size: 12px;\n  color: #373737;\n}\n#topology_dropdown div:hover, #object_dropdown div:hover {\n  color: #00006d;\n  background-color: #E6E6E6;\n}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9hcHAvZ2ktdmlld2VyL2F0dHJpYnV0ZS9DOlxcVXNlcnNcXGFraWJkcHRcXERvY3VtZW50c1xcQW5ndWxhclxcbW9iaXVzLXZpZXdlci9zcmNcXGFwcFxcZ2ktdmlld2VyXFxhdHRyaWJ1dGVcXHRhYnMuY29tcG9uZW50LnNjc3MiLCJzcmMvYXBwL2dpLXZpZXdlci9hdHRyaWJ1dGUvdGFicy5jb21wb25lbnQuc2NzcyIsInNyYy9hcHAvZ2ktdmlld2VyL2F0dHJpYnV0ZS9DOlxcVXNlcnNcXGFraWJkcHRcXERvY3VtZW50c1xcQW5ndWxhclxcbW9iaXVzLXZpZXdlci9zcmNcXHNjc3NcXGNvbG9ycy5zY3NzIiwic3JjL2FwcC9naS12aWV3ZXIvYXR0cmlidXRlL0M6XFxVc2Vyc1xcYWtpYmRwdFxcRG9jdW1lbnRzXFxBbmd1bGFyXFxtb2JpdXMtdmlld2VyL3NyY1xcc2Nzc1xcdmFyaWFibGVzLnNjc3MiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBR0EsOEJBQUE7QUFDQTtFQUNJLDZCQUFBO0VBQ0EsY0FBQTtFQUNBLDZCQUFBO0VBQ0EsZUFBQTtFQUNBLHVCQUFBO0VBQ0EsZ0JBQUE7RUFDQSxlQUFBO0VBQ0EsaUJBQUE7RUFDQSxhQUFBO0VBQ0Esa0JBQUE7RUFDQSxXQUFBO0VBQ0EsWUFBQTtFQUNBLGdCQUFBO0VBQ0EsbUJBQUE7RUFDQSxvQ0FBQTtBQ0ZKO0FES0E7RUFDSSxXQUFBO0VBQ0EsUUFBQTtFQUNBLFNBQUE7RUFDQSxrQ0FBQTtFQUNBLG1DQUFBO0VBQ0EsNkJBQUE7RUFDQSxtQkFBQTtFQUNBLGtCQUFBO0VBQ0EsUUFBQTtFQUNBLFVBQUE7QUNGSjtBREtFLGtFQUFBO0FBQ0E7RUFDRSxrQkFBQTtFQUNBLHFCQUFBO0VBQ0EsU0FBQTtFQUNBLFdBQUE7QUNGSjtBREtFLHlDQUFBO0FBQ0E7RUFDRSxhQUFBO0VBQ0Esa0JBQUE7RUFDQSx5QkFBQTtFQUNBLGVBQUE7RUFDQSwrQ0FBQTtFQUNBLFlBQUE7RUFDQSxTQUFBO0FDRko7QURLRSw4QkFBQTtBQUNBO0VBQ0UsWUFBQTtFQUNBLGdCQUFBO0VBQ0EscUJBQUE7QUNGSjtBREtFLDRDQUFBO0FBQ0E7RUFBNkIseUJBQUE7QUNEL0I7QURHRSxvQ0FBQTtBQUtBLDBGQUFBO0FBQ0E7RUFDRSxjQUFBO0FDSko7QURTUTtFQUNJLGNBQUE7RUFDQSw0QkFBQTtFQUNBLHlCQUFBO0VBQ0EsbUNBQUE7QUNOWjtBRFVRO0VBQ0ksV0FBQTtFQUNBLGdCQUFBO0VBQ0EsZ0NBQUE7QUNSWjtBRGFBO0VBQ0ksYUFBQTtFQUNBLGtCQUFBO0VBQ0EsMEJBQUE7RUFBQSx1QkFBQTtFQUFBLGtCQUFBO0VBQ0Esd0JBQUE7RUFFQSxpQkFBQTtFQUNBLHlCRTVGSztFRjZGTCx5QkFBQTtFQUNBLGdCQUFBO0FDWEo7QURhSTtFQUNJLGVBQUE7RUFDQSxjQUFBO0VBQ0EsZ0JBQUE7RUFDQSxnQkFBQTtFQUNBLGdCQUFBO0VBQ0EsaUJBQUE7RUFDQSx5QkV2R0M7RUZ3R0QsV0FBQTtFQUNBLFdBQUE7RUFDQSwwQkFBQTtFQUNBLGlCRzVHQztFSDZHRCxZRzdHQztFSDhHRCxlRy9HQztFSGdIRCxjRTNHQztBRGdHVDtBRFlRO0VBQ0ksY0UzR0s7RUY0R0wseUJFbkhIO0FEeUdUIiwiZmlsZSI6InNyYy9hcHAvZ2ktdmlld2VyL2F0dHJpYnV0ZS90YWJzLmNvbXBvbmVudC5zY3NzIiwic291cmNlc0NvbnRlbnQiOlsiQGltcG9ydCAnfnNjc3MvY29sb3JzJztcclxuQGltcG9ydCAnfnNjc3MvdmFyaWFibGVzJztcclxuXHJcbi8qIFN0eWxlIFRoZSBEcm9wZG93biBCdXR0b24gKi9cclxuLmRyb3BidG4ge1xyXG4gICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XHJcbiAgICBjb2xvcjogIzgwODA4MDtcclxuICAgIGJvcmRlcjogMXB4IHNvbGlkIHRyYW5zcGFyZW50O1xyXG4gICAgY3Vyc29yOiBwb2ludGVyO1xyXG4gICAgZm9udC1mYW1pbHk6IHNhbnMtc2VyaWY7XHJcbiAgICBmb250LXdlaWdodDogNTUwO1xyXG4gICAgZm9udC1zaXplOiAxMnB4O1xyXG4gICAgbGluZS1oZWlnaHQ6IDE1cHg7XHJcbiAgICBvdXRsaW5lOiBub25lO1xyXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xyXG4gICAgd2lkdGg6IDEwMCU7XHJcbiAgICBoZWlnaHQ6IDIxcHg7XHJcbiAgICBtYXJnaW4tdG9wOiAtMXB4O1xyXG4gICAgcGFkZGluZy1yaWdodDogMTBweDtcclxuICAgIGJvcmRlci1ib3R0b206IDJweCBzb2xpZCB0cmFuc3BhcmVudDtcclxufVxyXG5cclxuLmRyb3BidG46OmFmdGVye1xyXG4gICAgY29udGVudDogJyc7XHJcbiAgICB3aWR0aDogMDsgXHJcbiAgICBoZWlnaHQ6IDA7IFxyXG4gICAgYm9yZGVyLWxlZnQ6IDRweCBzb2xpZCB0cmFuc3BhcmVudDtcclxuICAgIGJvcmRlci1yaWdodDogNHB4IHNvbGlkIHRyYW5zcGFyZW50O1xyXG4gICAgYm9yZGVyLXRvcDogNHB4IHNvbGlkICM1MDUwNTA7XHJcbiAgICBib3JkZXItYm90dG9tOiBub25lO1xyXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xyXG4gICAgdG9wOiA3cHg7XHJcbiAgICByaWdodDogNnB4O1xyXG59XHJcbiAgXHJcbiAgLyogVGhlIGNvbnRhaW5lciA8ZGl2PiAtIG5lZWRlZCB0byBwb3NpdGlvbiB0aGUgZHJvcGRvd24gY29udGVudCAqL1xyXG4gIC5kcm9wZG93biB7XHJcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XHJcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XHJcbiAgICBsZWZ0OiAwcHg7XHJcbiAgICB3aWR0aDogMTAwJTtcclxuICB9XHJcbiAgXHJcbiAgLyogRHJvcGRvd24gQ29udGVudCAoSGlkZGVuIGJ5IERlZmF1bHQpICovXHJcbiAgLmRyb3Bkb3duLWNvbnRlbnQge1xyXG4gICAgZGlzcGxheTogbm9uZTtcclxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcclxuICAgIGJhY2tncm91bmQtY29sb3I6ICNlY2VjZWM7XHJcbiAgICBtaW4td2lkdGg6IDg1cHg7XHJcbiAgICBib3gtc2hhZG93OiAwcHggOHB4IDE2cHggMHB4IHJnYmEoMCwwLDAsMC4yKTtcclxuICAgIHotaW5kZXg6IDUwMDtcclxuICAgIHRvcDogMTlweDtcclxuICB9XHJcbiAgXHJcbiAgLyogTGlua3MgaW5zaWRlIHRoZSBkcm9wZG93biAqL1xyXG4gIC5kcm9wZG93bi1jb250ZW50IGRpdiB7XHJcbiAgICBjb2xvcjogYmxhY2s7XHJcbiAgICBwYWRkaW5nOiA2cHggOHB4O1xyXG4gICAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xyXG4gIH1cclxuICBcclxuICAvKiBDaGFuZ2UgY29sb3Igb2YgZHJvcGRvd24gbGlua3Mgb24gaG92ZXIgKi9cclxuICAuZHJvcGRvd24tY29udGVudCBkaXY6aG92ZXIge2JhY2tncm91bmQtY29sb3I6ICNmZWZlZmV9XHJcbiAgXHJcbiAgLyogU2hvdyB0aGUgZHJvcGRvd24gbWVudSBvbiBob3ZlciAqL1xyXG4gIC5kcm9wZG93bjpob3ZlciAuZHJvcGRvd24tY29udGVudCB7XHJcbiAgICAvLyBkaXNwbGF5OiBibG9jaztcclxuICB9XHJcbiAgXHJcbiAgLyogQ2hhbmdlIHRoZSBiYWNrZ3JvdW5kIGNvbG9yIG9mIHRoZSBkcm9wZG93biBidXR0b24gd2hlbiB0aGUgZHJvcGRvd24gY29udGVudCBpcyBzaG93biAqL1xyXG4gIC5kcm9wZG93bjpob3ZlciAuZHJvcGJ0biB7XHJcbiAgICBjb2xvcjogIzAwMDA2ZFxyXG59XHJcblxyXG4ubmF2LXRhYnN7XHJcbiAgICBsaS5hY3RpdmV7XHJcbiAgICAgICAgLmRyb3BidG57XHJcbiAgICAgICAgICAgIGNvbG9yOiAjMDAwMDZkO1xyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZXNtb2tlO1xyXG4gICAgICAgICAgICBib3JkZXI6IDFweCBzb2xpZCAjQjNCM0IzO1xyXG4gICAgICAgICAgICBib3JkZXItYm90dG9tOiAycHggc29saWQgd2hpdGVzbW9rZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBsaS5vcGVue1xyXG4gICAgICAgIC5kcm9wYnRuOjphZnRlcntcclxuICAgICAgICAgICAgY29udGVudDogJyc7XHJcbiAgICAgICAgICAgIGJvcmRlci10b3A6IG5vbmU7XHJcbiAgICAgICAgICAgIGJvcmRlci1ib3R0b206IDRweCBzb2xpZCAjNTA1MDUwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuI3RvcG9sb2d5X2Ryb3Bkb3duLCAjb2JqZWN0X2Ryb3Bkb3duIHtcclxuICAgIGRpc3BsYXk6IG5vbmU7XHJcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XHJcbiAgICB3aWR0aDogZml0LWNvbnRlbnQ7XHJcbiAgICB0cmFuc2l0aW9uOiBkaXNwbGF5IDAuNHM7XHJcblxyXG4gICAgei1pbmRleDogOTk5OTk5OTk7XHJcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkY29sb3I2O1xyXG4gICAgYm9yZGVyOiAxcHggc29saWQgJGNvbG9yMTtcclxuICAgIGJveC1zaGFkb3c6IG5vbmU7XHJcblxyXG4gICAgZGl2e1xyXG4gICAgICAgIGN1cnNvcjogcG9pbnRlcjtcclxuICAgICAgICBkaXNwbGF5OiBibG9jaztcclxuICAgICAgICBtaW4td2lkdGg6IDEwMHB4O1xyXG4gICAgICAgIG1heC13aWR0aDogMzAwcHg7XHJcbiAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcclxuICAgICAgICBsaW5lLWhlaWdodDogMjBweDtcclxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkY29sb3I2O1xyXG4gICAgICAgIGJvcmRlcjogMHB4O1xyXG4gICAgICAgIG1hcmdpbjogMHB4O1xyXG4gICAgICAgIHBhZGRpbmc6IDBweCAxMHB4IDBweCAxMHB4O1xyXG4gICAgICAgIGxpbmUtaGVpZ2h0OiAkZnNpemUzO1xyXG4gICAgICAgIGhlaWdodDogJGZzaXplMztcclxuICAgICAgICBmb250LXNpemU6ICRmc2l6ZTI7XHJcbiAgICAgICAgY29sb3I6ICRjb2xvcjg7XHJcbiAgICAgICAgJjpob3ZlcntcclxuICAgICAgICAgICAgY29sb3I6ICRzZWxlY3RlZC1jb2xvcjtcclxuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogJGNvbG9yNTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG59IiwiLyogU3R5bGUgVGhlIERyb3Bkb3duIEJ1dHRvbiAqL1xuLmRyb3BidG4ge1xuICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcbiAgY29sb3I6ICM4MDgwODA7XG4gIGJvcmRlcjogMXB4IHNvbGlkIHRyYW5zcGFyZW50O1xuICBjdXJzb3I6IHBvaW50ZXI7XG4gIGZvbnQtZmFtaWx5OiBzYW5zLXNlcmlmO1xuICBmb250LXdlaWdodDogNTUwO1xuICBmb250LXNpemU6IDEycHg7XG4gIGxpbmUtaGVpZ2h0OiAxNXB4O1xuICBvdXRsaW5lOiBub25lO1xuICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gIHdpZHRoOiAxMDAlO1xuICBoZWlnaHQ6IDIxcHg7XG4gIG1hcmdpbi10b3A6IC0xcHg7XG4gIHBhZGRpbmctcmlnaHQ6IDEwcHg7XG4gIGJvcmRlci1ib3R0b206IDJweCBzb2xpZCB0cmFuc3BhcmVudDtcbn1cblxuLmRyb3BidG46OmFmdGVyIHtcbiAgY29udGVudDogXCJcIjtcbiAgd2lkdGg6IDA7XG4gIGhlaWdodDogMDtcbiAgYm9yZGVyLWxlZnQ6IDRweCBzb2xpZCB0cmFuc3BhcmVudDtcbiAgYm9yZGVyLXJpZ2h0OiA0cHggc29saWQgdHJhbnNwYXJlbnQ7XG4gIGJvcmRlci10b3A6IDRweCBzb2xpZCAjNTA1MDUwO1xuICBib3JkZXItYm90dG9tOiBub25lO1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIHRvcDogN3B4O1xuICByaWdodDogNnB4O1xufVxuXG4vKiBUaGUgY29udGFpbmVyIDxkaXY+IC0gbmVlZGVkIHRvIHBvc2l0aW9uIHRoZSBkcm9wZG93biBjb250ZW50ICovXG4uZHJvcGRvd24ge1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgbGVmdDogMHB4O1xuICB3aWR0aDogMTAwJTtcbn1cblxuLyogRHJvcGRvd24gQ29udGVudCAoSGlkZGVuIGJ5IERlZmF1bHQpICovXG4uZHJvcGRvd24tY29udGVudCB7XG4gIGRpc3BsYXk6IG5vbmU7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgYmFja2dyb3VuZC1jb2xvcjogI2VjZWNlYztcbiAgbWluLXdpZHRoOiA4NXB4O1xuICBib3gtc2hhZG93OiAwcHggOHB4IDE2cHggMHB4IHJnYmEoMCwgMCwgMCwgMC4yKTtcbiAgei1pbmRleDogNTAwO1xuICB0b3A6IDE5cHg7XG59XG5cbi8qIExpbmtzIGluc2lkZSB0aGUgZHJvcGRvd24gKi9cbi5kcm9wZG93bi1jb250ZW50IGRpdiB7XG4gIGNvbG9yOiBibGFjaztcbiAgcGFkZGluZzogNnB4IDhweDtcbiAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xufVxuXG4vKiBDaGFuZ2UgY29sb3Igb2YgZHJvcGRvd24gbGlua3Mgb24gaG92ZXIgKi9cbi5kcm9wZG93bi1jb250ZW50IGRpdjpob3ZlciB7XG4gIGJhY2tncm91bmQtY29sb3I6ICNmZWZlZmU7XG59XG5cbi8qIFNob3cgdGhlIGRyb3Bkb3duIG1lbnUgb24gaG92ZXIgKi9cbi8qIENoYW5nZSB0aGUgYmFja2dyb3VuZCBjb2xvciBvZiB0aGUgZHJvcGRvd24gYnV0dG9uIHdoZW4gdGhlIGRyb3Bkb3duIGNvbnRlbnQgaXMgc2hvd24gKi9cbi5kcm9wZG93bjpob3ZlciAuZHJvcGJ0biB7XG4gIGNvbG9yOiAjMDAwMDZkO1xufVxuXG4ubmF2LXRhYnMgbGkuYWN0aXZlIC5kcm9wYnRuIHtcbiAgY29sb3I6ICMwMDAwNmQ7XG4gIGJhY2tncm91bmQtY29sb3I6IHdoaXRlc21va2U7XG4gIGJvcmRlcjogMXB4IHNvbGlkICNCM0IzQjM7XG4gIGJvcmRlci1ib3R0b206IDJweCBzb2xpZCB3aGl0ZXNtb2tlO1xufVxuLm5hdi10YWJzIGxpLm9wZW4gLmRyb3BidG46OmFmdGVyIHtcbiAgY29udGVudDogXCJcIjtcbiAgYm9yZGVyLXRvcDogbm9uZTtcbiAgYm9yZGVyLWJvdHRvbTogNHB4IHNvbGlkICM1MDUwNTA7XG59XG5cbiN0b3BvbG9neV9kcm9wZG93biwgI29iamVjdF9kcm9wZG93biB7XG4gIGRpc3BsYXk6IG5vbmU7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgd2lkdGg6IGZpdC1jb250ZW50O1xuICB0cmFuc2l0aW9uOiBkaXNwbGF5IDAuNHM7XG4gIHotaW5kZXg6IDk5OTk5OTk5O1xuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmFmYWZiO1xuICBib3JkZXI6IDFweCBzb2xpZCAjODA4MDgwO1xuICBib3gtc2hhZG93OiBub25lO1xufVxuI3RvcG9sb2d5X2Ryb3Bkb3duIGRpdiwgI29iamVjdF9kcm9wZG93biBkaXYge1xuICBjdXJzb3I6IHBvaW50ZXI7XG4gIGRpc3BsYXk6IGJsb2NrO1xuICBtaW4td2lkdGg6IDEwMHB4O1xuICBtYXgtd2lkdGg6IDMwMHB4O1xuICBvdmVyZmxvdzogaGlkZGVuO1xuICBsaW5lLWhlaWdodDogMjBweDtcbiAgYmFja2dyb3VuZC1jb2xvcjogI2ZhZmFmYjtcbiAgYm9yZGVyOiAwcHg7XG4gIG1hcmdpbjogMHB4O1xuICBwYWRkaW5nOiAwcHggMTBweCAwcHggMTBweDtcbiAgbGluZS1oZWlnaHQ6IDMwcHg7XG4gIGhlaWdodDogMzBweDtcbiAgZm9udC1zaXplOiAxMnB4O1xuICBjb2xvcjogIzM3MzczNztcbn1cbiN0b3BvbG9neV9kcm9wZG93biBkaXY6aG92ZXIsICNvYmplY3RfZHJvcGRvd24gZGl2OmhvdmVyIHtcbiAgY29sb3I6ICMwMDAwNmQ7XG4gIGJhY2tncm91bmQtY29sb3I6ICNFNkU2RTY7XG59IiwiXHJcbiRjb2xvcjE6ICM4MDgwODA7XHJcbiRjb2xvcjI6ICM5OTk5OTk7XHJcbiRjb2xvcjM6ICNCM0IzQjM7IFxyXG4kY29sb3I0OiAjQ0NDQ0NDO1xyXG4kY29sb3I1OiAjRTZFNkU2O1xyXG4kY29sb3I1LTU6IHJnYigyNDUsIDI0NSwgMjQ1KTtcclxuJGNvbG9yNjogcmdiKDI1MCwgMjUwLCAyNTEpO1xyXG5cclxuJGNvbG9yNzogd2hpdGU7XHJcbiRjb2xvcjg6ICMzNzM3Mzc7XHJcblxyXG4kc2VsZWN0ZWQtY29sb3I6IHJnYigwLCAwLCAxMDkpO1xyXG4kc2VsZWN0ZWQtY29sb3IxOiByZ2IoMjI4LCAyMjgsIDI0Nyk7XHJcbiRzZWxlY3RlZC1jb2xvcjI6IHJnYigyMTUsIDIxNSwgMjU1KTtcclxuJGhvdmVyLWNvbG9yOiAkY29sb3IyO1xyXG5cclxuJGVycm9yLWNvbG9yOiAjRTk0ODU4OyAvL3BpbmstcmVkXHJcbiRlcnJvci1jb2xvci1sdDogcmdiKDI1NSwgMjIwLCAyMjQpO1xyXG4kcGNvbG9yMjogI0YzQTMyQTsgLy9vcmFuZ2UteWVsbG93XHJcbiRwcmludC1jb2xvcjogcmdiKDEzMCwgMTkxLCAxMTApOyAvL2xpZ2h0Z3JlZW5cclxuJHByaW50LWNvbG9yLWx0OiByZ2IoMjMwLCAyNTUsIDIyMSk7XHJcbiRwcmludC1jb2xvci1kazogcmdiKDYzLCA5OSwgNTEpOyAvL2xpZ2h0Z3JlZW5cclxuJHNlbGVjdEdlb20tY29sb3I6IHJnYigyNTUsIDE3NCwgMCk7IC8vIGxpZ2h0IG9yYW5nZVxyXG4kc2VsZWN0R2VvbS1jb2xvci1sdDogcmdiKDI1NSwgMjI1LCAxNjApO1xyXG5cclxuLy8gJHByb2QtYmFja2dyb3VuZC1jb2xvcjogcmdiKDI1MCwyNTAsMjUwKTtcclxuLy8gJGJhY2tncm91bmQtY29sb3I6IHJnYigyMjAsMjIwLDIyMCk7XHJcbiRmdW5jdGlvbi10ZXh0LWNvbG9yOiByZ2IoMTkwLCAxNDAsIDMwKTtcclxuJGZ1bmN0aW9uLXRleHQtY29sb3IyOiByZ2IoMTgsIDEyNiwgMTM2KTtcclxuJGZ1bmN0aW9uLXRleHQtY29sb3IzOiByZ2IoMTkwLCAxNDAsIDMwKTtcclxuJGJhc2ljLWZ1bmN0aW9uLXRleHQtY29sb3I6IHJnYigyMDAsIDcwLCAxNTApO1xyXG4kY29tbWVudC1jb2xvcjogZGFya2dyZWVuO1xyXG4iLCIkcGFkZGluZzogNDBweDsgLy8gPyBub3QgdXNlZFxyXG4kc21hbGwtcGFkZGluZzogMTVweDtcclxuJGhlYWRlci1oZWlnaHQ6IDQwcHg7XHJcblxyXG4kZnNpemUxOiAxNXB4O1xyXG4kZnNpemUyOiAxMnB4O1xyXG4kZnNpemUzOiAzMHB4O1xyXG5cclxuJHBvcnQtc2l6ZTogMTVweDtcclxuJGRlZmF1bHQtc2lkZS1wYWRkaW5nOiAxNXB4O1xyXG5cclxuJGRpc2FibGVkLW9wYWNpdHk6IDAuNDsiXX0= */");

/***/ }),

/***/ "./src/app/gi-viewer/attribute/tabs.component.ts":
/*!*******************************************************!*\
  !*** ./src/app/gi-viewer/attribute/tabs.component.ts ***!
  \*******************************************************/
/*! exports provided: ATabsComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ATabsComponent", function() { return ATabsComponent; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
/* harmony import */ var _tab_component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tab.component */ "./src/app/gi-viewer/attribute/tab.component.ts");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};


let ATabsComponent = class ATabsComponent {
    constructor() {
        this.selectedTab = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this.selectedTopology = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this.tab_active = 0;
        this.topology_text = 'Topology';
        this.topologyActive = false;
        this.topology_open = false;
        this.topology = [
            { tab: 1, title: 'Vertices' },
            { tab: 2, title: 'Edges' },
            { tab: 3, title: 'Wires' },
            { tab: 4, title: 'Faces' }
        ];
        this.object_text = 'Objects';
        this.objectActive = false;
        this.object_open = false;
        this.object = [
            { tab: 5, title: 'Points' },
            { tab: 6, title: 'Polylines' },
            { tab: 7, title: 'Polygons' }
        ];
    }
    // contentChildren are set
    ngAfterContentInit() {
        setTimeout(() => {
            const activeTabs = this.tabs.filter((tab) => tab.active);
            // if there is no active tab set, activate the first
            if (activeTabs.length === 0) {
                this.selectTab(0);
            }
        }, 0);
    }
    ngAfterViewInit() {
        this.topology_dropdown = document.getElementById('topology_dropdown');
        this.topology_dropdown.style.display = 'none';
        this.object_dropdown = document.getElementById('object_dropdown');
        this.object_dropdown.style.display = 'none';
    }
    ngOnDestroy() {
        this.topology_dropdown = null;
        this.object_dropdown = null;
    }
    selectTab(tab) {
        // deactivate all tabs
        this.tabs.toArray().forEach(_tab => _tab.active = false);
        // activate the tab the user has clicked on.
        this.tab_active = tab;
        const tt = this.tabs.find(t => Number(t.index) === tab);
        if (tt) {
            tt.active = true;
        }
        this.selectedTab.emit(tab);
        if (this.topology_dropdown) {
            this.topology_dropdown.style.display = 'none';
        }
        this.topology_text = 'Topology';
        this.topology_open = false;
        if (this.object_dropdown) {
            this.topology_dropdown.style.display = 'none';
        }
        this.object_text = 'Objects';
        this.object_open = false;
    }
    selectTopology(tab, event) {
        this.tabs.toArray().forEach(_tab => _tab.active = false);
        this.tab_active = 1;
        const option = this.topology.find(item => item.tab === tab);
        if (!option) {
            return;
        }
        this.selectedTopology.emit(Number(tab));
        this.topology_text = option.title;
        this.tabs.toArray()[option.tab].active = true;
        if (event !== undefined) {
            // @ts-ignore
            event.target.parentElement.style.display = 'none';
        }
        this.topology_open = false;
    }
    selectObject(tab, event) {
        this.tabs.toArray().forEach(_tab => _tab.active = false);
        this.tab_active = 2;
        const option = this.object.find(item => item.tab === tab);
        if (!option) {
            return;
        }
        this.selectedTopology.emit(Number(tab));
        this.object_text = option.title;
        this.tabs.toArray()[option.tab].active = true;
        if (event !== undefined) {
            // @ts-ignore
            event.target.parentElement.style.display = 'none';
        }
        this.object_open = false;
    }
    showTDropdown() {
        this.object_text = 'Objects';
        this.object_open = false;
        // this.tabs.toArray().forEach(_tab => _tab.active = false);
        if (!this.topology_dropdown) {
            return;
        }
        this.object_dropdown.style.display = 'none';
        if (this.topology_dropdown.style.display === 'none') {
            this.topology_dropdown.style.display = 'block';
            this.topology_open = true;
        }
        else {
            this.topology_dropdown.style.display = 'none';
            this.topology_open = false;
        }
    }
    showODropdown() {
        this.topology_text = 'Topology';
        this.topology_open = false;
        // this.tabs.toArray().forEach(_tab => _tab.active = false);
        if (!this.object_dropdown) {
            return;
        }
        this.topology_dropdown.style.display = 'none';
        if (this.object_dropdown.style.display === 'none') {
            this.object_dropdown.style.display = 'block';
            this.object_open = true;
        }
        else {
            this.object_dropdown.style.display = 'none';
            this.object_open = false;
        }
    }
};
__decorate([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"])(),
    __metadata("design:type", Object)
], ATabsComponent.prototype, "selectedTab", void 0);
__decorate([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"])(),
    __metadata("design:type", Object)
], ATabsComponent.prototype, "selectedTopology", void 0);
__decorate([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ContentChildren"])(_tab_component__WEBPACK_IMPORTED_MODULE_1__["ATabComponent"]),
    __metadata("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_0__["QueryList"])
], ATabsComponent.prototype, "tabs", void 0);
ATabsComponent = __decorate([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"])({
        selector: 'my-tabs',
        template: __importDefault(__webpack_require__(/*! raw-loader!./tabs.component.html */ "./node_modules/raw-loader/dist/cjs.js!./src/app/gi-viewer/attribute/tabs.component.html")).default,
        styles: [__importDefault(__webpack_require__(/*! ./tabs.component.scss */ "./src/app/gi-viewer/attribute/tabs.component.scss")).default]
    })
], ATabsComponent);



/***/ }),

/***/ "./src/app/gi-viewer/data/data.service.ts":
/*!************************************************!*\
  !*** ./src/app/gi-viewer/data/data.service.ts ***!
  \************************************************/
/*! exports provided: DataService */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataService", function() { return DataService; });
/* harmony import */ var _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @libs/geo-info/common */ "./src/assets/libs/geo-info/common.ts");
/* harmony import */ var _data_threejs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./data.threejs */ "./src/app/gi-viewer/data/data.threejs.ts");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};


// import @angular stuff

/**
 * DataService
 * The data service for the Goe-Info viewer.
 */
let DataService = class DataService {
    /**
     * Create a data service.
     */
    constructor() {
        this._ngSplitGutter = 20;
        this.selecting = [];
        // Selected Entities by Threejs Viewer for Attribute Table
        this.selected_ents = new Map();
        this.selected_ents.set(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_0__["EEntTypeStr"][_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POSI], new Map());
        this.selected_ents.set(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_0__["EEntTypeStr"][_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].VERT], new Map());
        this.selected_ents.set(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_0__["EEntTypeStr"][_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].EDGE], new Map());
        this.selected_ents.set(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_0__["EEntTypeStr"][_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].FACE], new Map());
        this.selected_ents.set(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_0__["EEntTypeStr"][_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].WIRE], new Map());
        this.selected_ents.set(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_0__["EEntTypeStr"][_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PGON], new Map());
        this.selected_ents.set(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_0__["EEntTypeStr"][_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PLINE], new Map());
        this.selected_ents.set(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_0__["EEntTypeStr"][_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POINT], new Map());
        this.selected_ents.set(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_0__["EEntTypeStr"][_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].COLL], new Map());
        this.selected_positions = new Map();
        this.selected_vertex = new Map();
        this.selected_face_edges = new Map();
        this.selected_face_wires = new Map();
        this.selected_coll = new Map();
    }
    /**
     * Get the THreejs Scene
     */
    getThreejsScene() {
        return this._data_threejs;
    }
    /**
     * Set the THreejs Scene
     */
    setThreejsScene(settings) {
        this._data_threejs = new _data_threejs__WEBPACK_IMPORTED_MODULE_1__["DataThreejs"](settings);
    }
    /**
     * check selected entites number
     */
    countSelectedEnts() {
        let count = 0;
        this.selected_ents.forEach(selected_ents => {
            count = +selected_ents.size;
        });
        return count;
    }
    clearAll() {
        this.selected_ents.forEach(selected_ents => selected_ents.clear());
    }
    get ngSplitGutter() { return this._ngSplitGutter; }
    set ngSplitGutter(splitGutter) { this._ngSplitGutter = splitGutter; }
};
DataService = __decorate([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Injectable"])(),
    __metadata("design:paramtypes", [])
], DataService);



/***/ }),

/***/ "./src/app/gi-viewer/data/data.threejs.ts":
/*!************************************************!*\
  !*** ./src/app/gi-viewer/data/data.threejs.ts ***!
  \************************************************/
/*! exports provided: DataThreejs */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataThreejs", function() { return DataThreejs; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/* harmony import */ var _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @libs/geo-info/common */ "./src/assets/libs/geo-info/common.ts");
/* harmony import */ var _data_threejsLookAt__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./data.threejsLookAt */ "./src/app/gi-viewer/data/data.threejsLookAt.ts");
/* harmony import */ var three_examples_jsm_utils_BufferGeometryUtils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three/examples/jsm/utils/BufferGeometryUtils.js */ "./node_modules/three/examples/jsm/utils/BufferGeometryUtils.js");
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! util */ "./node_modules/util/util.js");
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(util__WEBPACK_IMPORTED_MODULE_4__);
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};





var MaterialType;
(function (MaterialType) {
    MaterialType["MeshBasicMaterial"] = "MeshBasicMaterial";
    MaterialType["MeshStandardMaterial"] = "MeshStandardMaterial";
    MaterialType["MeshLambertMaterial"] = "MeshLambertMaterial";
    MaterialType["MeshPhongMaterial"] = "MeshPhongMaterial";
    MaterialType["MeshPhysicalMaterial"] = "MeshPhysicalMaterial";
})(MaterialType || (MaterialType = {}));
/**
 * ThreejsScene Add
 */
class DataThreejs extends _data_threejsLookAt__WEBPACK_IMPORTED_MODULE_2__["DataThreejsLookAt"] {
    /**
     * Constructs a new data subscriber.
     */
    constructor(settings) {
        super(settings);
        // background
        if (this.settings.background.show) {
            this._loadBackground(this.settings.background.background_set);
        }
        else {
            this.cameraBackgrounds = null;
            this.scene.background = new three__WEBPACK_IMPORTED_MODULE_0__["Color"](this.settings.colors.viewer_bg);
        }
        // add grid and lights
        this._addGrid();
        this._addAxes();
        if (this.settings.ambient_light.show) {
            this._addAmbientLight();
        }
        if (this.settings.hemisphere_light.show) {
            this._addHemisphereLight();
        }
        if (this.settings.directional_light.show) {
            this._addDirectionalLight();
        }
    }
    /**
     *
     * @param object
     * @param property
     */
    static disposeObjectProperty(object, property) {
        if (object.hasOwnProperty(property)) {
            if (object[property].constructor === [].constructor) {
                object[property].forEach(prop => prop.dispose());
            }
            else {
                object[property].dispose();
            }
        }
    }
    populateScene(model, container) {
        // if (this.dataService.viewerSettingsUpdated) {
        //     this.settings = JSON.parse(localStorage.getItem('mpm_settings'));
        //     this.perspCam.position.copy(this.settings.camera.pos);
        //     this.perspControls.target.copy(this.settings.camera.target);
        //     this.perspCam.updateProjectionMatrix();
        //     this.perspControls.update();
        //     this.dataService.viewerSettingsUpdated = false;
        // }
        while (this.scene.children.length > 0) {
            DataThreejs.disposeObjectProperty(this.scene.children[0], 'geometry');
            DataThreejs.disposeObjectProperty(this.scene.children[0], 'texture');
            this.scene.remove(this.scene.children[0]);
        }
        this.scene_objs = [];
        document.querySelectorAll('[id^=textLabel_]').forEach(value => {
            container.removeChild(value);
        });
        this.ObjLabelMap.clear();
        this.textLabels.clear();
        this._addGeom(model);
        const position_size = this.settings.positions.size;
        this.raycaster.params.Points.threshold = position_size > 1 ? position_size / 3 : position_size / 4;
        this._all_objs_sphere = this._getAllObjsSphere();
        this.updateCameraFOV();
        // add the axes, ground, lights, etc
        this._addEnv();
        setTimeout(() => {
            let old = document.getElementById('hud');
            if (old) {
                container.removeChild(old);
            }
            // setTimeout(() => { this._getNodeSelect(); }, 10);
            if (!this.model.modeldata.attribs.query.hasAttrib(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_1__["EEntType"].MOD, 'hud')) {
                return;
            }
            const hud = this.model.modeldata.attribs.query.getModelAttribVal('hud');
            const element = this._createHud(hud).element;
            container.appendChild(element);
            old = null;
        }, 0);
    }
    _addGeom(model) {
        // Add geometry
        const threejs_data = model.get3jsData();
        this.tri_select_map = threejs_data.triangle_select_map;
        this.edge_select_map = threejs_data.edge_select_map;
        this.white_edge_select_map = threejs_data.white_edge_select_map;
        this.point_select_map = threejs_data.point_select_map;
        this.posis_map = threejs_data.posis_map;
        this.vertex_map = threejs_data.vertex_map;
        const material_groups = threejs_data.material_groups;
        const materials = threejs_data.materials;
        // Create buffers that will be used by all geometry
        const verts_xyz_buffer = new three__WEBPACK_IMPORTED_MODULE_0__["Float32BufferAttribute"](threejs_data.vertex_xyz, 3);
        const normals_buffer = new three__WEBPACK_IMPORTED_MODULE_0__["Float32BufferAttribute"](threejs_data.normals, 3);
        const colors_buffer = new three__WEBPACK_IMPORTED_MODULE_0__["Float32BufferAttribute"](threejs_data.colors, 3);
        const posis_xyz_buffer = new three__WEBPACK_IMPORTED_MODULE_0__["Float32BufferAttribute"](threejs_data.posis_xyz, 3);
        this._addTris(threejs_data.triangle_indices, verts_xyz_buffer, colors_buffer, normals_buffer, material_groups, materials);
        this._addLines(threejs_data.edge_indices, threejs_data.white_edge_indices, verts_xyz_buffer, colors_buffer, normals_buffer);
        this._addPoints(threejs_data.point_indices, verts_xyz_buffer, colors_buffer, [255, 255, 255], this.settings.positions.size + 1);
        // if (threejs_data.timeline) {
        //     this.timelineEnabled = true;
        //     this.timeline = threejs_data.timeline.__time_points__;
        //     if (!this.current_time_point || this.timeline.indexOf(this.current_time_point) === -1) {
        //         this.current_time_point = this.timeline[this.timeline.length - 1];
        //     }
        //     this.timeline_groups = {};
        //     for (const time_point of this.timeline) {
        //         const obj_group = new THREE.Group();
        //         const timeline_data = threejs_data.timeline[time_point];
        //         const tri = this._addTimelineTris(timeline_data.triangle_indices, verts_xyz_buffer, colors_buffer,
        //                     normals_buffer, material_groups, materials);
        //         const lines = this._addTimelineLines(timeline_data.edge_indices, threejs_data.white_edge_indices,
        //                     verts_xyz_buffer, colors_buffer, normals_buffer);
        //         const points = this._addTimelinePoints(timeline_data.point_indices, verts_xyz_buffer,
        //                     colors_buffer, [255, 255, 255], this.settings.positions.size + 1);
        //         obj_group.add(tri);
        //         obj_group.add(lines[0]);
        //         obj_group.add(lines[1]);
        //         obj_group.add(points);
        //         this.timeline_groups[time_point] = obj_group;
        //     }
        //     this.scene.add(this.timeline_groups[this.current_time_point]);
        // } else {
        //     this.timelineEnabled = false;
        //     this.timeline = null;
        //     this.timeline_groups = null;
        // }
        this._addPosis(threejs_data.posis_indices, posis_xyz_buffer, this.settings.colors.position, this.settings.positions.size);
        this._addPointLabels(model);
    }
    /**
     * Add background, grid, ground
     */
    _addEnv() {
        // background
        if (this.settings.background.show) {
            this._loadBackground(this.settings.background.background_set);
        }
        else {
            this.cameraBackgrounds = null;
            this.scene.background = new three__WEBPACK_IMPORTED_MODULE_0__["Color"](this.settings.colors.viewer_bg);
        }
        // add gird and axes
        this._addGrid();
        this._addAxes();
        // const center = new THREE.Vector3(0, 0, 0); // allObjs.center;
        // this.axes_pos.x = center.x;
        // this.axes_pos.y = center.y;
        // let grid_pos = this.settings.grid.pos;
        // if (!grid_pos) {
        //     grid_pos = new Vector3(0, 0, 0);
        // }
        // this.grid.position.set(grid_pos.x, grid_pos.y, -0.01);
        // this.axesHelper.position.set(grid_pos.x, grid_pos.y, 0);
        // // settings
        // // if (num_posis !== 0) {
        //     if (this.dataService.newFlowchart) {
        //         this.dataService.newFlowchart = false;
        //         this.origin = new THREE.Vector3(center.x, center.y, 0);
        //         this.settings.camera.target = this.origin ;
        //         localStorage.setItem('mpm_settings', JSON.stringify(this.settings));
        //         this.axesHelper.position.set(center.x, center.y, 0.05);
        //     } else {
        //         this.axesHelper.position.set(this.origin.x, this.origin.y, 0.05);
        //     }
        // // }
        // ground
        const ground = this.settings.ground;
        if (ground.show) {
            const planeGeometry = new three__WEBPACK_IMPORTED_MODULE_0__["PlaneBufferGeometry"](ground.width, ground.length, 32, 32);
            const planeMaterial = new three__WEBPACK_IMPORTED_MODULE_0__["MeshPhongMaterial"]({
                color: new three__WEBPACK_IMPORTED_MODULE_0__["Color"](parseInt(ground.color.replace('#', '0x'), 16)),
                shininess: ground.shininess,
                side: three__WEBPACK_IMPORTED_MODULE_0__["DoubleSide"]
            });
            this.groundObj = new three__WEBPACK_IMPORTED_MODULE_0__["Mesh"](planeGeometry, planeMaterial);
            this.groundObj.position.setZ(ground.height);
            this.groundObj.receiveShadow = true;
            this.scene.add(this.groundObj);
        }
        if (this.settings.ambient_light.show) {
            this._addAmbientLight();
        }
        if (this.settings.hemisphere_light.show) {
            this._addHemisphereLight();
        }
        if (this.settings.directional_light.show) {
            this._addDirectionalLight();
        }
    }
    // private _getNodeSelect(): void {
    //     const select_node: any = this.model.modeldata.attribs.query.getModelAttribVal('select_node');
    //     this.timelineEnabled = null;
    //     if (!select_node || !select_node.nodes) { return; }
    //     this.timeline_groups = select_node.nodes;
    //     const currentIndex = this.timeline_groups.indexOf(this.dataService.node.name);
    //     if (currentIndex !== -1) {
    //         this.timelineEnabled = 1;
    //         this.timelineIndex = currentIndex.toString();
    //         this.timelineValue = this.dataService.node.name;
    //         if (select_node.widget === 'dropdown') {
    //             this.timelineEnabled = 2;
    //         }
    //     }
    //     if (this.dataService.timelineDefault && select_node.default) {
    //         const nodeSelInput = <HTMLInputElement> document.getElementById('hidden_node_selection');
    //         nodeSelInput.value = select_node.default;
    //         (<HTMLButtonElement> document.getElementById('hidden_node_selection_button')).click();
    //         this.dataService.timelineDefault = false;
    //     }
    // }
    /**
     *
     * @param scale
     * @param azimuth
     * @param altitude
     */
    getDLPosition(scale = null, azimuth = null, altitude = null) {
        if (!scale && scale !== 0) {
            scale = this.directional_light_settings.distance;
        }
        if (!azimuth && azimuth !== 0) {
            azimuth = this.directional_light_settings.azimuth;
        }
        if (!altitude && altitude !== 0) {
            altitude = this.directional_light_settings.altitude;
        }
        if (this.model && this.model.modeldata.attribs && this.model.modeldata.attribs.query
            && this.model.modeldata.attribs.query.hasModelAttrib('directional_light')) {
            const model_light_settings = this.model.modeldata.attribs.query.getModelAttribVal('directional_light');
            if (model_light_settings.constructor === {}.constructor) {
                if (model_light_settings.hasOwnProperty('altitude')) {
                    altitude = model_light_settings.altitude;
                }
                if (model_light_settings.hasOwnProperty('azimuth')) {
                    azimuth = model_light_settings.azimuth;
                }
            }
        }
        if (scale === 0) {
            scale = 10000;
        }
        let azimuth_calc = 90 - azimuth;
        if (this.model && this.model.modeldata.attribs && this.model.modeldata.attribs.query
            && this.model.modeldata.attribs.query.hasModelAttrib('north')) {
            const north_attr = this.model.modeldata.attribs.query.getModelAttribVal('north');
            const north_vec = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](north_attr[0], north_attr[1], 0);
            const y_vec = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](0, 1, 0);
            const angle = north_vec.angleTo(y_vec) * 180 / Math.PI;
            if (north_attr[0] > 0) {
                azimuth_calc -= angle;
            }
            else {
                azimuth_calc += angle;
            }
        }
        let posX = Math.cos(altitude * Math.PI * 2 / 360) * Math.cos(azimuth_calc * Math.PI * 2 / 360) * scale * 2, posY = Math.cos(altitude * Math.PI * 2 / 360) * Math.sin(azimuth_calc * Math.PI * 2 / 360) * scale * 2, posZ = Math.sin(altitude * Math.PI * 2 / 360) * scale * 2;
        if (this._all_objs_sphere) {
            posX += this._all_objs_sphere.center.x;
            posY += this._all_objs_sphere.center.y;
            posZ += this._all_objs_sphere.center.z;
        }
        this.directional_light.position.set(posX, posY, posZ);
    }
    /**
     * Add axes
     * @param size
     */
    _addAxes(size = this.settings.axes.size) {
        let i = 0;
        const length = this.scene.children.length;
        if (length !== 0) {
            for (; i < length; i++) {
                if (this.scene.children[i]) {
                    if (this.scene.children[i].name === 'AxesHelper') {
                        this.scene.children[i]['dispose']();
                        this.scene.remove(this.scene.children[i]);
                    }
                }
            }
        }
        this.axesHelper = new three__WEBPACK_IMPORTED_MODULE_0__["AxesHelper"](size);
        this.axesHelper.geometry['attributes'].color = new three__WEBPACK_IMPORTED_MODULE_0__["Int16BufferAttribute"]([1, 0, 0, 1, 0, 0,
            0, 1, 0, 0, 1, 0,
            0, 0, 1, 0, 0, 1], 3);
        this.axesHelper.visible = this.settings.axes.show;
        if (this.axesHelper.visible) {
            this.axesHelper.name = 'AxesHelper';
            this.axesHelper.position.set(this.axes_pos.x, this.axes_pos.y, this.axes_pos.z);
            this.axesHelper.position.set(0, 0, 0);
            this.scene.add(this.axesHelper);
        }
    }
    /**
     * Draws a grid on the XY plane.
     * @param size
     */
    _addGrid(size = this.settings.grid.size) {
        let i = 0;
        const length = this.scene.children.length;
        for (; i < length; i++) {
            if (this.scene.children[i]) {
                if (this.scene.children[i].name === 'GridHelper') {
                    if (this.scene.children[i]['dispose']) {
                        this.scene.children[i]['dispose']();
                    }
                    this.scene.remove(this.scene.children[i]);
                }
            }
        }
        this.grid = new three__WEBPACK_IMPORTED_MODULE_0__["GridHelper"](size, size / 10, 0x888888, 0x888888);
        this.grid.visible = this.settings.grid.show;
        // todo: change grid -> grid_value
        if (this.grid.visible) {
            this.grid.name = 'GridHelper';
            const vector = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](0, 1, 0);
            this.grid.lookAt(vector);
            let pos = this.settings.grid.pos;
            if (!pos) {
                pos = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
            }
            if (!pos.z) {
                this.grid.position.set(pos.x, pos.y, -0.01);
            }
            else {
                this.grid.position.set(pos.x, pos.y, pos.z);
            }
            this.scene.add(this.grid);
        }
    }
    /**
     *
     */
    getGridPos() {
        if (this._all_objs_sphere) {
            const grd_pos = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](this._all_objs_sphere.center.x, this._all_objs_sphere.center.y, 0);
            this.grid.position.set(grd_pos.x, grd_pos.y, -0.01);
            return grd_pos;
        }
        const grid_pos = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](0, 0, 0);
        this.grid.position.set(0, 0, -0.01);
        return grid_pos;
    }
    // ============================================================================
    // ============================================================================
    // Private methods
    // ============================================================================
    // ============================================================================
    /**
     * Create the buffer for threejs triangles
     */
    _createTrisBuffGeom(tris_i_buff_attrib, coords_buff_attrib, colors_buff_attrib, normals_buff_attrib, material_groups) {
        const tris_geom_buff = new three__WEBPACK_IMPORTED_MODULE_0__["BufferGeometry"]();
        tris_geom_buff.setIndex(tris_i_buff_attrib);
        tris_geom_buff.setAttribute('position', coords_buff_attrib);
        tris_geom_buff.setAttribute('color', colors_buff_attrib);
        if (normals_buff_attrib !== null) {
            tris_geom_buff.setAttribute('normal', normals_buff_attrib);
        }
        tris_geom_buff.clearGroups();
        for (let i = 0; i < material_groups.length; i = i + 3) {
            tris_geom_buff.addGroup(material_groups[i], material_groups[i + 1], material_groups[i + 2]);
        }
        return tris_geom_buff;
    }
    /**
     * Add threejs triangles to the scene
     */
    _addTris(tris_i, posis_buffer, colors_buffer, normals_buffer, material_groups, materials) {
        const geom = new three__WEBPACK_IMPORTED_MODULE_0__["BufferGeometry"]();
        geom.setIndex(tris_i);
        geom.setAttribute('position', posis_buffer);
        if (normals_buffer.count > 0) {
            geom.setAttribute('normal', normals_buffer);
        }
        geom.setAttribute('color', colors_buffer);
        const colorf = new three__WEBPACK_IMPORTED_MODULE_0__["Color"](parseInt(this.settings.colors.face_f.replace('#', '0x'), 16));
        const colorb = new three__WEBPACK_IMPORTED_MODULE_0__["Color"](parseInt(this.settings.colors.face_b.replace('#', '0x'), 16));
        geom.clearGroups();
        material_groups.forEach(element => {
            geom.addGroup(element[0], element[1], element[2]);
        });
        this._buffer_geoms.push(geom);
        const material_arr = [];
        let index = 0;
        const l = materials.length;
        for (; index < l; index++) {
            const element = materials[index];
            // if (this.settings.background.show) {
            //     element.envMap = this.scene.background;
            //     // element.refractionRatio = 1;
            //     // element.envMap.mapping = THREE.CubeRefractionMapping;
            // }
            let mat;
            if (index === 0) {
                delete element.type;
                element.color = colorf;
                mat = new three__WEBPACK_IMPORTED_MODULE_0__["MeshPhongMaterial"](element);
            }
            else if (index === 1) {
                delete element.type;
                element.color = colorb;
                mat = new three__WEBPACK_IMPORTED_MODULE_0__["MeshPhongMaterial"](element);
            }
            else {
                if (element.type === MaterialType.MeshBasicMaterial) {
                    delete element.type;
                    mat = new three__WEBPACK_IMPORTED_MODULE_0__["MeshBasicMaterial"](element);
                }
                else if (element.type === MaterialType.MeshPhongMaterial) {
                    delete element.type;
                    mat = new three__WEBPACK_IMPORTED_MODULE_0__["MeshPhongMaterial"](element);
                }
                else if (element.type === MaterialType.MeshPhysicalMaterial) {
                    delete element.type;
                    if (this.settings.background.show) {
                        element.envMap = this.scene.background;
                    }
                    mat = new three__WEBPACK_IMPORTED_MODULE_0__["MeshPhysicalMaterial"](element);
                }
                else if (element.type === MaterialType.MeshLambertMaterial) {
                    delete element.type;
                    mat = new three__WEBPACK_IMPORTED_MODULE_0__["MeshLambertMaterial"](element);
                }
                else if (element.type === MaterialType.MeshStandardMaterial) {
                    delete element.type;
                    mat = new three__WEBPACK_IMPORTED_MODULE_0__["MeshStandardMaterial"](element);
                }
            }
            material_arr.push(mat);
        }
        const mesh = new three__WEBPACK_IMPORTED_MODULE_0__["Mesh"](geom, material_arr);
        mesh.geometry.computeBoundingSphere();
        if (normals_buffer.count === 0) {
            mesh.geometry.computeVertexNormals();
        }
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        // show vertex normals
        this.vnh = new three__WEBPACK_IMPORTED_MODULE_0__["VertexNormalsHelper"](mesh, this.settings.normals.size, 0x0000ff);
        this.vnh.visible = this.settings.normals.show;
        this.scene.add(this.vnh);
        this.scene_objs.push(mesh);
        // add mesh to scene
        this.scene.add(mesh);
        this.threejs_nums[2] = tris_i.length / 3;
    }
    // ============================================================================
    /**
     * Add threejs lines to the scene
     */
    _addLines(lines_i, white_line_i, posis_buffer, color_buffer, normals_buffer, size = 1) {
        const geom = new three__WEBPACK_IMPORTED_MODULE_0__["BufferGeometry"]();
        geom.setIndex(lines_i);
        geom.setAttribute('position', posis_buffer);
        geom.setAttribute('color', color_buffer);
        this._buffer_geoms.push(geom);
        // // geom.addAttribute( 'color', new THREE.Float32BufferAttribute( colors_flat, 3 ) );
        const mat = new three__WEBPACK_IMPORTED_MODULE_0__["LineDashedMaterial"]({
            color: 0x000000,
            vertexColors: three__WEBPACK_IMPORTED_MODULE_0__["VertexColors"],
            gapSize: 0
        });
        const line = new three__WEBPACK_IMPORTED_MODULE_0__["LineSegments"](geom, mat);
        this.scene_objs.push(line);
        this.scene.add(line);
        const geom_white = new three__WEBPACK_IMPORTED_MODULE_0__["BufferGeometry"]();
        geom_white.setIndex(white_line_i);
        geom_white.setAttribute('position', posis_buffer);
        geom_white.setAttribute('color', color_buffer);
        this._buffer_geoms.push(geom_white);
        // // geom.addAttribute( 'color', new THREE.Float32BufferAttribute( colors_flat, 3 ) );
        const mat_white = new three__WEBPACK_IMPORTED_MODULE_0__["LineDashedMaterial"]({
            color: 0xFFFFFF,
            vertexColors: three__WEBPACK_IMPORTED_MODULE_0__["VertexColors"],
            gapSize: 0
        });
        const line_white = new three__WEBPACK_IMPORTED_MODULE_0__["LineSegments"](geom_white, mat_white);
        this.scene_objs.push(line_white);
        this.scene.add(line_white);
        this.threejs_nums[1] = (lines_i.length + white_line_i.length) / 2;
    }
    // ============================================================================
    /**
     * Add threejs points to the scene
     */
    _addPoints(points_i, posis_buffer, colors_buffer, color, size = 1) {
        const geom = new three__WEBPACK_IMPORTED_MODULE_0__["BufferGeometry"]();
        geom.setIndex(points_i);
        geom.setAttribute('position', posis_buffer);
        geom.setAttribute('color', colors_buffer);
        this._buffer_geoms.push(geom);
        // geom.computeBoundingSphere();
        const rgb = `rgb(${color.toString()})`;
        const mat = new three__WEBPACK_IMPORTED_MODULE_0__["PointsMaterial"]({
            // color: new THREE.Color(rgb),
            size: size,
            vertexColors: three__WEBPACK_IMPORTED_MODULE_0__["VertexColors"],
            sizeAttenuation: false
        });
        const point = new three__WEBPACK_IMPORTED_MODULE_0__["Points"](geom, mat);
        this.scene_objs.push(point);
        this.scene.add(point);
        this.threejs_nums[0] = points_i.length;
    }
    // ============================================================================
    /**
     * Add threejs points to the scene
     */
    _addPointLabels(model) {
        const labels = model.modeldata.attribs.query.getModelAttribVal('labels');
        if (!labels || !Object(util__WEBPACK_IMPORTED_MODULE_4__["isArray"])(labels) || labels.length === 0) {
            return;
        }
        const loader = new three__WEBPACK_IMPORTED_MODULE_0__["FontLoader"]();
        loader.load('assets/fonts/helvetiker_regular.typeface.json', font => {
            const matLite = new three__WEBPACK_IMPORTED_MODULE_0__["MeshBasicMaterial"]({
                transparent: false,
                side: three__WEBPACK_IMPORTED_MODULE_0__["DoubleSide"],
                vertexColors: three__WEBPACK_IMPORTED_MODULE_0__["VertexColors"]
            });
            const shapes = [];
            const fromVec = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](0, 0, 1);
            const checkVecFrom = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](1, 0, 0);
            for (const label of labels) {
                const labelText = label.text;
                const labelOrient = label.position || label.location;
                if (!labelText || !labelOrient || !Object(util__WEBPACK_IMPORTED_MODULE_4__["isArray"])(labelOrient)) {
                    continue;
                }
                const labelSize = label.size || 20;
                const shape = font.generateShapes(labelText, labelSize, 1);
                const geom = new three__WEBPACK_IMPORTED_MODULE_0__["ShapeBufferGeometry"](shape);
                let labelPos = labelOrient[0];
                if (!Object(util__WEBPACK_IMPORTED_MODULE_4__["isArray"])(labelPos)) {
                    labelPos = labelOrient;
                }
                else {
                    let toVec = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](...labelOrient[1]);
                    const pVec2 = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](...labelOrient[2]);
                    toVec = toVec.cross(pVec2).normalize();
                    if (labelOrient[1][0] !== 0 || labelOrient[1][1] !== 0) {
                        const checkVecTo = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](labelOrient[1][0], labelOrient[1][1], 0).normalize();
                        const rotateQuat = new three__WEBPACK_IMPORTED_MODULE_0__["Quaternion"]();
                        rotateQuat.setFromUnitVectors(checkVecFrom, checkVecTo);
                        const rotateMat = new three__WEBPACK_IMPORTED_MODULE_0__["Matrix4"](); // create one and reuse it
                        rotateMat.makeRotationFromQuaternion(rotateQuat);
                        geom.applyMatrix(rotateMat);
                    }
                    const quaternion = new three__WEBPACK_IMPORTED_MODULE_0__["Quaternion"]();
                    quaternion.setFromUnitVectors(fromVec, toVec);
                    const matrix = new three__WEBPACK_IMPORTED_MODULE_0__["Matrix4"](); // create one and reuse it
                    matrix.makeRotationFromQuaternion(quaternion);
                    geom.applyMatrix(matrix);
                }
                geom.translate(labelPos[0], labelPos[1], labelPos[2]);
                let color = new three__WEBPACK_IMPORTED_MODULE_0__["Color"](0);
                if (label.color && label.color.length === 3) {
                    color = new three__WEBPACK_IMPORTED_MODULE_0__["Color"](`rgb(${label.color[0]}, ${label.color[1]}, ${label.color[2]})`);
                }
                const colors_buffer = new three__WEBPACK_IMPORTED_MODULE_0__["Float32BufferAttribute"](geom.attributes.position.count * 3, 3);
                if (label.color && label.color.length === 3) {
                    for (let i = 0; i < colors_buffer.count; i++) {
                        colors_buffer.setXYZ(i, label.color[0], label.color[1], label.color[2]);
                    }
                }
                geom.setAttribute('color', colors_buffer);
                shapes.push(geom);
            }
            if (shapes.length === 0) {
                return;
            }
            const mergedGeom = three_examples_jsm_utils_BufferGeometryUtils_js__WEBPACK_IMPORTED_MODULE_3__["BufferGeometryUtils"].mergeBufferGeometries(shapes);
            const text = new three__WEBPACK_IMPORTED_MODULE_0__["Mesh"](mergedGeom, matLite);
            this.scene.add(text);
            // this.renderer.render(this.scene, this.camera);
            this.renderer.render(this.scene, this.camera);
        });
    }
    // ============================================================================
    /**
     * Add threejs positions to the scene
     */
    _addPosis(points_i, posis_buffer, color, size = 1) {
        const geom = new three__WEBPACK_IMPORTED_MODULE_0__["BufferGeometry"]();
        geom.setIndex(points_i);
        // geom.addAttribute('position', posis_buffer);
        geom.setAttribute('position', posis_buffer);
        this._buffer_geoms.push(geom);
        // geom.computeBoundingSphere();
        const mat = new three__WEBPACK_IMPORTED_MODULE_0__["PointsMaterial"]({
            color: new three__WEBPACK_IMPORTED_MODULE_0__["Color"](parseInt(color.replace('#', '0x'), 16)),
            size: size,
            sizeAttenuation: false
            // vertexColors: THREE.VertexColors
        });
        const point = new three__WEBPACK_IMPORTED_MODULE_0__["Points"](geom, mat);
        this.scene_objs.push(point);
        this.scene.add(point);
        this.positions.push(point);
        this.positions.map(p => p.visible = this.settings.positions.show);
    }
    // ============================================================================
    /**
     *
     * @param text
     */
    _createHud(text) {
        const div = document.createElement('div');
        div.id = `hud`;
        div.style.position = 'absolute';
        div.style.background = 'rgba(255, 255, 255, 0.3)';
        div.style.padding = '5px';
        div.innerHTML = text;
        div.style.top = '40px';
        div.style.left = '5px';
        div.style.maxWidth = '200px';
        div.style.whiteSpace = 'pre-wrap';
        div.style.fontSize = '14px';
        return {
            element: div
        };
    }
    /**
     *
     * @param background_set
     */
    _loadBackground(background_set) {
        const path = 'assets/img/background/bg' + background_set + '/';
        const format = '.jpg';
        const urls = [
            path + 'px' + format, path + 'nx' + format,
            path + 'py' + format, path + 'ny' + format,
            path + 'pz' + format, path + 'nz' + format
        ];
        this.cameraBackgrounds = {};
        new three__WEBPACK_IMPORTED_MODULE_0__["CubeTextureLoader"]().load(urls, texture => {
            this.renderer.render(this.scene, this.camera);
            texture.format = three__WEBPACK_IMPORTED_MODULE_0__["RGBFormat"];
            this.cameraBackgrounds['Persp'] = texture;
            this.scene.background = this.cameraBackgrounds[this.currentCamera];
        });
        new three__WEBPACK_IMPORTED_MODULE_0__["TextureLoader"]().load(path + 'nz' + format, texture => {
            this.renderer.render(this.scene, this.camera);
            texture.format = three__WEBPACK_IMPORTED_MODULE_0__["RGBFormat"];
            this.cameraBackgrounds['Top'] = texture;
            this.scene.background = this.cameraBackgrounds[this.currentCamera];
        });
        new three__WEBPACK_IMPORTED_MODULE_0__["TextureLoader"]().load(path + 'left' + format, texture => {
            this.renderer.render(this.scene, this.camera);
            texture.format = three__WEBPACK_IMPORTED_MODULE_0__["RGBFormat"];
            this.cameraBackgrounds['Left'] = texture;
            this.scene.background = this.cameraBackgrounds[this.currentCamera];
        });
        new three__WEBPACK_IMPORTED_MODULE_0__["TextureLoader"]().load(path + 'front' + format, texture => {
            this.renderer.render(this.scene, this.camera);
            texture.format = three__WEBPACK_IMPORTED_MODULE_0__["RGBFormat"];
            this.cameraBackgrounds['Front'] = texture;
            this.scene.background = this.cameraBackgrounds[this.currentCamera];
        });
        // this._renderer.render(this._scene, this._camera);
    }
    /**
     * Create ambient light
     */
    _addAmbientLight() {
        const color = new three__WEBPACK_IMPORTED_MODULE_0__["Color"](parseInt(this.settings.ambient_light.color.replace('#', '0x'), 16));
        const intensity = this.settings.ambient_light.intensity;
        this.ambient_light = new three__WEBPACK_IMPORTED_MODULE_0__["AmbientLight"](color, intensity); // soft white light
        this.ambient_light.castShadow = false;
        this.scene.add(this.ambient_light);
    }
    /**
     * Create hemisphere light
     */
    _addHemisphereLight() {
        const skyColor = new three__WEBPACK_IMPORTED_MODULE_0__["Color"](parseInt(this.settings.hemisphere_light.skyColor.replace('#', '0x'), 16));
        const groundColor = new three__WEBPACK_IMPORTED_MODULE_0__["Color"](parseInt(this.settings.hemisphere_light.groundColor.replace('#', '0x'), 16));
        const intensity = this.settings.hemisphere_light.intensity;
        this.hemisphere_light = new three__WEBPACK_IMPORTED_MODULE_0__["HemisphereLight"](skyColor, // skyColor
        groundColor, // groundColor
        intensity // intensity
        );
        this.scene.add(this.hemisphere_light);
        const helper = new three__WEBPACK_IMPORTED_MODULE_0__["HemisphereLightHelper"](this.hemisphere_light, 10);
        helper.visible = this.settings.hemisphere_light.helper;
        this.scene.add(helper);
    }
    // Create Directional Light
    _addDirectionalLight() {
        this.directional_light_settings = JSON.parse(JSON.stringify(this.settings.directional_light));
        if (this.model
            && this.model.modeldata.attribs
            && this.model.modeldata.attribs.query
            && this.model.modeldata.attribs.query.hasModelAttrib('directional_light')) {
            const model_light_settings = this.model.modeldata.attribs.query.getModelAttribVal('directional_light');
            if (model_light_settings.constructor === {}.constructor) {
                for (const i in model_light_settings) {
                    if (model_light_settings[i]) {
                        this.directional_light_settings[i] = model_light_settings[i];
                    }
                }
            }
        }
        this.directional_light = new three__WEBPACK_IMPORTED_MODULE_0__["DirectionalLight"](this.directional_light_settings.color, this.directional_light_settings.intensity);
        // if (this.directional_light_settings.type === 'directional') {
        //     this.directional_light = new THREE.DirectionalLight(this.directional_light_settings.color,
        //         this.directional_light_settings.intensity);
        // } else {
        //     this.directional_light = new THREE.PointLight(this.directional_light_settings.color,
        //         this.directional_light_settings.intensity);
        // }
        let distance = 0;
        if (this._all_objs_sphere) {
            distance = Math.round(this._all_objs_sphere.radius);
            // if (distance < 10000) { distance = 10000; }
        }
        this.directional_light_settings.distance = distance;
        // this.getDLPosition(distance);
        this.directional_light.castShadow = this.directional_light_settings.shadow;
        this.directional_light.visible = this.directional_light_settings.show;
        // this.directional_light_settings.shadowSize = 2;
        // const shadowMapSize = this.directional_light_settings.shadowSize;
        if (this.directional_light_settings.shadowSize <= 10) {
            this.directional_light_settings.shadowSize = this.directional_light_settings.shadowSize * 512;
        }
        if (this.directional_light_settings.shadowSize < 1024) {
            this.directional_light_settings.shadowSize = 2048;
        }
        this.directional_light.shadow.mapSize.width = this.directional_light_settings.shadowSize; // default
        this.directional_light.shadow.mapSize.height = this.directional_light_settings.shadowSize; // default
        // this.directional_light.shadow.camera.visible = true;
        this._setDLDistance(distance);
        this.scene.add(this.directional_light);
    }
    /**
     * Get the bounding sphere of all objects
     */
    _getAllObjsSphere() {
        if (this.scene_objs.length !== 0) {
            const objs = new three__WEBPACK_IMPORTED_MODULE_0__["Object3D"]();
            this.scene_objs.map(obj => objs.children.push(obj));
            const boxHelper = new three__WEBPACK_IMPORTED_MODULE_0__["BoxHelper"](objs);
            boxHelper.geometry.computeBoundingSphere();
            const boundingSphere = boxHelper.geometry.boundingSphere;
            return boundingSphere;
        }
        else {
            return null;
        }
    }
    /**
     *
     * @param size
     */
    _setDLDistance(size = null) {
        let scale;
        if (size) {
            scale = size;
        }
        else {
            scale = 10000;
        }
        if (this.directional_light) {
            let i = 0;
            const length = this.scene.children.length;
            if (length !== 0) {
                for (; i < length; i++) {
                    if (this.scene.children[i]) {
                        if (this.scene.children[i].name === 'DLHelper' || this.scene.children[i].name === 'lightTarget') {
                            this.scene.children[i]['dispose']();
                            this.scene.remove(this.scene.children[i]);
                        }
                    }
                }
            }
            this.directional_light.shadow.camera.near = 0.5;
            // let altitude = this.directional_light_settings.altitude;
            // if (altitude < 3) { altitude = 3; }
            // const altitudeOffset = Math.sin(altitude * Math.PI / 180);
            this.directional_light.shadow.camera.far = scale * 20;
            this.directional_light.shadow.bias = -0.0001;
            let helper;
            const cam = this.directional_light.shadow.camera;
            cam.up.set(0, 0, 1);
            cam.left = -scale;
            cam.right = scale;
            cam.top = scale;
            cam.bottom = -scale;
            if (this._all_objs_sphere) {
                const lightTarget = new three__WEBPACK_IMPORTED_MODULE_0__["Object3D"]();
                lightTarget.position.set(this._all_objs_sphere.center.x, this._all_objs_sphere.center.y, this._all_objs_sphere.center.z);
                lightTarget.name = 'lightTarget';
                this.scene.add(lightTarget);
                this.directional_light.target = lightTarget;
            }
            helper = new three__WEBPACK_IMPORTED_MODULE_0__["CameraHelper"](this.directional_light.shadow.camera);
            // if (this.directional_light_settings.type === 'directional') {
            //     const cam = <THREE.OrthographicCamera> this.directional_light.shadow.camera;
            //     cam.left = -scale;
            //     cam.right = scale;
            //     cam.top = scale;
            //     cam.bottom = -scale;
            //     if (this._all_objs_sphere) {
            //         const lightTarget = new THREE.Object3D();
            //         lightTarget.position.set(
            //             this._all_objs_sphere.center.x, this._all_objs_sphere.center.y, this._all_objs_sphere.center.z);
            //         lightTarget.name = 'lightTarget';
            //         this.scene.add(lightTarget);
            //         (<THREE.DirectionalLight>this.directional_light).target = lightTarget;
            //     }
            //     helper = new THREE.CameraHelper(this.directional_light.shadow.camera);
            // } else {
            //     helper = new THREE.PointLightHelper( <THREE.PointLight>this.directional_light );
            // }
            helper.visible = this.directional_light_settings.helper;
            helper.name = 'DLHelper';
            if (size) {
                this.scene.add(helper);
            }
            this.getDLPosition(scale);
        }
    }
}


/***/ }),

/***/ "./src/app/gi-viewer/data/data.threejsBase.ts":
/*!****************************************************!*\
  !*** ./src/app/gi-viewer/data/data.threejsBase.ts ***!
  \****************************************************/
/*! exports provided: DataThreejsBase */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataThreejsBase", function() { return DataThreejsBase; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/* harmony import */ var three_examples_jsm_controls_OrbitControls_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three/examples/jsm/controls/OrbitControls.js */ "./node_modules/three/examples/jsm/controls/OrbitControls.js");
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};

// import * as OrbitControls from 'three-orbit-controls';

// import { WEBVR } from 'three/examples/jsm/vr/WebVR.js';
/**
 * ThreejsScene
 */
class DataThreejsBase {
    /**
     * Constructs a new data subscriber.
     */
    constructor(settings) {
        this.selected_geoms = new Map();
        this.selected_positions = new Map();
        this.selected_vertex = new Map();
        this.selected_face_edges = new Map();
        this.selected_face_wires = new Map();
        // public vrEnabled: boolean = true;
        // public vr;
        // text labels
        this.ObjLabelMap = new Map();
        this.textLabels = new Map();
        // number of threejs points, lines, triangles
        this.threejs_nums = [0, 0, 0];
        this.axes_pos = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
        this.scene_objs = [];
        this.scene_objs_selected = new Map();
        this.positions = [];
        this.timelineEnabled = null;
        this.timelineIndex = null;
        this.timelineValue = null;
        this.current_time_point = null;
        this.timeline_groups = null;
        // initial origin
        this.origin = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](0, 1, 0);
        // BufferGeoms
        this._buffer_geoms = [];
        this.settings = settings;
        if (!this.settings.directional_light.type) {
            this.settings.directional_light.type = 'directional';
            localStorage.setItem('mpm_settings', JSON.stringify(this.settings));
        }
        // scene
        this.scene = new three__WEBPACK_IMPORTED_MODULE_0__["Scene"]();
        // renderer
        this.renderer = new three__WEBPACK_IMPORTED_MODULE_0__["WebGLRenderer"]({ antialias: true, alpha: true, logarithmicDepthBuffer: true });
        this.renderer.autoClear = false;
        // this._renderer.setClearColor(0xcccccc, 0);
        this.renderer.setPixelRatio(window.devicePixelRatio);
        this.renderer.setSize(window.innerWidth / 1.8, window.innerHeight);
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = three__WEBPACK_IMPORTED_MODULE_0__["PCFSoftShadowMap"];
        // this.renderer.shadowMap.type = THREE.VSMShadowMap;
        // camera settings
        this.perspCam = new three__WEBPACK_IMPORTED_MODULE_0__["PerspectiveCamera"](50, 1, 0.01, 1000000);
        this.perspCam.position.x = -80;
        this.perspCam.position.y = -80;
        this.perspCam.position.z = 80;
        this.perspCam.aspect = 1;
        this.perspCam.up.set(0, 0, 1);
        this.perspCam.lookAt(this.scene.position);
        this.perspCam.updateProjectionMatrix();
        this.orthoCam = new three__WEBPACK_IMPORTED_MODULE_0__["OrthographicCamera"](0, 600, 600, 0, 0.1, 2000);
        this.orthoCam.position.x = -300;
        this.orthoCam.position.y = 0;
        this.orthoCam.position.z = 0;
        this.orthoCam.up.set(0, 0, 1);
        this.orthoCam.lookAt(this.scene.position);
        this.orthoCam.updateProjectionMatrix();
        this.orthoCamPos = {};
        this.currentCamera = 'Persp';
        // orbit controls
        // const orbit_controls = OrbitControls(THREE);
        // this.controls = new orbit_controls(this.camera, this.renderer.domElement);
        this.perspControls = new three_examples_jsm_controls_OrbitControls_js__WEBPACK_IMPORTED_MODULE_1__["OrbitControls"](this.perspCam, this.renderer.domElement);
        this.perspControls.enableKeys = false;
        this.perspControls.update();
        this.orthoControls = new three_examples_jsm_controls_OrbitControls_js__WEBPACK_IMPORTED_MODULE_1__["OrbitControls"](this.orthoCam, this.renderer.domElement);
        this.orthoControls.enableKeys = false;
        // this.orthoControls.screenSpacePanning = false;
        this.orthoControls.screenSpacePanning = true;
        this.orthoControls.enableRotate = false;
        this.orthoControls.enabled = false;
        this.orthoControls.update();
        this.camera = this.perspCam;
        this.controls = this.perspControls;
        // mouse
        this.mouse = new three__WEBPACK_IMPORTED_MODULE_0__["Vector2"]();
        // selecting
        this.raycaster = new three__WEBPACK_IMPORTED_MODULE_0__["Raycaster"]();
        this.raycaster.params.Line.threshold = 0.3; // TODO this need to be set dynamically based on model size and view zoom
        this.raycaster.params.Points.threshold = 0.3; // TODO this need to be set dynamically based on model size and view zoom
        // this.vr = WEBVR.createButton(this.renderer);
        setTimeout(() => {
            const threeContainer = document.getElementById('threejs-container');
            const aspect = (threeContainer.clientWidth / threeContainer.clientHeight + 1) / 2;
            this.orthoCam.left = aspect * -300;
            this.orthoCam.right = aspect * 300;
            this.orthoCam.updateProjectionMatrix();
            this.orthoControls.update();
        }, 0);
    }
}


/***/ }),

/***/ "./src/app/gi-viewer/data/data.threejsLookAt.ts":
/*!******************************************************!*\
  !*** ./src/app/gi-viewer/data/data.threejsLookAt.ts ***!
  \******************************************************/
/*! exports provided: DataThreejsLookAt */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataThreejsLookAt", function() { return DataThreejsLookAt; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/* harmony import */ var _data_threejsSelect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./data.threejsSelect */ "./src/app/gi-viewer/data/data.threejsSelect.ts");
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};


/**
 * ThreejsScene Look At
 */
class DataThreejsLookAt extends _data_threejsSelect__WEBPACK_IMPORTED_MODULE_1__["DataThreejsSelect"] {
    /**
     * Constructor
     */
    constructor(settings) {
        super(settings);
    }
    /**
     *
     */
    lookAtObj() {
        const selectedObjs = this._getSelectedObjs();
        let center = null;
        let radius = null;
        if (selectedObjs) {
            center = selectedObjs.center;
            radius = selectedObjs.radius;
            if (radius === 0) {
                radius = 50;
            }
        }
        else if (this._all_objs_sphere) {
            center = this._all_objs_sphere.center;
            radius = this._all_objs_sphere.radius;
            if (radius === 0) {
                radius = 50;
            }
        }
        else {
            center = this.scene.position;
            radius = 50;
        }
        this._cameraLookat(center, radius);
    }
    // ============================================================================
    // Private methods
    // ============================================================================
    /**
     *
     */
    _getSelectedObjs() {
        if (this.scene_objs_selected.size !== 0) {
            const objs = new three__WEBPACK_IMPORTED_MODULE_0__["Object3D"]();
            this.scene_objs_selected.forEach(obj => objs.children.push(obj));
            const boxHelper = new three__WEBPACK_IMPORTED_MODULE_0__["BoxHelper"](objs);
            boxHelper.geometry.computeBoundingSphere();
            const boundingSphere = boxHelper.geometry.boundingSphere;
            return boundingSphere;
        }
        else {
            return null;
        }
    }
    /**
     *
     * @param center
     * @param radius
     */
    _cameraLookat(center, radius = 100) {
        const fov = this.perspCam.fov * (Math.PI / 180);
        const perspectiveNewPos = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
        // Find looking direction: current camera position - current control target
        // Scale looking direction to be of length: radius / sin(fov/2)
        // New camera position: scaled looking direction + center
        perspectiveNewPos.subVectors(this.perspCam.position, this.perspControls.target);
        perspectiveNewPos.setLength(radius / Math.sin(fov / 2));
        perspectiveNewPos.add(center);
        this.perspCam.position.copy(perspectiveNewPos);
        this.perspControls.target.set(center.x, center.y, center.z);
        this.perspCam.updateProjectionMatrix();
        this.perspControls.update();
        const textLabels = this.textLabels;
        if (textLabels.size !== 0) {
            textLabels.forEach((label) => {
                label.updatePosition();
            });
        }
    }
    orthoLookatObj() {
        if (this.currentCamera === 'Top') {
            this._orthoLookat(0, 0, 1);
        }
        else if (this.currentCamera === 'Left') {
            this._orthoLookat(-1, 0, 0);
        }
        else if (this.currentCamera === 'Front') {
            this._orthoLookat(0, -1, 0);
        }
    }
    _orthoLookat(dirX, dirY, dirZ) {
        const selectedObjs = this._getSelectedObjs();
        let center = null;
        let radius = null;
        if (selectedObjs) {
            center = selectedObjs.center;
            radius = selectedObjs.radius;
            if (radius === 0) {
                radius = 50;
            }
        }
        else if (this._all_objs_sphere) {
            center = this._all_objs_sphere.center;
            radius = this._all_objs_sphere.radius;
            if (radius === 0) {
                radius = 50;
            }
        }
        else {
            center = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
            radius = 50;
        }
        const posVec = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](center.x + 1.5 * dirX * radius, center.y + 1.5 * dirY * radius, center.z + 1.5 * dirZ * radius);
        this.orthoCam.left = -radius * this.orthoCam.right / this.orthoCam.top;
        this.orthoCam.right = radius * this.orthoCam.right / this.orthoCam.top;
        this.orthoCam.top = radius;
        this.orthoCam.bottom = -radius;
        this.orthoCam.zoom = 1;
        this.orthoCam.position.copy(posVec);
        this.orthoControls.target.copy(new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](posVec.x * (1 - Math.abs(dirX)), posVec.y * (1 - Math.abs(dirY)), posVec.z * (1 - Math.abs(dirZ))));
        this.orthoCam.updateProjectionMatrix();
        this.orthoControls.update();
    }
    updateCameraFOV() {
        const selectedObjs = this._getSelectedObjs();
        let center = null;
        let radius = null;
        if (selectedObjs) {
            center = selectedObjs.center;
            radius = selectedObjs.radius;
            if (radius === 0) {
                radius = 50;
            }
        }
        else if (this._all_objs_sphere) {
            center = this._all_objs_sphere.center;
            radius = this._all_objs_sphere.radius;
            if (radius === 0) {
                radius = 50;
            }
        }
        else {
            center = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
            radius = 50;
        }
        this.orthoCam.left = -radius * this.orthoCam.right / this.orthoCam.top;
        this.orthoCam.right = radius * this.orthoCam.right / this.orthoCam.top;
        this.orthoCam.top = radius;
        this.orthoCam.bottom = -radius;
        if (this.currentCamera === 'Top') {
            this.orthoCam.position.z = center.z + 1.5 * radius;
        }
        else if (this.currentCamera === 'Left') {
            this.orthoCam.position.x = center.x - 1.5 * radius;
        }
        else if (this.currentCamera === 'Front') {
            this.orthoCam.position.y = center.y - 1.5 * radius;
        }
    }
    switchCamera(switchCam = true) {
        if (switchCam) {
            if (this.currentCamera !== 'Persp') {
                this.orthoCamPos[this.currentCamera] = {
                    position: new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]().copy(this.orthoCam.position),
                    target: new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]().copy(this.orthoControls.target),
                    zoom: this.orthoCam.zoom,
                };
            }
            if (this.currentCamera === 'Persp') {
                this.currentCamera = 'Top';
            }
            else if (this.currentCamera === 'Top') {
                this.currentCamera = 'Left';
            }
            else if (this.currentCamera === 'Left') {
                this.currentCamera = 'Front';
            }
            else if (this.currentCamera === 'Front') {
                this.currentCamera = 'Persp';
            }
            if (this.cameraBackgrounds) {
                this.scene.background = this.cameraBackgrounds[this.currentCamera];
            }
        }
        if (this.currentCamera === 'Persp') {
            this.orthoControls.enabled = false;
            this.perspControls.enabled = true;
            this.camera = this.perspCam;
            this.controls = this.perspControls;
            this.perspControls.update();
            this.orthoControls.update();
        }
        else {
            this.perspControls.enabled = false;
            this.orthoControls.enabled = true;
            this.camera = this.orthoCam;
            this.controls = this.orthoControls;
            if (this.orthoCamPos[this.currentCamera]) {
                const camPos = this.orthoCamPos[this.currentCamera];
                this.orthoCam.position.copy(camPos.position);
                this.orthoCam.zoom = camPos.zoom;
                this.orthoControls.target.copy(camPos.target);
                this.updateCameraFOV();
                this.orthoCam.updateProjectionMatrix();
            }
            else {
                if (this.currentCamera === 'Top') {
                    this._orthoLookat(0, 0, 1);
                }
                else if (this.currentCamera === 'Left') {
                    this._orthoLookat(-1, 0, 0);
                }
                else if (this.currentCamera === 'Front') {
                    this._orthoLookat(0, -1, 0);
                }
            }
            this.perspControls.update();
            this.orthoControls.update();
        }
    }
}


/***/ }),

/***/ "./src/app/gi-viewer/data/data.threejsSelect.ts":
/*!******************************************************!*\
  !*** ./src/app/gi-viewer/data/data.threejsSelect.ts ***!
  \******************************************************/
/*! exports provided: DataThreejsSelect */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataThreejsSelect", function() { return DataThreejsSelect; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/* harmony import */ var _data_threejsBase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./data.threejsBase */ "./src/app/gi-viewer/data/data.threejsBase.ts");
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};


var objType;
(function (objType) {
    objType["point"] = "point";
    objType["line"] = "line";
    objType["face"] = "face";
})(objType || (objType = {}));
/**
 * ThreejsScene Select
 */
class DataThreejsSelect extends _data_threejsBase__WEBPACK_IMPORTED_MODULE_1__["DataThreejsBase"] {
    /**
     * Constructor
     */
    constructor(settings) {
        super(settings);
    }
    /**
     *
     * @param ent_id
     * @param triangle_i
     * @param positions
     * @param container
     * @param label
     */
    selectObjFace(ent_id, tris_i, positions, container, labelText = null) {
        if (this.selected_geoms.has(ent_id)) {
            return;
        }
        const geom = new three__WEBPACK_IMPORTED_MODULE_0__["BufferGeometry"]();
        geom.setIndex(tris_i);
        geom.setAttribute('position', new three__WEBPACK_IMPORTED_MODULE_0__["Float32BufferAttribute"](positions, 3));
        geom.setAttribute('normal', new three__WEBPACK_IMPORTED_MODULE_0__["Float32BufferAttribute"](Array(positions.length).fill(0), 3));
        geom.setAttribute('color', new three__WEBPACK_IMPORTED_MODULE_0__["Float32BufferAttribute"](Array(positions.length).fill(0), 3));
        geom.clearGroups();
        geom.addGroup(0, tris_i.length, 0);
        geom.addGroup(0, tris_i.length, 1);
        const colorf = new three__WEBPACK_IMPORTED_MODULE_0__["Color"](parseInt(this.settings.colors.face_f_s.replace('#', '0x'), 16));
        const colorb = new three__WEBPACK_IMPORTED_MODULE_0__["Color"](parseInt(this.settings.colors.face_b_s.replace('#', '0x'), 16));
        const matf = new three__WEBPACK_IMPORTED_MODULE_0__["MeshPhongMaterial"]({
            specular: 0x000000,
            emissive: 0x000000,
            color: colorf,
            shininess: 0,
            side: three__WEBPACK_IMPORTED_MODULE_0__["FrontSide"]
        });
        const matb = new three__WEBPACK_IMPORTED_MODULE_0__["MeshPhongMaterial"]({
            specular: 0x000000,
            emissive: 0x000000,
            color: colorb,
            shininess: 0,
            side: three__WEBPACK_IMPORTED_MODULE_0__["BackSide"]
        });
        const mesh = new three__WEBPACK_IMPORTED_MODULE_0__["Mesh"](geom, [matf, matb]);
        mesh.geometry.computeBoundingSphere();
        mesh.geometry.computeVertexNormals();
        this.scene.add(mesh);
        this.selected_geoms.set(ent_id, mesh.id);
        this.scene_objs_selected.set(ent_id, mesh);
        if (labelText) {
            const obj = { entity: mesh, type: objType.face, text: labelText };
            this.createLabelforObj(container, obj.entity, obj.type, labelText, ent_id);
            this.ObjLabelMap.set(ent_id, obj);
        }
    }
    /**
     *
     * @param ent_id
     * @param indices
     * @param positions
     * @param container
     * @param labelText
     */
    selectObjLine(ent_id, indices, positions, container, labelText = null) {
        if (this.selected_geoms.has(ent_id)) {
            return;
        }
        const bg = this.initBufferLine(positions, indices, [255, 0, 0]);
        const line = new three__WEBPACK_IMPORTED_MODULE_0__["LineSegments"](bg.geom, bg.mat);
        this.scene.add(line);
        this.selected_geoms.set(ent_id, line.id);
        this.scene_objs_selected.set(ent_id, line);
        if (labelText) {
            const obj = { entity: line, type: objType.line, text: labelText };
            this.createLabelforObj(container, obj.entity, obj.type, labelText, ent_id);
            this.ObjLabelMap.set(ent_id, obj);
        }
    }
    /**
     *
     * @param parent_ent_id
     * @param ent_id
     * @param indices
     * @param positions
     * @param container
     * @param labelText
     */
    selectEdgeByFace(parent_ent_id, ent_id, indices, positions, container, labelText = null) {
        const bg = this.initBufferLine(positions, indices, [255, 0, 0]);
        if (this.selected_face_edges.get(parent_ent_id) === undefined) {
            this.selected_face_edges.set(parent_ent_id, new Map());
        }
        const check_exist = [];
        this.selected_face_edges.forEach(v => {
            v.forEach((vv, k) => {
                check_exist.push(k);
            });
        });
        this.selected_geoms.forEach((v, k) => {
            check_exist.push(k);
        });
        if (!check_exist.includes(ent_id)) {
            const line = new three__WEBPACK_IMPORTED_MODULE_0__["LineSegments"](bg.geom, bg.mat);
            this.scene.add(line);
            this.selected_face_edges.get(parent_ent_id).set(ent_id, line.id);
            this.selected_geoms.set(ent_id, line.id);
            this.scene_objs_selected.set(ent_id, line);
            if (labelText) {
                const obj = {
                    entity: line,
                    type: objType.line,
                    text: labelText
                };
                this.createLabelforObj(container, obj.entity, obj.type, labelText, ent_id);
                this.ObjLabelMap.set(ent_id, obj);
            }
        }
    }
    /**
     *
     * @param parent_ent_id
     * @param ent_id
     * @param indices
     * @param positions
     * @param container
     * @param labelText
     */
    selectWireByFace(parent_ent_id, ent_id, indices, positions, container, labelText = null) {
        const bg = this.initBufferLine(positions, indices, [255, 0, 0]);
        if (this.selected_face_wires.get(parent_ent_id) === undefined) {
            this.selected_face_wires.set(parent_ent_id, new Map());
        }
        const check_exist = [];
        this.selected_face_wires.forEach(v => {
            v.forEach((vv, k) => {
                check_exist.push(k);
            });
        });
        this.selected_geoms.forEach((v, k) => {
            check_exist.push(k);
        });
        if (!check_exist.includes(ent_id)) {
            const line = new three__WEBPACK_IMPORTED_MODULE_0__["LineSegments"](bg.geom, bg.mat);
            this.scene.add(line);
            this.selected_face_wires.get(parent_ent_id).set(ent_id, line.id);
            this.selected_geoms.set(ent_id, line.id);
            this.scene_objs_selected.set(ent_id, line);
            if (labelText) {
                const obj = {
                    entity: line,
                    type: objType.line,
                    text: labelText
                };
                this.createLabelforObj(container, obj.entity, obj.type, labelText, ent_id);
                this.ObjLabelMap.set(ent_id, obj);
            }
        }
    }
    /**
     *
     * @param ent_id
     * @param point_indices
     * @param positions
     * @param container
     * @param labelText
     */
    selectObjPoint(ent_id = null, point_indices, positions, container, labelText = null) {
        if (this.selected_geoms.has(ent_id)) {
            return;
        }
        const bg = this.initBufferPoint(positions, point_indices, null, '#ff0000');
        const point = new three__WEBPACK_IMPORTED_MODULE_0__["Points"](bg.geom, bg.mat);
        this.scene.add(point);
        this.selected_geoms.set(ent_id, point.id);
        this.scene_objs_selected.set(ent_id, point);
        if (labelText) {
            const obj = { entity: point, type: objType.point, text: labelText };
            this.createLabelforObj(container, obj.entity, obj.type, labelText, ent_id);
            this.ObjLabelMap.set(ent_id, obj);
        }
    }
    /**
     *
     * @param parent_ent_id
     * @param ent_id
     * @param positions
     * @param container
     * @param labelText
     */
    selectObjPosition(parent_ent_id, ent_id, positions, container, labelText = null) {
        const bg = this.initBufferPoint(positions, null, null, this.settings.colors.position_s, this.settings.positions.size + 0.1);
        if (parent_ent_id === null) {
            const point = new three__WEBPACK_IMPORTED_MODULE_0__["Points"](bg.geom, bg.mat);
            this.scene.add(point);
            this.selected_geoms.set(ent_id, point.id);
            this.scene_objs_selected.set(ent_id, point);
            if (labelText) {
                const obj = {
                    entity: point,
                    type: objType.point,
                    text: labelText
                };
                this.createLabelforObj(container, obj.entity, obj.type, labelText, ent_id);
                this.ObjLabelMap.set(ent_id, obj);
            }
        }
        else {
            if (this.selected_positions.get(parent_ent_id) === undefined) {
                this.selected_positions.set(parent_ent_id, new Map());
            }
            const check_exist = [];
            this.selected_positions.forEach(v => {
                v.forEach((vv, k) => {
                    check_exist.push(k);
                });
            });
            if (!check_exist.includes(ent_id)) {
                const point = new three__WEBPACK_IMPORTED_MODULE_0__["Points"](bg.geom, bg.mat);
                this.scene.add(point);
                this.selected_positions.get(parent_ent_id).set(ent_id, point.id);
                this.selected_geoms.set(ent_id, point.id);
                this.scene_objs_selected.set(ent_id, point);
                if (labelText) {
                    const obj = {
                        entity: point,
                        type: objType.point,
                        text: labelText
                    };
                    this.createLabelforObj(container, obj.entity, obj.type, labelText, ent_id);
                    this.ObjLabelMap.set(ent_id, obj);
                }
            }
        }
    }
    /**
     *
     * @param parent_ent_id
     * @param ent_id
     * @param positions
     * @param container
     * @param labelText
     */
    selectObjvertex(parent_ent_id, ent_id, positions, container, labelText = null) {
        const bg = this.initBufferPoint(positions, null, null, this.settings.colors.vertex_s, this.settings.positions.size + 0.1);
        if (parent_ent_id === null) {
            const point = new three__WEBPACK_IMPORTED_MODULE_0__["Points"](bg.geom, bg.mat);
            this.scene.add(point);
            this.scene_objs_selected.set(ent_id, point);
            this.selected_geoms.set(ent_id, point.id);
            if (labelText) {
                const obj = {
                    entity: point,
                    type: objType.point,
                    text: labelText
                };
                this.createLabelforObj(container, obj.entity, obj.type, labelText, ent_id);
                this.ObjLabelMap.set(ent_id, obj);
            }
        }
        else {
            if (this.selected_vertex.get(parent_ent_id) === undefined) {
                this.selected_vertex.set(parent_ent_id, new Map());
            }
            const check_exist = [];
            this.selected_vertex.forEach(v => {
                v.forEach((vv, k) => {
                    check_exist.push(k);
                });
            });
            if (!check_exist.includes(ent_id)) {
                const point = new three__WEBPACK_IMPORTED_MODULE_0__["Points"](bg.geom, bg.mat);
                this.scene.add(point);
                this.selected_vertex.get(parent_ent_id).set(ent_id, point.id);
                this.scene_objs_selected.set(ent_id, point);
                this.selected_geoms.set(ent_id, point.id);
                if (labelText) {
                    const obj = {
                        entity: point,
                        type: objType.point,
                        text: labelText
                    };
                    this.createLabelforObj(container, obj.entity, obj.type, labelText, ent_id);
                    this.ObjLabelMap.set(ent_id, obj);
                }
            }
        }
    }
    /**
     *
     * @param container
     * @param obj
     * @param type
     * @param labelText
     * @param ent_id
     */
    createLabelforObj(container, obj, type, labelText, ent_id) {
        const label = this._createTextLabel(container, type, labelText, ent_id);
        label.setHTML(labelText);
        label.setParent(obj);
        this.textLabels.set(label.element.id, label);
        container.appendChild(label.element);
        label.updatePosition();
    }
    /**
     *
     * @param ent_id
     * @param container
     */
    unselectObj(ent_id, container) {
        const removing = this.scene.getObjectById(this.selected_geoms.get(ent_id));
        // remove Geom from scene
        if (removing && removing.hasOwnProperty('dispose')) {
            removing['dispose']();
        }
        this.scene.remove(removing);
        this.selected_geoms.delete(ent_id);
        // remove Geom from selected Objs Map
        this.scene_objs_selected.delete(ent_id);
        this.ObjLabelMap.delete(ent_id);
        if (document.getElementById(`textLabel_${ent_id}`)) {
            container.removeChild(document.getElementById(`textLabel_${ent_id}`));
        }
    }
    /**
     *
     * @param parent_ent_id
     * @param container
     * @param group
     */
    unselectObjGroup(parent_ent_id, container, group) {
        let removing;
        if (group === 'positions') {
            removing = this.selected_positions.get(parent_ent_id);
        }
        else if (group === 'vertex') {
            removing = this.selected_vertex.get(parent_ent_id);
        }
        else if (group === 'face_edges') {
            // get the removing first
            removing = this.selected_face_edges.get(parent_ent_id);
        }
        else if (group === 'face_wires') {
            removing = this.selected_face_wires.get(parent_ent_id);
        }
        // remove positions from scene
        removing.forEach((v, k) => {
            this.scene.remove(this.scene.getObjectById(v));
            this.ObjLabelMap.delete(k);
            if (document.getElementById(`textLabel_${k}`)) {
                container.removeChild(document.getElementById(`textLabel_${k}`));
            }
        });
        if (group === 'positions') {
            // then delete
            this.selected_positions.delete(parent_ent_id);
        }
        else if (group === 'vertex') {
            this.selected_vertex.delete(parent_ent_id);
        }
        else if (group === 'face_edges') {
            this.selected_face_edges.delete(parent_ent_id);
        }
        else if (group === 'face_wires') {
            this.selected_face_wires.delete(parent_ent_id);
        }
    }
    // ============================================================================
    // ============================================================================
    // Private methods
    // ============================================================================
    // ============================================================================
    /**
     *
     * @param positions
     * @param indices
     * @param colors
     */
    initBufferLine(positions, indices, colors) {
        const geom = new three__WEBPACK_IMPORTED_MODULE_0__["BufferGeometry"]();
        if (indices.length > 2) {
            geom.setIndex(indices);
        }
        else {
            geom.setIndex([0, 1]);
        }
        // geom.addAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        // geom.addAttribute('normal', new THREE.Float32BufferAttribute(Array(positions.length).fill(0), 3));
        geom.setAttribute('position', new three__WEBPACK_IMPORTED_MODULE_0__["Float32BufferAttribute"](positions, 3));
        geom.setAttribute('normal', new three__WEBPACK_IMPORTED_MODULE_0__["Float32BufferAttribute"](Array(positions.length).fill(0), 3));
        const rgb = `rgb(${colors.toString()})`;
        const mat = new three__WEBPACK_IMPORTED_MODULE_0__["LineBasicMaterial"]({
            color: new three__WEBPACK_IMPORTED_MODULE_0__["Color"](rgb),
            linewidth: 5,
            linecap: 'round',
            linejoin: 'round' // ignored by WebGLRenderer
        });
        const bg = { geom, mat };
        return bg;
    }
    /**
     *
     * @param positions
     * @param point_indices
     * @param colors
     * @param color
     * @param size
     */
    initBufferPoint(positions, point_indices = null, colors = null, color, size = 1) {
        // TODO check color and colors
        const geom = new three__WEBPACK_IMPORTED_MODULE_0__["BufferGeometry"]();
        if (point_indices) {
            geom.setIndex(point_indices);
        }
        // geom.addAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        geom.setAttribute('position', new three__WEBPACK_IMPORTED_MODULE_0__["Float32BufferAttribute"](positions, 3));
        const color_rgb = new three__WEBPACK_IMPORTED_MODULE_0__["Color"](parseInt(color.replace('#', '0x'), 16));
        if (colors) {
            // geom.addAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geom.setAttribute('color', new three__WEBPACK_IMPORTED_MODULE_0__["Float32BufferAttribute"](colors, 3));
        }
        else {
            let color_data;
            if (positions) {
                if (positions && positions.length < 3) {
                    color_data = [color_rgb.r, color_rgb.g, color_rgb.b];
                }
                else {
                    // @ts-ignore
                    color_data = Array(positions.length / 3).fill([color_rgb.r, color_rgb.g, color_rgb.b]).flat(1);
                }
            }
            const color_buffer = new Uint8Array(color_data);
            // geom.addAttribute('color', new THREE.BufferAttribute(color_buffer, 3, true));
            geom.setAttribute('color', new three__WEBPACK_IMPORTED_MODULE_0__["BufferAttribute"](color_buffer, 3, true));
        }
        geom.computeBoundingSphere();
        const mat = new three__WEBPACK_IMPORTED_MODULE_0__["PointsMaterial"]({
            color: color_rgb,
            size: size,
            sizeAttenuation: false
            // vertexColors: THREE.VertexColors
        });
        const bg = { geom, mat };
        return bg;
    }
    /**
     * Text labels
     * @param container
     * @param type
     * @param labelText
     * @param ent_id
     */
    _createTextLabel(container, type, labelText, ent_id) {
        const div = document.createElement('div');
        div.id = `textLabel_${ent_id}`;
        div.title = ent_id;
        div.setAttribute('data-index', ent_id.substr(2));
        div.className = `text-label${ent_id.substr(0, 2)}`;
        div.style.position = 'absolute';
        div.style.background = 'rgba(255, 255, 255, 0.3)';
        div.style.padding = '1px';
        div.style.pointerEvents = 'none';
        div.innerHTML = labelText;
        div.style.top = '-1000';
        div.style.left = '-1000';
        div.style.whiteSpace = 'pre-line';
        const _this = this;
        return {
            element: div,
            parent: false,
            position: new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](0, 0, 0),
            setHTML: function (html) {
                this.element.innerHTML = html;
            },
            setParent: function (threejsobj) {
                this.parent = threejsobj;
            },
            updatePosition: function () {
                if (this.parent) {
                    if (type === objType.point || type === objType.face) {
                        const center = this.parent.geometry.boundingSphere.center;
                        this.position.copy(center);
                    }
                    else if (type === objType.line) {
                        const p = this.parent.geometry.getAttribute('position').array;
                        const x = (p[0] + p[3]) / 2, y = (p[1] + p[4]) / 2, z = (p[2] + p[5]) / 2;
                        const center = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](x, y, z);
                        this.position.copy(center);
                    }
                }
                const coords2d = this.get2DCoords(this.position, _this.camera);
                this.element.style.left = coords2d.x - div.clientWidth * 0.5 + 'px';
                this.element.style.top = coords2d.y + 'px';
            },
            get2DCoords: function (position, camera) {
                const vector = position.project(camera);
                vector.x = (vector.x + 1) / 2 * container.offsetWidth;
                vector.y = -(vector.y - 1) / 2 * container.offsetHeight;
                return vector;
            }
        };
    }
}


/***/ }),

/***/ "./src/app/gi-viewer/gi-viewer.component.scss":
/*!****************************************************!*\
  !*** ./src/app/gi-viewer/gi-viewer.component.scss ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("#gi-viewer-container {\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n\n.mat-tab-group {\n  margin-bottom: 0px;\n}\n\nas-split-area {\n  position: relative;\n  overflow: hidden auto !important;\n}\n\n#settings_button {\n  outline: none;\n  width: 40px;\n  height: 30px;\n  font-size: 15px;\n  position: absolute;\n  top: 0px;\n  right: 0px;\n  text-align: center;\n  color: #808080;\n  background-color: transparent;\n  border: 0;\n  cursor: pointer;\n}\n\n#settings_button:hover {\n  color: #00006d;\n}\n\n#attrib {\n  overflow: hidden !important;\n}\n\n#attrib attribute {\n  height: calc(100% - 10px);\n  display: flex;\n  flex-flow: column nowrap;\n  justify-content: space-between;\n}\n\nmodal-window {\n  display: none;\n}\n\nmodal-window h1 {\n  font-size: 14px;\n  font-weight: 700;\n  line-height: 35px;\n}\n\nmodal-window dl {\n  margin: 20px 0;\n  padding: 0;\n  background-color: transparent;\n}\n\nmodal-window dl dd {\n  list-style: none;\n  padding: 8px 0;\n  margin-left: 20px;\n  background-color: inherit;\n  min-height: 12px;\n  box-sizing: content-box;\n  color: #373737;\n  font-size: 12px;\n  font-style: normal;\n}\n\nmodal-window dl dd .label {\n  float: left;\n  line-height: 15px;\n  width: 120px;\n}\n\nmodal-window dl dd .label + div {\n  float: left;\n}\n\nmodal-window dl dd .label, modal-window dl dd input {\n  color: #373737;\n  font-size: 12px;\n  font-style: normal;\n}\n\nmodal-window dl dd .label:hover, modal-window dl dd input:hover {\n  background-color: inherit;\n}\n\nmodal-window dl dd.colors hr {\n  margin: 20px 0px 0px;\n}\n\nmodal-window dl dd.colors .label {\n  line-height: 20px;\n}\n\nmodal-window dl dd.colors input {\n  padding-left: 5px;\n  margin-left: 0px !important;\n  border: 1px solid #E6E6E6;\n  width: 120px;\n  vertical-align: top;\n  text-transform: uppercase;\n}\n\nmodal-window dl dd.colors input.light {\n  color: #ffffff !important;\n}\n\nmodal-window .save {\n  cursor: pointer;\n  background: #00006d;\n  color: #ffffff;\n  height: 20px;\n}\n\nmodal-window .closebtn {\n  cursor: pointer;\n  background: white;\n  border: 1px solid #CCCCCC;\n  box-sizing: border-box;\n  margin-left: 10px;\n  height: 20px;\n}\n\nmodal-window .getbtn {\n  cursor: pointer;\n  background: white;\n  border: 1px solid #CCCCCC;\n  box-sizing: border-box;\n  margin-left: 10px;\n  height: 20px;\n  width: 50px;\n}\n\nbody.modal-open {\n  overflow: hidden;\n}\n\n#settings_modal {\n  /* The slider itself */\n  /* Mouse-over effects */\n  /* The slider handle (use -webkit- (Chrome, Opera, Safari, Edge) and -moz- (Firefox) to override default look) */\n}\n\n#settings_modal .filebtn.setting {\n  margin-top: 20px;\n}\n\n#settings_modal ::ng-deep .modal-window .modal-body {\n  background: #fafafb;\n}\n\n#settings_modal .onoffswitch {\n  position: relative;\n  width: 17px;\n  height: 6px;\n  top: 4px;\n  box-sizing: border-box;\n  vertical-align: middle;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n}\n\n#settings_modal .onoffswitch-checkbox {\n  display: none;\n}\n\n#settings_modal .onoffswitch-label {\n  display: block;\n  overflow: hidden;\n  height: inherit;\n  background-color: #dedede;\n  cursor: pointer;\n}\n\n#settings_modal .onoffswitch-switch {\n  position: absolute;\n  top: -4px;\n  left: 0px;\n  width: 3px;\n  height: 12px;\n  background: #ccc;\n  border: 1px solid #ccc;\n}\n\n#settings_modal .onoffswitch-checkbox:hover:not(:checked) + .onoffswitch-label {\n  background-color: rgba(0, 0, 109, 0.4);\n}\n\n#settings_modal .onoffswitch-checkbox:disabled + .onoffswitch-label {\n  background-color: #dedede !important;\n}\n\n#settings_modal .onoffswitch-checkbox:disabled + .onoffswitch-label .onoffswitch-switch {\n  box-shadow: none !important;\n}\n\n#settings_modal .onoffswitch-checkbox:checked + .onoffswitch-label {\n  background-color: #00006d;\n}\n\n#settings_modal .onoffswitch-checkbox:checked + .onoffswitch-label .onoffswitch-switch {\n  right: 0px;\n  left: calc(100% + 1px);\n  transform: translateX(-100%);\n}\n\n#settings_modal .onoffswitch-checkbox:disabled:checked + .onoffswitch-label .onoffswitch-inner,\n#settings_modal .onoffswitch-checkbox:disabled:checked + .onoffswitch-label .onoffswitch-switch {\n  cursor: help;\n}\n\n#settings_modal .slidecontainer {\n  width: 100%;\n  /* Width of the outside container */\n  height: 15px;\n}\n\n#settings_modal .slidecontainer:hover {\n  background-color: transparent;\n}\n\n#settings_modal .slidecontainer.light {\n  width: calc(100% - 120px);\n}\n\n#settings_modal .slidecontainer.light .slider {\n  margin-left: 0px !important;\n  width: calc(100% - 80px);\n}\n\n#settings_modal .slidecontainer.light .slider + input[type=text] {\n  margin-left: 15px !important;\n}\n\n#settings_modal .slider {\n  -webkit-appearance: none;\n  /* Override default CSS styles */\n  -moz-appearance: none;\n       appearance: none;\n  width: 210px;\n  max-width: 500px;\n  height: 15px;\n  /* Specified height */\n  background: whitesmoke;\n  /* Grey background */\n  box-sizing: border-box;\n  border: 2px solid #E6E6E6;\n  outline: none;\n  /* Remove outline */\n  opacity: 0.7;\n  /* Set transparency (for mouse-over effects on hover) */\n  /* 0.2 seconds transition on hover */\n  transition: opacity 0.2s;\n  margin: 0;\n  margin-left: 10px !important;\n}\n\n#settings_modal .slider:hover {\n  opacity: 1;\n  /* Fully shown on mouse-over */\n}\n\n#settings_modal .slider::-webkit-slider-thumb {\n  -webkit-appearance: none;\n  appearance: none;\n  width: 5px;\n  height: 15px;\n  background: #CCCCCC;\n  border: 1px solid #808080;\n  cursor: pointer;\n}\n\n#settings_modal .slider::-webkit-slider-thumb:hover, #settings_modal .slider::-webkit-slider-thumb:active {\n  background: #00006d;\n}\n\n#settings_modal .slider::-moz-range-thumb {\n  width: 5px;\n  height: 15px;\n  background: #CCCCCC;\n  cursor: pointer;\n}\n\n#settings_modal .slider:disabled::-webkit-slider-thumb {\n  background: white;\n}\n\n#settings_modal .slider:disabled::-moz-range-thumb {\n  background: white;\n}\n\n#settings_modal .slider:disabled {\n  cursor: help;\n}\n\n#settings_modal input + input {\n  vertical-align: top;\n  border: none;\n  line-height: 20px;\n  background: transparent;\n  width: 55px;\n  margin-left: 10px !important;\n  height: 14px;\n}\n\n#settings_modal .number {\n  width: 100px;\n  padding-left: 5px;\n  border: 1px solid #dddddd;\n}\n\n#settings_modal .light-shadow {\n  width: 120px;\n  float: left;\n}\n\n#settings_modal #camera input, #settings_modal #camera_target input, #settings_modal #grid_pos input {\n  width: 65px;\n  border: 1px solid #bdbdbd;\n  height: 16px;\n  margin-right: 3px;\n  text-align: right;\n  padding-right: 3px;\n}\n\n::ng-deep #settingsTab {\n  height: 100%;\n  width: 100%;\n  overflow-x: scroll;\n}\n\n::ng-deep #settingsTab ul {\n  background-color: transparent;\n  margin: 0;\n  padding-left: 0px;\n  white-space: nowrap;\n  width: 100%;\n  min-width: -webkit-fit-content;\n  min-width: -moz-fit-content;\n  min-width: fit-content;\n  display: inline-flex;\n}\n\n::ng-deep #settingsTab ul li {\n  list-style: none;\n  float: left;\n  min-width: 75px;\n  color: #808080;\n  overflow: visible;\n  cursor: pointer;\n  position: relative;\n  height: inherit;\n  padding: 0px;\n}\n\n::ng-deep #settingsTab ul li span {\n  font-family: sans-serif;\n  margin-right: 2px;\n  font-weight: 550;\n  font-size: 12px;\n  line-height: 15px;\n  border: 1px solid transparent;\n  position: relative;\n  display: block;\n  padding: 2px 7px;\n  text-align: center;\n  width: inherit;\n  box-sizing: border-box;\n  width: 100%;\n  margin-top: -1px;\n  height: 21px;\n}\n\n::ng-deep #settingsTab ul li:hover {\n  background-color: transparent;\n}\n\n::ng-deep #settingsTab ul li:hover span {\n  color: #00006d;\n  background-color: transparent;\n}\n\n::ng-deep #settingsTab ul li.active {\n  background-color: transparent;\n}\n\n::ng-deep #settingsTab ul li.active span {\n  color: #00006d;\n  cursor: default;\n  background-color: #fafafb;\n  border: 1px solid #B3B3B3;\n  border-bottom: 0px;\n}\n\n::ng-deep #settingsTab .pane {\n  margin-top: -1px;\n  border: 1px solid #B3B3B3;\n}\n\n::ng-deep #settingsTab .pane .mat-elevation-z1 {\n  display: flex;\n  flex-flow: column nowrap;\n  justify-content: space-between;\n  box-shadow: none;\n}\n\n::ng-deep #settingsTab hr {\n  border: 1px solid #dfdfdf;\n  background: #dfdfdf;\n}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9hcHAvZ2ktdmlld2VyL0M6XFxVc2Vyc1xcYWtpYmRwdFxcRG9jdW1lbnRzXFxBbmd1bGFyXFxtb2JpdXMtdmlld2VyL3NyY1xcYXBwXFxnaS12aWV3ZXJcXGdpLXZpZXdlci5jb21wb25lbnQuc2NzcyIsInNyYy9hcHAvZ2ktdmlld2VyL2dpLXZpZXdlci5jb21wb25lbnQuc2NzcyIsInNyYy9hcHAvZ2ktdmlld2VyL0M6XFxVc2Vyc1xcYWtpYmRwdFxcRG9jdW1lbnRzXFxBbmd1bGFyXFxtb2JpdXMtdmlld2VyL3NyY1xcc2Nzc1xcdmFyaWFibGVzLnNjc3MiLCJzcmMvYXBwL2dpLXZpZXdlci9DOlxcVXNlcnNcXGFraWJkcHRcXERvY3VtZW50c1xcQW5ndWxhclxcbW9iaXVzLXZpZXdlci9zcmNcXHNjc3NcXGNvbG9ycy5zY3NzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUdBO0VBRUksV0FBQTtFQUNBLFlBQUE7RUFFQSxnQkFBQTtBQ0pKOztBRE1BO0VBQ0ksa0JBQUE7QUNISjs7QURNQTtFQUNJLGtCQUFBO0VBQ0EsZ0NBQUE7QUNISjs7QURPQTtFQUNJLGFBQUE7RUFDQSxXQUFBO0VBQ0EsWUFBQTtFQUNBLGVFcEJLO0VGcUJMLGtCQUFBO0VBQ0EsUUFBQTtFQUNBLFVBQUE7RUFDQSxrQkFBQTtFQUNBLGNHNUJLO0VINkJMLDZCQUFBO0VBQ0EsU0FBQTtFQUNBLGVBQUE7QUNKSjs7QURLSTtFQUNJLGNHdEJTO0FGbUJqQjs7QURPQTtFQUNJLDJCQUFBO0FDSko7O0FES0k7RUFDSSx5QkFBQTtFQUNBLGFBQUE7RUFDQSx3QkFBQTtFQUNBLDhCQUFBO0FDSFI7O0FEUUE7RUFDSSxhQUFBO0FDTEo7O0FETUk7RUFDSSxlQUFBO0VBQ0EsZ0JBQUE7RUFDQSxpQkFBQTtBQ0pSOztBRE1JO0VBQ0ksY0FBQTtFQUNBLFVBQUE7RUFDQSw2QkFBQTtBQ0pSOztBREtRO0VBQ0ksZ0JBQUE7RUFDQSxjQUFBO0VBQ0EsaUJBQUE7RUFDQSx5QkFBQTtFQUVBLGdCQUFBO0VBQ0EsdUJBQUE7RUFDQSxjRzFESDtFSDJERyxlRWhFSDtFRmlFRyxrQkFBQTtBQ0paOztBREtZO0VBQ0ksV0FBQTtFQUNBLGlCQUFBO0VBQ0EsWUFBQTtBQ0hoQjs7QURLWTtFQUNJLFdBQUE7QUNIaEI7O0FES1k7RUFDSSxjR3RFUDtFSHVFTyxlRTVFUDtFRjZFTyxrQkFBQTtBQ0hoQjs7QURJZ0I7RUFDSSx5QkFBQTtBQ0ZwQjs7QURNZ0I7RUFDSSxvQkFBQTtBQ0pwQjs7QURNZ0I7RUFDSSxpQkFBQTtBQ0pwQjs7QURNZ0I7RUFDSSxpQkFBQTtFQUNBLDJCQUFBO0VBQ0EseUJBQUE7RUFDQSxZQUFBO0VBQ0EsbUJBQUE7RUFDQSx5QkFBQTtBQ0pwQjs7QURLb0I7RUFDSSx5QkFBQTtBQ0h4Qjs7QURTSTtFQUNJLGVBQUE7RUFDQSxtQkdsR1M7RUhtR1QsY0FBQTtFQUNBLFlBQUE7QUNQUjs7QURTSTtFQUNJLGVBQUE7RUFDQSxpQkczR0M7RUg0R0QseUJBQUE7RUFDQSxzQkFBQTtFQUNBLGlCQUFBO0VBQ0EsWUFBQTtBQ1BSOztBRDBCSTtFQUNJLGVBQUE7RUFDQSxpQkdwSUM7RUhxSUQseUJBQUE7RUFDQSxzQkFBQTtFQUNBLGlCQUFBO0VBQ0EsWUFBQTtFQUNBLFdBQUE7QUN4QlI7O0FENEJBO0VBQ0ksZ0JBQUE7QUN6Qko7O0FENkJBO0VBd0ZJLHNCQUFBO0VBa0JBLHVCQUFBO0VBS0EsZ0hBQUE7QUN0SUo7O0FEd0JJO0VBQ0ksZ0JBQUE7QUN0QlI7O0FEd0JJO0VBQ0ksbUJHekpDO0FGbUlUOztBRHlCSTtFQUNJLGtCQUFBO0VBQ0EsV0FBQTtFQUNBLFdBQUE7RUFDQSxRQUFBO0VBQ0Esc0JBQUE7RUFDQSxzQkFBQTtFQUNBLHlCQUFBO0VBQTBCLHNCQUFBO0VBQXVCLHFCQUFBO0FDckJ6RDs7QUR1Qkk7RUFDSSxhQUFBO0FDckJSOztBRHVCSTtFQUNJLGNBQUE7RUFDQSxnQkFBQTtFQUNBLGVBQUE7RUFDQSx5QkFBQTtFQUNBLGVBQUE7QUNyQlI7O0FEd0JJO0VBQ0ksa0JBQUE7RUFDQSxTQUFBO0VBQ0EsU0FBQTtFQUNBLFVBQUE7RUFDQSxZQUFBO0VBQ0EsZ0JBQUE7RUFDQSxzQkFBQTtBQ3RCUjs7QUQwQkk7RUFDSSxzQ0FBQTtBQ3hCUjs7QUQ4Qkk7RUFDSSxvQ0FBQTtBQzVCUjs7QUQ2QlE7RUFDSSwyQkFBQTtBQzNCWjs7QUQrQkk7RUFDSSx5QkdyTVM7QUZ3S2pCOztBRDhCUTtFQUNJLFVBQUE7RUFFQSxzQkFBQTtFQUNBLDRCQUFBO0FDN0JaOztBRGlDSTs7RUFFSSxZQUFBO0FDL0JSOztBRG9DSTtFQUNJLFdBQUE7RUFBYSxtQ0FBQTtFQUNiLFlFL05DO0FEOExUOztBRGtDUTtFQUNJLDZCQUFBO0FDaENaOztBRGtDUTtFQUNJLHlCQUFBO0FDaENaOztBRGlDWTtFQUNJLDJCQUFBO0VBQ0Esd0JBQUE7QUMvQmhCOztBRGlDWTtFQUNJLDRCQUFBO0FDL0JoQjs7QURxQ0k7RUFDSSx3QkFBQTtFQUEyQixnQ0FBQTtFQUMzQixxQkFBQTtPQUFBLGdCQUFBO0VBQ0EsWUFBQTtFQUNBLGdCQUFBO0VBQ0EsWUVyUEM7RUZxUGdCLHFCQUFBO0VBQ2pCLHNCR3BQRztFSG9Qb0Isb0JBQUE7RUFDdkIsc0JBQUE7RUFDQSx5QkFBQTtFQUNBLGFBQUE7RUFBZSxtQkFBQTtFQUNmLFlBQUE7RUFBYyx1REFBQTtFQUNXLG9DQUFBO0VBQ3pCLHdCQUFBO0VBQ0EsU0FBQTtFQUNBLDRCQUFBO0FDN0JSOztBRGlDSTtFQUNJLFVBQUE7RUFBWSw4QkFBQTtBQzlCcEI7O0FEa0NJO0VBQ0ksd0JBQUE7RUFDQSxnQkFBQTtFQUNBLFVBQUE7RUFDQSxZRTNRQztFRjRRRCxtQkc1UUM7RUg2UUQseUJBQUE7RUFDQSxlQUFBO0FDaENSOztBRGlDUTtFQUNJLG1CR3hRSztBRnlPakI7O0FEbUNJO0VBQ0ksVUFBQTtFQUNBLFlFdFJDO0VGdVJELG1CR3ZSQztFSHdSRCxlQUFBO0FDakNSOztBRG1DSTtFQUNJLGlCR3RSQztBRnFQVDs7QURvQ0k7RUFDSSxpQkcxUkM7QUZ3UFQ7O0FEcUNJO0VBQ0ksWUFBQTtBQ25DUjs7QURzQ0k7RUFDSSxtQkFBQTtFQUNBLFlBQUE7RUFDQSxpQkFBQTtFQUNBLHVCQUFBO0VBQ0EsV0FBQTtFQUNBLDRCQUFBO0VBQ0EsWUFBQTtBQ3BDUjs7QUR1Q0k7RUFDSSxZQUFBO0VBQ0EsaUJBQUE7RUFDQSx5QkFBQTtBQ3JDUjs7QUR1Q0k7RUFDSSxZQUFBO0VBQ0EsV0FBQTtBQ3JDUjs7QUR5Q1E7RUFDSSxXQUFBO0VBQ0EseUJBQUE7RUFDQSxZQUFBO0VBQ0EsaUJBQUE7RUFDQSxpQkFBQTtFQUNBLGtCQUFBO0FDdkNaOztBRDRDQTtFQUNJLFlBQUE7RUFDQSxXQUFBO0VBQ0Esa0JBQUE7QUN6Q0o7O0FEMkNJO0VBQ0UsNkJBQUE7RUFDQSxTQUFBO0VBQ0EsaUJBQUE7RUFFQSxtQkFBQTtFQUNBLFdBQUE7RUFDQSw4QkFBQTtFQUFBLDJCQUFBO0VBQUEsc0JBQUE7RUFDQSxvQkFBQTtBQzFDTjs7QUQyQ007RUFDRSxnQkFBQTtFQUVBLFdBQUE7RUFDQSxlQUFBO0VBQ0EsY0c1VkM7RUg2VkQsaUJBQUE7RUFDQSxlQUFBO0VBQ0Esa0JBQUE7RUFDQSxlQUFBO0VBQ0EsWUFBQTtBQzFDUjs7QUQyQ1E7RUFDSSx1QkFBQTtFQUNBLGlCQUFBO0VBQ0EsZ0JBQUE7RUFDQSxlRWxXSDtFRm1XRyxpQkVwV0g7RUZxV0csNkJBQUE7RUFDQSxrQkFBQTtFQUNBLGNBQUE7RUFDQSxnQkFBQTtFQUNBLGtCQUFBO0VBQ0EsY0FBQTtFQUNBLHNCQUFBO0VBQ0EsV0FBQTtFQUNBLGdCQUFBO0VBQ0EsWUFBQTtBQ3pDWjs7QUQyQ1E7RUFDSSw2QkFBQTtBQ3pDWjs7QUQwQ1k7RUFDSSxjRzNXQztFSDRXRCw2QkFBQTtBQ3hDaEI7O0FEMkNRO0VBQ0UsNkJBQUE7QUN6Q1Y7O0FEMENVO0VBQ0UsY0dsWEs7RUhtWEwsZUFBQTtFQUNBLHlCQUFBO0VBQ0EseUJBQUE7RUFDQSxrQkFBQTtBQ3hDWjs7QUQ4Q0k7RUFDRSxnQkFBQTtFQUNBLHlCQUFBO0FDNUNOOztBRDhDTTtFQUNFLGFBQUE7RUFDQSx3QkFBQTtFQUVBLDhCQUFBO0VBQ0EsZ0JBQUE7QUM3Q1I7O0FEaURJO0VBQ0kseUJBQUE7RUFDQSxtQkFBQTtBQy9DUiIsImZpbGUiOiJzcmMvYXBwL2dpLXZpZXdlci9naS12aWV3ZXIuY29tcG9uZW50LnNjc3MiLCJzb3VyY2VzQ29udGVudCI6WyJAaW1wb3J0ICd+c2Nzcy9jb2xvcnMnO1xyXG5AaW1wb3J0ICd+c2Nzcy92YXJpYWJsZXMnO1xyXG5cclxuI2dpLXZpZXdlci1jb250YWluZXIge1xyXG4gICAgLy8gcG9zaXRpb246IGFic29sdXRlO1xyXG4gICAgd2lkdGg6IDEwMCU7XHJcbiAgICBoZWlnaHQ6IDEwMCU7XHJcbiAgICAvLyBiYWNrZ3JvdW5kLWNvbG9yOiB5ZWxsb3c7XHJcbiAgICBvdmVyZmxvdzpoaWRkZW47XHJcbn1cclxuLm1hdC10YWItZ3JvdXAge1xyXG4gICAgbWFyZ2luLWJvdHRvbTogMHB4O1xyXG59XHJcblxyXG5hcy1zcGxpdC1hcmVhe1xyXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xyXG4gICAgb3ZlcmZsb3c6IGhpZGRlbiBhdXRvICFpbXBvcnRhbnQ7XHJcbn1cclxuXHJcblxyXG4jc2V0dGluZ3NfYnV0dG9ue1xyXG4gICAgb3V0bGluZTogbm9uZTtcclxuICAgIHdpZHRoOiA0MHB4O1xyXG4gICAgaGVpZ2h0OiAzMHB4O1xyXG4gICAgZm9udC1zaXplOiRmc2l6ZTE7XHJcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XHJcbiAgICB0b3A6MHB4O1xyXG4gICAgcmlnaHQ6MHB4OyBcclxuICAgIHRleHQtYWxpZ246Y2VudGVyO1xyXG4gICAgY29sb3I6ICRjb2xvcjE7XHJcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOnRyYW5zcGFyZW50O1xyXG4gICAgYm9yZGVyOjA7XHJcbiAgICBjdXJzb3I6IHBvaW50ZXI7XHJcbiAgICAmOmhvdmVyIHtcclxuICAgICAgICBjb2xvcjokc2VsZWN0ZWQtY29sb3I7XHJcbiAgICB9XHJcbn1cclxuXHJcbiNhdHRyaWJ7XHJcbiAgICBvdmVyZmxvdzogaGlkZGVuICFpbXBvcnRhbnQ7XHJcbiAgICBhdHRyaWJ1dGV7XHJcbiAgICAgICAgaGVpZ2h0OiBjYWxjKDEwMCUgLSAxMHB4KTtcclxuICAgICAgICBkaXNwbGF5OiBmbGV4O1xyXG4gICAgICAgIGZsZXgtZmxvdzogY29sdW1uIG5vd3JhcDtcclxuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5tb2RhbC13aW5kb3cge1xyXG4gICAgZGlzcGxheTogbm9uZTtcclxuICAgIGgxe1xyXG4gICAgICAgIGZvbnQtc2l6ZTogMTRweDtcclxuICAgICAgICBmb250LXdlaWdodDogNzAwO1xyXG4gICAgICAgIGxpbmUtaGVpZ2h0OiAzNXB4O1xyXG4gICAgfVxyXG4gICAgZGx7XHJcbiAgICAgICAgbWFyZ2luOiAyMHB4IDA7XHJcbiAgICAgICAgcGFkZGluZzogMDtcclxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcclxuICAgICAgICBkZHtcclxuICAgICAgICAgICAgbGlzdC1zdHlsZTogbm9uZTtcclxuICAgICAgICAgICAgcGFkZGluZzogOHB4IDA7XHJcbiAgICAgICAgICAgIG1hcmdpbi1sZWZ0OiAyMHB4O1xyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiBpbmhlcml0O1xyXG4gICAgICAgICAgICAvLyBoZWlnaHQ6ICRmc2l6ZTE7XHJcbiAgICAgICAgICAgIG1pbi1oZWlnaHQ6IDEycHg7XHJcbiAgICAgICAgICAgIGJveC1zaXppbmc6IGNvbnRlbnQtYm94O1xyXG4gICAgICAgICAgICBjb2xvcjogJGNvbG9yODtcclxuICAgICAgICAgICAgZm9udC1zaXplOiAkZnNpemUyO1xyXG4gICAgICAgICAgICBmb250LXN0eWxlOiBub3JtYWw7XHJcbiAgICAgICAgICAgIC5sYWJlbHtcclxuICAgICAgICAgICAgICAgIGZsb2F0OiBsZWZ0O1xyXG4gICAgICAgICAgICAgICAgbGluZS1oZWlnaHQ6IDE1cHg7XHJcbiAgICAgICAgICAgICAgICB3aWR0aDogMTIwcHg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLmxhYmVsICsgZGl2e1xyXG4gICAgICAgICAgICAgICAgZmxvYXQ6IGxlZnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLmxhYmVsLCBpbnB1dHtcclxuICAgICAgICAgICAgICAgIGNvbG9yOiAkY29sb3I4O1xyXG4gICAgICAgICAgICAgICAgZm9udC1zaXplOiAkZnNpemUyO1xyXG4gICAgICAgICAgICAgICAgZm9udC1zdHlsZTogbm9ybWFsO1xyXG4gICAgICAgICAgICAgICAgJjpob3ZlcntcclxuICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiBpbmhlcml0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICYuY29sb3Jze1xyXG4gICAgICAgICAgICAgICAgaHJ7XHJcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luOiAyMHB4IDBweCAwcHg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAubGFiZWx7XHJcbiAgICAgICAgICAgICAgICAgICAgbGluZS1oZWlnaHQ6IDIwcHg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpbnB1dHtcclxuICAgICAgICAgICAgICAgICAgICBwYWRkaW5nLWxlZnQ6NXB4O1xyXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbi1sZWZ0OiAwcHggIWltcG9ydGFudDtcclxuICAgICAgICAgICAgICAgICAgICBib3JkZXI6MXB4IHNvbGlkICNFNkU2RTY7XHJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDEyMHB4O1xyXG4gICAgICAgICAgICAgICAgICAgIHZlcnRpY2FsLWFsaWduOiB0b3A7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dC10cmFuc2Zvcm06IHVwcGVyY2FzZTtcclxuICAgICAgICAgICAgICAgICAgICAmLmxpZ2h0e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogI2ZmZmZmZiAhaW1wb3J0YW50O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC5zYXZlIHtcclxuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XHJcbiAgICAgICAgYmFja2dyb3VuZDogJHNlbGVjdGVkLWNvbG9yO1xyXG4gICAgICAgIGNvbG9yOiAjZmZmZmZmO1xyXG4gICAgICAgIGhlaWdodDogMjBweDtcclxuICAgIH1cclxuICAgIC5jbG9zZWJ0bntcclxuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XHJcbiAgICAgICAgYmFja2dyb3VuZDogJGNvbG9yNztcclxuICAgICAgICBib3JkZXI6IDFweCBzb2xpZCAkY29sb3I0O1xyXG4gICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XHJcbiAgICAgICAgbWFyZ2luLWxlZnQ6IDEwcHg7XHJcbiAgICAgICAgaGVpZ2h0OiAyMHB4O1xyXG4gICAgICAgIC8vIHBhZGRpbmc6IDNweCAxMHB4O1xyXG4gICAgICAgIC8vIGN1cnNvcjogcG9pbnRlcjtcclxuICAgICAgICAvLyBtYXJnaW4tcmlnaHQ6IDEwcHg7XHJcbiAgICAgICAgLy8gd2lkdGg6IDc1cHg7XHJcbiAgICAgICAgLy8gZm9udC1zaXplOiAkZnNpemUyO1xyXG4gICAgICAgIC8vICYucHJpbWFyeXtcclxuICAgICAgICAvLyAgICAgYmFja2dyb3VuZDogJHNlbGVjdGVkLWNvbG9yO1xyXG4gICAgICAgIC8vICAgICBib3JkZXItY29sb3I6ICRzZWxlY3RlZC1jb2xvcjtcclxuICAgICAgICAvLyAgICAgY29sb3I6IHdoaXRlO1xyXG4gICAgICAgIC8vICAgICAmOmhvdmVye1xyXG4gICAgICAgIC8vICAgICAgICAgYmFja2dyb3VuZDogcmdiYSgkc2VsZWN0ZWQtY29sb3IsMC43NSk7XHJcbiAgICAgICAgLy8gICAgIH1cclxuICAgICAgICAvLyB9XHJcbiAgICAgICAgLy8gJjpmb2N1c3tcclxuICAgICAgICAvLyAgICAgb3V0bGluZTogbm9uZTtcclxuICAgICAgICAvLyB9XHJcbiAgICB9XHJcblxyXG4gICAgLmdldGJ0bntcclxuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XHJcbiAgICAgICAgYmFja2dyb3VuZDogJGNvbG9yNztcclxuICAgICAgICBib3JkZXI6IDFweCBzb2xpZCAkY29sb3I0O1xyXG4gICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XHJcbiAgICAgICAgbWFyZ2luLWxlZnQ6IDEwcHg7XHJcbiAgICAgICAgaGVpZ2h0OiAyMHB4O1xyXG4gICAgICAgIHdpZHRoOiA1MHB4O1xyXG4gICAgfVxyXG59XHJcblxyXG5ib2R5Lm1vZGFsLW9wZW4ge1xyXG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcclxufVxyXG5cclxuXHJcbiNzZXR0aW5nc19tb2RhbHtcclxuICAgIC5maWxlYnRuLnNldHRpbmd7XHJcbiAgICAgICAgbWFyZ2luLXRvcDogMjBweDtcclxuICAgIH1cclxuICAgIDo6bmctZGVlcCAubW9kYWwtd2luZG93IC5tb2RhbC1ib2R5e1xyXG4gICAgICAgIGJhY2tncm91bmQ6ICRjb2xvcjY7XHJcbiAgICB9XHJcblxyXG4gICAgLm9ub2Zmc3dpdGNoIHtcclxuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7IFxyXG4gICAgICAgIHdpZHRoOiAxN3B4O1xyXG4gICAgICAgIGhlaWdodDogNnB4O1xyXG4gICAgICAgIHRvcDogNHB4O1xyXG4gICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XHJcbiAgICAgICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcclxuICAgICAgICAtd2Via2l0LXVzZXItc2VsZWN0Om5vbmU7IC1tb3otdXNlci1zZWxlY3Q6bm9uZTsgLW1zLXVzZXItc2VsZWN0OiBub25lO1xyXG4gICAgfVxyXG4gICAgLm9ub2Zmc3dpdGNoLWNoZWNrYm94IHtcclxuICAgICAgICBkaXNwbGF5OiBub25lO1xyXG4gICAgfVxyXG4gICAgLm9ub2Zmc3dpdGNoLWxhYmVsIHtcclxuICAgICAgICBkaXNwbGF5OiBibG9jaztcclxuICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xyXG4gICAgICAgIGhlaWdodDogaW5oZXJpdDtcclxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZGVkZWRlO1xyXG4gICAgICAgIGN1cnNvcjogcG9pbnRlcjtcclxuICAgIH1cclxuXHJcbiAgICAub25vZmZzd2l0Y2gtc3dpdGNoIHtcclxuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XHJcbiAgICAgICAgdG9wOiAtNHB4O1xyXG4gICAgICAgIGxlZnQ6IDBweDtcclxuICAgICAgICB3aWR0aDogM3B4O1xyXG4gICAgICAgIGhlaWdodDogMTJweDtcclxuICAgICAgICBiYWNrZ3JvdW5kOiAjY2NjO1xyXG4gICAgICAgIGJvcmRlcjogMXB4IHNvbGlkICNjY2M7XHJcbiAgICB9XHJcblxyXG4gICAgXHJcbiAgICAub25vZmZzd2l0Y2gtY2hlY2tib3g6aG92ZXI6bm90KDpjaGVja2VkKSArIC5vbm9mZnN3aXRjaC1sYWJlbHtcclxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKCRzZWxlY3RlZC1jb2xvciwgMC40KTtcclxuICAgICAgICAub25vZmZzd2l0Y2gtc3dpdGNoe1xyXG4gICAgICAgICAgICAvLyBib3gtc2hhZG93OiAycHggMHB4IDBweCAwcHg7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC5vbm9mZnN3aXRjaC1jaGVja2JveDpkaXNhYmxlZCArIC5vbm9mZnN3aXRjaC1sYWJlbHtcclxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZGVkZWRlICFpbXBvcnRhbnQ7XHJcbiAgICAgICAgLm9ub2Zmc3dpdGNoLXN3aXRjaHtcclxuICAgICAgICAgICAgYm94LXNoYWRvdzogbm9uZSAhaW1wb3J0YW50O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAub25vZmZzd2l0Y2gtY2hlY2tib3g6Y2hlY2tlZCArIC5vbm9mZnN3aXRjaC1sYWJlbHtcclxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkc2VsZWN0ZWQtY29sb3I7IFxyXG4gICAgICAgIC5vbm9mZnN3aXRjaC1zd2l0Y2gge1xyXG4gICAgICAgICAgICByaWdodDogMHB4OyBcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGxlZnQ6IGNhbGMoMTAwJSArIDFweCk7XHJcbiAgICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgtMTAwJSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC5vbm9mZnN3aXRjaC1jaGVja2JveDpkaXNhYmxlZDpjaGVja2VkICsgLm9ub2Zmc3dpdGNoLWxhYmVsIC5vbm9mZnN3aXRjaC1pbm5lcixcclxuICAgIC5vbm9mZnN3aXRjaC1jaGVja2JveDpkaXNhYmxlZDpjaGVja2VkICsgLm9ub2Zmc3dpdGNoLWxhYmVsIC5vbm9mZnN3aXRjaC1zd2l0Y2h7XHJcbiAgICAgICAgY3Vyc29yOiBoZWxwO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyBHcmlkIFNpemUgU2xpZGVyXHJcbiAgICAuc2xpZGVjb250YWluZXIge1xyXG4gICAgICAgIHdpZHRoOiAxMDAlOyAvKiBXaWR0aCBvZiB0aGUgb3V0c2lkZSBjb250YWluZXIgKi9cclxuICAgICAgICBoZWlnaHQ6ICRmc2l6ZTE7XHJcbiAgICAgICAgJjpob3ZlcntcclxuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7ICBcclxuICAgICAgICB9XHJcbiAgICAgICAgJi5saWdodHtcclxuICAgICAgICAgICAgd2lkdGg6IGNhbGMoMTAwJSAtIDEyMHB4KTtcclxuICAgICAgICAgICAgLnNsaWRlcntcclxuICAgICAgICAgICAgICAgIG1hcmdpbi1sZWZ0OiAwcHggIWltcG9ydGFudDtcclxuICAgICAgICAgICAgICAgIHdpZHRoOiBjYWxjKDEwMCUgLSA4MHB4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAuc2xpZGVyICsgaW5wdXRbdHlwZT0ndGV4dCdde1xyXG4gICAgICAgICAgICAgICAgbWFyZ2luLWxlZnQ6IDE1cHggIWltcG9ydGFudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgICAgXHJcbiAgICAvKiBUaGUgc2xpZGVyIGl0c2VsZiAqL1xyXG4gICAgLnNsaWRlciB7XHJcbiAgICAgICAgLXdlYmtpdC1hcHBlYXJhbmNlOiBub25lOyAgLyogT3ZlcnJpZGUgZGVmYXVsdCBDU1Mgc3R5bGVzICovXHJcbiAgICAgICAgYXBwZWFyYW5jZTogbm9uZTtcclxuICAgICAgICB3aWR0aDogMjEwcHg7XHJcbiAgICAgICAgbWF4LXdpZHRoOiA1MDBweDtcclxuICAgICAgICBoZWlnaHQ6ICRmc2l6ZTE7IC8qIFNwZWNpZmllZCBoZWlnaHQgKi9cclxuICAgICAgICBiYWNrZ3JvdW5kOiAkY29sb3I1LTU7IC8qIEdyZXkgYmFja2dyb3VuZCAqL1xyXG4gICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XHJcbiAgICAgICAgYm9yZGVyOiAycHggc29saWQgJGNvbG9yNTtcclxuICAgICAgICBvdXRsaW5lOiBub25lOyAvKiBSZW1vdmUgb3V0bGluZSAqL1xyXG4gICAgICAgIG9wYWNpdHk6IDAuNzsgLyogU2V0IHRyYW5zcGFyZW5jeSAoZm9yIG1vdXNlLW92ZXIgZWZmZWN0cyBvbiBob3ZlcikgKi9cclxuICAgICAgICAtd2Via2l0LXRyYW5zaXRpb246IC4yczsgLyogMC4yIHNlY29uZHMgdHJhbnNpdGlvbiBvbiBob3ZlciAqL1xyXG4gICAgICAgIHRyYW5zaXRpb246IG9wYWNpdHkgLjJzO1xyXG4gICAgICAgIG1hcmdpbjogMDtcclxuICAgICAgICBtYXJnaW4tbGVmdDogMTBweCAhaW1wb3J0YW50O1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvKiBNb3VzZS1vdmVyIGVmZmVjdHMgKi9cclxuICAgIC5zbGlkZXI6aG92ZXIge1xyXG4gICAgICAgIG9wYWNpdHk6IDE7IC8qIEZ1bGx5IHNob3duIG9uIG1vdXNlLW92ZXIgKi9cclxuICAgIH1cclxuICAgIFxyXG4gICAgLyogVGhlIHNsaWRlciBoYW5kbGUgKHVzZSAtd2Via2l0LSAoQ2hyb21lLCBPcGVyYSwgU2FmYXJpLCBFZGdlKSBhbmQgLW1vei0gKEZpcmVmb3gpIHRvIG92ZXJyaWRlIGRlZmF1bHQgbG9vaykgKi8gXHJcbiAgICAuc2xpZGVyOjotd2Via2l0LXNsaWRlci10aHVtYiB7XHJcbiAgICAgICAgLXdlYmtpdC1hcHBlYXJhbmNlOiBub25lOyBcclxuICAgICAgICBhcHBlYXJhbmNlOiBub25lO1xyXG4gICAgICAgIHdpZHRoOiA1cHg7IFxyXG4gICAgICAgIGhlaWdodDogJGZzaXplMTsgXHJcbiAgICAgICAgYmFja2dyb3VuZDogJGNvbG9yNDsgXHJcbiAgICAgICAgYm9yZGVyOiAxcHggc29saWQgJGNvbG9yMTtcclxuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7IFxyXG4gICAgICAgICY6aG92ZXIsICY6YWN0aXZle1xyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kOiAkc2VsZWN0ZWQtY29sb3I7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICAuc2xpZGVyOjotbW96LXJhbmdlLXRodW1iIHtcclxuICAgICAgICB3aWR0aDogNXB4OyBcclxuICAgICAgICBoZWlnaHQ6ICRmc2l6ZTE7IFxyXG4gICAgICAgIGJhY2tncm91bmQ6ICRjb2xvcjQ7IFxyXG4gICAgICAgIGN1cnNvcjogcG9pbnRlcjtcclxuICAgIH1cclxuICAgIC5zbGlkZXI6ZGlzYWJsZWQ6Oi13ZWJraXQtc2xpZGVyLXRodW1iIHtcclxuICAgICAgICBiYWNrZ3JvdW5kOiAkY29sb3I3O1xyXG4gICAgfVxyXG5cclxuICAgIC5zbGlkZXI6ZGlzYWJsZWQ6Oi1tb3otcmFuZ2UtdGh1bWIge1xyXG4gICAgICAgIGJhY2tncm91bmQ6ICRjb2xvcjc7IFxyXG4gICAgfVxyXG5cclxuICAgIC5zbGlkZXI6ZGlzYWJsZWR7XHJcbiAgICAgICAgY3Vyc29yOiBoZWxwO1xyXG4gICAgfVxyXG5cclxuICAgIGlucHV0ICsgaW5wdXR7XHJcbiAgICAgICAgdmVydGljYWwtYWxpZ246IHRvcDtcclxuICAgICAgICBib3JkZXI6IG5vbmU7XHJcbiAgICAgICAgbGluZS1oZWlnaHQ6IDIwcHg7XHJcbiAgICAgICAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XHJcbiAgICAgICAgd2lkdGg6IDU1cHg7XHJcbiAgICAgICAgbWFyZ2luLWxlZnQ6IDEwcHggIWltcG9ydGFudDtcclxuICAgICAgICBoZWlnaHQ6IDE0cHg7XHJcbiAgICB9XHJcblxyXG4gICAgLm51bWJlcntcclxuICAgICAgICB3aWR0aDogMTAwcHg7XHJcbiAgICAgICAgcGFkZGluZy1sZWZ0OiA1cHg7XHJcbiAgICAgICAgYm9yZGVyOjFweCBzb2xpZCAjZGRkZGRkO1xyXG4gICAgfVxyXG4gICAgLmxpZ2h0LXNoYWRvd3tcclxuICAgICAgICB3aWR0aDogMTIwcHg7XHJcbiAgICAgICAgZmxvYXQ6IGxlZnQ7XHJcbiAgICB9XHJcblxyXG4gICAgI2NhbWVyYSwgI2NhbWVyYV90YXJnZXQsICNncmlkX3Bvc3tcclxuICAgICAgICBpbnB1dHtcclxuICAgICAgICAgICAgd2lkdGg6IDY1cHg7XHJcbiAgICAgICAgICAgIGJvcmRlcjogMXB4IHNvbGlkICNiZGJkYmQ7XHJcbiAgICAgICAgICAgIGhlaWdodDogMTZweDtcclxuICAgICAgICAgICAgbWFyZ2luLXJpZ2h0OiAzcHg7XHJcbiAgICAgICAgICAgIHRleHQtYWxpZ246IHJpZ2h0O1xyXG4gICAgICAgICAgICBwYWRkaW5nLXJpZ2h0OiAzcHhcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbjo6bmctZGVlcCAjc2V0dGluZ3NUYWJ7XHJcbiAgICBoZWlnaHQ6IDEwMCU7XHJcbiAgICB3aWR0aDogMTAwJTtcclxuICAgIG92ZXJmbG93LXg6IHNjcm9sbDtcclxuICAgIFxyXG4gICAgdWx7XHJcbiAgICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xyXG4gICAgICBtYXJnaW46IDA7XHJcbiAgICAgIHBhZGRpbmctbGVmdDogMHB4O1xyXG4gICAgICAvLyBib3JkZXItYm90dG9tOiAxcHggc29saWQgJGNvbG9yMztcclxuICAgICAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcclxuICAgICAgd2lkdGg6IDEwMCU7XHJcbiAgICAgIG1pbi13aWR0aDogZml0LWNvbnRlbnQ7XHJcbiAgICAgIGRpc3BsYXk6IGlubGluZS1mbGV4O1xyXG4gICAgICBsaXtcclxuICAgICAgICBsaXN0LXN0eWxlOiBub25lO1xyXG4gICAgICAgIC8vIGRpc3BsYXk6IGlubGluZS1ibG9jaztcclxuICAgICAgICBmbG9hdDogbGVmdDtcclxuICAgICAgICBtaW4td2lkdGg6IDc1cHg7XHJcbiAgICAgICAgY29sb3I6ICRjb2xvcjE7XHJcbiAgICAgICAgb3ZlcmZsb3c6dmlzaWJsZTtcclxuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XHJcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xyXG4gICAgICAgIGhlaWdodDogaW5oZXJpdDtcclxuICAgICAgICBwYWRkaW5nOiAwcHg7XHJcbiAgICAgICAgc3BhbntcclxuICAgICAgICAgICAgZm9udC1mYW1pbHk6IHNhbnMtc2VyaWY7XHJcbiAgICAgICAgICAgIG1hcmdpbi1yaWdodDogMnB4O1xyXG4gICAgICAgICAgICBmb250LXdlaWdodDogNTUwO1xyXG4gICAgICAgICAgICBmb250LXNpemU6ICRmc2l6ZTI7XHJcbiAgICAgICAgICAgIGxpbmUtaGVpZ2h0OiAkZnNpemUxO1xyXG4gICAgICAgICAgICBib3JkZXI6IDFweCBzb2xpZCB0cmFuc3BhcmVudDtcclxuICAgICAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xyXG4gICAgICAgICAgICBkaXNwbGF5OiBibG9jaztcclxuICAgICAgICAgICAgcGFkZGluZzogMnB4IDdweDtcclxuICAgICAgICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xyXG4gICAgICAgICAgICB3aWR0aDogaW5oZXJpdDtcclxuICAgICAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcclxuICAgICAgICAgICAgd2lkdGg6IDEwMCU7XHJcbiAgICAgICAgICAgIG1hcmdpbi10b3A6IC0xcHg7XHJcbiAgICAgICAgICAgIGhlaWdodDogMjFweDtcclxuICAgICAgICB9XHJcbiAgICAgICAgJjpob3ZlcntcclxuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XHJcbiAgICAgICAgICAgIHNwYW57XHJcbiAgICAgICAgICAgICAgICBjb2xvcjogJHNlbGVjdGVkLWNvbG9yO1xyXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgJi5hY3RpdmV7XHJcbiAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcclxuICAgICAgICAgIHNwYW57XHJcbiAgICAgICAgICAgIGNvbG9yOiAkc2VsZWN0ZWQtY29sb3I7XHJcbiAgICAgICAgICAgIGN1cnNvcjogZGVmYXVsdDtcclxuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2ZhZmFmYjtcclxuICAgICAgICAgICAgYm9yZGVyOiAxcHggc29saWQgJGNvbG9yMztcclxuICAgICAgICAgICAgYm9yZGVyLWJvdHRvbTogMHB4O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gY29udGFpbnMgZXZlcnl0aGluZ1xyXG4gICAgLnBhbmV7XHJcbiAgICAgIG1hcmdpbi10b3A6IC0xcHg7XHJcbiAgICAgIGJvcmRlcjogMXB4IHNvbGlkICNCM0IzQjM7XHJcbiAgICAvLyAgIGhlaWdodDogY2FsYygxMDAlIC0gMjBweCk7XHJcbiAgICAgIC5tYXQtZWxldmF0aW9uLXoxe1xyXG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XHJcbiAgICAgICAgZmxleC1mbG93OiBjb2x1bW4gbm93cmFwO1xyXG4gICAgICAgIC8vIGhlaWdodDogMTAwJTtcclxuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XHJcbiAgICAgICAgYm94LXNoYWRvdzogbm9uZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGhye1xyXG4gICAgICAgIGJvcmRlcjogMXB4IHNvbGlkICNkZmRmZGY7XHJcbiAgICAgICAgYmFja2dyb3VuZDogI2RmZGZkZjtcclxuICAgIH1cclxuICB9XHJcblxyXG4iLCIjZ2ktdmlld2VyLWNvbnRhaW5lciB7XG4gIHdpZHRoOiAxMDAlO1xuICBoZWlnaHQ6IDEwMCU7XG4gIG92ZXJmbG93OiBoaWRkZW47XG59XG5cbi5tYXQtdGFiLWdyb3VwIHtcbiAgbWFyZ2luLWJvdHRvbTogMHB4O1xufVxuXG5hcy1zcGxpdC1hcmVhIHtcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xuICBvdmVyZmxvdzogaGlkZGVuIGF1dG8gIWltcG9ydGFudDtcbn1cblxuI3NldHRpbmdzX2J1dHRvbiB7XG4gIG91dGxpbmU6IG5vbmU7XG4gIHdpZHRoOiA0MHB4O1xuICBoZWlnaHQ6IDMwcHg7XG4gIGZvbnQtc2l6ZTogMTVweDtcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICB0b3A6IDBweDtcbiAgcmlnaHQ6IDBweDtcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xuICBjb2xvcjogIzgwODA4MDtcbiAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XG4gIGJvcmRlcjogMDtcbiAgY3Vyc29yOiBwb2ludGVyO1xufVxuI3NldHRpbmdzX2J1dHRvbjpob3ZlciB7XG4gIGNvbG9yOiAjMDAwMDZkO1xufVxuXG4jYXR0cmliIHtcbiAgb3ZlcmZsb3c6IGhpZGRlbiAhaW1wb3J0YW50O1xufVxuI2F0dHJpYiBhdHRyaWJ1dGUge1xuICBoZWlnaHQ6IGNhbGMoMTAwJSAtIDEwcHgpO1xuICBkaXNwbGF5OiBmbGV4O1xuICBmbGV4LWZsb3c6IGNvbHVtbiBub3dyYXA7XG4gIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2Vlbjtcbn1cblxubW9kYWwtd2luZG93IHtcbiAgZGlzcGxheTogbm9uZTtcbn1cbm1vZGFsLXdpbmRvdyBoMSB7XG4gIGZvbnQtc2l6ZTogMTRweDtcbiAgZm9udC13ZWlnaHQ6IDcwMDtcbiAgbGluZS1oZWlnaHQ6IDM1cHg7XG59XG5tb2RhbC13aW5kb3cgZGwge1xuICBtYXJnaW46IDIwcHggMDtcbiAgcGFkZGluZzogMDtcbiAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XG59XG5tb2RhbC13aW5kb3cgZGwgZGQge1xuICBsaXN0LXN0eWxlOiBub25lO1xuICBwYWRkaW5nOiA4cHggMDtcbiAgbWFyZ2luLWxlZnQ6IDIwcHg7XG4gIGJhY2tncm91bmQtY29sb3I6IGluaGVyaXQ7XG4gIG1pbi1oZWlnaHQ6IDEycHg7XG4gIGJveC1zaXppbmc6IGNvbnRlbnQtYm94O1xuICBjb2xvcjogIzM3MzczNztcbiAgZm9udC1zaXplOiAxMnB4O1xuICBmb250LXN0eWxlOiBub3JtYWw7XG59XG5tb2RhbC13aW5kb3cgZGwgZGQgLmxhYmVsIHtcbiAgZmxvYXQ6IGxlZnQ7XG4gIGxpbmUtaGVpZ2h0OiAxNXB4O1xuICB3aWR0aDogMTIwcHg7XG59XG5tb2RhbC13aW5kb3cgZGwgZGQgLmxhYmVsICsgZGl2IHtcbiAgZmxvYXQ6IGxlZnQ7XG59XG5tb2RhbC13aW5kb3cgZGwgZGQgLmxhYmVsLCBtb2RhbC13aW5kb3cgZGwgZGQgaW5wdXQge1xuICBjb2xvcjogIzM3MzczNztcbiAgZm9udC1zaXplOiAxMnB4O1xuICBmb250LXN0eWxlOiBub3JtYWw7XG59XG5tb2RhbC13aW5kb3cgZGwgZGQgLmxhYmVsOmhvdmVyLCBtb2RhbC13aW5kb3cgZGwgZGQgaW5wdXQ6aG92ZXIge1xuICBiYWNrZ3JvdW5kLWNvbG9yOiBpbmhlcml0O1xufVxubW9kYWwtd2luZG93IGRsIGRkLmNvbG9ycyBociB7XG4gIG1hcmdpbjogMjBweCAwcHggMHB4O1xufVxubW9kYWwtd2luZG93IGRsIGRkLmNvbG9ycyAubGFiZWwge1xuICBsaW5lLWhlaWdodDogMjBweDtcbn1cbm1vZGFsLXdpbmRvdyBkbCBkZC5jb2xvcnMgaW5wdXQge1xuICBwYWRkaW5nLWxlZnQ6IDVweDtcbiAgbWFyZ2luLWxlZnQ6IDBweCAhaW1wb3J0YW50O1xuICBib3JkZXI6IDFweCBzb2xpZCAjRTZFNkU2O1xuICB3aWR0aDogMTIwcHg7XG4gIHZlcnRpY2FsLWFsaWduOiB0b3A7XG4gIHRleHQtdHJhbnNmb3JtOiB1cHBlcmNhc2U7XG59XG5tb2RhbC13aW5kb3cgZGwgZGQuY29sb3JzIGlucHV0LmxpZ2h0IHtcbiAgY29sb3I6ICNmZmZmZmYgIWltcG9ydGFudDtcbn1cbm1vZGFsLXdpbmRvdyAuc2F2ZSB7XG4gIGN1cnNvcjogcG9pbnRlcjtcbiAgYmFja2dyb3VuZDogIzAwMDA2ZDtcbiAgY29sb3I6ICNmZmZmZmY7XG4gIGhlaWdodDogMjBweDtcbn1cbm1vZGFsLXdpbmRvdyAuY2xvc2VidG4ge1xuICBjdXJzb3I6IHBvaW50ZXI7XG4gIGJhY2tncm91bmQ6IHdoaXRlO1xuICBib3JkZXI6IDFweCBzb2xpZCAjQ0NDQ0NDO1xuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICBtYXJnaW4tbGVmdDogMTBweDtcbiAgaGVpZ2h0OiAyMHB4O1xufVxubW9kYWwtd2luZG93IC5nZXRidG4ge1xuICBjdXJzb3I6IHBvaW50ZXI7XG4gIGJhY2tncm91bmQ6IHdoaXRlO1xuICBib3JkZXI6IDFweCBzb2xpZCAjQ0NDQ0NDO1xuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICBtYXJnaW4tbGVmdDogMTBweDtcbiAgaGVpZ2h0OiAyMHB4O1xuICB3aWR0aDogNTBweDtcbn1cblxuYm9keS5tb2RhbC1vcGVuIHtcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcbn1cblxuI3NldHRpbmdzX21vZGFsIHtcbiAgLyogVGhlIHNsaWRlciBpdHNlbGYgKi9cbiAgLyogTW91c2Utb3ZlciBlZmZlY3RzICovXG4gIC8qIFRoZSBzbGlkZXIgaGFuZGxlICh1c2UgLXdlYmtpdC0gKENocm9tZSwgT3BlcmEsIFNhZmFyaSwgRWRnZSkgYW5kIC1tb3otIChGaXJlZm94KSB0byBvdmVycmlkZSBkZWZhdWx0IGxvb2spICovXG59XG4jc2V0dGluZ3NfbW9kYWwgLmZpbGVidG4uc2V0dGluZyB7XG4gIG1hcmdpbi10b3A6IDIwcHg7XG59XG4jc2V0dGluZ3NfbW9kYWwgOjpuZy1kZWVwIC5tb2RhbC13aW5kb3cgLm1vZGFsLWJvZHkge1xuICBiYWNrZ3JvdW5kOiAjZmFmYWZiO1xufVxuI3NldHRpbmdzX21vZGFsIC5vbm9mZnN3aXRjaCB7XG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgd2lkdGg6IDE3cHg7XG4gIGhlaWdodDogNnB4O1xuICB0b3A6IDRweDtcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcbiAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTtcbiAgLW1vei11c2VyLXNlbGVjdDogbm9uZTtcbiAgLW1zLXVzZXItc2VsZWN0OiBub25lO1xufVxuI3NldHRpbmdzX21vZGFsIC5vbm9mZnN3aXRjaC1jaGVja2JveCB7XG4gIGRpc3BsYXk6IG5vbmU7XG59XG4jc2V0dGluZ3NfbW9kYWwgLm9ub2Zmc3dpdGNoLWxhYmVsIHtcbiAgZGlzcGxheTogYmxvY2s7XG4gIG92ZXJmbG93OiBoaWRkZW47XG4gIGhlaWdodDogaW5oZXJpdDtcbiAgYmFja2dyb3VuZC1jb2xvcjogI2RlZGVkZTtcbiAgY3Vyc29yOiBwb2ludGVyO1xufVxuI3NldHRpbmdzX21vZGFsIC5vbm9mZnN3aXRjaC1zd2l0Y2gge1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIHRvcDogLTRweDtcbiAgbGVmdDogMHB4O1xuICB3aWR0aDogM3B4O1xuICBoZWlnaHQ6IDEycHg7XG4gIGJhY2tncm91bmQ6ICNjY2M7XG4gIGJvcmRlcjogMXB4IHNvbGlkICNjY2M7XG59XG4jc2V0dGluZ3NfbW9kYWwgLm9ub2Zmc3dpdGNoLWNoZWNrYm94OmhvdmVyOm5vdCg6Y2hlY2tlZCkgKyAub25vZmZzd2l0Y2gtbGFiZWwge1xuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDAsIDEwOSwgMC40KTtcbn1cbiNzZXR0aW5nc19tb2RhbCAub25vZmZzd2l0Y2gtY2hlY2tib3g6ZGlzYWJsZWQgKyAub25vZmZzd2l0Y2gtbGFiZWwge1xuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZGVkZWRlICFpbXBvcnRhbnQ7XG59XG4jc2V0dGluZ3NfbW9kYWwgLm9ub2Zmc3dpdGNoLWNoZWNrYm94OmRpc2FibGVkICsgLm9ub2Zmc3dpdGNoLWxhYmVsIC5vbm9mZnN3aXRjaC1zd2l0Y2gge1xuICBib3gtc2hhZG93OiBub25lICFpbXBvcnRhbnQ7XG59XG4jc2V0dGluZ3NfbW9kYWwgLm9ub2Zmc3dpdGNoLWNoZWNrYm94OmNoZWNrZWQgKyAub25vZmZzd2l0Y2gtbGFiZWwge1xuICBiYWNrZ3JvdW5kLWNvbG9yOiAjMDAwMDZkO1xufVxuI3NldHRpbmdzX21vZGFsIC5vbm9mZnN3aXRjaC1jaGVja2JveDpjaGVja2VkICsgLm9ub2Zmc3dpdGNoLWxhYmVsIC5vbm9mZnN3aXRjaC1zd2l0Y2gge1xuICByaWdodDogMHB4O1xuICBsZWZ0OiBjYWxjKDEwMCUgKyAxcHgpO1xuICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTEwMCUpO1xufVxuI3NldHRpbmdzX21vZGFsIC5vbm9mZnN3aXRjaC1jaGVja2JveDpkaXNhYmxlZDpjaGVja2VkICsgLm9ub2Zmc3dpdGNoLWxhYmVsIC5vbm9mZnN3aXRjaC1pbm5lcixcbiNzZXR0aW5nc19tb2RhbCAub25vZmZzd2l0Y2gtY2hlY2tib3g6ZGlzYWJsZWQ6Y2hlY2tlZCArIC5vbm9mZnN3aXRjaC1sYWJlbCAub25vZmZzd2l0Y2gtc3dpdGNoIHtcbiAgY3Vyc29yOiBoZWxwO1xufVxuI3NldHRpbmdzX21vZGFsIC5zbGlkZWNvbnRhaW5lciB7XG4gIHdpZHRoOiAxMDAlO1xuICAvKiBXaWR0aCBvZiB0aGUgb3V0c2lkZSBjb250YWluZXIgKi9cbiAgaGVpZ2h0OiAxNXB4O1xufVxuI3NldHRpbmdzX21vZGFsIC5zbGlkZWNvbnRhaW5lcjpob3ZlciB7XG4gIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xufVxuI3NldHRpbmdzX21vZGFsIC5zbGlkZWNvbnRhaW5lci5saWdodCB7XG4gIHdpZHRoOiBjYWxjKDEwMCUgLSAxMjBweCk7XG59XG4jc2V0dGluZ3NfbW9kYWwgLnNsaWRlY29udGFpbmVyLmxpZ2h0IC5zbGlkZXIge1xuICBtYXJnaW4tbGVmdDogMHB4ICFpbXBvcnRhbnQ7XG4gIHdpZHRoOiBjYWxjKDEwMCUgLSA4MHB4KTtcbn1cbiNzZXR0aW5nc19tb2RhbCAuc2xpZGVjb250YWluZXIubGlnaHQgLnNsaWRlciArIGlucHV0W3R5cGU9dGV4dF0ge1xuICBtYXJnaW4tbGVmdDogMTVweCAhaW1wb3J0YW50O1xufVxuI3NldHRpbmdzX21vZGFsIC5zbGlkZXIge1xuICAtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmU7XG4gIC8qIE92ZXJyaWRlIGRlZmF1bHQgQ1NTIHN0eWxlcyAqL1xuICBhcHBlYXJhbmNlOiBub25lO1xuICB3aWR0aDogMjEwcHg7XG4gIG1heC13aWR0aDogNTAwcHg7XG4gIGhlaWdodDogMTVweDtcbiAgLyogU3BlY2lmaWVkIGhlaWdodCAqL1xuICBiYWNrZ3JvdW5kOiB3aGl0ZXNtb2tlO1xuICAvKiBHcmV5IGJhY2tncm91bmQgKi9cbiAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgYm9yZGVyOiAycHggc29saWQgI0U2RTZFNjtcbiAgb3V0bGluZTogbm9uZTtcbiAgLyogUmVtb3ZlIG91dGxpbmUgKi9cbiAgb3BhY2l0eTogMC43O1xuICAvKiBTZXQgdHJhbnNwYXJlbmN5IChmb3IgbW91c2Utb3ZlciBlZmZlY3RzIG9uIGhvdmVyKSAqL1xuICAtd2Via2l0LXRyYW5zaXRpb246IDAuMnM7XG4gIC8qIDAuMiBzZWNvbmRzIHRyYW5zaXRpb24gb24gaG92ZXIgKi9cbiAgdHJhbnNpdGlvbjogb3BhY2l0eSAwLjJzO1xuICBtYXJnaW46IDA7XG4gIG1hcmdpbi1sZWZ0OiAxMHB4ICFpbXBvcnRhbnQ7XG59XG4jc2V0dGluZ3NfbW9kYWwgLnNsaWRlcjpob3ZlciB7XG4gIG9wYWNpdHk6IDE7XG4gIC8qIEZ1bGx5IHNob3duIG9uIG1vdXNlLW92ZXIgKi9cbn1cbiNzZXR0aW5nc19tb2RhbCAuc2xpZGVyOjotd2Via2l0LXNsaWRlci10aHVtYiB7XG4gIC13ZWJraXQtYXBwZWFyYW5jZTogbm9uZTtcbiAgYXBwZWFyYW5jZTogbm9uZTtcbiAgd2lkdGg6IDVweDtcbiAgaGVpZ2h0OiAxNXB4O1xuICBiYWNrZ3JvdW5kOiAjQ0NDQ0NDO1xuICBib3JkZXI6IDFweCBzb2xpZCAjODA4MDgwO1xuICBjdXJzb3I6IHBvaW50ZXI7XG59XG4jc2V0dGluZ3NfbW9kYWwgLnNsaWRlcjo6LXdlYmtpdC1zbGlkZXItdGh1bWI6aG92ZXIsICNzZXR0aW5nc19tb2RhbCAuc2xpZGVyOjotd2Via2l0LXNsaWRlci10aHVtYjphY3RpdmUge1xuICBiYWNrZ3JvdW5kOiAjMDAwMDZkO1xufVxuI3NldHRpbmdzX21vZGFsIC5zbGlkZXI6Oi1tb3otcmFuZ2UtdGh1bWIge1xuICB3aWR0aDogNXB4O1xuICBoZWlnaHQ6IDE1cHg7XG4gIGJhY2tncm91bmQ6ICNDQ0NDQ0M7XG4gIGN1cnNvcjogcG9pbnRlcjtcbn1cbiNzZXR0aW5nc19tb2RhbCAuc2xpZGVyOmRpc2FibGVkOjotd2Via2l0LXNsaWRlci10aHVtYiB7XG4gIGJhY2tncm91bmQ6IHdoaXRlO1xufVxuI3NldHRpbmdzX21vZGFsIC5zbGlkZXI6ZGlzYWJsZWQ6Oi1tb3otcmFuZ2UtdGh1bWIge1xuICBiYWNrZ3JvdW5kOiB3aGl0ZTtcbn1cbiNzZXR0aW5nc19tb2RhbCAuc2xpZGVyOmRpc2FibGVkIHtcbiAgY3Vyc29yOiBoZWxwO1xufVxuI3NldHRpbmdzX21vZGFsIGlucHV0ICsgaW5wdXQge1xuICB2ZXJ0aWNhbC1hbGlnbjogdG9wO1xuICBib3JkZXI6IG5vbmU7XG4gIGxpbmUtaGVpZ2h0OiAyMHB4O1xuICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcbiAgd2lkdGg6IDU1cHg7XG4gIG1hcmdpbi1sZWZ0OiAxMHB4ICFpbXBvcnRhbnQ7XG4gIGhlaWdodDogMTRweDtcbn1cbiNzZXR0aW5nc19tb2RhbCAubnVtYmVyIHtcbiAgd2lkdGg6IDEwMHB4O1xuICBwYWRkaW5nLWxlZnQ6IDVweDtcbiAgYm9yZGVyOiAxcHggc29saWQgI2RkZGRkZDtcbn1cbiNzZXR0aW5nc19tb2RhbCAubGlnaHQtc2hhZG93IHtcbiAgd2lkdGg6IDEyMHB4O1xuICBmbG9hdDogbGVmdDtcbn1cbiNzZXR0aW5nc19tb2RhbCAjY2FtZXJhIGlucHV0LCAjc2V0dGluZ3NfbW9kYWwgI2NhbWVyYV90YXJnZXQgaW5wdXQsICNzZXR0aW5nc19tb2RhbCAjZ3JpZF9wb3MgaW5wdXQge1xuICB3aWR0aDogNjVweDtcbiAgYm9yZGVyOiAxcHggc29saWQgI2JkYmRiZDtcbiAgaGVpZ2h0OiAxNnB4O1xuICBtYXJnaW4tcmlnaHQ6IDNweDtcbiAgdGV4dC1hbGlnbjogcmlnaHQ7XG4gIHBhZGRpbmctcmlnaHQ6IDNweDtcbn1cblxuOjpuZy1kZWVwICNzZXR0aW5nc1RhYiB7XG4gIGhlaWdodDogMTAwJTtcbiAgd2lkdGg6IDEwMCU7XG4gIG92ZXJmbG93LXg6IHNjcm9sbDtcbn1cbjo6bmctZGVlcCAjc2V0dGluZ3NUYWIgdWwge1xuICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcbiAgbWFyZ2luOiAwO1xuICBwYWRkaW5nLWxlZnQ6IDBweDtcbiAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcbiAgd2lkdGg6IDEwMCU7XG4gIG1pbi13aWR0aDogZml0LWNvbnRlbnQ7XG4gIGRpc3BsYXk6IGlubGluZS1mbGV4O1xufVxuOjpuZy1kZWVwICNzZXR0aW5nc1RhYiB1bCBsaSB7XG4gIGxpc3Qtc3R5bGU6IG5vbmU7XG4gIGZsb2F0OiBsZWZ0O1xuICBtaW4td2lkdGg6IDc1cHg7XG4gIGNvbG9yOiAjODA4MDgwO1xuICBvdmVyZmxvdzogdmlzaWJsZTtcbiAgY3Vyc29yOiBwb2ludGVyO1xuICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gIGhlaWdodDogaW5oZXJpdDtcbiAgcGFkZGluZzogMHB4O1xufVxuOjpuZy1kZWVwICNzZXR0aW5nc1RhYiB1bCBsaSBzcGFuIHtcbiAgZm9udC1mYW1pbHk6IHNhbnMtc2VyaWY7XG4gIG1hcmdpbi1yaWdodDogMnB4O1xuICBmb250LXdlaWdodDogNTUwO1xuICBmb250LXNpemU6IDEycHg7XG4gIGxpbmUtaGVpZ2h0OiAxNXB4O1xuICBib3JkZXI6IDFweCBzb2xpZCB0cmFuc3BhcmVudDtcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xuICBkaXNwbGF5OiBibG9jaztcbiAgcGFkZGluZzogMnB4IDdweDtcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xuICB3aWR0aDogaW5oZXJpdDtcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgd2lkdGg6IDEwMCU7XG4gIG1hcmdpbi10b3A6IC0xcHg7XG4gIGhlaWdodDogMjFweDtcbn1cbjo6bmctZGVlcCAjc2V0dGluZ3NUYWIgdWwgbGk6aG92ZXIge1xuICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcbn1cbjo6bmctZGVlcCAjc2V0dGluZ3NUYWIgdWwgbGk6aG92ZXIgc3BhbiB7XG4gIGNvbG9yOiAjMDAwMDZkO1xuICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcbn1cbjo6bmctZGVlcCAjc2V0dGluZ3NUYWIgdWwgbGkuYWN0aXZlIHtcbiAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XG59XG46Om5nLWRlZXAgI3NldHRpbmdzVGFiIHVsIGxpLmFjdGl2ZSBzcGFuIHtcbiAgY29sb3I6ICMwMDAwNmQ7XG4gIGN1cnNvcjogZGVmYXVsdDtcbiAgYmFja2dyb3VuZC1jb2xvcjogI2ZhZmFmYjtcbiAgYm9yZGVyOiAxcHggc29saWQgI0IzQjNCMztcbiAgYm9yZGVyLWJvdHRvbTogMHB4O1xufVxuOjpuZy1kZWVwICNzZXR0aW5nc1RhYiAucGFuZSB7XG4gIG1hcmdpbi10b3A6IC0xcHg7XG4gIGJvcmRlcjogMXB4IHNvbGlkICNCM0IzQjM7XG59XG46Om5nLWRlZXAgI3NldHRpbmdzVGFiIC5wYW5lIC5tYXQtZWxldmF0aW9uLXoxIHtcbiAgZGlzcGxheTogZmxleDtcbiAgZmxleC1mbG93OiBjb2x1bW4gbm93cmFwO1xuICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gIGJveC1zaGFkb3c6IG5vbmU7XG59XG46Om5nLWRlZXAgI3NldHRpbmdzVGFiIGhyIHtcbiAgYm9yZGVyOiAxcHggc29saWQgI2RmZGZkZjtcbiAgYmFja2dyb3VuZDogI2RmZGZkZjtcbn0iLCIkcGFkZGluZzogNDBweDsgLy8gPyBub3QgdXNlZFxyXG4kc21hbGwtcGFkZGluZzogMTVweDtcclxuJGhlYWRlci1oZWlnaHQ6IDQwcHg7XHJcblxyXG4kZnNpemUxOiAxNXB4O1xyXG4kZnNpemUyOiAxMnB4O1xyXG4kZnNpemUzOiAzMHB4O1xyXG5cclxuJHBvcnQtc2l6ZTogMTVweDtcclxuJGRlZmF1bHQtc2lkZS1wYWRkaW5nOiAxNXB4O1xyXG5cclxuJGRpc2FibGVkLW9wYWNpdHk6IDAuNDsiLCJcclxuJGNvbG9yMTogIzgwODA4MDtcclxuJGNvbG9yMjogIzk5OTk5OTtcclxuJGNvbG9yMzogI0IzQjNCMzsgXHJcbiRjb2xvcjQ6ICNDQ0NDQ0M7XHJcbiRjb2xvcjU6ICNFNkU2RTY7XHJcbiRjb2xvcjUtNTogcmdiKDI0NSwgMjQ1LCAyNDUpO1xyXG4kY29sb3I2OiByZ2IoMjUwLCAyNTAsIDI1MSk7XHJcblxyXG4kY29sb3I3OiB3aGl0ZTtcclxuJGNvbG9yODogIzM3MzczNztcclxuXHJcbiRzZWxlY3RlZC1jb2xvcjogcmdiKDAsIDAsIDEwOSk7XHJcbiRzZWxlY3RlZC1jb2xvcjE6IHJnYigyMjgsIDIyOCwgMjQ3KTtcclxuJHNlbGVjdGVkLWNvbG9yMjogcmdiKDIxNSwgMjE1LCAyNTUpO1xyXG4kaG92ZXItY29sb3I6ICRjb2xvcjI7XHJcblxyXG4kZXJyb3ItY29sb3I6ICNFOTQ4NTg7IC8vcGluay1yZWRcclxuJGVycm9yLWNvbG9yLWx0OiByZ2IoMjU1LCAyMjAsIDIyNCk7XHJcbiRwY29sb3IyOiAjRjNBMzJBOyAvL29yYW5nZS15ZWxsb3dcclxuJHByaW50LWNvbG9yOiByZ2IoMTMwLCAxOTEsIDExMCk7IC8vbGlnaHRncmVlblxyXG4kcHJpbnQtY29sb3ItbHQ6IHJnYigyMzAsIDI1NSwgMjIxKTtcclxuJHByaW50LWNvbG9yLWRrOiByZ2IoNjMsIDk5LCA1MSk7IC8vbGlnaHRncmVlblxyXG4kc2VsZWN0R2VvbS1jb2xvcjogcmdiKDI1NSwgMTc0LCAwKTsgLy8gbGlnaHQgb3JhbmdlXHJcbiRzZWxlY3RHZW9tLWNvbG9yLWx0OiByZ2IoMjU1LCAyMjUsIDE2MCk7XHJcblxyXG4vLyAkcHJvZC1iYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMjUwLDI1MCwyNTApO1xyXG4vLyAkYmFja2dyb3VuZC1jb2xvcjogcmdiKDIyMCwyMjAsMjIwKTtcclxuJGZ1bmN0aW9uLXRleHQtY29sb3I6IHJnYigxOTAsIDE0MCwgMzApO1xyXG4kZnVuY3Rpb24tdGV4dC1jb2xvcjI6IHJnYigxOCwgMTI2LCAxMzYpO1xyXG4kZnVuY3Rpb24tdGV4dC1jb2xvcjM6IHJnYigxOTAsIDE0MCwgMzApO1xyXG4kYmFzaWMtZnVuY3Rpb24tdGV4dC1jb2xvcjogcmdiKDIwMCwgNzAsIDE1MCk7XHJcbiRjb21tZW50LWNvbG9yOiBkYXJrZ3JlZW47XHJcbiJdfQ== */");

/***/ }),

/***/ "./src/app/gi-viewer/gi-viewer.component.ts":
/*!**************************************************!*\
  !*** ./src/app/gi-viewer/gi-viewer.component.ts ***!
  \**************************************************/
/*! exports provided: GIViewerComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GIViewerComponent", function() { return GIViewerComponent; });
/* harmony import */ var _libs_geo_info_GIModel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @libs/geo-info/GIModel */ "./src/assets/libs/geo-info/GIModel.ts");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
/* harmony import */ var _gi_viewer_settings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./gi-viewer.settings */ "./src/app/gi-viewer/gi-viewer.settings.ts");
/* harmony import */ var _data_data_service__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./data/data.service */ "./src/app/gi-viewer/data/data.service.ts");
/* harmony import */ var _html_modal_window_service__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./html/modal-window.service */ "./src/app/gi-viewer/html/modal-window.service.ts");
/* harmony import */ var ngx_color_picker__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ngx-color-picker */ "./node_modules/ngx-color-picker/dist/ngx-color-picker.es5.js");
/* harmony import */ var _threejs_threejs_viewer_component__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./threejs/threejs-viewer.component */ "./src/app/gi-viewer/threejs/threejs-viewer.component.ts");
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/* harmony import */ var angular_split__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! angular-split */ "./node_modules/angular-split/fesm2015/angular-split.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};



// import @angular stuff

// import app services






// import others
// import { ThreejsViewerComponent } from './threejs/threejs-viewer.component';
/**
 * GIViewerComponent
 * This component is used in /app/model-viewers/model-viewers-container.component.html
 */
let GIViewerComponent = class GIViewerComponent {
    /**
     * constructor
     * @param dataService
     */
    constructor(dataService, modalService, cpService) {
        this.dataService = dataService;
        this.modalService = modalService;
        this.cpService = cpService;
        this.settings = _gi_viewer_settings__WEBPACK_IMPORTED_MODULE_2__["DefaultSettings"];
        this.setting_colors = _gi_viewer_settings__WEBPACK_IMPORTED_MODULE_2__["SettingsColorMap"];
        this.normalsEnabled = false;
        this.temp_camera_pos = new three__WEBPACK_IMPORTED_MODULE_7__["Vector3"](-80, -80, 80);
        this.temp_target_pos = new three__WEBPACK_IMPORTED_MODULE_7__["Vector3"](0, 0, 0);
        this.temp_grid_pos = new three__WEBPACK_IMPORTED_MODULE_7__["Vector3"](0, 0, 0);
        const previous_settings = JSON.parse(localStorage.getItem('mpm_settings'));
        // const devMode = isDevMode();
        const devMode = false;
        if (previous_settings === null) {
            localStorage.setItem('mpm_settings', JSON.stringify(this.settings));
        }
        else {
            this.propCheck(previous_settings, this.settings);
            localStorage.setItem('mpm_settings', JSON.stringify(previous_settings));
        }
        // if (previous_settings === null || this.hasDiffProps(previous_settings, this.settings)) {
        //     localStorage.setItem('mpm_settings', JSON.stringify(this.settings));
        // }
    }
    /**
     * Check whether the current settings has same structure with
     * the previous settings saved in local storage. If not, replace the local storage.
     * @param obj1
     * @param obj2
     */
    hasDiffProps(obj1, obj2) {
        return !Object.keys(obj2).every(e => Object.keys(obj1).includes(e));
    }
    /**
     * Check whether the current settings has same structure with
     * the previous settings saved in local storage. If not, replace the local storage.
     * @param obj1
     * @param obj2
     */
    propCheck(obj1, obj2, checkChildren = true) {
        for (const i in obj2) {
            if (!obj1.hasOwnProperty(i)) {
                obj1[i] = JSON.parse(JSON.stringify(obj2[i]));
            }
            else if (checkChildren && obj1[i].constructor === {}.constructor && obj2[i].constructor === {}.constructor) {
                this.propCheck(obj1[i], obj2[i], false);
            }
        }
    }
    /**
     * ngOnInit
     */
    ngOnInit() {
        this.getSettings();
        if (this.dataService.getThreejsScene() === undefined) {
            this.dataService.setThreejsScene(this.settings);
        }
        localStorage.setItem('mpm_default_settings', JSON.stringify(_gi_viewer_settings__WEBPACK_IMPORTED_MODULE_2__["DefaultSettings"]));
        this.temp_camera_pos = this.dataService.getThreejsScene().perspCam.position;
    }
    getSettings() {
        if (localStorage.getItem('mpm_settings') !== null) {
            this.settings = JSON.parse(localStorage.getItem('mpm_settings'));
        }
    }
    threejsAction(action) {
        // <threejs-viewer [model]='data'
        // (eventClicked)="childEventClicked($event)"
        // [attr_table_select]='attrTableSelect'
        // [selectSwitch] = 'selectSwitchOnOff'
        // [attribLabel] = 'attribLabelVal'
        // (resetTableEvent) = "resetTable()"
        // ></threejs-viewer>
        if (action.type === 'resetTableEvent') {
            this.resetTable();
        }
        else if (action.type === 'eventClicked') {
            this.childEventClicked(action.event);
        }
    }
    childEventClicked(event) {
        this.clickedEvent = event;
    }
    attribTableSelected(event) {
        this.attrTableSelect = event;
    }
    selectSwitch(event) {
        this.selectSwitchOnOff = event;
    }
    attribLabel(event) {
        this.attribLabelVal = event;
    }
    resetTable() {
        this.attrTableReset = Date.now();
    }
    openModal(id) {
        this.getSettings();
        if (document.body.className === 'modal-open') {
            this.modalService.close(id);
        }
        else {
            this.modalService.open(id);
            const scene = this.dataService.getThreejsScene();
            if (scene.threejs_nums.reduce((a, b) => a + b, 0) !== 0) {
                scene.vnh !== undefined ? this.normalsEnabled = true : this.normalsEnabled = false;
            }
        }
    }
    closeModal(id, save = false) {
        this.modalService.close(id);
        if (save) {
            const _selector = JSON.parse(localStorage.getItem('mpm_selecting_entity_type'));
            const _tab = Number(JSON.parse(localStorage.getItem('mpm_attrib_current_tab')));
            // this.settings.select = {selector: _selector, tab: _tab, };
            this.settings.select.selector = _selector;
            this.settings.select.tab = _tab;
            this.settings.camera = {
                pos: this.temp_camera_pos,
                target: this.temp_target_pos,
                ortho: false
            };
            this.dataService.getThreejsScene().settings = this.settings;
            localStorage.setItem('mpm_settings', JSON.stringify(this.settings));
            this.threejs.updateModel(this.data);
        }
        else {
            // tslint:disable-next-line: forin
            for (const setting in this.dataService.getThreejsScene().settings) {
                this.settings[setting] = this.dataService.getThreejsScene().settings[setting];
            }
            this.threejs.updateModel(this.data);
        }
        setTimeout(() => {
            this.threejs.activateRender();
        }, 100);
    }
    onCloseModal() {
        // tslint:disable-next-line: forin
        for (const setting in this.dataService.getThreejsScene().settings) {
            this.settings[setting] = this.dataService.getThreejsScene().settings[setting];
        }
        this.threejs.updateModel(this.data);
    }
    settingOnChange(setting, value) {
        const scene = this.dataService.getThreejsScene();
        switch (setting) {
            case 'normals.show':
                this.settings.normals.show = !this.settings.normals.show;
                scene.vnh.visible = this.settings.normals.show;
                break;
            case 'normals.size':
                this.settings.normals.size = Number(value);
                break;
            case 'axes.show':
                this.settings.axes.show = !this.settings.axes.show;
                scene.axesHelper.visible = this.settings.axes.show;
                break;
            case 'axes.size':
                this.settings.axes.size = Number(value);
                scene._addAxes(Number(value));
                break;
            case 'grid.show':
                this.settings.grid.show = !this.settings.grid.show;
                scene.grid.visible = this.settings.grid.show;
                break;
            case 'grid.size':
                this.settings.grid.size = Number(value);
                scene._addGrid(this.settings.grid.size);
                break;
            case 'grid.update_pos':
                this.temp_grid_pos = this.dataService.getThreejsScene().getGridPos();
                if (this.temp_grid_pos) {
                    this.settings.grid.pos = this.temp_grid_pos;
                    this.settings.grid.pos_x = this.temp_grid_pos.x;
                    this.settings.grid.pos_y = this.temp_grid_pos.y;
                }
                break;
            case 'grid.update_pos_x':
                if (isNaN(value)) {
                    return;
                }
                this.settings.grid.pos_x = Number(value);
                this.settings.grid.pos.x = Number(value);
                break;
            case 'grid.update_pos_y':
                if (isNaN(value)) {
                    return;
                }
                this.settings.grid.pos_y = Number(value);
                this.settings.grid.pos.y = Number(value);
                break;
            case 'grid.update_pos_z':
                if (isNaN(value)) {
                    return;
                }
                this.settings.grid.pos_z = Number(value);
                this.settings.grid.pos.z = Number(value);
                break;
            case 'positions.show':
                this.settings.positions.show = !this.settings.positions.show;
                scene.positions.map(p => p.visible = this.settings.positions.show);
                break;
            case 'positions.size':
                this.settings.positions.size = Number(value);
                break;
            case 'background.show':
                this.settings.background.show = !this.settings.background.show;
                break;
            case 'background.set':
                this.settings.background.background_set = Number(value);
                break;
            case 'tjs_summary.show':
                this.settings.gi_summary.show = false;
                this.settings.tjs_summary.show = !this.settings.tjs_summary.show;
                break;
            case 'gi_summary.show':
                this.settings.tjs_summary.show = false;
                this.settings.gi_summary.show = !this.settings.gi_summary.show;
                break;
            case 'wireframe.show':
                this.wireframeToggle();
                break;
            case 'camera.pos_x':
                if (isNaN(value)) {
                    return;
                }
                this.temp_camera_pos.x = Math.round(value);
                break;
            case 'camera.pos_y':
                if (isNaN(value)) {
                    return;
                }
                this.temp_camera_pos.y = Math.round(value);
                break;
            case 'camera.pos_z':
                if (isNaN(value)) {
                    return;
                }
                this.temp_camera_pos.z = Math.round(value);
                break;
            case 'camera.get_camera_pos':
                this.temp_camera_pos = this.dataService.getThreejsScene().camera.position;
                this.settings.camera.pos = this.temp_camera_pos;
                break;
            case 'camera.target_x':
                if (isNaN(value)) {
                    return;
                }
                this.temp_target_pos.x = Math.round(value);
                break;
            case 'camera.target_y':
                if (isNaN(value)) {
                    return;
                }
                this.temp_target_pos.y = Math.round(value);
                break;
            case 'camera.target_z':
                if (isNaN(value)) {
                    return;
                }
                this.temp_target_pos.z = Math.round(value);
                break;
            case 'camera.get_target_pos':
                this.temp_target_pos = this.dataService.getThreejsScene().perspControls.target;
                this.settings.camera.target = this.temp_target_pos;
                break;
            case 'ambient_light.show': // Ambient Light
                this.settings.ambient_light.show = !this.settings.ambient_light.show;
                if (scene.ambient_light) {
                    scene.ambient_light.visible = this.settings.ambient_light.show;
                }
                break;
            case 'ambient_light.intensity':
                this.settings.ambient_light.intensity = Number(value);
                scene.ambient_light.intensity = this.settings.ambient_light.intensity;
                break;
            case 'hemisphere_light.show': // Hemisphere Light
                this.settings.hemisphere_light.show = !this.settings.hemisphere_light.show;
                if (scene.hemisphere_light) {
                    scene.hemisphere_light.visible = this.settings.hemisphere_light.show;
                }
                break;
            case 'hemisphere_light.helper':
                this.settings.hemisphere_light.helper = !this.settings.hemisphere_light.helper;
                break;
            case 'hemisphere_light.intensity':
                this.settings.hemisphere_light.intensity = Number(value);
                scene.hemisphere_light.intensity = this.settings.hemisphere_light.intensity;
                break;
            case 'directional_light.show': // Directional Light
                this.settings.directional_light.show = !this.settings.directional_light.show;
                if (scene.directional_light) {
                    scene.directional_light.visible = this.settings.directional_light.show;
                }
                if (this.settings.directional_light.show) {
                    this.settings.ambient_light.intensity = 0.15;
                    this.settings.hemisphere_light.intensity = 0.15;
                }
                else {
                    this.settings.ambient_light.intensity = 0.5;
                    this.settings.hemisphere_light.intensity = 0.5;
                }
                break;
            // case 'directional_light.type': // Directional Light
            //     if (this.settings.directional_light.type === 'directional') {
            //         this.settings.directional_light.type = 'point';
            //     } else {
            //         this.settings.directional_light.type = 'directional';
            //     }
            //     this.threejs.updateModel(this.data);
            //     break;
            case 'directional_light.helper':
                this.settings.directional_light.helper = !this.settings.directional_light.helper;
                break;
            case 'directional_light.intensity':
                this.settings.directional_light.intensity = Number(value);
                scene.directional_light.intensity = this.settings.directional_light.intensity;
                break;
            case 'directional_light.shadow':
                this.settings.directional_light.shadow = !this.settings.directional_light.shadow;
                break;
            case 'directional_light.shadowSize':
                this.settings.directional_light.shadowSize = Number(value);
                break;
            case 'directional_light.azimuth':
                this.settings.directional_light.azimuth = Number(value);
                scene.getDLPosition(null, this.settings.directional_light.azimuth, this.settings.directional_light.altitude);
                setTimeout(() => { this.threejs.activateRender(); }, 0);
                break;
            case 'directional_light.altitude':
                this.settings.directional_light.altitude = Number(value);
                scene.getDLPosition(null, this.settings.directional_light.azimuth, this.settings.directional_light.altitude);
                break;
            // case 'directional_light.distance':
            //     this.settings.directional_light.distance = Number(value);
            //     scene.DLDistance(this.settings.directional_light.distance);
            //     break;
            case 'ground.show':
                this.settings.ground.show = !this.settings.ground.show;
                // scene.directional_light.visible = this.settings.directional_light.show;
                break;
            case 'ground.width':
                this.settings.ground.width = Number(value);
                break;
            case 'ground.length':
                this.settings.ground.length = Number(value);
                break;
            case 'ground.height':
                this.settings.ground.height = Number(value);
                if (scene.groundObj) {
                    scene.groundObj.position.setZ(this.settings.ground.height);
                }
                break;
            case 'ground.shininess':
                this.settings.ground.shininess = Number(value);
                break;
            case 'select.ps':
                this.settings.select.enabledselector.ps = !this.settings.select.enabledselector.ps;
                break;
            case 'select._v':
                this.settings.select.enabledselector._v = !this.settings.select.enabledselector._v;
                break;
            case 'select._e':
                this.settings.select.enabledselector._e = !this.settings.select.enabledselector._e;
                break;
            case 'select._w':
                this.settings.select.enabledselector._w = !this.settings.select.enabledselector._w;
                break;
            case 'select._f':
                this.settings.select.enabledselector._f = !this.settings.select.enabledselector._f;
                break;
            case 'select.pt':
                this.settings.select.enabledselector.pt = !this.settings.select.enabledselector.pt;
                break;
            case 'select.pl':
                this.settings.select.enabledselector.pl = !this.settings.select.enabledselector.pl;
                break;
            case 'select.pg':
                this.settings.select.enabledselector.pg = !this.settings.select.enabledselector.pg;
                break;
            case 'select.co':
                this.settings.select.enabledselector.co = !this.settings.select.enabledselector.co;
                break;
            default:
                break;
        }
        this.threejs.activateRender();
    }
    // resetDefault(setting, value) {
    //     const seg = setting.split('.');
    //     this.settings[seg[0]][seg[1]] = value;
    // }
    resetToDefault() {
        const default_settings = JSON.parse(localStorage.getItem('mpm_default_settings'));
        this.settings = default_settings;
    }
    checkColor(color) {
        const _color = this.cpService.hsvaToRgba(this.cpService.stringToHsva(color));
        if ((_color.r + _color.g + _color.b) / _color.a < 1.5) {
            return true;
        }
        else {
            return false;
        }
    }
    wireframeToggle() {
        const scene = this.dataService.getThreejsScene();
        scene.scene_objs.forEach(obj => {
            if (obj.type === 'Mesh') {
                this.settings.wireframe.show = !this.settings.wireframe.show;
                // @ts-ignore
                obj.material.wireframe = this.settings.wireframe.show;
            }
        });
    }
    dragSplitEnd(e) {
        this.dataService.ngSplitGutter = e.sizes[1];
    }
    getSplit() {
        return this.dataService.ngSplitGutter;
    }
    checkPublish() {
        const d = document.getElementById('published');
        return d !== null;
    }
    setCamera(x = null, y = null, z = null) {
        const scene = this.dataService.getThreejsScene();
        if (x) {
            scene.perspCam.position.x = x;
        }
        if (y) {
            scene.perspCam.position.y = y;
        }
        if (z) {
            scene.perspCam.position.z = z;
        }
        scene.perspCam.lookAt(scene.scene.position);
        scene.perspCam.updateProjectionMatrix();
    }
    formatNumber(value) {
        if (!value) {
            value = 0;
        }
        return Math.round(value * 100) / 100;
    }
    onmouseleave() {
        this.viewerSplit.notify('end');
    }
};
GIViewerComponent.ctorParameters = () => [
    { type: _data_data_service__WEBPACK_IMPORTED_MODULE_3__["DataService"] },
    { type: _html_modal_window_service__WEBPACK_IMPORTED_MODULE_4__["ModalService"] },
    { type: ngx_color_picker__WEBPACK_IMPORTED_MODULE_5__["ColorPickerService"] }
];
__decorate([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    __metadata("design:type", _libs_geo_info_GIModel__WEBPACK_IMPORTED_MODULE_0__["GIModel"])
], GIViewerComponent.prototype, "data", void 0);
__decorate([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"])(_threejs_threejs_viewer_component__WEBPACK_IMPORTED_MODULE_6__["ThreejsViewerComponent"], { static: true }),
    __metadata("design:type", _threejs_threejs_viewer_component__WEBPACK_IMPORTED_MODULE_6__["ThreejsViewerComponent"])
], GIViewerComponent.prototype, "threejs", void 0);
__decorate([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"])(angular_split__WEBPACK_IMPORTED_MODULE_8__["SplitComponent"], { static: true }),
    __metadata("design:type", angular_split__WEBPACK_IMPORTED_MODULE_8__["SplitComponent"])
], GIViewerComponent.prototype, "viewerSplit", void 0);
__decorate([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"])('mouseleave', []),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], GIViewerComponent.prototype, "onmouseleave", null);
GIViewerComponent = __decorate([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
        selector: 'gi-viewer',
        template: __importDefault(__webpack_require__(/*! raw-loader!./gi-viewer.component.html */ "./node_modules/raw-loader/dist/cjs.js!./src/app/gi-viewer/gi-viewer.component.html")).default,
        styles: [__importDefault(__webpack_require__(/*! ./gi-viewer.component.scss */ "./src/app/gi-viewer/gi-viewer.component.scss")).default]
    }),
    __metadata("design:paramtypes", [_data_data_service__WEBPACK_IMPORTED_MODULE_3__["DataService"],
        _html_modal_window_service__WEBPACK_IMPORTED_MODULE_4__["ModalService"],
        ngx_color_picker__WEBPACK_IMPORTED_MODULE_5__["ColorPickerService"]])
], GIViewerComponent);

// interface Settings {
//     normals: { show: boolean, size: number };
//     axes: { show: boolean, size: number };
//     grid: {
//         show: boolean,
//         size: number,
//         pos: Vector3,
//         pos_x: number,
//         pos_y: number,
//         pos_z: number,
//     };
//     background: {
//         show: boolean,
//         background_set: number
//     };
//     positions: { show: boolean, size: number };
//     wireframe: { show: boolean };
//     tjs_summary: { show: boolean };
//     gi_summary: { show: boolean };
//     camera: {
//         pos: Vector3,
//         pos_x: number,
//         pos_y: number,
//         pos_z: number,
//         target: Vector3
//     };
//     colors: {
//         viewer_bg: string,
//         position: string,
//         position_s: string,
//         vertex_s: string,
//         face_f: string,
//         face_f_s: string,
//         face_b: string,
//         face_b_s: string
//     };
//     ambient_light: {
//         show: boolean,
//         color: string,
//         intensity: number
//     };
//     hemisphere_light: {
//         show: boolean,
//         helper: boolean,
//         skyColor: string,
//         groundColor: string,
//         intensity: number
//     };
//     directional_light: {
//         show: boolean,
//         helper: boolean,
//         color: string,
//         intensity: number,
//         shadow: boolean,
//         azimuth: number,
//         altitude: number,
//         distance: number,
//         type: string,
//         shadowSize: number
//     };
//     ground: {
//         show: boolean,
//         width: number,
//         length: number,
//         height: number,
//         color: string,
//         shininess: number
//     };
//     select: {
//         selector: object,
//         tab: number,
//         ps: boolean,
//         _v: boolean,
//         _e: boolean,
//         _w: boolean,
//         _f: boolean,
//         pt: boolean,
//         pl: boolean,
//         pg: boolean,
//         co: boolean
//     };
//     version: string;
// }


/***/ }),

/***/ "./src/app/gi-viewer/gi-viewer.module.ts":
/*!***********************************************!*\
  !*** ./src/app/gi-viewer/gi-viewer.module.ts ***!
  \***********************************************/
/*! exports provided: GIViewerModule */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GIViewerModule", function() { return GIViewerModule; });
/* harmony import */ var angular_split__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! angular-split */ "./node_modules/angular-split/fesm2015/angular-split.js");
/* harmony import */ var ngx_pagination__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ngx-pagination */ "./node_modules/ngx-pagination/dist/ngx-pagination.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
/* harmony import */ var _angular_material_slider__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/material/slider */ "./node_modules/@angular/material/esm2015/slider.js");
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/fesm2015/common.js");
/* harmony import */ var _angular_forms__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/forms */ "./node_modules/@angular/forms/fesm2015/forms.js");
/* harmony import */ var _angular_material_tooltip__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @angular/material/tooltip */ "./node_modules/@angular/material/esm2015/tooltip.js");
/* harmony import */ var _angular_material_icon__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @angular/material/icon */ "./node_modules/@angular/material/esm2015/icon.js");
/* harmony import */ var _angular_material_expansion__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @angular/material/expansion */ "./node_modules/@angular/material/esm2015/expansion.js");
/* harmony import */ var ngx_color_picker__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ngx-color-picker */ "./node_modules/ngx-color-picker/dist/ngx-color-picker.es5.js");
/* harmony import */ var _attribute_attribute_module__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./attribute/attribute.module */ "./src/app/gi-viewer/attribute/attribute.module.ts");
/* harmony import */ var _gi_viewer_component__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./gi-viewer.component */ "./src/app/gi-viewer/gi-viewer.component.ts");
/* harmony import */ var _threejs_threejs_viewer_component__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./threejs/threejs-viewer.component */ "./src/app/gi-viewer/threejs/threejs-viewer.component.ts");
/* harmony import */ var _attribute_attribute_component__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./attribute/attribute.component */ "./src/app/gi-viewer/attribute/attribute.component.ts");
/* harmony import */ var _attribute_tab_component__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./attribute/tab.component */ "./src/app/gi-viewer/attribute/tab.component.ts");
/* harmony import */ var _attribute_tabs_component__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./attribute/tabs.component */ "./src/app/gi-viewer/attribute/tabs.component.ts");
/* harmony import */ var _html_tab_component__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./html/tab.component */ "./src/app/gi-viewer/html/tab.component.ts");
/* harmony import */ var _html_tabs_component__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./html/tabs.component */ "./src/app/gi-viewer/html/tabs.component.ts");
/* harmony import */ var _html_dropdown_menu_component__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./html/dropdown-menu.component */ "./src/app/gi-viewer/html/dropdown-menu.component.ts");
/* harmony import */ var _html_modal_window_component__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./html/modal-window.component */ "./src/app/gi-viewer/html/modal-window.component.ts");
/* harmony import */ var _html_modal_window_service__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./html/modal-window.service */ "./src/app/gi-viewer/html/modal-window.service.ts");
/* harmony import */ var _threejs_threejs_viewer_service__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./threejs/threejs-viewer.service */ "./src/app/gi-viewer/threejs/threejs-viewer.service.ts");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};
var GIViewerModule_1;


// import @angular stuff









// import app components











/**
 * GIViewer
 * A viewer for Geo-Info models.
 */
let GIViewerModule = GIViewerModule_1 = class GIViewerModule {
    static forRoot() {
        return {
            ngModule: GIViewerModule_1
        };
    }
};
GIViewerModule = GIViewerModule_1 = __decorate([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["NgModule"])({
        declarations: [
            _gi_viewer_component__WEBPACK_IMPORTED_MODULE_11__["GIViewerComponent"],
            _threejs_threejs_viewer_component__WEBPACK_IMPORTED_MODULE_12__["ThreejsViewerComponent"],
            _attribute_attribute_component__WEBPACK_IMPORTED_MODULE_13__["AttributeComponent"],
            _attribute_tab_component__WEBPACK_IMPORTED_MODULE_14__["ATabComponent"],
            _attribute_tabs_component__WEBPACK_IMPORTED_MODULE_15__["ATabsComponent"],
            _html_tab_component__WEBPACK_IMPORTED_MODULE_16__["TabComponent"],
            _html_tabs_component__WEBPACK_IMPORTED_MODULE_17__["TabsComponent"],
            _html_dropdown_menu_component__WEBPACK_IMPORTED_MODULE_18__["DropdownMenuComponent"],
            _html_modal_window_component__WEBPACK_IMPORTED_MODULE_19__["ModalWindowComponent"]
        ],
        exports: [
            _gi_viewer_component__WEBPACK_IMPORTED_MODULE_11__["GIViewerComponent"]
        ],
        imports: [
            _angular_common__WEBPACK_IMPORTED_MODULE_4__["CommonModule"],
            angular_split__WEBPACK_IMPORTED_MODULE_0__["AngularSplitModule"],
            _angular_material_slider__WEBPACK_IMPORTED_MODULE_3__["MatSliderModule"],
            _angular_material_icon__WEBPACK_IMPORTED_MODULE_7__["MatIconModule"],
            ngx_pagination__WEBPACK_IMPORTED_MODULE_1__["NgxPaginationModule"],
            _angular_material_expansion__WEBPACK_IMPORTED_MODULE_8__["MatExpansionModule"],
            _angular_material_tooltip__WEBPACK_IMPORTED_MODULE_6__["MatTooltipModule"],
            _attribute_attribute_module__WEBPACK_IMPORTED_MODULE_10__["AttributeModule"],
            _angular_forms__WEBPACK_IMPORTED_MODULE_5__["FormsModule"],
            ngx_color_picker__WEBPACK_IMPORTED_MODULE_9__["ColorPickerModule"]
        ],
        providers: [
            _html_modal_window_service__WEBPACK_IMPORTED_MODULE_20__["ModalService"],
            _threejs_threejs_viewer_service__WEBPACK_IMPORTED_MODULE_21__["ThreeJSViewerService"]
        ]
    })
], GIViewerModule);



/***/ }),

/***/ "./src/app/gi-viewer/gi-viewer.settings.ts":
/*!*************************************************!*\
  !*** ./src/app/gi-viewer/gi-viewer.settings.ts ***!
  \*************************************************/
/*! exports provided: DefaultSettings, SettingsColorMap, Locale */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DefaultSettings", function() { return DefaultSettings; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SettingsColorMap", function() { return SettingsColorMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Locale", function() { return Locale; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};

const DefaultSettings = {
    normals: { show: false, size: 5 },
    axes: { show: true, size: 50 },
    grid: {
        show: true,
        size: 500,
        pos_x: 0,
        pos_y: 0,
        pos_z: 0,
        pos: new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](0, 0, 0)
    },
    background: {
        show: false,
        background_set: 0
    },
    positions: { show: true, size: 0.5 },
    tjs_summary: { show: false },
    gi_summary: { show: false },
    wireframe: { show: false },
    camera: {
        pos: new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](-80, -80, 80),
        target: new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](0, 0, 0),
        ortho: false
    },
    colors: {
        viewer_bg: '#E6E6E6',
        position: '#000000',
        position_s: '#0033FF',
        vertex_s: '#FFCC00',
        face_f: '#FFFFFF',
        face_f_s: '#4949BD',
        face_b: '#DDDDDD',
        face_b_s: '#00006D'
    },
    ambient_light: {
        show: true,
        color: '#FFFFFF',
        intensity: 0.5
    },
    hemisphere_light: {
        show: true,
        helper: false,
        skyColor: '#FFFFFF',
        groundColor: '#FFFFFF',
        intensity: 0.5
    },
    directional_light: {
        show: false,
        helper: false,
        color: '#FFFFFF',
        intensity: 1,
        shadow: true,
        azimuth: 90,
        altitude: 45,
        distance: 10,
        type: 'directional',
        shadowSize: 2048
    },
    ground: {
        show: false,
        width: 1000,
        length: 1000,
        height: -0.5,
        color: '#FFFFFF',
        shininess: 0
    },
    select: {
        selector: { id: 5, name: 'Faces' },
        tab: 0,
        enabledselector: {
            ps: true,
            _v: true,
            _e: true,
            _w: true,
            _f: true,
            pt: true,
            pl: true,
            pg: true,
            co: true
        }
    },
};
const SettingsColorMap = [{
        label: 'Viewer Background',
        setting: 'viewer_bg',
        default: '#E6E6E6'
    }, {
        label: 'Position',
        setting: 'position'
    }, {
        label: 'Position Selected',
        setting: 'position_s'
    }, {
        label: 'Face Front',
        setting: 'face_f'
    }, {
        label: 'Face Front Selected',
        setting: 'face_f_s'
    }, {
        label: 'Face Back',
        setting: 'face_b'
    }, {
        label: 'Face Back Selected',
        setting: 'face_b_s'
    }, {
        label: 'Vertices Selected',
        setting: 'vertex_s'
    }];
const Locale = [{
        name: 'Singapore',
        zone: 'Asia/Singapore',
        lat: '1.35',
        long: '103.8'
    }];


/***/ }),

/***/ "./src/app/gi-viewer/gi-viewer.ts":
/*!****************************************!*\
  !*** ./src/app/gi-viewer/gi-viewer.ts ***!
  \****************************************/
/*! exports provided: GIViewerModule */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _gi_viewer_module__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gi-viewer.module */ "./src/app/gi-viewer/gi-viewer.module.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GIViewerModule", function() { return _gi_viewer_module__WEBPACK_IMPORTED_MODULE_0__["GIViewerModule"]; });

var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};



/***/ }),

/***/ "./src/app/gi-viewer/html/dropdown-menu.component.scss":
/*!*************************************************************!*\
  !*** ./src/app/gi-viewer/html/dropdown-menu.component.scss ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("div {\n  position: absolute;\n}\ndiv ul {\n  padding: 0;\n  border: 1px solid #eeeeee;\n  box-shadow: 1px 1px 3px 0px #bbbbbb;\n}\ndiv ul ol {\n  cursor: pointer;\n  list-style: none;\n  background: #ffffff;\n  min-width: 20px;\n  padding: 5px 10px;\n}\ndiv ul ol:hover {\n  background: #eeeeee;\n}\ndiv ul:first-child {\n  background: #f9f9f9;\n}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9hcHAvZ2ktdmlld2VyL2h0bWwvQzpcXFVzZXJzXFxha2liZHB0XFxEb2N1bWVudHNcXEFuZ3VsYXJcXG1vYml1cy12aWV3ZXIvc3JjXFxhcHBcXGdpLXZpZXdlclxcaHRtbFxcZHJvcGRvd24tbWVudS5jb21wb25lbnQuc2NzcyIsInNyYy9hcHAvZ2ktdmlld2VyL2h0bWwvZHJvcGRvd24tbWVudS5jb21wb25lbnQuc2NzcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtFQUNJLGtCQUFBO0FDQ0o7QURBSTtFQUNJLFVBQUE7RUFDQSx5QkFBQTtFQUNBLG1DQUFBO0FDRVI7QUREUTtFQUNJLGVBQUE7RUFDQSxnQkFBQTtFQUNBLG1CQUFBO0VBQ0EsZUFBQTtFQUNBLGlCQUFBO0FDR1o7QURGWTtFQUNJLG1CQUFBO0FDSWhCO0FERFE7RUFDSSxtQkFBQTtBQ0daIiwiZmlsZSI6InNyYy9hcHAvZ2ktdmlld2VyL2h0bWwvZHJvcGRvd24tbWVudS5jb21wb25lbnQuc2NzcyIsInNvdXJjZXNDb250ZW50IjpbImRpdntcclxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcclxuICAgIHVse1xyXG4gICAgICAgIHBhZGRpbmc6IDA7XHJcbiAgICAgICAgYm9yZGVyOiAxcHggc29saWQgI2VlZWVlZTtcclxuICAgICAgICBib3gtc2hhZG93OiAxcHggMXB4IDNweCAwcHggI2JiYmJiYjtcclxuICAgICAgICBvbHtcclxuICAgICAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xyXG4gICAgICAgICAgICBsaXN0LXN0eWxlOiBub25lO1xyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kOiAjZmZmZmZmO1xyXG4gICAgICAgICAgICBtaW4td2lkdGg6IDIwcHg7XHJcbiAgICAgICAgICAgIHBhZGRpbmc6IDVweCAxMHB4O1xyXG4gICAgICAgICAgICAmOmhvdmVye1xyXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZDogI2VlZWVlZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAmOmZpcnN0LWNoaWxke1xyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kOiAjZjlmOWY5O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsImRpdiB7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbn1cbmRpdiB1bCB7XG4gIHBhZGRpbmc6IDA7XG4gIGJvcmRlcjogMXB4IHNvbGlkICNlZWVlZWU7XG4gIGJveC1zaGFkb3c6IDFweCAxcHggM3B4IDBweCAjYmJiYmJiO1xufVxuZGl2IHVsIG9sIHtcbiAgY3Vyc29yOiBwb2ludGVyO1xuICBsaXN0LXN0eWxlOiBub25lO1xuICBiYWNrZ3JvdW5kOiAjZmZmZmZmO1xuICBtaW4td2lkdGg6IDIwcHg7XG4gIHBhZGRpbmc6IDVweCAxMHB4O1xufVxuZGl2IHVsIG9sOmhvdmVyIHtcbiAgYmFja2dyb3VuZDogI2VlZWVlZTtcbn1cbmRpdiB1bDpmaXJzdC1jaGlsZCB7XG4gIGJhY2tncm91bmQ6ICNmOWY5Zjk7XG59Il19 */");

/***/ }),

/***/ "./src/app/gi-viewer/html/dropdown-menu.component.ts":
/*!***********************************************************!*\
  !*** ./src/app/gi-viewer/html/dropdown-menu.component.ts ***!
  \***********************************************************/
/*! exports provided: DropdownMenuComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DropdownMenuComponent", function() { return DropdownMenuComponent; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};

let DropdownMenuComponent = class DropdownMenuComponent {
    constructor() {
        this.selected = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
    }
    setItems(items, label) {
        const dropdownMenu = [];
        items.map(item => dropdownMenu.push({ id: item, label: `${label}${item}` }));
        // console.log('dropdownMenu', dropdownMenu);
        this.items = dropdownMenu;
    }
    selectItem(item) {
        this.visible = false;
        this.selected.emit(item.id);
    }
};
__decorate([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"])(),
    __metadata("design:type", Object)
], DropdownMenuComponent.prototype, "selected", void 0);
DropdownMenuComponent = __decorate([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"])({
        selector: 'dropdown-menu',
        template: __importDefault(__webpack_require__(/*! raw-loader!./dropdown-menu.component.html */ "./node_modules/raw-loader/dist/cjs.js!./src/app/gi-viewer/html/dropdown-menu.component.html")).default,
        styles: [__importDefault(__webpack_require__(/*! ./dropdown-menu.component.scss */ "./src/app/gi-viewer/html/dropdown-menu.component.scss")).default]
    })
], DropdownMenuComponent);



/***/ }),

/***/ "./src/app/gi-viewer/html/modal-window.component.scss":
/*!************************************************************!*\
  !*** ./src/app/gi-viewer/html/modal-window.component.scss ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("@charset \"UTF-8\";\n.modal-window {\n  border-right: 1px solid #bdbdbd;\n  max-width: 777px;\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  z-index: 1000;\n  overflow: auto;\n  -webkit-transition: transform 1s ease;\n}\n.modal-window.open {\n  -webkit-animation: slide 0.5s forwards;\n  animation: slide 0.5s forwards;\n}\n.modal-window     .modal-body {\n  padding: 20px;\n  background: #fff;\n  margin: 0;\n  min-height: calc(100% - 40px);\n  position: relative;\n}\n@-webkit-keyframes slide {\n  100% {\n    left: 0;\n  }\n}\n@keyframes slide {\n  100% {\n    left: 0;\n  }\n}\n.modal-background {\n  position: fixed;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  background-color: transparent;\n  opacity: 0.5;\n  z-index: 900;\n}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9hcHAvZ2ktdmlld2VyL2h0bWwvbW9kYWwtd2luZG93LmNvbXBvbmVudC5zY3NzIiwic3JjL2FwcC9naS12aWV3ZXIvaHRtbC9DOlxcVXNlcnNcXGFraWJkcHRcXERvY3VtZW50c1xcQW5ndWxhclxcbW9iaXVzLXZpZXdlci9zcmNcXGFwcFxcZ2ktdmlld2VyXFxodG1sXFxtb2RhbC13aW5kb3cuY29tcG9uZW50LnNjc3MiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsZ0JBQWdCO0FDQWhCO0VBQ0ksK0JBQUE7RUFDQSxnQkFBQTtFQUNBLGtCQUFBO0VBQ0EsTUFBQTtFQUNBLFFBQUE7RUFDQSxTQUFBO0VBRUEsYUFBQTtFQUNBLGNBQUE7RUFDQSxxQ0FBQTtBRENKO0FDQUk7RUFDSSxzQ0FBQTtFQUNBLDhCQUFBO0FERVI7QUNDQTtFQUNRLGFBQUE7RUFDQSxnQkFBQTtFQUNBLFNBQUE7RUFDQSw2QkFBQTtFQUlBLGtCQUFBO0FERlI7QUNPQTtFQUNJO0lBQU8sT0FBQTtFREhUO0FBQ0Y7QUNLQTtFQUNJO0lBQU8sT0FBQTtFREZUO0FBQ0Y7QUNJQTtFQUNJLGVBQUE7RUFDQSxNQUFBO0VBQ0EsUUFBQTtFQUNBLFNBQUE7RUFDQSxPQUFBO0VBQ0EsNkJBQUE7RUFDQSxZQUFBO0VBQ0EsWUFBQTtBREZKIiwiZmlsZSI6InNyYy9hcHAvZ2ktdmlld2VyL2h0bWwvbW9kYWwtd2luZG93LmNvbXBvbmVudC5zY3NzIiwic291cmNlc0NvbnRlbnQiOlsiQGNoYXJzZXQgXCJVVEYtOFwiO1xuLm1vZGFsLXdpbmRvdyB7XG4gIGJvcmRlci1yaWdodDogMXB4IHNvbGlkICNiZGJkYmQ7XG4gIG1heC13aWR0aDogNzc3cHg7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgdG9wOiAwO1xuICByaWdodDogMDtcbiAgYm90dG9tOiAwO1xuICB6LWluZGV4OiAxMDAwO1xuICBvdmVyZmxvdzogYXV0bztcbiAgLXdlYmtpdC10cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMXMgZWFzZTtcbn1cbi5tb2RhbC13aW5kb3cub3BlbiB7XG4gIC13ZWJraXQtYW5pbWF0aW9uOiBzbGlkZSAwLjVzIGZvcndhcmRzO1xuICBhbmltYXRpb246IHNsaWRlIDAuNXMgZm9yd2FyZHM7XG59XG4ubW9kYWwtd2luZG93IMKgwqDCoMKgLm1vZGFsLWJvZHkge1xuICBwYWRkaW5nOiAyMHB4O1xuICBiYWNrZ3JvdW5kOiAjZmZmO1xuICBtYXJnaW46IDA7XG4gIG1pbi1oZWlnaHQ6IGNhbGMoMTAwJSAtIDQwcHgpO1xuICBwb3NpdGlvbjogcmVsYXRpdmU7XG59XG5cbkAtd2Via2l0LWtleWZyYW1lcyBzbGlkZSB7XG4gIDEwMCUge1xuICAgIGxlZnQ6IDA7XG4gIH1cbn1cbkBrZXlmcmFtZXMgc2xpZGUge1xuICAxMDAlIHtcbiAgICBsZWZ0OiAwO1xuICB9XG59XG4ubW9kYWwtYmFja2dyb3VuZCB7XG4gIHBvc2l0aW9uOiBmaXhlZDtcbiAgdG9wOiAwO1xuICByaWdodDogMDtcbiAgYm90dG9tOiAwO1xuICBsZWZ0OiAwO1xuICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcbiAgb3BhY2l0eTogMC41O1xuICB6LWluZGV4OiA5MDA7XG59IiwiLm1vZGFsLXdpbmRvdyB7XHJcbiAgICBib3JkZXItcmlnaHQ6IDFweCBzb2xpZCAjYmRiZGJkO1xyXG4gICAgbWF4LXdpZHRoOiA3NzdweDtcclxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcclxuICAgIHRvcDogMDtcclxuICAgIHJpZ2h0OiAwO1xyXG4gICAgYm90dG9tOiAwO1xyXG4gICAgLy8gbGVmdDogMDtcclxuICAgIHotaW5kZXg6IDEwMDA7XHJcbiAgICBvdmVyZmxvdzogYXV0bztcclxuICAgIC13ZWJraXQtdHJhbnNpdGlvbjogdHJhbnNmb3JtIDFzIGVhc2U7XHJcbiAgICAmLm9wZW57XHJcbiAgICAgICAgLXdlYmtpdC1hbmltYXRpb246IHNsaWRlIDAuNXMgZm9yd2FyZHM7XHJcbiAgICAgICAgYW5pbWF0aW9uOiBzbGlkZSAwLjVzIGZvcndhcmRzO1xyXG4gICAgfVxyXG5cclxuwqDCoMKgwqAubW9kYWwtYm9keSB7XHJcbiAgICAgICAgcGFkZGluZzogMjBweDtcclxuICAgICAgICBiYWNrZ3JvdW5kOiAjZmZmO1xyXG4gICAgICAgIG1hcmdpbjogMDtcclxuICAgICAgICBtaW4taGVpZ2h0OiBjYWxjKDEwMCUgLSA0MHB4KTtcclxuICAgICAgICAvLyB3aWR0aDogNTAlO1xyXG4gICAgICAgIC8vIG1hcmdpbi1sZWZ0OiA1MCU7XHJcbiAgICAgICAgLy8gbGVmdDogLTI1JTtcclxuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5ALXdlYmtpdC1rZXlmcmFtZXMgc2xpZGUge1xyXG4gICAgMTAwJSB7IGxlZnQ6IDA7IH1cclxufVxyXG5cclxuQGtleWZyYW1lcyBzbGlkZSB7XHJcbiAgICAxMDAlIHsgbGVmdDogMDsgfVxyXG59XHJcblxyXG4ubW9kYWwtYmFja2dyb3VuZCB7XHJcbiAgICBwb3NpdGlvbjogZml4ZWQ7XHJcbiAgICB0b3A6IDA7XHJcbiAgICByaWdodDogMDtcclxuICAgIGJvdHRvbTogMDtcclxuICAgIGxlZnQ6IDA7XHJcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcclxuICAgIG9wYWNpdHk6IDAuNTtcclxuICAgIHotaW5kZXg6IDkwMDtcclxufSJdfQ== */");

/***/ }),

/***/ "./src/app/gi-viewer/html/modal-window.component.ts":
/*!**********************************************************!*\
  !*** ./src/app/gi-viewer/html/modal-window.component.ts ***!
  \**********************************************************/
/*! exports provided: ModalWindowComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ModalWindowComponent", function() { return ModalWindowComponent; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
/* harmony import */ var _modal_window_service__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modal-window.service */ "./src/app/gi-viewer/html/modal-window.service.ts");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};


let ModalWindowComponent = class ModalWindowComponent {
    constructor(modalService, el) {
        this.modalService = modalService;
        this.el = el;
        this.closeModal = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this.element = el.nativeElement;
    }
    ngOnInit() {
        const modal = this;
        // ensure id attribute exists
        if (!this.id) {
            console.error('modal must have an id');
            return;
        }
        let leftContent = document.getElementsByClassName('content__panel')[0];
        this.containerWidth = leftContent.clientWidth;
        let modalWindow = this.element.querySelector('.modal-window');
        // modalWindow.style.width = `${this.containerWidth + 11}px`;
        // modalWindow.style.left = `${-this.containerWidth - 11}px`;
        modalWindow.style.width = '500px';
        modalWindow.style.left = '-500px';
        // move element to bottom of page (just before </body>) so it can be displayed above everything else
        document.body.appendChild(this.element);
        const closeModal = this.closeModal;
        // close modal on background click
        this.element.addEventListener('click', function (e) {
            if (e.target.className === 'modal-background') {
                modal.close();
                closeModal.emit();
            }
        });
        // add self (this modal instance) to the modal service so it's accessible from controllers
        this.modalService.add(this);
        leftContent = null;
        modalWindow = null;
    }
    // remove self from modal service when directive is destroyed
    ngOnDestroy() {
        this.modalService.remove(this.id);
        this.element.remove();
        this.element = null;
    }
    // open modal
    open() {
        let modalWindow = document.getElementById('modal-window');
        // modalWindow.style.left = 0;
        modalWindow.classList.add('open');
        this.element.style.display = 'block';
        document.body.classList.add('modal-open');
        modalWindow = null;
    }
    // close modal
    close() {
        this.element.style.display = 'none';
        const modalWindow = this.element.querySelector('.modal-window');
        // modalWindow.style.left = `${-this.containerWidth - 11}px`;
        modalWindow.classList.remove('open');
        document.body.classList.remove('modal-open');
    }
};
ModalWindowComponent.ctorParameters = () => [
    { type: _modal_window_service__WEBPACK_IMPORTED_MODULE_1__["ModalService"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] }
];
__decorate([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(),
    __metadata("design:type", String)
], ModalWindowComponent.prototype, "id", void 0);
__decorate([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"])(),
    __metadata("design:type", Object)
], ModalWindowComponent.prototype, "closeModal", void 0);
ModalWindowComponent = __decorate([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"])({
        selector: 'modal-window',
        template: __importDefault(__webpack_require__(/*! raw-loader!./modal-window.component.html */ "./node_modules/raw-loader/dist/cjs.js!./src/app/gi-viewer/html/modal-window.component.html")).default,
        styles: [__importDefault(__webpack_require__(/*! ./modal-window.component.scss */ "./src/app/gi-viewer/html/modal-window.component.scss")).default]
    }),
    __metadata("design:paramtypes", [_modal_window_service__WEBPACK_IMPORTED_MODULE_1__["ModalService"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"]])
], ModalWindowComponent);



/***/ }),

/***/ "./src/app/gi-viewer/html/modal-window.service.ts":
/*!********************************************************!*\
  !*** ./src/app/gi-viewer/html/modal-window.service.ts ***!
  \********************************************************/
/*! exports provided: ModalService */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ModalService", function() { return ModalService; });
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};
class ModalService {
    constructor() {
        this.modals = [];
    }
    add(modal) {
        // add modal to array of active modals
        this.modals.push(modal);
    }
    remove(id) {
        // remove modal from array of active modals
        this.modals = this.modals.filter(x => x.id !== id);
    }
    open(id) {
        const modal = this.modals.filter(x => x.id === id)[0];
        modal.open();
    }
    close(id) {
        // close modal specified by id
        const modal = this.modals.filter(x => x.id === id)[0];
        modal.close();
    }
}


/***/ }),

/***/ "./src/app/gi-viewer/html/tab.component.ts":
/*!*************************************************!*\
  !*** ./src/app/gi-viewer/html/tab.component.ts ***!
  \*************************************************/
/*! exports provided: TabComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TabComponent", function() { return TabComponent; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};

let TabComponent = class TabComponent {
    constructor() {
        this.active = false;
    }
};
__decorate([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])('tabTitle'),
    __metadata("design:type", String)
], TabComponent.prototype, "title", void 0);
__decorate([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(),
    __metadata("design:type", Object)
], TabComponent.prototype, "active", void 0);
__decorate([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])('index'),
    __metadata("design:type", Number)
], TabComponent.prototype, "index", void 0);
TabComponent = __decorate([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"])({
        selector: 'tab',
        template: `
    <div [hidden]="!active" class="pane">
      <ng-content></ng-content>
    </div>
  `,
        styles: ["\n    .pane{\n      padding: 0;\n    }\n  "]
    })
], TabComponent);



/***/ }),

/***/ "./src/app/gi-viewer/html/tabs.component.scss":
/*!****************************************************!*\
  !*** ./src/app/gi-viewer/html/tabs.component.scss ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("/* Style The Dropdown Button */\n.dropbtn {\n  background-color: transparent;\n  color: #808080;\n  border: 1px solid transparent;\n  cursor: pointer;\n  font-family: sans-serif;\n  font-weight: 550;\n  font-size: 12px;\n  line-height: 15px;\n  outline: none;\n  text-align: center;\n  width: 100%;\n  height: 21px;\n  margin-top: -1px;\n  padding-right: 10px;\n  border-bottom: 2px solid transparent;\n}\n.dropbtn::after {\n  content: \"\";\n  width: 0;\n  height: 0;\n  border-left: 4px solid transparent;\n  border-right: 4px solid transparent;\n  border-top: 4px solid #505050;\n  border-bottom: none;\n  position: absolute;\n  top: 7px;\n  right: 6px;\n}\n/* The container <div> - needed to position the dropdown content */\n.dropdown {\n  position: absolute;\n  display: inline-block;\n  left: 0px;\n  width: 100%;\n}\n/* Dropdown Content (Hidden by Default) */\n.dropdown-content {\n  display: none;\n  position: absolute;\n  background-color: #ececec;\n  min-width: 85px;\n  box-shadow: 0px 8px 16px 0px rgba(0, 0, 0, 0.2);\n  z-index: 500;\n  top: 19px;\n}\n/* Links inside the dropdown */\n.dropdown-content div {\n  color: black;\n  padding: 6px 8px;\n  text-decoration: none;\n}\n/* Change color of dropdown links on hover */\n.dropdown-content div:hover {\n  background-color: #fefefe;\n}\n/* Show the dropdown menu on hover */\n/* Change the background color of the dropdown button when the dropdown content is shown */\n.dropdown:hover .dropbtn {\n  color: #00006d;\n}\n.nav-tabs li.active .dropbtn {\n  color: #00006d;\n  background-color: whitesmoke;\n  border: 1px solid #B3B3B3;\n  border-bottom: 2px solid whitesmoke;\n}\n.nav-tabs li.open .dropbtn::after {\n  content: \"\";\n  border-top: none;\n  border-bottom: 4px solid #505050;\n}\n#topology_dropdown, #object_dropdown {\n  display: none;\n  position: absolute;\n  width: -webkit-fit-content;\n  width: -moz-fit-content;\n  width: fit-content;\n  transition: display 0.4s;\n  z-index: 99999999;\n  background-color: #fafafb;\n  border: 1px solid #808080;\n  box-shadow: none;\n}\n#topology_dropdown div, #object_dropdown div {\n  cursor: pointer;\n  display: block;\n  min-width: 100px;\n  max-width: 300px;\n  overflow: hidden;\n  line-height: 20px;\n  background-color: #fafafb;\n  border: 0px;\n  margin: 0px;\n  padding: 0px 10px 0px 10px;\n  line-height: 30px;\n  height: 30px;\n  font-size: 12px;\n  color: #373737;\n}\n#topology_dropdown div:hover, #object_dropdown div:hover {\n  color: #00006d;\n  background-color: #E6E6E6;\n}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9hcHAvZ2ktdmlld2VyL2h0bWwvQzpcXFVzZXJzXFxha2liZHB0XFxEb2N1bWVudHNcXEFuZ3VsYXJcXG1vYml1cy12aWV3ZXIvc3JjXFxhcHBcXGdpLXZpZXdlclxcaHRtbFxcdGFicy5jb21wb25lbnQuc2NzcyIsInNyYy9hcHAvZ2ktdmlld2VyL2h0bWwvdGFicy5jb21wb25lbnQuc2NzcyIsInNyYy9hcHAvZ2ktdmlld2VyL2h0bWwvQzpcXFVzZXJzXFxha2liZHB0XFxEb2N1bWVudHNcXEFuZ3VsYXJcXG1vYml1cy12aWV3ZXIvc3JjXFxzY3NzXFxjb2xvcnMuc2NzcyIsInNyYy9hcHAvZ2ktdmlld2VyL2h0bWwvQzpcXFVzZXJzXFxha2liZHB0XFxEb2N1bWVudHNcXEFuZ3VsYXJcXG1vYml1cy12aWV3ZXIvc3JjXFxzY3NzXFx2YXJpYWJsZXMuc2NzcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFHQSw4QkFBQTtBQUNBO0VBQ0ksNkJBQUE7RUFDQSxjQUFBO0VBQ0EsNkJBQUE7RUFDQSxlQUFBO0VBQ0EsdUJBQUE7RUFDQSxnQkFBQTtFQUNBLGVBQUE7RUFDQSxpQkFBQTtFQUNBLGFBQUE7RUFDQSxrQkFBQTtFQUNBLFdBQUE7RUFDQSxZQUFBO0VBQ0EsZ0JBQUE7RUFDQSxtQkFBQTtFQUNBLG9DQUFBO0FDRko7QURLQTtFQUNJLFdBQUE7RUFDQSxRQUFBO0VBQ0EsU0FBQTtFQUNBLGtDQUFBO0VBQ0EsbUNBQUE7RUFDQSw2QkFBQTtFQUNBLG1CQUFBO0VBQ0Esa0JBQUE7RUFDQSxRQUFBO0VBQ0EsVUFBQTtBQ0ZKO0FES0Usa0VBQUE7QUFDQTtFQUNFLGtCQUFBO0VBQ0EscUJBQUE7RUFDQSxTQUFBO0VBQ0EsV0FBQTtBQ0ZKO0FES0UseUNBQUE7QUFDQTtFQUNFLGFBQUE7RUFDQSxrQkFBQTtFQUNBLHlCQUFBO0VBQ0EsZUFBQTtFQUNBLCtDQUFBO0VBQ0EsWUFBQTtFQUNBLFNBQUE7QUNGSjtBREtFLDhCQUFBO0FBQ0E7RUFDRSxZQUFBO0VBQ0EsZ0JBQUE7RUFDQSxxQkFBQTtBQ0ZKO0FES0UsNENBQUE7QUFDQTtFQUE2Qix5QkFBQTtBQ0QvQjtBREdFLG9DQUFBO0FBS0EsMEZBQUE7QUFDQTtFQUNFLGNBQUE7QUNKSjtBRFNRO0VBQ0ksY0FBQTtFQUNBLDRCQUFBO0VBQ0EseUJBQUE7RUFDQSxtQ0FBQTtBQ05aO0FEVVE7RUFDSSxXQUFBO0VBQ0EsZ0JBQUE7RUFDQSxnQ0FBQTtBQ1JaO0FEYUE7RUFDSSxhQUFBO0VBQ0Esa0JBQUE7RUFDQSwwQkFBQTtFQUFBLHVCQUFBO0VBQUEsa0JBQUE7RUFDQSx3QkFBQTtFQUVBLGlCQUFBO0VBQ0EseUJFNUZLO0VGNkZMLHlCQUFBO0VBQ0EsZ0JBQUE7QUNYSjtBRGFJO0VBQ0ksZUFBQTtFQUNBLGNBQUE7RUFDQSxnQkFBQTtFQUNBLGdCQUFBO0VBQ0EsZ0JBQUE7RUFDQSxpQkFBQTtFQUNBLHlCRXZHQztFRndHRCxXQUFBO0VBQ0EsV0FBQTtFQUNBLDBCQUFBO0VBQ0EsaUJHNUdDO0VINkdELFlHN0dDO0VIOEdELGVHL0dDO0VIZ0hELGNFM0dDO0FEZ0dUO0FEWVE7RUFDSSxjRTNHSztFRjRHTCx5QkVuSEg7QUR5R1QiLCJmaWxlIjoic3JjL2FwcC9naS12aWV3ZXIvaHRtbC90YWJzLmNvbXBvbmVudC5zY3NzIiwic291cmNlc0NvbnRlbnQiOlsiQGltcG9ydCAnfnNjc3MvY29sb3JzJztcclxuQGltcG9ydCAnfnNjc3MvdmFyaWFibGVzJztcclxuXHJcbi8qIFN0eWxlIFRoZSBEcm9wZG93biBCdXR0b24gKi9cclxuLmRyb3BidG4ge1xyXG4gICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XHJcbiAgICBjb2xvcjogIzgwODA4MDtcclxuICAgIGJvcmRlcjogMXB4IHNvbGlkIHRyYW5zcGFyZW50O1xyXG4gICAgY3Vyc29yOiBwb2ludGVyO1xyXG4gICAgZm9udC1mYW1pbHk6IHNhbnMtc2VyaWY7XHJcbiAgICBmb250LXdlaWdodDogNTUwO1xyXG4gICAgZm9udC1zaXplOiAxMnB4O1xyXG4gICAgbGluZS1oZWlnaHQ6IDE1cHg7XHJcbiAgICBvdXRsaW5lOiBub25lO1xyXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xyXG4gICAgd2lkdGg6IDEwMCU7XHJcbiAgICBoZWlnaHQ6IDIxcHg7XHJcbiAgICBtYXJnaW4tdG9wOiAtMXB4O1xyXG4gICAgcGFkZGluZy1yaWdodDogMTBweDtcclxuICAgIGJvcmRlci1ib3R0b206IDJweCBzb2xpZCB0cmFuc3BhcmVudDtcclxufVxyXG5cclxuLmRyb3BidG46OmFmdGVye1xyXG4gICAgY29udGVudDogJyc7XHJcbiAgICB3aWR0aDogMDsgXHJcbiAgICBoZWlnaHQ6IDA7IFxyXG4gICAgYm9yZGVyLWxlZnQ6IDRweCBzb2xpZCB0cmFuc3BhcmVudDtcclxuICAgIGJvcmRlci1yaWdodDogNHB4IHNvbGlkIHRyYW5zcGFyZW50O1xyXG4gICAgYm9yZGVyLXRvcDogNHB4IHNvbGlkICM1MDUwNTA7XHJcbiAgICBib3JkZXItYm90dG9tOiBub25lO1xyXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xyXG4gICAgdG9wOiA3cHg7XHJcbiAgICByaWdodDogNnB4O1xyXG59XHJcbiAgXHJcbiAgLyogVGhlIGNvbnRhaW5lciA8ZGl2PiAtIG5lZWRlZCB0byBwb3NpdGlvbiB0aGUgZHJvcGRvd24gY29udGVudCAqL1xyXG4gIC5kcm9wZG93biB7XHJcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XHJcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XHJcbiAgICBsZWZ0OiAwcHg7XHJcbiAgICB3aWR0aDogMTAwJTtcclxuICB9XHJcbiAgXHJcbiAgLyogRHJvcGRvd24gQ29udGVudCAoSGlkZGVuIGJ5IERlZmF1bHQpICovXHJcbiAgLmRyb3Bkb3duLWNvbnRlbnQge1xyXG4gICAgZGlzcGxheTogbm9uZTtcclxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcclxuICAgIGJhY2tncm91bmQtY29sb3I6ICNlY2VjZWM7XHJcbiAgICBtaW4td2lkdGg6IDg1cHg7XHJcbiAgICBib3gtc2hhZG93OiAwcHggOHB4IDE2cHggMHB4IHJnYmEoMCwwLDAsMC4yKTtcclxuICAgIHotaW5kZXg6IDUwMDtcclxuICAgIHRvcDogMTlweDtcclxuICB9XHJcbiAgXHJcbiAgLyogTGlua3MgaW5zaWRlIHRoZSBkcm9wZG93biAqL1xyXG4gIC5kcm9wZG93bi1jb250ZW50IGRpdiB7XHJcbiAgICBjb2xvcjogYmxhY2s7XHJcbiAgICBwYWRkaW5nOiA2cHggOHB4O1xyXG4gICAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xyXG4gIH1cclxuICBcclxuICAvKiBDaGFuZ2UgY29sb3Igb2YgZHJvcGRvd24gbGlua3Mgb24gaG92ZXIgKi9cclxuICAuZHJvcGRvd24tY29udGVudCBkaXY6aG92ZXIge2JhY2tncm91bmQtY29sb3I6ICNmZWZlZmV9XHJcbiAgXHJcbiAgLyogU2hvdyB0aGUgZHJvcGRvd24gbWVudSBvbiBob3ZlciAqL1xyXG4gIC5kcm9wZG93bjpob3ZlciAuZHJvcGRvd24tY29udGVudCB7XHJcbiAgICAvLyBkaXNwbGF5OiBibG9jaztcclxuICB9XHJcbiAgXHJcbiAgLyogQ2hhbmdlIHRoZSBiYWNrZ3JvdW5kIGNvbG9yIG9mIHRoZSBkcm9wZG93biBidXR0b24gd2hlbiB0aGUgZHJvcGRvd24gY29udGVudCBpcyBzaG93biAqL1xyXG4gIC5kcm9wZG93bjpob3ZlciAuZHJvcGJ0biB7XHJcbiAgICBjb2xvcjogIzAwMDA2ZFxyXG59XHJcblxyXG4ubmF2LXRhYnN7XHJcbiAgICBsaS5hY3RpdmV7XHJcbiAgICAgICAgLmRyb3BidG57XHJcbiAgICAgICAgICAgIGNvbG9yOiAjMDAwMDZkO1xyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZXNtb2tlO1xyXG4gICAgICAgICAgICBib3JkZXI6IDFweCBzb2xpZCAjQjNCM0IzO1xyXG4gICAgICAgICAgICBib3JkZXItYm90dG9tOiAycHggc29saWQgd2hpdGVzbW9rZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBsaS5vcGVue1xyXG4gICAgICAgIC5kcm9wYnRuOjphZnRlcntcclxuICAgICAgICAgICAgY29udGVudDogJyc7XHJcbiAgICAgICAgICAgIGJvcmRlci10b3A6IG5vbmU7XHJcbiAgICAgICAgICAgIGJvcmRlci1ib3R0b206IDRweCBzb2xpZCAjNTA1MDUwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuI3RvcG9sb2d5X2Ryb3Bkb3duLCAjb2JqZWN0X2Ryb3Bkb3duIHtcclxuICAgIGRpc3BsYXk6IG5vbmU7XHJcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XHJcbiAgICB3aWR0aDogZml0LWNvbnRlbnQ7XHJcbiAgICB0cmFuc2l0aW9uOiBkaXNwbGF5IDAuNHM7XHJcblxyXG4gICAgei1pbmRleDogOTk5OTk5OTk7XHJcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkY29sb3I2O1xyXG4gICAgYm9yZGVyOiAxcHggc29saWQgJGNvbG9yMTtcclxuICAgIGJveC1zaGFkb3c6IG5vbmU7XHJcblxyXG4gICAgZGl2e1xyXG4gICAgICAgIGN1cnNvcjogcG9pbnRlcjtcclxuICAgICAgICBkaXNwbGF5OiBibG9jaztcclxuICAgICAgICBtaW4td2lkdGg6IDEwMHB4O1xyXG4gICAgICAgIG1heC13aWR0aDogMzAwcHg7XHJcbiAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcclxuICAgICAgICBsaW5lLWhlaWdodDogMjBweDtcclxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkY29sb3I2O1xyXG4gICAgICAgIGJvcmRlcjogMHB4O1xyXG4gICAgICAgIG1hcmdpbjogMHB4O1xyXG4gICAgICAgIHBhZGRpbmc6IDBweCAxMHB4IDBweCAxMHB4O1xyXG4gICAgICAgIGxpbmUtaGVpZ2h0OiAkZnNpemUzO1xyXG4gICAgICAgIGhlaWdodDogJGZzaXplMztcclxuICAgICAgICBmb250LXNpemU6ICRmc2l6ZTI7XHJcbiAgICAgICAgY29sb3I6ICRjb2xvcjg7XHJcbiAgICAgICAgJjpob3ZlcntcclxuICAgICAgICAgICAgY29sb3I6ICRzZWxlY3RlZC1jb2xvcjtcclxuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogJGNvbG9yNTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG59IiwiLyogU3R5bGUgVGhlIERyb3Bkb3duIEJ1dHRvbiAqL1xuLmRyb3BidG4ge1xuICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcbiAgY29sb3I6ICM4MDgwODA7XG4gIGJvcmRlcjogMXB4IHNvbGlkIHRyYW5zcGFyZW50O1xuICBjdXJzb3I6IHBvaW50ZXI7XG4gIGZvbnQtZmFtaWx5OiBzYW5zLXNlcmlmO1xuICBmb250LXdlaWdodDogNTUwO1xuICBmb250LXNpemU6IDEycHg7XG4gIGxpbmUtaGVpZ2h0OiAxNXB4O1xuICBvdXRsaW5lOiBub25lO1xuICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gIHdpZHRoOiAxMDAlO1xuICBoZWlnaHQ6IDIxcHg7XG4gIG1hcmdpbi10b3A6IC0xcHg7XG4gIHBhZGRpbmctcmlnaHQ6IDEwcHg7XG4gIGJvcmRlci1ib3R0b206IDJweCBzb2xpZCB0cmFuc3BhcmVudDtcbn1cblxuLmRyb3BidG46OmFmdGVyIHtcbiAgY29udGVudDogXCJcIjtcbiAgd2lkdGg6IDA7XG4gIGhlaWdodDogMDtcbiAgYm9yZGVyLWxlZnQ6IDRweCBzb2xpZCB0cmFuc3BhcmVudDtcbiAgYm9yZGVyLXJpZ2h0OiA0cHggc29saWQgdHJhbnNwYXJlbnQ7XG4gIGJvcmRlci10b3A6IDRweCBzb2xpZCAjNTA1MDUwO1xuICBib3JkZXItYm90dG9tOiBub25lO1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIHRvcDogN3B4O1xuICByaWdodDogNnB4O1xufVxuXG4vKiBUaGUgY29udGFpbmVyIDxkaXY+IC0gbmVlZGVkIHRvIHBvc2l0aW9uIHRoZSBkcm9wZG93biBjb250ZW50ICovXG4uZHJvcGRvd24ge1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgbGVmdDogMHB4O1xuICB3aWR0aDogMTAwJTtcbn1cblxuLyogRHJvcGRvd24gQ29udGVudCAoSGlkZGVuIGJ5IERlZmF1bHQpICovXG4uZHJvcGRvd24tY29udGVudCB7XG4gIGRpc3BsYXk6IG5vbmU7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgYmFja2dyb3VuZC1jb2xvcjogI2VjZWNlYztcbiAgbWluLXdpZHRoOiA4NXB4O1xuICBib3gtc2hhZG93OiAwcHggOHB4IDE2cHggMHB4IHJnYmEoMCwgMCwgMCwgMC4yKTtcbiAgei1pbmRleDogNTAwO1xuICB0b3A6IDE5cHg7XG59XG5cbi8qIExpbmtzIGluc2lkZSB0aGUgZHJvcGRvd24gKi9cbi5kcm9wZG93bi1jb250ZW50IGRpdiB7XG4gIGNvbG9yOiBibGFjaztcbiAgcGFkZGluZzogNnB4IDhweDtcbiAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xufVxuXG4vKiBDaGFuZ2UgY29sb3Igb2YgZHJvcGRvd24gbGlua3Mgb24gaG92ZXIgKi9cbi5kcm9wZG93bi1jb250ZW50IGRpdjpob3ZlciB7XG4gIGJhY2tncm91bmQtY29sb3I6ICNmZWZlZmU7XG59XG5cbi8qIFNob3cgdGhlIGRyb3Bkb3duIG1lbnUgb24gaG92ZXIgKi9cbi8qIENoYW5nZSB0aGUgYmFja2dyb3VuZCBjb2xvciBvZiB0aGUgZHJvcGRvd24gYnV0dG9uIHdoZW4gdGhlIGRyb3Bkb3duIGNvbnRlbnQgaXMgc2hvd24gKi9cbi5kcm9wZG93bjpob3ZlciAuZHJvcGJ0biB7XG4gIGNvbG9yOiAjMDAwMDZkO1xufVxuXG4ubmF2LXRhYnMgbGkuYWN0aXZlIC5kcm9wYnRuIHtcbiAgY29sb3I6ICMwMDAwNmQ7XG4gIGJhY2tncm91bmQtY29sb3I6IHdoaXRlc21va2U7XG4gIGJvcmRlcjogMXB4IHNvbGlkICNCM0IzQjM7XG4gIGJvcmRlci1ib3R0b206IDJweCBzb2xpZCB3aGl0ZXNtb2tlO1xufVxuLm5hdi10YWJzIGxpLm9wZW4gLmRyb3BidG46OmFmdGVyIHtcbiAgY29udGVudDogXCJcIjtcbiAgYm9yZGVyLXRvcDogbm9uZTtcbiAgYm9yZGVyLWJvdHRvbTogNHB4IHNvbGlkICM1MDUwNTA7XG59XG5cbiN0b3BvbG9neV9kcm9wZG93biwgI29iamVjdF9kcm9wZG93biB7XG4gIGRpc3BsYXk6IG5vbmU7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgd2lkdGg6IGZpdC1jb250ZW50O1xuICB0cmFuc2l0aW9uOiBkaXNwbGF5IDAuNHM7XG4gIHotaW5kZXg6IDk5OTk5OTk5O1xuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmFmYWZiO1xuICBib3JkZXI6IDFweCBzb2xpZCAjODA4MDgwO1xuICBib3gtc2hhZG93OiBub25lO1xufVxuI3RvcG9sb2d5X2Ryb3Bkb3duIGRpdiwgI29iamVjdF9kcm9wZG93biBkaXYge1xuICBjdXJzb3I6IHBvaW50ZXI7XG4gIGRpc3BsYXk6IGJsb2NrO1xuICBtaW4td2lkdGg6IDEwMHB4O1xuICBtYXgtd2lkdGg6IDMwMHB4O1xuICBvdmVyZmxvdzogaGlkZGVuO1xuICBsaW5lLWhlaWdodDogMjBweDtcbiAgYmFja2dyb3VuZC1jb2xvcjogI2ZhZmFmYjtcbiAgYm9yZGVyOiAwcHg7XG4gIG1hcmdpbjogMHB4O1xuICBwYWRkaW5nOiAwcHggMTBweCAwcHggMTBweDtcbiAgbGluZS1oZWlnaHQ6IDMwcHg7XG4gIGhlaWdodDogMzBweDtcbiAgZm9udC1zaXplOiAxMnB4O1xuICBjb2xvcjogIzM3MzczNztcbn1cbiN0b3BvbG9neV9kcm9wZG93biBkaXY6aG92ZXIsICNvYmplY3RfZHJvcGRvd24gZGl2OmhvdmVyIHtcbiAgY29sb3I6ICMwMDAwNmQ7XG4gIGJhY2tncm91bmQtY29sb3I6ICNFNkU2RTY7XG59IiwiXHJcbiRjb2xvcjE6ICM4MDgwODA7XHJcbiRjb2xvcjI6ICM5OTk5OTk7XHJcbiRjb2xvcjM6ICNCM0IzQjM7IFxyXG4kY29sb3I0OiAjQ0NDQ0NDO1xyXG4kY29sb3I1OiAjRTZFNkU2O1xyXG4kY29sb3I1LTU6IHJnYigyNDUsIDI0NSwgMjQ1KTtcclxuJGNvbG9yNjogcmdiKDI1MCwgMjUwLCAyNTEpO1xyXG5cclxuJGNvbG9yNzogd2hpdGU7XHJcbiRjb2xvcjg6ICMzNzM3Mzc7XHJcblxyXG4kc2VsZWN0ZWQtY29sb3I6IHJnYigwLCAwLCAxMDkpO1xyXG4kc2VsZWN0ZWQtY29sb3IxOiByZ2IoMjI4LCAyMjgsIDI0Nyk7XHJcbiRzZWxlY3RlZC1jb2xvcjI6IHJnYigyMTUsIDIxNSwgMjU1KTtcclxuJGhvdmVyLWNvbG9yOiAkY29sb3IyO1xyXG5cclxuJGVycm9yLWNvbG9yOiAjRTk0ODU4OyAvL3BpbmstcmVkXHJcbiRlcnJvci1jb2xvci1sdDogcmdiKDI1NSwgMjIwLCAyMjQpO1xyXG4kcGNvbG9yMjogI0YzQTMyQTsgLy9vcmFuZ2UteWVsbG93XHJcbiRwcmludC1jb2xvcjogcmdiKDEzMCwgMTkxLCAxMTApOyAvL2xpZ2h0Z3JlZW5cclxuJHByaW50LWNvbG9yLWx0OiByZ2IoMjMwLCAyNTUsIDIyMSk7XHJcbiRwcmludC1jb2xvci1kazogcmdiKDYzLCA5OSwgNTEpOyAvL2xpZ2h0Z3JlZW5cclxuJHNlbGVjdEdlb20tY29sb3I6IHJnYigyNTUsIDE3NCwgMCk7IC8vIGxpZ2h0IG9yYW5nZVxyXG4kc2VsZWN0R2VvbS1jb2xvci1sdDogcmdiKDI1NSwgMjI1LCAxNjApO1xyXG5cclxuLy8gJHByb2QtYmFja2dyb3VuZC1jb2xvcjogcmdiKDI1MCwyNTAsMjUwKTtcclxuLy8gJGJhY2tncm91bmQtY29sb3I6IHJnYigyMjAsMjIwLDIyMCk7XHJcbiRmdW5jdGlvbi10ZXh0LWNvbG9yOiByZ2IoMTkwLCAxNDAsIDMwKTtcclxuJGZ1bmN0aW9uLXRleHQtY29sb3IyOiByZ2IoMTgsIDEyNiwgMTM2KTtcclxuJGZ1bmN0aW9uLXRleHQtY29sb3IzOiByZ2IoMTkwLCAxNDAsIDMwKTtcclxuJGJhc2ljLWZ1bmN0aW9uLXRleHQtY29sb3I6IHJnYigyMDAsIDcwLCAxNTApO1xyXG4kY29tbWVudC1jb2xvcjogZGFya2dyZWVuO1xyXG4iLCIkcGFkZGluZzogNDBweDsgLy8gPyBub3QgdXNlZFxyXG4kc21hbGwtcGFkZGluZzogMTVweDtcclxuJGhlYWRlci1oZWlnaHQ6IDQwcHg7XHJcblxyXG4kZnNpemUxOiAxNXB4O1xyXG4kZnNpemUyOiAxMnB4O1xyXG4kZnNpemUzOiAzMHB4O1xyXG5cclxuJHBvcnQtc2l6ZTogMTVweDtcclxuJGRlZmF1bHQtc2lkZS1wYWRkaW5nOiAxNXB4O1xyXG5cclxuJGRpc2FibGVkLW9wYWNpdHk6IDAuNDsiXX0= */");

/***/ }),

/***/ "./src/app/gi-viewer/html/tabs.component.ts":
/*!**************************************************!*\
  !*** ./src/app/gi-viewer/html/tabs.component.ts ***!
  \**************************************************/
/*! exports provided: TabsComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TabsComponent", function() { return TabsComponent; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
/* harmony import */ var _tab_component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tab.component */ "./src/app/gi-viewer/html/tab.component.ts");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};


let TabsComponent = class TabsComponent {
    ngAfterContentInit() {
        setTimeout(() => {
            const activeTabs = this.tabs.filter((tab) => tab.active);
            // if there is no active tab set, activate the first
            if (activeTabs.length === 0) {
                this.selectTab(this.tabs.first);
            }
        }, 0);
    }
    selectTab(tab) {
        // deactivate all tabs
        this.tabs.toArray().forEach(_tab => _tab.active = false);
        tab.active = true;
    }
};
__decorate([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ContentChildren"])(_tab_component__WEBPACK_IMPORTED_MODULE_1__["TabComponent"]),
    __metadata("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_0__["QueryList"])
], TabsComponent.prototype, "tabs", void 0);
TabsComponent = __decorate([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"])({
        selector: 'tabs',
        template: __importDefault(__webpack_require__(/*! raw-loader!./tabs.component.html */ "./node_modules/raw-loader/dist/cjs.js!./src/app/gi-viewer/html/tabs.component.html")).default,
        styles: [__importDefault(__webpack_require__(/*! ./tabs.component.scss */ "./src/app/gi-viewer/html/tabs.component.scss")).default]
    })
], TabsComponent);



/***/ }),

/***/ "./src/app/gi-viewer/threejs/threejs-viewer.component.scss":
/*!*****************************************************************!*\
  !*** ./src/app/gi-viewer/threejs/threejs-viewer.component.scss ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("button {\n  cursor: pointer;\n}\nbutton:focus {\n  outline: none;\n}\n:host {\n  width: 100%;\n  height: 100%;\n  background-color: green;\n  overflow: hidden;\n}\n#threejs-container {\n  position: relative;\n  height: 100%;\n  width: 100%;\n  margin: 0px;\n  overflow: hidden;\n  font-family: sans-serif;\n}\n#container-top-right-resize {\n  top: 0px;\n  right: 0px;\n}\n#giSummary, #tjsSummary {\n  position: absolute;\n  bottom: 5px;\n  left: 5px;\n  background: rgba(255, 255, 255, 0.3);\n  padding: 10px;\n  color: #2a8ac5;\n}\n#giSummary td, #tjsSummary td {\n  height: 17px;\n}\n#nodeSelect_slider {\n  position: absolute;\n  bottom: 5px;\n  right: 50px;\n  background: rgba(255, 255, 255, 0.3);\n  padding: 10px 25px 10px 10px;\n  color: #808080;\n}\n#nodeSelect_slider datalist {\n  width: 121%;\n  display: flex;\n}\n#nodeSelect_slider datalist option {\n  width: 15px;\n  padding: none;\n  flex-grow: 1;\n  right: 1px;\n}\n#nodeSelect_dropdown {\n  position: absolute;\n  bottom: 5px;\n  right: 50px;\n  background: rgba(255, 255, 255, 0.3);\n  padding: 10px 25px 10px 10px;\n  color: #808080;\n}\n#nodeSelect_dropdown datalist {\n  width: 121%;\n  display: flex;\n}\n#nodeSelect_dropdown datalist option {\n  width: 15px;\n  padding: none;\n  flex-grow: 1;\n  right: 1px;\n}\n/*#rotating{\n    width: 30px;\n    height: 25px;\n    font-size:15px;\n    right:0px; \n    text-align:center;\n    position: absolute;\n    top: 0px;\n    background-color:transparent;\n    border:0;\n}\n\n#paning{\n    width: 30px;\n    height: 25px;\n    font-size:15px;\n    right:0px; \n    text-align:center;\n    position: absolute;\n    top: 25px;\n    background-color:transparent;\n    border:0;\n}\n\n#zooming{\n    width: 30px;\n    height: 25px;\n    font-size:15px;\n    right:0px; \n    text-align:center;\n    position: absolute;\n    margin-top: 50px;\n    background-color:transparent;\n    border:0;\n}*/\n/*#imagery{\n    width: 30px;\n    height: 25px;\n    font-size:14px;\n    right:0px; \n    text-align:center;\n    position: absolute;\n    margin-top: 10px;\n    background-color:transparent;\n    border:0;\n}*/\n.messages {\n  position: absolute;\n  color: orange;\n  margin-top: 50px;\n  left: 40%;\n  padding: 10px;\n  text-align: center;\n  font-family: sans-serif;\n  font-size: 14px;\n  background-color: white;\n  box-shadow: 2px 2px 5px 0px #505050;\n}\n#zoomingfit {\n  width: 40px;\n  height: 30px;\n  font-size: 15px;\n  position: absolute;\n  top: 30px;\n  right: 0px;\n  text-align: center;\n  color: #808080;\n  background-color: transparent;\n  border: 0;\n}\n#zoomingfit:hover {\n  color: #00006d;\n}\n#EntitySelection {\n  width: 40px;\n  height: 30px;\n  font-size: 15px;\n  position: absolute;\n  top: 60px;\n  right: 0px;\n  text-align: center;\n  color: #808080;\n  background-color: transparent;\n  border: 0;\n}\n#EntitySelection:hover {\n  color: #00006d;\n}\n#SelectingEntityType {\n  width: 40px;\n  font-size: 15px;\n  position: absolute;\n  text-align: center;\n  color: #505050;\n  top: 90px;\n  right: 0px;\n  cursor: pointer;\n}\n#selectDropdown {\n  position: absolute;\n  top: 85px;\n  right: 5px;\n}\n#selectDropdown button {\n  width: 30px;\n  height: 25px;\n  font: 15px bolder;\n  display: block;\n  background-color: transparent;\n  border: 1px solid transparent;\n  font-family: sans-serif;\n  color: #505050;\n  cursor: pointer;\n}\n#selectDropdown button.active {\n  background-color: #f3f3f3;\n}\n#selectDropdown button:hover {\n  background-color: #f9f9f9;\n  border-color: #bbbbbb;\n}\n#setting {\n  width: 30px;\n  height: 25px;\n  font-size: 15px;\n  right: 0px;\n  text-align: center;\n  position: absolute;\n  top: 10px;\n  background-color: transparent;\n  border: 0;\n}\n.switchCameraButton {\n  cursor: pointer;\n  font-size: 15px;\n  position: absolute;\n  width: 40px;\n  bottom: 2px;\n  right: 2px;\n  text-align: center;\n  color: #808080;\n  background-color: transparent;\n  border: 0;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n      -ms-user-select: none;\n          user-select: none;\n}\n.switchCameraButton:hover {\n  color: #00006d;\n}\n.visible {\n  color: grey;\n}\n.selectvisible {\n  background-color: white !important;\n  color: #395d73;\n}\n#mouse_label {\n  display: none;\n  position: fixed;\n  overflow: hidden;\n  font-style: italic;\n  background: rgba(255, 255, 255, 0.5);\n  padding: 5px;\n}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9hcHAvZ2ktdmlld2VyL3RocmVlanMvQzpcXFVzZXJzXFxha2liZHB0XFxEb2N1bWVudHNcXEFuZ3VsYXJcXG1vYml1cy12aWV3ZXIvc3JjXFxhcHBcXGdpLXZpZXdlclxcdGhyZWVqc1xcdGhyZWVqcy12aWV3ZXIuY29tcG9uZW50LnNjc3MiLCJzcmMvYXBwL2dpLXZpZXdlci90aHJlZWpzL3RocmVlanMtdmlld2VyLmNvbXBvbmVudC5zY3NzIiwic3JjL2FwcC9naS12aWV3ZXIvdGhyZWVqcy9DOlxcVXNlcnNcXGFraWJkcHRcXERvY3VtZW50c1xcQW5ndWxhclxcbW9iaXVzLXZpZXdlci9zcmNcXHNjc3NcXGNvbG9ycy5zY3NzIiwic3JjL2FwcC9naS12aWV3ZXIvdGhyZWVqcy9DOlxcVXNlcnNcXGFraWJkcHRcXERvY3VtZW50c1xcQW5ndWxhclxcbW9iaXVzLXZpZXdlci9zcmNcXHNjc3NcXHZhcmlhYmxlcy5zY3NzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUdBO0VBQ0ksZUFBQTtBQ0ZKO0FER0k7RUFDSSxhQUFBO0FDRFI7QURLQTtFQUdJLFdBQUE7RUFDQSxZQUFBO0VBQ0EsdUJBQUE7RUFDQSxnQkFBQTtBQ0pKO0FET0E7RUFDSSxrQkFBQTtFQUVBLFlBQUE7RUFDQSxXQUFBO0VBQ0EsV0FBQTtFQUNBLGdCQUFBO0VBRUEsdUJBQUE7QUNOSjtBRFNBO0VBQ0ksUUFBQTtFQUNBLFVBQUE7QUNOSjtBRFNBO0VBQ0ksa0JBQUE7RUFDQSxXQUFBO0VBQ0EsU0FBQTtFQUNBLG9DQUFBO0VBQ0EsYUFBQTtFQUNBLGNBQUE7QUNOSjtBRE9JO0VBQ0ksWUFBQTtBQ0xSO0FEU0E7RUFDSSxrQkFBQTtFQUNBLFdBQUE7RUFDQSxXQUFBO0VBQ0Esb0NBQUE7RUFDQSw0QkFBQTtFQUNBLGNFcERLO0FEOENUO0FEUUk7RUFDSSxXQUFBO0VBSUEsYUFBQTtBQ05SO0FEU0k7RUFDSSxXQUFBO0VBQ0EsYUFBQTtFQUNBLFlBQUE7RUFDQSxVQUFBO0FDUFI7QURVQTtFQUNJLGtCQUFBO0VBQ0EsV0FBQTtFQUNBLFdBQUE7RUFDQSxvQ0FBQTtFQUNBLDRCQUFBO0VBQ0EsY0UzRUs7QURvRVQ7QURTSTtFQUNJLFdBQUE7RUFJQSxhQUFBO0FDUFI7QURVSTtFQUNJLFdBQUE7RUFDQSxhQUFBO0VBQ0EsWUFBQTtFQUNBLFVBQUE7QUNSUjtBRFdBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBQUE7QUFvQ0E7Ozs7Ozs7Ozs7RUFBQTtBQVlBO0VBQ0ksa0JBQUE7RUFDQSxhQUFBO0VBQ0EsZ0JBQUE7RUFDQSxTQUFBO0VBQ0EsYUFBQTtFQUNBLGtCQUFBO0VBQ0EsdUJBQUE7RUFDQSxlQUFBO0VBQ0EsdUJBQUE7RUFDQSxtQ0FBQTtBQ1ZKO0FEY0E7RUFDSSxXQUFBO0VBQ0EsWUFBQTtFQUNBLGVHMUpLO0VIMkpMLGtCQUFBO0VBQ0EsU0FBQTtFQUNBLFVBQUE7RUFDQSxrQkFBQTtFQUNBLGNFbEtLO0VGbUtMLDZCQUFBO0VBQ0EsU0FBQTtBQ1hKO0FEWUk7RUFDSSxjRTNKUztBRGlKakI7QURjQTtFQUNJLFdBQUE7RUFDQSxZQUFBO0VBQ0EsZUcxS0s7RUgyS0wsa0JBQUE7RUFDQSxTQUFBO0VBQ0EsVUFBQTtFQUNBLGtCQUFBO0VBQ0EsY0VsTEs7RUZtTEwsNkJBQUE7RUFDQSxTQUFBO0FDWEo7QURZSTtFQUNJLGNFM0tTO0FEaUtqQjtBRGNBO0VBQ0ksV0FBQTtFQUNBLGVHekxLO0VIMExMLGtCQUFBO0VBQ0Esa0JBQUE7RUFDQSxjQUFBO0VBQ0EsU0FBQTtFQUNBLFVBQUE7RUFDQSxlQUFBO0FDWEo7QURjQTtFQUNJLGtCQUFBO0VBQ0EsU0FBQTtFQUNBLFVBQUE7QUNYSjtBRFlJO0VBQ0ksV0FBQTtFQUNBLFlBQUE7RUFDQSxpQkFBQTtFQUNBLGNBQUE7RUFDQSw2QkFBQTtFQUNBLDZCQUFBO0VBQ0EsdUJBQUE7RUFDQSxjQUFBO0VBQ0EsZUFBQTtBQ1ZSO0FEV1E7RUFDSSx5QkFBQTtBQ1RaO0FEV1E7RUFDSSx5QkFBQTtFQUNBLHFCQUFBO0FDVFo7QURjQTtFQUNJLFdBQUE7RUFDQSxZQUFBO0VBQ0EsZUc3Tks7RUg4TkwsVUFBQTtFQUNBLGtCQUFBO0VBQ0Esa0JBQUE7RUFDQSxTQUFBO0VBQ0EsNkJBQUE7RUFDQSxTQUFBO0FDWEo7QURlQTtFQUNJLGVBQUE7RUFDQSxlR3pPSztFSDBPTCxrQkFBQTtFQUNBLFdBQUE7RUFDQSxXQUFBO0VBQ0EsVUFBQTtFQUNBLGtCQUFBO0VBQ0EsY0VsUEs7RUZtUEwsNkJBQUE7RUFDQSxTQUFBO0VBQ0EseUJBQUE7S0FBQSxzQkFBQTtNQUFBLHFCQUFBO1VBQUEsaUJBQUE7QUNaSjtBRGFJO0VBQ0ksY0U1T1M7QURpT2pCO0FEb0JBO0VBQ0ksV0FBQTtBQ2pCSjtBRG9CQTtFQUNJLGtDQUFBO0VBQ0EsY0FBQTtBQ2pCSjtBRG9CQTtFQUNJLGFBQUE7RUFDQSxlQUFBO0VBQ0EsZ0JBQUE7RUFDQSxrQkFBQTtFQUNBLG9DQUFBO0VBQ0EsWUFBQTtBQ2pCSiIsImZpbGUiOiJzcmMvYXBwL2dpLXZpZXdlci90aHJlZWpzL3RocmVlanMtdmlld2VyLmNvbXBvbmVudC5zY3NzIiwic291cmNlc0NvbnRlbnQiOlsiQGltcG9ydCAnfnNjc3MvY29sb3JzJztcclxuQGltcG9ydCAnfnNjc3MvdmFyaWFibGVzJztcclxuXHJcbmJ1dHRvbntcclxuICAgIGN1cnNvcjogcG9pbnRlcjtcclxuICAgICY6Zm9jdXN7XHJcbiAgICAgICAgb3V0bGluZTogbm9uZTtcclxuICAgIH1cclxufVxyXG4vL3RocmVlanMtdmlld2VyXHJcbjpob3N0ICB7IFxyXG4gICAgLy8gcG9zaXRpb246IGFic29sdXRlO1xyXG4gICAgLy8gcGFkZGluZzo1cHg7XHJcbiAgICB3aWR0aDogMTAwJTtcclxuICAgIGhlaWdodDogMTAwJTtcclxuICAgIGJhY2tncm91bmQtY29sb3I6IGdyZWVuO1xyXG4gICAgb3ZlcmZsb3c6aGlkZGVuO1xyXG59XHJcblxyXG4jdGhyZWVqcy1jb250YWluZXIge1xyXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xyXG4gICAgLy8gcGFkZGluZzo1MHB4O1xyXG4gICAgaGVpZ2h0OiAxMDAlO1xyXG4gICAgd2lkdGg6IDEwMCU7XHJcbiAgICBtYXJnaW46MHB4O1xyXG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcclxuICAgIC8vIGNvbG9yOiBibHVlO1xyXG4gICAgZm9udC1mYW1pbHk6c2Fucy1zZXJpZjtcclxufVxyXG5cclxuI2NvbnRhaW5lci10b3AtcmlnaHQtcmVzaXplIHsgXHJcbiAgICB0b3A6IDBweDsgXHJcbiAgICByaWdodDogMHB4OyBcclxufVxyXG5cclxuI2dpU3VtbWFyeSwgI3Rqc1N1bW1hcnl7XHJcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XHJcbiAgICBib3R0b206IDVweDtcclxuICAgIGxlZnQ6IDVweDtcclxuICAgIGJhY2tncm91bmQ6IHJnYmEoMjU1LDI1NSwyNTUsMC4zKTtcclxuICAgIHBhZGRpbmc6IDEwcHg7XHJcbiAgICBjb2xvcjogIzJhOGFjNTtcclxuICAgIHRke1xyXG4gICAgICAgIGhlaWdodDogMTdweDtcclxuICAgIH1cclxufVxyXG5cclxuI25vZGVTZWxlY3Rfc2xpZGVye1xyXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xyXG4gICAgYm90dG9tOiA1cHg7XHJcbiAgICByaWdodDogNTBweDtcclxuICAgIGJhY2tncm91bmQ6IHJnYmEoMjU1LDI1NSwyNTUsMC4zKTtcclxuICAgIHBhZGRpbmc6IDEwcHggMjVweCAxMHB4IDEwcHg7XHJcbiAgICBjb2xvcjogJGNvbG9yMTtcclxuXHJcbiAgICBkYXRhbGlzdCB7XHJcbiAgICAgICAgd2lkdGg6IDEyMSU7XHJcbiAgICAgICAgZGlzcGxheTogLXdlYmtpdC1ib3g7XHJcbiAgICAgICAgZGlzcGxheTogLXdlYmtpdC1mbGV4O1xyXG4gICAgICAgIGRpc3BsYXk6IC1tcy1mbGV4Ym94O1xyXG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGRhdGFsaXN0IG9wdGlvbiB7XHJcbiAgICAgICAgd2lkdGg6IDE1cHg7XHJcbiAgICAgICAgcGFkZGluZzogbm9uZTtcclxuICAgICAgICBmbGV4LWdyb3c6IDE7XHJcbiAgICAgICAgcmlnaHQ6IDFweDtcclxuICAgIH1cclxufVxyXG4jbm9kZVNlbGVjdF9kcm9wZG93bntcclxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcclxuICAgIGJvdHRvbTogNXB4O1xyXG4gICAgcmlnaHQ6IDUwcHg7XHJcbiAgICBiYWNrZ3JvdW5kOiByZ2JhKDI1NSwyNTUsMjU1LDAuMyk7XHJcbiAgICBwYWRkaW5nOiAxMHB4IDI1cHggMTBweCAxMHB4O1xyXG4gICAgY29sb3I6ICRjb2xvcjE7XHJcblxyXG4gICAgZGF0YWxpc3Qge1xyXG4gICAgICAgIHdpZHRoOiAxMjElO1xyXG4gICAgICAgIGRpc3BsYXk6IC13ZWJraXQtYm94O1xyXG4gICAgICAgIGRpc3BsYXk6IC13ZWJraXQtZmxleDtcclxuICAgICAgICBkaXNwbGF5OiAtbXMtZmxleGJveDtcclxuICAgICAgICBkaXNwbGF5OiBmbGV4O1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBkYXRhbGlzdCBvcHRpb24ge1xyXG4gICAgICAgIHdpZHRoOiAxNXB4O1xyXG4gICAgICAgIHBhZGRpbmc6IG5vbmU7XHJcbiAgICAgICAgZmxleC1ncm93OiAxO1xyXG4gICAgICAgIHJpZ2h0OiAxcHg7XHJcbiAgICB9XHJcbn1cclxuLyojcm90YXRpbmd7XHJcbiAgICB3aWR0aDogMzBweDtcclxuICAgIGhlaWdodDogMjVweDtcclxuICAgIGZvbnQtc2l6ZToxNXB4O1xyXG4gICAgcmlnaHQ6MHB4OyBcclxuICAgIHRleHQtYWxpZ246Y2VudGVyO1xyXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xyXG4gICAgdG9wOiAwcHg7XHJcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOnRyYW5zcGFyZW50O1xyXG4gICAgYm9yZGVyOjA7XHJcbn1cclxuXHJcbiNwYW5pbmd7XHJcbiAgICB3aWR0aDogMzBweDtcclxuICAgIGhlaWdodDogMjVweDtcclxuICAgIGZvbnQtc2l6ZToxNXB4O1xyXG4gICAgcmlnaHQ6MHB4OyBcclxuICAgIHRleHQtYWxpZ246Y2VudGVyO1xyXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xyXG4gICAgdG9wOiAyNXB4O1xyXG4gICAgYmFja2dyb3VuZC1jb2xvcjp0cmFuc3BhcmVudDtcclxuICAgIGJvcmRlcjowO1xyXG59XHJcblxyXG4jem9vbWluZ3tcclxuICAgIHdpZHRoOiAzMHB4O1xyXG4gICAgaGVpZ2h0OiAyNXB4O1xyXG4gICAgZm9udC1zaXplOjE1cHg7XHJcbiAgICByaWdodDowcHg7IFxyXG4gICAgdGV4dC1hbGlnbjpjZW50ZXI7XHJcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XHJcbiAgICBtYXJnaW4tdG9wOiA1MHB4O1xyXG4gICAgYmFja2dyb3VuZC1jb2xvcjp0cmFuc3BhcmVudDtcclxuICAgIGJvcmRlcjowO1xyXG59Ki9cclxuXHJcbi8qI2ltYWdlcnl7XHJcbiAgICB3aWR0aDogMzBweDtcclxuICAgIGhlaWdodDogMjVweDtcclxuICAgIGZvbnQtc2l6ZToxNHB4O1xyXG4gICAgcmlnaHQ6MHB4OyBcclxuICAgIHRleHQtYWxpZ246Y2VudGVyO1xyXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xyXG4gICAgbWFyZ2luLXRvcDogMTBweDtcclxuICAgIGJhY2tncm91bmQtY29sb3I6dHJhbnNwYXJlbnQ7XHJcbiAgICBib3JkZXI6MDtcclxufSovXHJcblxyXG4ubWVzc2FnZXN7XHJcbiAgICBwb3NpdGlvbjphYnNvbHV0ZTtcclxuICAgIGNvbG9yOm9yYW5nZTtcclxuICAgIG1hcmdpbi10b3A6IDUwcHg7XHJcbiAgICBsZWZ0OjQwJTtcclxuICAgIHBhZGRpbmc6MTBweDtcclxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcclxuICAgIGZvbnQtZmFtaWx5OnNhbnMtc2VyaWY7XHJcbiAgICBmb250LXNpemU6IDE0cHg7XHJcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTtcclxuICAgIGJveC1zaGFkb3c6IDJweCAycHggNXB4IDBweCAjNTA1MDUwO1xyXG59XHJcblxyXG5cclxuI3pvb21pbmdmaXR7XHJcbiAgICB3aWR0aDogNDBweDtcclxuICAgIGhlaWdodDogMzBweDtcclxuICAgIGZvbnQtc2l6ZTokZnNpemUxO1xyXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xyXG4gICAgdG9wOjMwcHg7XHJcbiAgICByaWdodDowcHg7IFxyXG4gICAgdGV4dC1hbGlnbjpjZW50ZXI7XHJcbiAgICBjb2xvcjogJGNvbG9yMTtcclxuICAgIGJhY2tncm91bmQtY29sb3I6dHJhbnNwYXJlbnQ7XHJcbiAgICBib3JkZXI6MDtcclxuICAgICY6aG92ZXIge1xyXG4gICAgICAgIGNvbG9yOiRzZWxlY3RlZC1jb2xvcjtcclxuICAgIH1cclxufVxyXG5cclxuI0VudGl0eVNlbGVjdGlvbntcclxuICAgIHdpZHRoOiA0MHB4O1xyXG4gICAgaGVpZ2h0OiAzMHB4O1xyXG4gICAgZm9udC1zaXplOiRmc2l6ZTE7XHJcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XHJcbiAgICB0b3A6IDYwcHg7XHJcbiAgICByaWdodDowcHg7IFxyXG4gICAgdGV4dC1hbGlnbjpjZW50ZXI7XHJcbiAgICBjb2xvcjogJGNvbG9yMTtcclxuICAgIGJhY2tncm91bmQtY29sb3I6dHJhbnNwYXJlbnQ7XHJcbiAgICBib3JkZXI6MDtcclxuICAgICY6aG92ZXIge1xyXG4gICAgICAgIGNvbG9yOiRzZWxlY3RlZC1jb2xvcjtcclxuICAgIH1cclxufVxyXG5cclxuI1NlbGVjdGluZ0VudGl0eVR5cGV7XHJcbiAgICB3aWR0aDogNDBweDtcclxuICAgIGZvbnQtc2l6ZTokZnNpemUxO1xyXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xyXG4gICAgdGV4dC1hbGlnbjpjZW50ZXI7XHJcbiAgICBjb2xvcjogIzUwNTA1MDtcclxuICAgIHRvcDogOTBweDtcclxuICAgIHJpZ2h0OjBweDtcclxuICAgIGN1cnNvcjogcG9pbnRlcjtcclxufVxyXG5cclxuI3NlbGVjdERyb3Bkb3due1xyXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xyXG4gICAgdG9wOiA4NXB4O1xyXG4gICAgcmlnaHQ6IDVweDtcclxuICAgIGJ1dHRvbntcclxuICAgICAgICB3aWR0aDogMzBweDtcclxuICAgICAgICBoZWlnaHQ6IDI1cHg7XHJcbiAgICAgICAgZm9udDogJGZzaXplMSBib2xkZXI7XHJcbiAgICAgICAgZGlzcGxheTogYmxvY2s7XHJcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjp0cmFuc3BhcmVudDtcclxuICAgICAgICBib3JkZXI6MXB4IHNvbGlkIHRyYW5zcGFyZW50O1xyXG4gICAgICAgIGZvbnQtZmFtaWx5OnNhbnMtc2VyaWY7XHJcbiAgICAgICAgY29sb3I6ICM1MDUwNTA7XHJcbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xyXG4gICAgICAgICYuYWN0aXZle1xyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAgI2YzZjNmMztcclxuICAgICAgICB9XHJcbiAgICAgICAgJjpob3ZlcntcclxuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogICNmOWY5Zjk7XHJcbiAgICAgICAgICAgIGJvcmRlci1jb2xvcjogI2JiYmJiYjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbiNzZXR0aW5ne1xyXG4gICAgd2lkdGg6IDMwcHg7XHJcbiAgICBoZWlnaHQ6IDI1cHg7XHJcbiAgICBmb250LXNpemU6JGZzaXplMTtcclxuICAgIHJpZ2h0OjBweDsgXHJcbiAgICB0ZXh0LWFsaWduOmNlbnRlcjtcclxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcclxuICAgIHRvcDogMTBweDtcclxuICAgIGJhY2tncm91bmQtY29sb3I6dHJhbnNwYXJlbnQ7XHJcbiAgICBib3JkZXI6MDtcclxufVxyXG5cclxuXHJcbi5zd2l0Y2hDYW1lcmFCdXR0b257XHJcbiAgICBjdXJzb3I6IHBvaW50ZXI7XHJcbiAgICBmb250LXNpemU6JGZzaXplMTtcclxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcclxuICAgIHdpZHRoOiA0MHB4O1xyXG4gICAgYm90dG9tOjJweDtcclxuICAgIHJpZ2h0OjJweDsgXHJcbiAgICB0ZXh0LWFsaWduOmNlbnRlcjtcclxuICAgIGNvbG9yOiAkY29sb3IxO1xyXG4gICAgYmFja2dyb3VuZC1jb2xvcjp0cmFuc3BhcmVudDtcclxuICAgIGJvcmRlcjowO1xyXG4gICAgdXNlci1zZWxlY3Q6IG5vbmU7XHJcbiAgICAmOmhvdmVyIHtcclxuICAgICAgICBjb2xvcjokc2VsZWN0ZWQtY29sb3I7XHJcbiAgICB9XHJcbiAgICAvLyBtYXQtaWNvbiB7XHJcbiAgICAvLyAgICAgc3ZnIHtcclxuICAgIC8vICAgICAgICAgZmlsbDogJGNvbG9yMSAhaW1wb3J0YW50O1xyXG4gICAgLy8gICAgIH1cclxuICAgIC8vIH1cclxufVxyXG5cclxuLnZpc2libGV7XHJcbiAgICBjb2xvcjogZ3JleTtcclxufVxyXG5cclxuLnNlbGVjdHZpc2libGV7XHJcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAgd2hpdGUgIWltcG9ydGFudDtcclxuICAgIGNvbG9yOiMzOTVkNzM7XHJcbn1cclxuXHJcbiNtb3VzZV9sYWJlbHtcclxuICAgIGRpc3BsYXk6bm9uZTtcclxuICAgIHBvc2l0aW9uOmZpeGVkO1xyXG4gICAgb3ZlcmZsb3c6aGlkZGVuO1xyXG4gICAgZm9udC1zdHlsZTogaXRhbGljO1xyXG4gICAgYmFja2dyb3VuZDogcmdiYSgyNTUsMjU1LDI1NSwwLjUpO1xyXG4gICAgcGFkZGluZzogNXB4O1xyXG59XHJcbiIsImJ1dHRvbiB7XG4gIGN1cnNvcjogcG9pbnRlcjtcbn1cbmJ1dHRvbjpmb2N1cyB7XG4gIG91dGxpbmU6IG5vbmU7XG59XG5cbjpob3N0IHtcbiAgd2lkdGg6IDEwMCU7XG4gIGhlaWdodDogMTAwJTtcbiAgYmFja2dyb3VuZC1jb2xvcjogZ3JlZW47XG4gIG92ZXJmbG93OiBoaWRkZW47XG59XG5cbiN0aHJlZWpzLWNvbnRhaW5lciB7XG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgaGVpZ2h0OiAxMDAlO1xuICB3aWR0aDogMTAwJTtcbiAgbWFyZ2luOiAwcHg7XG4gIG92ZXJmbG93OiBoaWRkZW47XG4gIGZvbnQtZmFtaWx5OiBzYW5zLXNlcmlmO1xufVxuXG4jY29udGFpbmVyLXRvcC1yaWdodC1yZXNpemUge1xuICB0b3A6IDBweDtcbiAgcmlnaHQ6IDBweDtcbn1cblxuI2dpU3VtbWFyeSwgI3Rqc1N1bW1hcnkge1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIGJvdHRvbTogNXB4O1xuICBsZWZ0OiA1cHg7XG4gIGJhY2tncm91bmQ6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4zKTtcbiAgcGFkZGluZzogMTBweDtcbiAgY29sb3I6ICMyYThhYzU7XG59XG4jZ2lTdW1tYXJ5IHRkLCAjdGpzU3VtbWFyeSB0ZCB7XG4gIGhlaWdodDogMTdweDtcbn1cblxuI25vZGVTZWxlY3Rfc2xpZGVyIHtcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICBib3R0b206IDVweDtcbiAgcmlnaHQ6IDUwcHg7XG4gIGJhY2tncm91bmQ6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4zKTtcbiAgcGFkZGluZzogMTBweCAyNXB4IDEwcHggMTBweDtcbiAgY29sb3I6ICM4MDgwODA7XG59XG4jbm9kZVNlbGVjdF9zbGlkZXIgZGF0YWxpc3Qge1xuICB3aWR0aDogMTIxJTtcbiAgZGlzcGxheTogLXdlYmtpdC1ib3g7XG4gIGRpc3BsYXk6IC13ZWJraXQtZmxleDtcbiAgZGlzcGxheTogLW1zLWZsZXhib3g7XG4gIGRpc3BsYXk6IGZsZXg7XG59XG4jbm9kZVNlbGVjdF9zbGlkZXIgZGF0YWxpc3Qgb3B0aW9uIHtcbiAgd2lkdGg6IDE1cHg7XG4gIHBhZGRpbmc6IG5vbmU7XG4gIGZsZXgtZ3JvdzogMTtcbiAgcmlnaHQ6IDFweDtcbn1cblxuI25vZGVTZWxlY3RfZHJvcGRvd24ge1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIGJvdHRvbTogNXB4O1xuICByaWdodDogNTBweDtcbiAgYmFja2dyb3VuZDogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjMpO1xuICBwYWRkaW5nOiAxMHB4IDI1cHggMTBweCAxMHB4O1xuICBjb2xvcjogIzgwODA4MDtcbn1cbiNub2RlU2VsZWN0X2Ryb3Bkb3duIGRhdGFsaXN0IHtcbiAgd2lkdGg6IDEyMSU7XG4gIGRpc3BsYXk6IC13ZWJraXQtYm94O1xuICBkaXNwbGF5OiAtd2Via2l0LWZsZXg7XG4gIGRpc3BsYXk6IC1tcy1mbGV4Ym94O1xuICBkaXNwbGF5OiBmbGV4O1xufVxuI25vZGVTZWxlY3RfZHJvcGRvd24gZGF0YWxpc3Qgb3B0aW9uIHtcbiAgd2lkdGg6IDE1cHg7XG4gIHBhZGRpbmc6IG5vbmU7XG4gIGZsZXgtZ3JvdzogMTtcbiAgcmlnaHQ6IDFweDtcbn1cblxuLyojcm90YXRpbmd7XG4gICAgd2lkdGg6IDMwcHg7XG4gICAgaGVpZ2h0OiAyNXB4O1xuICAgIGZvbnQtc2l6ZToxNXB4O1xuICAgIHJpZ2h0OjBweDsgXG4gICAgdGV4dC1hbGlnbjpjZW50ZXI7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIHRvcDogMHB4O1xuICAgIGJhY2tncm91bmQtY29sb3I6dHJhbnNwYXJlbnQ7XG4gICAgYm9yZGVyOjA7XG59XG5cbiNwYW5pbmd7XG4gICAgd2lkdGg6IDMwcHg7XG4gICAgaGVpZ2h0OiAyNXB4O1xuICAgIGZvbnQtc2l6ZToxNXB4O1xuICAgIHJpZ2h0OjBweDsgXG4gICAgdGV4dC1hbGlnbjpjZW50ZXI7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIHRvcDogMjVweDtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOnRyYW5zcGFyZW50O1xuICAgIGJvcmRlcjowO1xufVxuXG4jem9vbWluZ3tcbiAgICB3aWR0aDogMzBweDtcbiAgICBoZWlnaHQ6IDI1cHg7XG4gICAgZm9udC1zaXplOjE1cHg7XG4gICAgcmlnaHQ6MHB4OyBcbiAgICB0ZXh0LWFsaWduOmNlbnRlcjtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgbWFyZ2luLXRvcDogNTBweDtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOnRyYW5zcGFyZW50O1xuICAgIGJvcmRlcjowO1xufSovXG4vKiNpbWFnZXJ5e1xuICAgIHdpZHRoOiAzMHB4O1xuICAgIGhlaWdodDogMjVweDtcbiAgICBmb250LXNpemU6MTRweDtcbiAgICByaWdodDowcHg7IFxuICAgIHRleHQtYWxpZ246Y2VudGVyO1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICBtYXJnaW4tdG9wOiAxMHB4O1xuICAgIGJhY2tncm91bmQtY29sb3I6dHJhbnNwYXJlbnQ7XG4gICAgYm9yZGVyOjA7XG59Ki9cbi5tZXNzYWdlcyB7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgY29sb3I6IG9yYW5nZTtcbiAgbWFyZ2luLXRvcDogNTBweDtcbiAgbGVmdDogNDAlO1xuICBwYWRkaW5nOiAxMHB4O1xuICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gIGZvbnQtZmFtaWx5OiBzYW5zLXNlcmlmO1xuICBmb250LXNpemU6IDE0cHg7XG4gIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xuICBib3gtc2hhZG93OiAycHggMnB4IDVweCAwcHggIzUwNTA1MDtcbn1cblxuI3pvb21pbmdmaXQge1xuICB3aWR0aDogNDBweDtcbiAgaGVpZ2h0OiAzMHB4O1xuICBmb250LXNpemU6IDE1cHg7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgdG9wOiAzMHB4O1xuICByaWdodDogMHB4O1xuICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gIGNvbG9yOiAjODA4MDgwO1xuICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcbiAgYm9yZGVyOiAwO1xufVxuI3pvb21pbmdmaXQ6aG92ZXIge1xuICBjb2xvcjogIzAwMDA2ZDtcbn1cblxuI0VudGl0eVNlbGVjdGlvbiB7XG4gIHdpZHRoOiA0MHB4O1xuICBoZWlnaHQ6IDMwcHg7XG4gIGZvbnQtc2l6ZTogMTVweDtcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICB0b3A6IDYwcHg7XG4gIHJpZ2h0OiAwcHg7XG4gIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgY29sb3I6ICM4MDgwODA7XG4gIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xuICBib3JkZXI6IDA7XG59XG4jRW50aXR5U2VsZWN0aW9uOmhvdmVyIHtcbiAgY29sb3I6ICMwMDAwNmQ7XG59XG5cbiNTZWxlY3RpbmdFbnRpdHlUeXBlIHtcbiAgd2lkdGg6IDQwcHg7XG4gIGZvbnQtc2l6ZTogMTVweDtcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gIGNvbG9yOiAjNTA1MDUwO1xuICB0b3A6IDkwcHg7XG4gIHJpZ2h0OiAwcHg7XG4gIGN1cnNvcjogcG9pbnRlcjtcbn1cblxuI3NlbGVjdERyb3Bkb3duIHtcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICB0b3A6IDg1cHg7XG4gIHJpZ2h0OiA1cHg7XG59XG4jc2VsZWN0RHJvcGRvd24gYnV0dG9uIHtcbiAgd2lkdGg6IDMwcHg7XG4gIGhlaWdodDogMjVweDtcbiAgZm9udDogMTVweCBib2xkZXI7XG4gIGRpc3BsYXk6IGJsb2NrO1xuICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcbiAgYm9yZGVyOiAxcHggc29saWQgdHJhbnNwYXJlbnQ7XG4gIGZvbnQtZmFtaWx5OiBzYW5zLXNlcmlmO1xuICBjb2xvcjogIzUwNTA1MDtcbiAgY3Vyc29yOiBwb2ludGVyO1xufVxuI3NlbGVjdERyb3Bkb3duIGJ1dHRvbi5hY3RpdmUge1xuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZjNmM2YzO1xufVxuI3NlbGVjdERyb3Bkb3duIGJ1dHRvbjpob3ZlciB7XG4gIGJhY2tncm91bmQtY29sb3I6ICNmOWY5Zjk7XG4gIGJvcmRlci1jb2xvcjogI2JiYmJiYjtcbn1cblxuI3NldHRpbmcge1xuICB3aWR0aDogMzBweDtcbiAgaGVpZ2h0OiAyNXB4O1xuICBmb250LXNpemU6IDE1cHg7XG4gIHJpZ2h0OiAwcHg7XG4gIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICB0b3A6IDEwcHg7XG4gIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xuICBib3JkZXI6IDA7XG59XG5cbi5zd2l0Y2hDYW1lcmFCdXR0b24ge1xuICBjdXJzb3I6IHBvaW50ZXI7XG4gIGZvbnQtc2l6ZTogMTVweDtcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICB3aWR0aDogNDBweDtcbiAgYm90dG9tOiAycHg7XG4gIHJpZ2h0OiAycHg7XG4gIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgY29sb3I6ICM4MDgwODA7XG4gIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xuICBib3JkZXI6IDA7XG4gIHVzZXItc2VsZWN0OiBub25lO1xufVxuLnN3aXRjaENhbWVyYUJ1dHRvbjpob3ZlciB7XG4gIGNvbG9yOiAjMDAwMDZkO1xufVxuXG4udmlzaWJsZSB7XG4gIGNvbG9yOiBncmV5O1xufVxuXG4uc2VsZWN0dmlzaWJsZSB7XG4gIGJhY2tncm91bmQtY29sb3I6IHdoaXRlICFpbXBvcnRhbnQ7XG4gIGNvbG9yOiAjMzk1ZDczO1xufVxuXG4jbW91c2VfbGFiZWwge1xuICBkaXNwbGF5OiBub25lO1xuICBwb3NpdGlvbjogZml4ZWQ7XG4gIG92ZXJmbG93OiBoaWRkZW47XG4gIGZvbnQtc3R5bGU6IGl0YWxpYztcbiAgYmFja2dyb3VuZDogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjUpO1xuICBwYWRkaW5nOiA1cHg7XG59IiwiXHJcbiRjb2xvcjE6ICM4MDgwODA7XHJcbiRjb2xvcjI6ICM5OTk5OTk7XHJcbiRjb2xvcjM6ICNCM0IzQjM7IFxyXG4kY29sb3I0OiAjQ0NDQ0NDO1xyXG4kY29sb3I1OiAjRTZFNkU2O1xyXG4kY29sb3I1LTU6IHJnYigyNDUsIDI0NSwgMjQ1KTtcclxuJGNvbG9yNjogcmdiKDI1MCwgMjUwLCAyNTEpO1xyXG5cclxuJGNvbG9yNzogd2hpdGU7XHJcbiRjb2xvcjg6ICMzNzM3Mzc7XHJcblxyXG4kc2VsZWN0ZWQtY29sb3I6IHJnYigwLCAwLCAxMDkpO1xyXG4kc2VsZWN0ZWQtY29sb3IxOiByZ2IoMjI4LCAyMjgsIDI0Nyk7XHJcbiRzZWxlY3RlZC1jb2xvcjI6IHJnYigyMTUsIDIxNSwgMjU1KTtcclxuJGhvdmVyLWNvbG9yOiAkY29sb3IyO1xyXG5cclxuJGVycm9yLWNvbG9yOiAjRTk0ODU4OyAvL3BpbmstcmVkXHJcbiRlcnJvci1jb2xvci1sdDogcmdiKDI1NSwgMjIwLCAyMjQpO1xyXG4kcGNvbG9yMjogI0YzQTMyQTsgLy9vcmFuZ2UteWVsbG93XHJcbiRwcmludC1jb2xvcjogcmdiKDEzMCwgMTkxLCAxMTApOyAvL2xpZ2h0Z3JlZW5cclxuJHByaW50LWNvbG9yLWx0OiByZ2IoMjMwLCAyNTUsIDIyMSk7XHJcbiRwcmludC1jb2xvci1kazogcmdiKDYzLCA5OSwgNTEpOyAvL2xpZ2h0Z3JlZW5cclxuJHNlbGVjdEdlb20tY29sb3I6IHJnYigyNTUsIDE3NCwgMCk7IC8vIGxpZ2h0IG9yYW5nZVxyXG4kc2VsZWN0R2VvbS1jb2xvci1sdDogcmdiKDI1NSwgMjI1LCAxNjApO1xyXG5cclxuLy8gJHByb2QtYmFja2dyb3VuZC1jb2xvcjogcmdiKDI1MCwyNTAsMjUwKTtcclxuLy8gJGJhY2tncm91bmQtY29sb3I6IHJnYigyMjAsMjIwLDIyMCk7XHJcbiRmdW5jdGlvbi10ZXh0LWNvbG9yOiByZ2IoMTkwLCAxNDAsIDMwKTtcclxuJGZ1bmN0aW9uLXRleHQtY29sb3IyOiByZ2IoMTgsIDEyNiwgMTM2KTtcclxuJGZ1bmN0aW9uLXRleHQtY29sb3IzOiByZ2IoMTkwLCAxNDAsIDMwKTtcclxuJGJhc2ljLWZ1bmN0aW9uLXRleHQtY29sb3I6IHJnYigyMDAsIDcwLCAxNTApO1xyXG4kY29tbWVudC1jb2xvcjogZGFya2dyZWVuO1xyXG4iLCIkcGFkZGluZzogNDBweDsgLy8gPyBub3QgdXNlZFxyXG4kc21hbGwtcGFkZGluZzogMTVweDtcclxuJGhlYWRlci1oZWlnaHQ6IDQwcHg7XHJcblxyXG4kZnNpemUxOiAxNXB4O1xyXG4kZnNpemUyOiAxMnB4O1xyXG4kZnNpemUzOiAzMHB4O1xyXG5cclxuJHBvcnQtc2l6ZTogMTVweDtcclxuJGRlZmF1bHQtc2lkZS1wYWRkaW5nOiAxNXB4O1xyXG5cclxuJGRpc2FibGVkLW9wYWNpdHk6IDAuNDsiXX0= */");

/***/ }),

/***/ "./src/app/gi-viewer/threejs/threejs-viewer.component.ts":
/*!***************************************************************!*\
  !*** ./src/app/gi-viewer/threejs/threejs-viewer.component.ts ***!
  \***************************************************************/
/*! exports provided: ThreejsViewerComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ThreejsViewerComponent", function() { return ThreejsViewerComponent; });
/* harmony import */ var _libs_geo_info_GIModel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @libs/geo-info/GIModel */ "./src/assets/libs/geo-info/GIModel.ts");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
/* harmony import */ var _data_data_service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../data/data.service */ "./src/app/gi-viewer/data/data.service.ts");
/* harmony import */ var _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @libs/geo-info/common */ "./src/assets/libs/geo-info/common.ts");
/* harmony import */ var _html_dropdown_menu_component__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../html/dropdown-menu.component */ "./src/app/gi-viewer/html/dropdown-menu.component.ts");
/* harmony import */ var _html_modal_window_service__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../html/modal-window.service */ "./src/app/gi-viewer/html/modal-window.service.ts");
/* harmony import */ var _threejs_viewer_service__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./threejs-viewer.service */ "./src/app/gi-viewer/threejs/threejs-viewer.service.ts");
/* harmony import */ var _libs_util_maps__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @libs/util/maps */ "./src/assets/libs/util/maps.ts");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};

// import @angular stuff

// import { IModel } from 'gs-json';






let renderCheck = true;
/**
 * A threejs viewer for viewing geo-info (GI) models.
 * This component gets used in /app/model-viewers/all-viewers/gi-viewer/gi-viewer.component.html
 */
let ThreejsViewerComponent = class ThreejsViewerComponent {
    /**
     * Creates a new viewer,
     * @param injector
     * @param elem
     */
    constructor(injector, elem, threeJSViewerService) {
        this.threeJSViewerService = threeJSViewerService;
        this.action = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this.dropdown = new _html_dropdown_menu_component__WEBPACK_IMPORTED_MODULE_4__["DropdownMenuComponent"]();
        // protected keyboardService: KeyboardService;
        // private keyboardServiceSub: Subscription;
        this.container = null;
        // flags for displayinhg text in viewer, see html
        this._no_model = false;
        this._model_error = false;
        this.messageVisible = false;
        // right selection dropdown
        // public needSelect = false;
        // current entity type enabled for selection
        this.SelectingEntityType = { id: _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].FACE, name: 'Faces' };
        this.selectDropdownVisible = false;
        this.selections = [
            { id: _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].POSI, name: 'Positions' }, { id: _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].VERT, name: 'Vertex' },
            { id: _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].EDGE, name: 'Edges' }, { id: _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].WIRE, name: 'Wires' },
            { id: _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].FACE, name: 'Faces' }, { id: _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].POINT, name: 'Points' },
            { id: _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].PLINE, name: 'Polylines' }, { id: _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].PGON, name: 'Polygons' },
            { id: _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].COLL, name: 'Collections' }
        ];
        this.default_selections = {
            ps: { id: _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].POSI, name: 'Positions' },
            _v: { id: _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].VERT, name: 'Vertex' },
            _e: { id: _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].EDGE, name: 'Edges' },
            _w: { id: _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].WIRE, name: 'Wires' },
            _f: { id: _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].FACE, name: 'Faces' },
            pt: { id: _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].POINT, name: 'Points' },
            pl: { id: _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].PLINE, name: 'Polylines' },
            pg: { id: _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].PGON, name: 'Polygons' },
            co: { id: _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].COLL, name: 'Collections' }
        };
        this.dropdownPosition = { x: 0, y: 0 };
        this.shiftKeyPressed = false;
        this.giSummary = [];
        this.currentAttribLabel = '';
        this.tab_map = {
            0: _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].POSI,
            1: _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].VERT,
            2: _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].EDGE,
            3: _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].WIRE,
            4: _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].FACE,
            5: _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].POINT,
            6: _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].PLINE,
            7: _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].PGON,
            8: _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].COLL,
            9: _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].MOD
        };
        this.tab_rev_map = {
            0: 0,
            2: 1,
            3: 2,
            4: 3,
            5: 4,
            6: 5,
            7: 6,
            8: 7,
            9: 8,
            10: 9
        };
        this._elem = elem;
        this.dataService = injector.get(_data_data_service__WEBPACK_IMPORTED_MODULE_2__["DataService"]);
        this.modalWindow = injector.get(_html_modal_window_service__WEBPACK_IMPORTED_MODULE_5__["ModalService"]);
        // this.keyboardService = injector.get(KeyboardService);
        // this.keyboardServiceSub = this.keyboardService.viewerControl$.subscribe(event => {
        //     this._data_threejs.onWindowKeyPress(event);
        // });
    }
    /**
     * Called when the viewer is initialised.
     */
    ngOnInit() {
        this.dropdown.items = [];
        this.dropdown.visible = false;
        this.dropdown.position = { x: 0, y: 0 };
        this.container = this._elem.nativeElement.children.namedItem('threejs-container');
        // check for container
        if (!this.container) {
            console.error('No container in Three Viewer');
            return;
        }
        // size of window
        this._width = this.container.offsetWidth; // container.client_width;
        this._height = this.container.offsetHeight; // container.client_height;
        this._data_threejs = this.dataService.getThreejsScene();
        this.threeJSViewerService.DataThreejs = this._data_threejs;
        this.container.appendChild(this._data_threejs.renderer.domElement);
        this._data_threejs.renderer.domElement.style.outline = 'none';
        // this.container.appendChild(this._data_threejs.vr);
        // console.log(this._data_threejs.vr)
        // set the numbers of entities
        this._threejs_nums = this._data_threejs.threejs_nums;
        // ??? What is happening here?
        this._data_threejs.perspControls.addEventListener('change', this.activateRender);
        this._data_threejs.orthoControls.addEventListener('change', this.activateRender);
        this._data_threejs.renderer.render(this._data_threejs.scene, this._data_threejs.camera);
        if (this._data_threejs.ObjLabelMap.size !== 0) {
            this._data_threejs.ObjLabelMap.forEach((obj, label) => {
                this._data_threejs.createLabelforObj(this.container, obj.entity, obj.type, obj.text, label);
            });
        }
        this.getSelectingEntityType();
        this._data_threejs.switchCamera(false);
        for (let i = 1; i < 10; i++) {
            setTimeout(() => {
                this.activateRender();
            }, i * 100);
        }
        this.renderInterval = setInterval(() => {
            // this.render();
            if (renderCheck) {
                this.render();
                renderCheck = false;
            }
        }, 20);
    }
    /**
     * Called when anything changes
     */
    ngDoCheck() {
        if (!this.container) {
            console.error('No container in Three Viewer');
            return;
        }
        const width = this.container.offsetWidth;
        const height = this.container.offsetHeight;
        // this is when dimensions change
        if (width !== this._width || height !== this._height) {
            this._width = width;
            this._height = height;
            setTimeout(() => {
                const aspect = this._width / this._height;
                this._data_threejs.perspCam.aspect = this._width / this._height;
                this._data_threejs.perspCam.updateProjectionMatrix();
                this._data_threejs.renderer.setSize(this._width, this._height);
                this._data_threejs.orthoCam.left = -this._data_threejs.orthoCam.top * aspect;
                this._data_threejs.orthoCam.right = this._data_threejs.orthoCam.top * aspect;
                this._data_threejs.orthoCam.updateProjectionMatrix();
                this.activateRender();
            }, 10);
        }
        if (renderCheck) {
            this.render();
            renderCheck = false;
        }
        // this.render();
    }
    // receive data -> model from gi-viewer component and update model in the scene
    ngOnChanges(changes) {
        if (changes['model']) {
            if (this.model) {
                // if (this.dataService.switch_page) {
                //     this.dataService.switch_page = false;
                //     return;
                // }
                if (!this.container) {
                    return;
                }
                this.updateModel(this.model);
            }
        }
        if (changes['attr_table_select']) {
            if (this.attr_table_select) {
                this.attrTableSelect(this.attr_table_select);
            }
        }
        if (changes['selectSwitch']) {
            if (this.selectSwitch !== undefined) {
                const ent_type = this.tab_map[this.getCurrentTab()];
                this.refreshLabels(ent_type);
            }
        }
        if (changes['attribLabel']) {
            if (this.attribLabel !== undefined) {
                const ent_type = this.tab_map[this.getCurrentTab()];
                this.currentAttribLabel = this.attribLabel;
                this.refreshLabels(ent_type);
            }
        }
    }
    ngOnDestroy() {
        this._elem = null;
        this.container = null;
        this.dataService.switch_page = true;
        this.model = null;
        clearInterval(this.renderInterval);
        this.renderInterval = null;
        this._data_threejs.perspControls.removeEventListener('change', this.activateRender);
        this._data_threejs.orthoControls.removeEventListener('change', this.activateRender);
        // this.keyboardServiceSub.unsubscribe();
    }
    activateRender() {
        renderCheck = true;
    }
    /**
     * @param self
     */
    render() {
        const textLabels = this._data_threejs.textLabels;
        if (textLabels.size !== 0) {
            textLabels.forEach((label) => {
                label.updatePosition();
            });
        }
        this._data_threejs.renderer.render(this._data_threejs.scene, this._data_threejs.camera);
    }
    getCurrentTab() {
        if (localStorage.getItem('mpm_attrib_current_tab') !== null) {
            return Number(localStorage.getItem('mpm_attrib_current_tab'));
        }
        else {
            return 0;
        }
    }
    refreshLabels(ent_type) {
        if (!this.SelectingEntityType.id) {
            return;
        }
        const allLabels = document.getElementsByClassName(`text-label${_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntTypeStr"][ent_type]}`);
        const unSorted = this.dataService.selected_ents.get(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntTypeStr"][ent_type]);
        if (unSorted === undefined) {
            return;
        }
        const sorted = Object(_libs_util_maps__WEBPACK_IMPORTED_MODULE_7__["sortByKey"])(unSorted);
        const arr = Array.from(sorted.values());
        const showSelected = JSON.parse(sessionStorage.getItem('mpm_showSelected'));
        const attr_names = this._data_threejs.model.modeldata.attribs.query.getAttribNames(ent_type);
        let attr_name = this.currentAttribLabel, isArr = false, key;
        if (attr_name.match(/\[.*?\]/g)) {
            isArr = true;
            const _key = String(attr_name.match(/\[.*?\]/g));
            const _attr_name = attr_name.replace(_key, '');
            key = Number(_key.replace('[', '').replace(']', ''));
            attr_name = _attr_name;
        }
        else {
            isArr = false;
        }
        if (attr_name !== '') {
            if (attr_names.includes(attr_name)) {
                for (let i = 0; i < allLabels.length; i++) {
                    const element = allLabels[i];
                    const attr = Number(element.getAttribute('data-index'));
                    const attr_val = this._data_threejs.model.modeldata.attribs.query.getAttribVal(ent_type, attr_name, attr);
                    const _attr_val = attr_val !== undefined ? attr_val : '';
                    if (isArr && _attr_val !== '') {
                        const val = String(_attr_val).split(',')[key];
                        const _val = val !== undefined ? val : '';
                        element.innerHTML = _val;
                    }
                    else {
                        element.innerHTML = String(_attr_val);
                    }
                }
            }
            else if (attr_name === '#') {
                this.labelforindex(showSelected, allLabels, arr);
            }
            else if (attr_name === '_id') {
                for (let i = 0; i < allLabels.length; i++) {
                    const element = allLabels[i];
                    const val = element.getAttribute('title');
                    element.innerHTML = String(val);
                }
            }
        }
        else {
            this.labelforindex(showSelected, allLabels, arr);
            for (let i = 0; i < allLabels.length; i++) {
                const element = allLabels[i];
                element.innerHTML = String('');
            }
        }
        this.activateRender();
        setTimeout(() => {
            this.activateRender();
        }, 50);
        // this.render();
    }
    labelforindex(showSelected, allLabels, arr) {
        if (showSelected) {
            for (let i = 0; i < allLabels.length; i++) {
                const element = allLabels[i];
                const val = Number(element.getAttribute('data-index'));
                const index = arr.findIndex(l => l === val);
                element.innerHTML = String(index);
            }
        }
        else {
            const ent_arr = this.model.modeldata.geom.query.getEnts(this.SelectingEntityType.id);
            for (let i = 0; i < allLabels.length; i++) {
                const element = allLabels[i];
                const val = Number(element.getAttribute('data-index'));
                const index = ent_arr.findIndex(l => l === val);
                element.innerHTML = String(index);
            }
        }
    }
    attrTableSelect(attrib, flowchart = false) {
        sessionStorage.setItem('mpm_changetab', 'false');
        if (attrib.action === 'select') {
            if (!flowchart) {
                this.unselectAll();
            } // If select from Flowchart, don't unselect all.
            switch (attrib.ent_type) {
                case _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntTypeStr"][_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].POSI]:
                    if (typeof attrib.id === 'number') {
                        this.selectPositions(attrib.id, null, null, attrib.ent_type + attrib.id);
                    }
                    else {
                        attrib.id.forEach((_id) => {
                            this.selectPositions(_id, null, null, attrib.ent_type + _id);
                        });
                    }
                    break;
                case _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntTypeStr"][_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].VERT]:
                    if (typeof attrib.id === 'number') {
                        this.selectVertex(attrib.id, null, null, attrib.ent_type + attrib.id);
                    }
                    else {
                        attrib.id.forEach((_id) => {
                            this.selectVertex(_id, null, null, attrib.ent_type + _id);
                        });
                    }
                    break;
                case _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntTypeStr"][_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].EDGE]:
                    if (typeof attrib.id === 'number') {
                        this.selectEdge(attrib.id);
                    }
                    else {
                        attrib.id.forEach((_id) => {
                            this.selectEdge(_id);
                        });
                    }
                    break;
                case _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntTypeStr"][_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].WIRE]:
                    if (typeof attrib.id === 'number') {
                        this.selectWire(attrib.id);
                    }
                    else {
                        attrib.id.forEach((_id) => {
                            this.selectWire(_id);
                        });
                    }
                    break;
                case _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntTypeStr"][_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].FACE]:
                    if (typeof attrib.id === 'number') {
                        this.selectFace(attrib.id);
                    }
                    else {
                        attrib.id.forEach((_id) => {
                            this.selectFace(_id);
                        });
                    }
                    break;
                case _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntTypeStr"][_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].PGON]:
                    if (typeof attrib.id === 'number') {
                        this.selectPGon(attrib.id);
                    }
                    else {
                        attrib.id.forEach((_id) => {
                            this.selectPGon(_id);
                        });
                    }
                    break;
                case _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntTypeStr"][_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].PLINE]:
                    if (typeof attrib.id === 'number') {
                        this.selectPLine(attrib.id);
                    }
                    else {
                        attrib.id.forEach((_id) => {
                            this.selectPLine(_id);
                        });
                    }
                    break;
                case _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntTypeStr"][_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].POINT]:
                    if (typeof attrib.id === 'number') {
                        this.selectPoint(attrib.id);
                    }
                    else {
                        attrib.id.forEach((_id) => {
                            this.selectPoint(_id);
                        });
                    }
                    break;
                case _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntTypeStr"][_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].COLL]:
                    if (typeof attrib.id === 'number') {
                        // const coll_parents = this.model.modeldata.geom.query.getCollParents(attrib.id);
                        // if (coll_parents[0] === -1) { // no parent
                        //     this.chooseColl(attrib.id);
                        // } else {
                        //     coll_parents.forEach(element => {
                        //         this.chooseColl(element);
                        //     });
                        // }
                        this.chooseColl(attrib.id);
                        // const parent_coll_i: number = this.model.modeldata.geom.query.getCollParent(attrib.id);
                        // if (parent_coll_i === -1) { // no parent
                        //     this.chooseColl(attrib.id);
                        // }
                    }
                    else {
                        attrib.id.forEach((_id) => {
                            this.chooseColl(_id);
                        });
                    }
                    break;
                default:
                    break;
            }
        }
        else if (attrib.action === 'unselect') {
            if (attrib.ent_type === _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntTypeStr"][_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].COLL]) {
                const coll_children = this.dataService.selected_coll.get(attrib.ent_type + attrib.id);
                if (coll_children && coll_children.length) {
                    coll_children.forEach(child => {
                        this.unselectGeom(child, attrib.ent_type, true);
                    });
                    this.dataService.selected_ents.get(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntTypeStr"][_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].COLL]).delete(attrib.ent_type + attrib.id);
                }
            }
            else {
                this.unselectGeom(attrib.ent_type + attrib.id, attrib.ent_type, true);
            }
        }
        this.refreshLabels(this.tab_map[this.getCurrentTab()]);
    }
    getGISummary(model) {
        let colls = 0, pgons = 0, plines = 0, points = 0, faces = 0, wires = 0, edges = 0, vertices = 0, positions = 0;
        if (this) {
            colls = model.modeldata.geom.query.numEnts(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].COLL);
            pgons = model.modeldata.geom.query.numEnts(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].PGON);
            plines = model.modeldata.geom.query.numEnts(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].PLINE);
            points = model.modeldata.geom.query.numEnts(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].POINT);
            faces = model.modeldata.geom.query.numEnts(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].FACE);
            wires = model.modeldata.geom.query.numEnts(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].WIRE);
            edges = model.modeldata.geom.query.numEnts(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].EDGE);
            vertices = model.modeldata.geom.query.numEnts(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].VERT);
            positions = model.modeldata.geom.query.numEnts(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].POSI);
        }
        const gi_summary = [{ title: 'Collections', val: colls },
            { title: 'Polygons', val: pgons },
            { title: 'Polylines', val: plines },
            { title: 'Points', val: points },
            { title: 'Faces', val: faces },
            { title: 'Wires', val: wires },
            { title: 'Edges', val: edges },
            { title: 'Vertices', val: vertices },
            { title: 'Positions', val: positions }];
        localStorage.setItem('gi_summary', JSON.stringify(gi_summary));
    }
    /**
     * Update the model in the viewer.
     */
    updateModel(model) {
        return __awaiter(this, void 0, void 0, function* () {
            this._data_threejs = this.dataService.getThreejsScene();
            if (!model) {
                console.warn('Model or Scene not defined.');
                this._no_model = true;
                return;
            }
            else {
                this._data_threejs.model = model;
                try {
                    // add geometry to the scene
                    this._data_threejs.populateScene(model, this.container);
                    // this.resetTable();
                    this.getGISummary(model);
                    if (localStorage.getItem('gi_summary')) {
                        this.giSummary = JSON.parse(localStorage.getItem('gi_summary'));
                    }
                    this._model_error = false;
                    this._no_model = false;
                    // Show Flowchart Selected Entities
                    const selected = this.model.modeldata.geom.selected;
                    this.dataService.clearAll();
                    if (selected !== undefined && selected.length) {
                        let selectingType;
                        this._data_threejs.selected_geoms.clear();
                        const select_groups = {};
                        selected.forEach(s => {
                            const type = _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntTypeStr"][s[0]], id = Number(s[1]);
                            let idList;
                            if (!select_groups[type]) {
                                idList = [];
                            }
                            else {
                                idList = select_groups[type];
                            }
                            if (this.model.modeldata.geom.query.entExists(s[0], id)) {
                                this.dataService.selected_ents.get(type).set(`${type}${id}`, id);
                                idList.push(id);
                                // this.attrTableSelect({ action: 'select', ent_type: type, id: id }, true);
                            }
                            select_groups[type] = idList;
                            selectingType = s[0];
                        });
                        for (const type in select_groups) {
                            if (!select_groups[type]) {
                                continue;
                            }
                            this.attrTableSelect({ action: 'select', ent_type: type, id: select_groups[type] }, true);
                        }
                        sessionStorage.setItem('mpm_showSelected', 'true');
                        sessionStorage.setItem('mpm_changetab', 'true');
                        localStorage.setItem('mpm_attrib_current_tab', this.tab_rev_map[selectingType]);
                        this.selectEntityType(this.selections.find(selection => selection.id === selectingType));
                    }
                    else {
                        sessionStorage.setItem('mpm_showSelected', 'false');
                        sessionStorage.setItem('mpm_changetab', 'false');
                    }
                    this.getSelectingEntityType();
                    this.refreshTable(event);
                }
                catch (ex) {
                    console.error('Error displaying model:', ex);
                    this._model_error = true;
                    this._data_threejs.text = ex;
                }
            }
        });
    }
    onClick(event) {
        if (event.target.tagName !== 'CANVAS') {
            return null;
        }
        else {
            this.onUserAction(event);
            this.refreshLabels(this.tab_map[this.getCurrentTab()]);
        }
    }
    onMouseUp(event) {
        if (event.target.tagName !== 'CANVAS' || !this.lastX || !this.model) {
            return null;
        }
        for (const htmlElement of this.container.children) {
            if (htmlElement.id.startsWith('textLabel')) {
                htmlElement.style.display = '';
            }
        }
        const distX = event.clientX - event.target.getBoundingClientRect().left - this.lastX;
        const distY = event.clientY - event.target.getBoundingClientRect().top - this.lastY;
        const distSqr = distX * distX + distY * distY;
        if (performance.now() - this.dragHash < 500 && distSqr < 500) {
            this.onUserAction(event);
            this.refreshLabels(this.tab_map[this.getCurrentTab()]);
        }
        else {
            // this._data_threejs._controls.enabled = true;
        }
        this.lastX = null;
        this.lastY = null;
        // this.isDown = false;
    }
    // public onMouseMove(event) {
    //     const body = document.getElementsByTagName('body');
    //     if (event.target.tagName !== 'CANVAS') {
    //         // body[0].style.cursor = 'default';
    //         return null;
    //     } else {
    //         if (!this.isDown) {
    //             // const intersects = this.threeJSViewerService.initRaycaster(event);
    //             // if (intersects && intersects.length > 0) {
    //             //     body[0].style.cursor = 'pointer';
    //             // } else {
    //             //     body[0].style.cursor = 'default';
    //             // }
    //             return;
    //         }
    //         const mouseX = event.clientX - event.target.getBoundingClientRect().left;
    //         const mouseY = event.clientY - event.target.getBoundingClientRect().top;
    //         const dx = mouseX - this.lastX;
    //         const dy = mouseY - this.lastY;
    //         this.lastX = mouseX;
    //         this.lastY = mouseY;
    //         this.dragHash += Math.abs(dx) + Math.abs(dy);
    //         if (this.dragHash > 4) {
    //             // dragging
    //         }
    //     }
    // }
    onMouseDown(event) {
        if (event.target.tagName !== 'CANVAS' || !this.model) {
            return null;
        }
        else {
            event.stopPropagation();
            this.lastX = event.clientX - event.target.getBoundingClientRect().left;
            this.lastY = event.clientY - event.target.getBoundingClientRect().top;
            for (const htmlElement of this.container.children) {
                if (htmlElement.id.startsWith('textLabel')) {
                    htmlElement.style.display = 'none';
                }
            }
            // Put your mousedown stuff here
            this.dragHash = performance.now();
            // this.isDown = true;
        }
    }
    onKeyDown(event) {
    }
    onKeyUp(event) {
    }
    onUserAction(event) {
        // get entities for mouse event
        const intersects = this.threeJSViewerService.initRaycaster(event);
        if (event.shiftKey || event.ctrlKey || event.metaKey) {
            this.shiftKeyPressed = true;
        }
        // check intersect exist
        if (intersects.length > 0) {
            if (event.which === 1) {
                // check mouse event triggered in THREE viewer, then enable dropdown menu
                if (event.target.tagName === 'CANVAS') {
                    const pos_x = event.clientX - event.target.getBoundingClientRect().left;
                    const pos_y = event.clientY - event.target.getBoundingClientRect().top;
                    this.dropdownPosition = { x: pos_x, y: pos_y };
                }
                let intsType = '';
                switch (this.SelectingEntityType.id) {
                    case _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].POSI:
                    case _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].POINT:
                    case _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].VERT:
                        intsType = 'Points';
                        break;
                    case _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].EDGE:
                    case _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].WIRE:
                    case _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].PLINE:
                        intsType = 'LineSegments';
                        break;
                    case _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].FACE:
                    case _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].PGON:
                        intsType = 'Mesh';
                        break;
                }
                let intsObj = intersects[0];
                for (const inst of intersects) {
                    if (inst.object.type === intsType) {
                        intsObj = inst;
                        break;
                    }
                }
                this.selectObj(intsObj);
                // setTimeout(() => {
                //     this.activateRender();
                // }, 50);
            }
        }
        else {
            if (event.target.tagName === 'CANVAS') {
                this.unselectAll();
                this.resetTable();
                if (event.target.tagName !== 'OL') {
                    // not clicking on Menu item, hide dropdown menu
                    this.dropdown.visible = false;
                    // return;
                }
            }
        }
        this.shiftKeyPressed = false;
        this.refreshTable(event);
    }
    refreshTable(event) {
        this.action.emit({ 'type': 'eventClicked', 'event': event });
        setTimeout(() => {
            this.activateRender();
        }, 0);
    }
    resetTable() {
        this.action.emit({ 'type': 'resetTableEvent', 'event': null });
    }
    unselectAll() {
        const scene = this._data_threejs;
        const selectings = Array.from(scene.selected_geoms.keys());
        for (const selecting of selectings) {
            scene.unselectObj(selecting, this.container);
        }
        document.querySelectorAll('[id^=textLabel_]').forEach(value => {
            this.container.removeChild(value);
        });
        this._data_threejs.textLabels.clear();
        this.dataService.selected_ents.forEach(map => {
            map.clear();
        });
        this.refreshTable(event);
        scene.scene_objs_selected.clear();
        // if (this.SelectingEntityType.id === EEntTypeStr[EEntType.COLL]) {
        //     document.getElementById('executeButton').click();
        // }
        const positions = Array.from(scene.selected_positions.keys());
        for (const posi of positions) {
            scene.unselectObjGroup(posi, this.container, 'positions');
        }
        const vertex = Array.from(scene.selected_vertex.keys());
        for (const vert of vertex) {
            scene.unselectObjGroup(vert, this.container, 'vertex');
        }
        const edges = Array.from(scene.selected_face_edges.keys());
        for (const edge of edges) {
            scene.unselectObjGroup(edge, this.container, 'face_edges');
        }
        const wires = Array.from(scene.selected_face_wires.keys());
        for (const wire of wires) {
            scene.unselectObjGroup(wire, this.container, 'face_wires');
        }
        setTimeout(() => {
            this.activateRender();
        }, 0);
    }
    getSelectingEntityType() {
        const select = JSON.parse(localStorage.getItem('mpm_settings'))['select'];
        const default_selector = { id: _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].FACE, name: 'Faces' };
        if (select && select.enabledselector) {
            this.selections = [];
            for (const i in select.enabledselector) {
                if (select.enabledselector[i]) {
                    this.selections.push(this.default_selections[i]);
                }
            }
        }
        if (select !== undefined && select.selector && this.selections.indexOf(select.selector) !== -1) {
            this.SelectingEntityType = select.selector;
        }
        else if (this.selections.indexOf(default_selector) !== -1) {
            this.SelectingEntityType = default_selector;
        }
        else if (this.selections.length > 0) {
            this.SelectingEntityType = this.selections[0];
        }
        else {
            this.SelectingEntityType = { id: null, name: null };
        }
        // if (localStorage.getItem('mpm_selecting_entity_type') != null) {
        //     this.SelectingEntityType = JSON.parse(localStorage.getItem('mpm_selecting_entity_type'));
        // }
    }
    selectObj(intersect0) {
        const scene = this._data_threejs;
        // this.getSelectingEntityType();
        switch (this.SelectingEntityType.id) {
            case _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].POSI:
                if (intersect0.object.type === 'Points') {
                    let posi = 0;
                    for (const m of scene.posis_map) {
                        if (m[1] === intersect0.index) {
                            posi = m[0];
                            break;
                        }
                    }
                    // const posi = scene.posis_map.get(intersect0.index);
                    // const posi = scene.posis_idx_to_i[intersect0.index];
                    const ent_id = `${_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntTypeStr"][_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].POSI]}${posi}`;
                    if (scene.selected_geoms.has(ent_id)) {
                        this.unselectGeom(ent_id, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntTypeStr"][_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].POSI], true);
                    }
                    else {
                        if (!this.shiftKeyPressed) {
                            this.unselectAll();
                        }
                        this.selectPositions(posi, null, null, ent_id);
                    }
                }
                else if (intersect0.object.type === 'LineSegments') {
                    let edge;
                    const edge_color = intersect0.object.material.color;
                    if (edge_color['r'] === 1 && edge_color['b'] === 1 && edge_color['g'] === 1) {
                        edge = scene.white_edge_select_map.get(intersect0.index / 2);
                    }
                    else {
                        edge = scene.edge_select_map.get(intersect0.index / 2);
                    }
                    // const edge = scene.edge_select_map.get(intersect0.index / 2);
                    const ent_id = `_e_posi${edge}`;
                    if (scene.selected_positions.has(ent_id)) {
                        this.unselectGeom(ent_id, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntTypeStr"][_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].POSI]);
                    }
                    else {
                        if (!this.shiftKeyPressed) {
                            this.unselectAll();
                        }
                        this.selectPositions(null, edge, null, ent_id);
                    }
                }
                else if (intersect0.object.type === 'Mesh') {
                    // const tri = scene.tris_select_idx_to_i[intersect0.faceIndex];
                    const tri = scene.tri_select_map.get(intersect0.faceIndex);
                    const face = this.model.modeldata.geom.nav.navTriToFace(tri);
                    const ent_id = `_f_posi${face}`;
                    if (scene.selected_positions.has(ent_id)) {
                        this.unselectGeom(ent_id, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntTypeStr"][_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].POSI]);
                    }
                    else {
                        if (!this.shiftKeyPressed) {
                            this.unselectAll();
                        }
                        this.selectPositions(null, null, face, ent_id);
                    }
                }
                break;
            case _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].VERT:
                if (intersect0.object.type === 'Points') {
                    let posi = 0;
                    for (const m of scene.posis_map) {
                        if (m[1] === intersect0.index) {
                            posi = m[0];
                            break;
                        }
                    }
                    // const vert = scene.verts_idx_to_i[intersect0.index];
                    // const vert = scene.vertex_map.get(intersect0.index);
                    const verts = this.model.modeldata.geom.nav.navPosiToVert(posi);
                    let point;
                    if (verts.length > 1) {
                        this.dropdown.setItems(verts, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntTypeStr"][_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].VERT]);
                        this.dropdown.visible = true;
                        this.dropdown.position = this.dropdownPosition;
                    }
                    else {
                        let vert = 0;
                        for (const m of scene.vertex_map) {
                            if (m[1] === intersect0.index) {
                                vert = m[0];
                                break;
                            }
                        }
                        point = vert;
                    }
                    const ent_id = `${_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntTypeStr"][_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].VERT]}${point}`;
                    if (scene.selected_geoms.has(ent_id)) {
                        this.unselectGeom(ent_id, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntTypeStr"][_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].VERT], true);
                    }
                    else {
                        if (!this.shiftKeyPressed) {
                            this.unselectAll();
                        }
                        this.selectVertex(point, null, null, ent_id);
                    }
                }
                else if (intersect0.object.type === 'LineSegments') {
                    let edge;
                    const edge_color = intersect0.object.material.color;
                    if (edge_color['r'] === 1 && edge_color['b'] === 1 && edge_color['g'] === 1) {
                        edge = scene.white_edge_select_map.get(intersect0.index / 2);
                    }
                    else {
                        edge = scene.edge_select_map.get(intersect0.index / 2);
                    }
                    // const edge = scene.edge_select_map.get(intersect0.index / 2);
                    const ent_id = `_e_v${edge}`;
                    if (scene.selected_vertex.has(ent_id)) {
                        this.unselectGeom(ent_id, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntTypeStr"][_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].VERT]);
                    }
                    else {
                        if (!this.shiftKeyPressed) {
                            this.unselectAll();
                        }
                        this.selectVertex(null, edge, null, ent_id);
                    }
                }
                else if (intersect0.object.type === 'Mesh') {
                    const tri = scene.tri_select_map.get(intersect0.faceIndex);
                    const face = this.model.modeldata.geom.nav.navTriToFace(tri);
                    // // const tri = scene.tri_select_map.get(intersect0.faceIndex);
                    // const tri = scene.tris_select_idx_to_i[intersect0.faceIndex];
                    const ent_id = `_f_v${face}`;
                    if (scene.selected_vertex.has(ent_id)) {
                        this.unselectGeom(ent_id, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntTypeStr"][_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].VERT]);
                    }
                    else {
                        if (!this.shiftKeyPressed) {
                            this.unselectAll();
                        }
                        this.selectVertex(null, null, face, ent_id);
                    }
                }
                break;
            case _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].COLL:
                if (!this.shiftKeyPressed) {
                    this.unselectAll();
                }
                this.selectColl(intersect0, intersect0.object.type);
                break;
            case _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].FACE:
                if (intersect0.object.type === 'Mesh') {
                    const tri = scene.tri_select_map.get(intersect0.faceIndex);
                    const face = this.model.modeldata.geom.nav.navTriToFace(tri);
                    // // const tri = scene.tri_select_map.get(intersect0.faceIndex);
                    // const tri = scene.tris_select_idx_to_i[intersect0.faceIndex];
                    const ent_id = `${_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntTypeStr"][_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].FACE]}${face}`;
                    if (scene.selected_geoms.has(ent_id)) {
                        this.unselectGeom(ent_id, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntTypeStr"][_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].FACE], true);
                    }
                    else {
                        if (!this.shiftKeyPressed) {
                            this.unselectAll();
                        }
                        this.selectFace(face);
                    }
                }
                else {
                    this.showMessages('Faces');
                }
                break;
            case _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].PGON:
                if (intersect0.object.type === 'Mesh') {
                    const tri = scene.tri_select_map.get(intersect0.faceIndex);
                    const face = this.model.modeldata.geom.nav.navTriToFace(tri);
                    const pgon = this.model.modeldata.geom.nav.navFaceToPgon(face);
                    // const tri = scene.tris_select_idx_to_i[intersect0.faceIndex];
                    const ent_id = `${_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntTypeStr"][_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].PGON]}${pgon}`;
                    if (scene.selected_geoms.has(ent_id)) {
                        this.unselectGeom(ent_id, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntTypeStr"][_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].PGON], true);
                    }
                    else {
                        if (!this.shiftKeyPressed) {
                            this.unselectAll();
                        }
                        this.selectPGon(face);
                    }
                }
                else {
                    this.showMessages('Polygons');
                }
                break;
            case _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].EDGE:
                if (intersect0.object.type === 'LineSegments') {
                    let edge;
                    const edge_color = intersect0.object.material.color;
                    if (edge_color['r'] === 1 && edge_color['b'] === 1 && edge_color['g'] === 1) {
                        edge = scene.white_edge_select_map.get(intersect0.index / 2);
                    }
                    else {
                        edge = scene.edge_select_map.get(intersect0.index / 2);
                    }
                    // const edge = scene.edge_select_map.get(intersect0.index / 2);
                    const ent_id = `${_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntTypeStr"][_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].EDGE]}${edge}`;
                    if (scene.selected_geoms.has(ent_id)) {
                        this.unselectGeom(ent_id, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntTypeStr"][_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].EDGE], true);
                    }
                    else {
                        if (!this.shiftKeyPressed) {
                            this.unselectAll();
                        }
                        this.selectEdge(edge);
                    }
                }
                else if (intersect0.object.type === 'Mesh') {
                    const tri = scene.tri_select_map.get(intersect0.faceIndex);
                    const face = this.model.modeldata.geom.nav.navTriToFace(tri);
                    // const tri = scene.tris_select_idx_to_i[intersect0.faceIndex];
                    const ent_id = `${_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntTypeStr"][_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].FACE]}${face}`;
                    if (scene.selected_face_edges.has(ent_id)) {
                        this.unselectGeom(ent_id, 'face_edges');
                    }
                    else {
                        if (!this.shiftKeyPressed) {
                            this.unselectAll();
                        }
                        this.selectEdgeByFace(face, ent_id);
                    }
                }
                else {
                    this.showMessages('Edges');
                }
                break;
            case _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].WIRE:
                if (intersect0.object.type === 'LineSegments') {
                    let edge;
                    const edge_color = intersect0.object.material.color;
                    if (edge_color['r'] === 1 && edge_color['b'] === 1 && edge_color['g'] === 1) {
                        edge = scene.white_edge_select_map.get(intersect0.index / 2);
                    }
                    else {
                        edge = scene.edge_select_map.get(intersect0.index / 2);
                    }
                    const wire = this.model.modeldata.geom.nav.navEdgeToWire(edge);
                    // const edge = scene.edge_select_map.get(intersect0.index / 2)
                    // const edge = scene.edges_select_idx_to_i[intersect0.index / 2],
                    const ent_id = `${_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntTypeStr"][_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].WIRE]}${edge}`;
                    if (scene.selected_geoms.has(ent_id)) {
                        this.unselectGeom(ent_id, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntTypeStr"][_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].WIRE], true);
                    }
                    else {
                        if (!this.shiftKeyPressed) {
                            this.unselectAll();
                        }
                        this.selectWire(wire);
                    }
                }
                else if (intersect0.object.type === 'Mesh') {
                    const tri = scene.tri_select_map.get(intersect0.faceIndex);
                    const face = this.model.modeldata.geom.nav.navTriToFace(tri);
                    // const tri = scene.tris_select_idx_to_i[intersect0.faceIndex];
                    const ent_id = `${_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntTypeStr"][_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].FACE]}${face}`;
                    if (scene.selected_face_wires.has(ent_id)) {
                        this.unselectGeom(ent_id, 'face_wires');
                    }
                    else {
                        if (!this.shiftKeyPressed) {
                            this.unselectAll();
                        }
                        this.selectWireByFace(face, ent_id);
                    }
                }
                else {
                    this.showMessages('Wires');
                }
                break;
            case _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].PLINE:
                if (intersect0.object.type === 'LineSegments') {
                    let edge;
                    const edge_color = intersect0.object.material.color;
                    if (edge_color['r'] === 1 && edge_color['b'] === 1 && edge_color['g'] === 1) {
                        edge = scene.white_edge_select_map.get(intersect0.index / 2);
                    }
                    else {
                        edge = scene.edge_select_map.get(intersect0.index / 2);
                    }
                    // const edge = scene.edge_select_map.get(intersect0.index / 2);
                    const wire = this.model.modeldata.geom.nav.navEdgeToWire(edge);
                    const pline = this.model.modeldata.geom.nav.navWireToPline(wire);
                    // const edge = scene.edges_select_idx_to_i[intersect0.index / 2];
                    const ent_id = `${_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntTypeStr"][_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].PLINE]}${pline}`;
                    if (scene.selected_geoms.has(ent_id)) {
                        this.unselectGeom(ent_id, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntTypeStr"][_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].PLINE], true);
                    }
                    else {
                        if (!this.shiftKeyPressed) {
                            this.unselectAll();
                        }
                        if (pline !== undefined && pline !== null) {
                            this.selectPLine(pline);
                        }
                        else {
                            this.showMessages('Selection is not a Polyline', 'custom');
                        }
                    }
                }
                else {
                    this.showMessages('Polylines');
                }
                break;
            case _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].POINT:
                if (intersect0.object.type === 'Points') {
                    const vert = this.model.modeldata.geom.nav.navPosiToVert(intersect0.index);
                    const _point = this.model.modeldata.geom.nav.navVertToPoint(vert[0]);
                    const point = scene.point_select_map.get(_point);
                    // const point = scene.points_select_idx_to_i[_point];
                    const ent_id = `${_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntTypeStr"][_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].POINT]}${point}`;
                    if (scene.selected_geoms.has(ent_id)) {
                        this.unselectGeom(ent_id, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntTypeStr"][_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].POINT], true);
                    }
                    else {
                        if (!this.shiftKeyPressed) {
                            this.unselectAll();
                        }
                        if (point !== undefined && point !== null) {
                            this.selectPoint(point);
                        }
                        else {
                            this.showMessages('Selection is not a Point', 'custom');
                        }
                    }
                }
                else {
                    this.showMessages('Points');
                }
                break;
            default:
                return;
                this.showMessages('Please choose an Entity type.', 'custom');
                break;
        }
        // this.activateRender();
        // this.render();
    }
    showMessages(msg, mode = 'notice') {
        switch (mode) {
            case 'custom':
                this.message = msg;
                break;
            case 'notice':
                this.message = `Please Select ${msg}`;
                break;
            default:
                break;
        }
        this.messageVisible = true;
        setTimeout(() => {
            this.messageVisible = false;
        }, 3000);
    }
    selectPositions(point = null, edge = null, face = null, parent_ent_id) {
        const ent_type_str = _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntTypeStr"][_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].POSI];
        const scene = this._data_threejs;
        const posi_ent = this.dataService.selected_ents.get(ent_type_str);
        if (point !== null) {
            const position = this.model.modeldata.attribs.query.getPosiCoords(point);
            const ent_id = parent_ent_id;
            posi_ent.set(ent_id, point);
            const labelText = this.indexAsLabel(ent_type_str, ent_id, point, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].POSI);
            scene.selectObjPosition(null, ent_id, position, this.container, labelText);
            this.dataService.selected_positions.set(`${parent_ent_id}`, [ent_id]);
        }
        else if (edge !== null) {
            const verts = this.model.modeldata.geom.nav.navEdgeToVert(edge);
            const posis = verts.map(v => this.model.modeldata.geom.nav.navVertToPosi(v));
            const children = [];
            posis.map(posi => {
                const ent_id = `${ent_type_str}${posi}`;
                const position = this.model.modeldata.attribs.query.getPosiCoords(posi);
                posi_ent.set(ent_id, posi);
                const labelText = this.indexAsLabel(ent_type_str, ent_id, posi, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].POSI);
                scene.selectObjPosition(parent_ent_id, ent_id, position, this.container, labelText);
                children.push(ent_id);
            });
            this.dataService.selected_positions.set(`${parent_ent_id}`, children);
        }
        else if (face !== null) {
            const tris = this.model.modeldata.geom.nav.navFaceToTri(face), posis = tris.map(tri => this.model.modeldata.geom.nav.navAnyToPosi(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].TRI, tri)), posi_flat = [].concat(...posis);
            const uniqPositions = this.uniq(posi_flat);
            const children = [];
            uniqPositions.map(posi => {
                const ent_id = `${ent_type_str}${posi}`;
                const position = this.model.modeldata.attribs.query.getPosiCoords(posi);
                posi_ent.set(ent_id, posi);
                const labelText = this.indexAsLabel(ent_type_str, ent_id, posi, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].POSI);
                scene.selectObjPosition(parent_ent_id, ent_id, position, this.container, labelText);
                children.push(ent_id);
            });
            this.dataService.selected_positions.set(`${parent_ent_id}`, children);
        }
    }
    uniq(a) {
        const seen = {};
        return a.filter(function (item) {
            return seen.hasOwnProperty(item) ? false : (seen[item] = true);
        });
    }
    selectVertex(point = null, edge = null, face = null, parent_ent_id) {
        const ent_type_str = _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntTypeStr"][_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].VERT];
        const posi_ent = this.dataService.selected_ents.get(ent_type_str);
        const scene = this._data_threejs;
        if (point !== null) {
            const position = this.model.modeldata.attribs.query.getVertCoords(point);
            const ent_id = parent_ent_id;
            posi_ent.set(ent_id, point);
            const labelText = this.indexAsLabel(ent_type_str, ent_id, point, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].VERT);
            scene.selectObjvertex(null, ent_id, position, this.container, labelText);
            this.dataService.selected_vertex.set(`${parent_ent_id}`, [ent_id]);
        }
        else if (edge !== null) {
            const verts = this.model.modeldata.geom.nav.navEdgeToVert(edge);
            const children = [];
            verts.map(vert => {
                const ent_id = `${ent_type_str}${vert}`;
                const position = this.model.modeldata.attribs.query.getVertCoords(vert);
                posi_ent.set(ent_id, vert);
                const labelText = this.indexAsLabel(ent_type_str, ent_id, vert, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].VERT);
                scene.selectObjvertex(parent_ent_id, ent_id, position, this.container, labelText);
                children.push(ent_id);
            });
            this.dataService.selected_vertex.set(`${parent_ent_id}`, children);
        }
        else if (face !== null) {
            const tris = this.model.modeldata.geom.nav.navFaceToTri(face), verts = tris.map(tri => this.model.modeldata.geom.nav.navTriToVert(tri)), verts_flat = [].concat(...verts);
            const uniqVerts = this.uniq(verts_flat);
            const children = [];
            uniqVerts.map(vert => {
                const ent_id = `${ent_type_str}${vert}`;
                const position = this.model.modeldata.attribs.query.getVertCoords(vert);
                posi_ent.set(ent_id, vert);
                const labelText = this.indexAsLabel(ent_type_str, ent_id, vert, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].VERT);
                scene.selectObjvertex(parent_ent_id, ent_id, position, this.container, labelText);
                children.push(ent_id);
            });
            this.dataService.selected_vertex.set(`${parent_ent_id}`, children);
        }
    }
    unselectGeom(ent_id, ent_type_str, direct = false) {
        const scene = this._data_threejs;
        if (!direct) {
            if (ent_type_str === _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntTypeStr"][_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].POSI]) {
                this.unselectLabel(ent_id, ent_type_str);
                scene.unselectObjGroup(ent_id, this.container, 'positions');
                const children = this.dataService.selected_positions.get(ent_id);
                children.forEach(c => {
                    this.dataService.selected_ents.get(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntTypeStr"][_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].POSI]).delete(c);
                });
                this.dataService.selected_positions.delete(ent_id);
            }
            else if (ent_type_str === _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntTypeStr"][_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].VERT]) {
                this.unselectLabel(ent_id, ent_type_str);
                scene.unselectObjGroup(ent_id, this.container, 'vertex');
                const children = this.dataService.selected_vertex.get(ent_id);
                children.forEach(c => {
                    this.dataService.selected_ents.get(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntTypeStr"][_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].VERT]).delete(c);
                });
                this.dataService.selected_vertex.delete(ent_id);
            }
            else if (ent_type_str === 'face_edges') {
                scene.unselectObjGroup(ent_id, this.container, 'face_edges');
                const children = this.dataService.selected_face_edges.get(ent_id);
                children.forEach(c => {
                    this.dataService.selected_ents.get(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntTypeStr"][_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].EDGE]).delete(c);
                });
                this.dataService.selected_face_edges.delete(ent_id);
            }
            else if (ent_type_str === 'face_wires') {
                scene.unselectObjGroup(ent_id, this.container, 'face_wires');
                const children = this.dataService.selected_face_wires.get(ent_id);
                children.forEach(c => {
                    this.dataService.selected_ents.get(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntTypeStr"][_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].WIRE]).delete(c);
                });
                this.dataService.selected_face_wires.delete(ent_id);
            }
        }
        else {
            scene.unselectObj(ent_id, this.container);
            this.dataService.selected_ents.get(ent_type_str).delete(ent_id);
            this.unselectLabel(ent_id, ent_type_str);
        }
        this.refreshTable(event);
    }
    unselectLabel(ent_id, ent_type_str) {
        let arr = Array.from(this.dataService.selected_ents.get(ent_type_str).values());
        arr = arr.filter(item => {
            return item !== Number(ent_id.substr(2));
        });
        this.refreshLabels(ent_type_str);
    }
    selectEdge(line) {
        const ent_type_str = _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntTypeStr"][_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].EDGE], verts = this.model.modeldata.geom.nav.navEdgeToVert(line), positions = verts.map(v => this.model.modeldata.attribs.query.getVertCoords(v)), posi_flat = [].concat(...positions), ent_id = `${ent_type_str}${line}`;
        this.dataService.selected_ents.get(ent_type_str).set(ent_id, line);
        const labelText = this.indexAsLabel(ent_type_str, ent_id, line, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].EDGE);
        this._data_threejs.selectObjLine(ent_id, [], posi_flat, this.container, labelText);
    }
    selectEdgeByFace(face, parent_ent_id) {
        const ent_type_str = _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntTypeStr"][_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].EDGE], edges = this.model.modeldata.geom.nav.navAnyToAny(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].FACE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].EDGE, face);
        const children = [];
        edges.map(edge => {
            const ent_id = `${ent_type_str}${edge}`;
            children.push(ent_id);
            const vert = this.model.modeldata.geom.nav.navEdgeToVert(edge);
            const position = [];
            const indices = [];
            vert.map((v, i) => {
                position.push(this.model.modeldata.attribs.query.getVertCoords(v));
                indices.push(i);
            });
            const posi_flat = [].concat(...position);
            this.dataService.selected_ents.get(ent_type_str).set(ent_id, edge);
            const labelText = this.indexAsLabel(ent_type_str, ent_id, edge, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].EDGE);
            this._data_threejs.selectEdgeByFace(parent_ent_id, ent_id, indices, posi_flat, this.container, labelText);
        });
        this.dataService.selected_face_edges.set(`${parent_ent_id}`, children);
    }
    selectWire(wire) {
        const ent_type_str = _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntTypeStr"][_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].WIRE], edges = this.model.modeldata.geom.nav.navWireToEdge(wire), verts = edges.map(e => this.model.modeldata.geom.nav.navEdgeToVert(e)), verts_flat = [].concat(...[].concat(...verts)), indices = [], positions = [];
        verts_flat.map((v, i) => {
            positions.push(this.model.modeldata.attribs.query.getVertCoords(v));
            indices.push(i);
        });
        const posi_flat = [].concat(...positions), ent_id = `${ent_type_str}${wire}`;
        this.dataService.selected_ents.get(ent_type_str).set(ent_id, wire);
        const labelText = this.indexAsLabel(ent_type_str, ent_id, wire, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].WIRE);
        this._data_threejs.selectObjLine(ent_id, indices, posi_flat, this.container, labelText);
    }
    selectWireByFace(face, parent_ent_id) {
        const ent_type_str = _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntTypeStr"][_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].WIRE], wires = this.model.modeldata.geom.nav.navFaceToWire(face);
        const children = [];
        wires.map(wire => {
            const ent_id = `${ent_type_str}${wire}`;
            children.push(ent_id);
            const edges = this.model.modeldata.geom.nav.navWireToEdge(wire), verts = edges.map(e => this.model.modeldata.geom.nav.navEdgeToVert(e));
            // @ts-ignore
            const verts_flat = verts.flat(1), indices = [], positions = [];
            verts_flat.map((v, i) => {
                positions.push(this.model.modeldata.attribs.query.getVertCoords(v));
                indices.push(i);
            });
            const posi_flat = [].concat(...positions);
            this.dataService.selected_ents.get(ent_type_str).set(ent_id, wire);
            const labelText = this.indexAsLabel(ent_type_str, ent_id, wire, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].WIRE);
            this._data_threejs.selectWireByFace(parent_ent_id, ent_id, indices, posi_flat, this.container, labelText);
        });
        this.dataService.selected_face_wires.set(`${parent_ent_id}`, children);
    }
    selectFace(face) {
        const ent_type_str = _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntTypeStr"][_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].FACE], tri = this.model.modeldata.geom.nav.navFaceToTri(face), verts = tri.map(index => this.model.modeldata.geom.nav.navTriToVert(index)), verts_flat = [].concat(...verts), posis = verts_flat.map(v => this.model.modeldata.geom.nav.navAnyToPosi(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].VERT, v)), posis_flat = [].concat(...posis), tri_indices = [], positions = [];
        posis_flat.map((posi, index) => {
            positions.push(this.model.modeldata.attribs.query.getPosiCoords(posi));
            tri_indices.push(index);
        });
        const posi_flat = [].concat(...positions), ent_id = `${ent_type_str}${face}`;
        this.dataService.selected_ents.get(ent_type_str).set(ent_id, face);
        const labelText = this.indexAsLabel(ent_type_str, ent_id, face, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].FACE);
        this._data_threejs.selectObjFace(ent_id, tri_indices, posi_flat, this.container, labelText);
    }
    indexAsLabel(ent_type_str, ent_id, id, type) {
        let indexAsLabel;
        const showSelected = JSON.parse(sessionStorage.getItem('mpm_showSelected'));
        if (showSelected) {
            const sorted = Object(_libs_util_maps__WEBPACK_IMPORTED_MODULE_7__["sortByKey"])(this.dataService.selected_ents.get(ent_type_str));
            const arr = Array.from(sorted.values());
            indexAsLabel = String(arr.findIndex(ent => ent === id));
        }
        else {
            indexAsLabel = ent_id;
            // indexAsLabel = String(this._data_threejs._model.modeldata.attribs.threejs.getIdIndex(type, id));
        }
        return indexAsLabel;
    }
    selectPoint(point) {
        const ent_type_str = _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntTypeStr"][_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].POINT];
        const result = this.getPointPosis(point, null);
        if (result) {
            const point_indices = result.point_indices;
            const point_posi = result.posi_flat;
            const ent_id = `${ent_type_str}${point}`;
            this.dataService.selected_ents.get(ent_type_str).set(ent_id, point);
            const labelText = this.indexAsLabel(ent_type_str, ent_id, point, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].POINT);
            this._data_threejs.selectObjPoint(ent_id, point_indices, point_posi, this.container, labelText);
        }
    }
    selectPLine(pline) {
        const ent_type_str = _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntTypeStr"][_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].PLINE];
        const result = this.getPLinePosis(pline);
        const ent_id = `${ent_type_str}${pline}`;
        if (result) {
            const posi_flat = result.posi_flat;
            const indices = result.indices;
            this.dataService.selected_ents.get(ent_type_str).set(ent_id, pline);
            const labelText = this.indexAsLabel(ent_type_str, ent_id, pline, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].PLINE);
            this._data_threejs.selectObjLine(ent_id, indices, posi_flat, this.container, labelText);
        }
        else {
            this.showMessages('Please Select a Polyline', 'custom');
        }
    }
    selectPGon(face) {
        const ent_type_str = _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntTypeStr"][_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].PGON];
        const result = this.getPGonPosis(face);
        if (result) {
            const posi_flat = result.posi_flat;
            const tri_indices = result.indices;
            const ent_id = `${ent_type_str}${face}`;
            this.dataService.selected_ents.get(ent_type_str).set(ent_id, face);
            const labelText = this.indexAsLabel(ent_type_str, ent_id, face, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].PGON);
            this._data_threejs.selectObjFace(ent_id, tri_indices, posi_flat, this.container, labelText);
        }
    }
    /**
     * get point positions for collections
     * @param points
     */
    getPointPosis(point1 = null, points = null) {
        let verts_flat = null;
        if (point1 !== null) {
            verts_flat = [this.model.modeldata.geom.nav.navPointToVert(point1)];
        }
        if (points !== null) {
            const verts = points.map(p => this.model.modeldata.geom.nav.navPointToVert(p));
            verts_flat = [].concat(...verts);
        }
        const point_indices = [];
        const positions = [];
        verts_flat.map((v, i) => {
            positions.push(this.model.modeldata.attribs.query.getPosiCoords(v));
            point_indices.push(i);
        });
        const posi_flat = [].concat(...positions);
        const result = { posi_flat, point_indices };
        return result;
    }
    /**
     * get pline positions for selectPLine or collections
     * @param wire1
     * @param plines
     */
    getPLinePosis(pline1 = null, plines = null) {
        let wires_flat = null;
        if (pline1 !== null) {
            wires_flat = [this.model.modeldata.geom.nav.navPlineToWire(pline1)];
        }
        if (plines !== null) {
            const wires = plines.map(pl => this.model.modeldata.geom.nav.navPlineToWire(pl));
            wires_flat = [].concat(...wires);
        }
        const edges = wires_flat.map(w => this.model.modeldata.geom.nav.navWireToEdge(w));
        const edges_flat = [].concat(...edges);
        const verts = edges_flat.map(e => this.model.modeldata.geom.nav.navEdgeToVert(e));
        const verts_flat = [].concat(...[].concat(...verts));
        const indices = [];
        const positions = [];
        verts_flat.map((v, i) => {
            positions.push(this.model.modeldata.attribs.query.getVertCoords(v));
            indices.push(i);
        });
        const posi_flat = [].concat(...positions);
        const result = { posi_flat, indices };
        return result;
    }
    /**
     * get pgon positions for selectPGon or collections
     * @param face1
     * @param pgons
     */
    getPGonPosis(face1 = null, pgons = null) {
        let faces_flat = null;
        if (face1 !== null) {
            const _pgon = this.model.modeldata.geom.nav.navFaceToPgon(face1);
            if (_pgon === undefined) {
                return null;
            }
            faces_flat = [this.model.modeldata.geom.nav.navPgonToFace(_pgon)];
        }
        if (pgons !== null) {
            const faces = pgons.map(pgon => this.model.modeldata.geom.nav.navPgonToFace(pgon));
            faces_flat = [].concat(...faces);
        }
        const tris = faces_flat.map(face => this.model.modeldata.geom.nav.navFaceToTri(face));
        const tris_flat = [].concat(...tris);
        const verts = tris_flat.map(tri => this.model.modeldata.geom.nav.navTriToVert(tri));
        const verts_flat = [].concat(...verts);
        const posis = verts_flat.map(v => this.model.modeldata.geom.nav.navAnyToPosi(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].VERT, v));
        const posis_flat = [].concat(...posis);
        const indices = [];
        const positions = [];
        posis_flat.map((posi, index) => {
            positions.push(this.model.modeldata.attribs.query.getPosiCoords(posi));
            indices.push(index);
        });
        const posi_flat = [].concat(...positions);
        const result = { posi_flat, indices };
        return result;
    }
    selectColl(object, type) {
        let colls = [];
        if (type === 'Mesh') {
            const tri = this._data_threejs.tri_select_map.get(object.faceIndex);
            colls = this.model.modeldata.geom.nav.navAnyToColl(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].TRI, tri);
        }
        else if (type === 'LineSegments') {
            let edge;
            const edge_color = object.object.material.color;
            if (edge_color['r'] === 1 && edge_color['b'] === 1 && edge_color['g'] === 1) {
                edge = this._data_threejs.white_edge_select_map.get(object.index / 2);
            }
            else {
                edge = this._data_threejs.edge_select_map.get(object.index / 2);
            }
            colls = this.model.modeldata.geom.nav.navAnyToColl(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].EDGE, edge);
        }
        else if (type === 'Points') {
            const vert = this.model.modeldata.geom.nav.navPosiToVert(object.index);
            const point = this.model.modeldata.geom.nav.navVertToPoint(vert[0]);
            colls = this.model.modeldata.geom.nav.navAnyToColl(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].POINT, point);
        }
        /**
         * Show dropdown menu only when Entity belongs to more than 1 Collection.
         */
        if (this.dataService.selected_ents.get(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntTypeStr"][_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].COLL]).size === 0 && colls.length > 1) {
            this.dropdown.setItems(colls, 'co');
            this.dropdown.visible = true;
            this.dropdown.position = this.dropdownPosition;
        }
        else if (colls && colls.length === 1) {
            this.chooseColl(colls[0]);
        }
        else {
            this.showMessages('No Collections Available', 'custom');
        }
    }
    chooseColl(id) {
        const scene = this._data_threejs;
        const coll_id = `${_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntTypeStr"][_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].COLL]}${id}`;
        const children = [];
        const pgons = this.model.modeldata.geom.nav.navCollToPgon(id);
        const pgons_flat = [].concat(...pgons);
        let labelText = this.indexAsLabel(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntTypeStr"][_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].COLL], coll_id, id, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].COLL);
        if (pgons_flat.length) {
            const pgonResult = this.getPGonPosis(null, pgons_flat);
            const pgons_posi = pgonResult.posi_flat;
            const pgons_indices = pgonResult.indices;
            if (pgons_indices.length !== 0) {
                // const attrib_val = this.model.modeldata.attribs.query.getAttribValue(EEntType.COLL, EAttribNames.NAME, id);
                // const selecting = attrib_val ? attrib_val.toString() : `${EEntType.COLL}${id}`;
                const pgon_id = `${_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntTypeStr"][_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].COLL]}_pg_${id}`;
                scene.selectObjFace(coll_id, pgons_indices, pgons_posi, this.container, labelText);
                children.push(pgon_id);
                labelText = false;
            }
        }
        const plines = this.model.modeldata.geom.nav.navCollToPline(id);
        const plines_flat = [].concat(...plines);
        if (plines_flat.length) {
            const plineResult = this.getPLinePosis(null, plines_flat);
            const plines_posi = plineResult.posi_flat;
            const plines_indices = plineResult.indices;
            if (plines_indices.length !== 0) {
                const pline_id = `${_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntTypeStr"][_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].COLL]}_pl_${id}`;
                scene.selectObjLine(coll_id, plines_indices, plines_posi, this.container, labelText);
                children.push(pline_id);
                labelText = false;
            }
        }
        const points = this.model.modeldata.geom.nav.navCollToPoint(id);
        const points_flat = [].concat(...points);
        if (points_flat.length) {
            const pointResult = this.getPointPosis(null, points_flat);
            const point_posi = pointResult.posi_flat;
            const point_indices = pointResult.point_indices;
            if (point_indices.length !== 0) {
                const point_id = `${_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntTypeStr"][_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].COLL]}_pt_${id}`;
                scene.selectObjPoint(coll_id, point_indices, point_posi, this.container, labelText);
                children.push(point_id);
                labelText = false;
            }
        }
        this.dataService.selected_ents.get(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntTypeStr"][_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].COLL]).set(coll_id, id);
        this.dataService.selected_coll.set(coll_id, children);
        // this.refreshTable(null);
    }
    chooseVertex(id) {
        const ent_type_str = _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntTypeStr"][_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].VERT];
        const posi_ent = this.dataService.selected_ents.get(ent_type_str);
        const scene = this._data_threejs;
        const date = new Date(), timestamp = date.getTime();
        const position = this.model.modeldata.attribs.query.getVertCoords(id);
        const ent_id = `${ent_type_str}${id}`;
        const labelText = this.indexAsLabel(ent_type_str, ent_id, id, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].VERT);
        scene.selectObjvertex(`_single_v${timestamp}`, ent_id, position, this.container, labelText);
        posi_ent.set(ent_id, id);
        this.dataService.selected_vertex.set(`_single_v${timestamp}`, [ent_id]);
        this.refreshTable(null);
    }
    zoomfit() {
        // if (JSON.stringify(this._data_threejs._threejs_nums) === JSON.stringify([0, 0, 0])) {
        //     return;
        // }
        if (this._data_threejs.currentCamera === 'Persp') {
            this._data_threejs.lookAtObj();
        }
        else {
            this._data_threejs.orthoLookatObj();
        }
    }
    EntTypeToStr(ent_type) {
        return _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntTypeStr"][ent_type];
    }
    enableSelect() {
        return this.selections.length > 1;
    }
    selectEntityType(selection) {
        this.SelectingEntityType = selection;
        localStorage.setItem('mpm_selecting_entity_type', JSON.stringify(selection));
        const settings = JSON.parse(localStorage.getItem('mpm_settings'));
        if (settings !== undefined && selection) {
            settings.select.selector = selection;
            localStorage.setItem('mpm_settings', JSON.stringify(settings));
        }
        this.selectDropdownVisible = false;
    }
    openCredits(event) {
        event.stopPropagation();
        const el = document.getElementById('openCredits');
        if (el) {
            el.click();
        }
    }
    switchCamera() {
        this._data_threejs.switchCamera();
        setTimeout(() => {
            this.activateRender();
        }, 0);
    }
    selectEntity(id) {
        if (this.SelectingEntityType.id === _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].COLL) {
            this.chooseColl(id);
        }
        else if (this.SelectingEntityType.id === _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].VERT) {
            this.chooseVertex(id);
        }
        // not sure why but this has to be done
        for (let i = 0; i < 5; i++) {
            setTimeout(() => {
                this.activateRender();
            }, 0);
        }
    }
    getMaxNodeSelect() {
        if (this._data_threejs.timeline_groups) {
            return this._data_threejs.timeline_groups.length - 1;
        }
        return 0;
    }
    getSliderWidth() {
        let width = 10;
        for (const g of this._data_threejs.timeline_groups) {
            width += g.length * 7 + 5;
        }
        return width + 'px';
    }
    changeNodeSlider(event) {
        const nodeSelInput = document.getElementById('hidden_node_selection');
        nodeSelInput.value = this._data_threejs.timeline_groups[event.target.value];
        document.getElementById('hidden_node_selection_button').click();
    }
    changeNodeDropdown(event) {
        const nodeSelInput = document.getElementById('hidden_node_selection');
        nodeSelInput.value = event.target.value;
        document.getElementById('hidden_node_selection_button').click();
    }
    onmouseleave() {
        this._data_threejs.controls.saveState();
        this._data_threejs.controls.reset();
    }
};
ThreejsViewerComponent.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injector"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
    { type: _threejs_viewer_service__WEBPACK_IMPORTED_MODULE_6__["ThreeJSViewerService"] }
];
__decorate([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    __metadata("design:type", Object)
], ThreejsViewerComponent.prototype, "action", void 0);
__decorate([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    __metadata("design:type", _libs_geo_info_GIModel__WEBPACK_IMPORTED_MODULE_0__["GIModel"])
], ThreejsViewerComponent.prototype, "model", void 0);
__decorate([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    __metadata("design:type", Object)
], ThreejsViewerComponent.prototype, "attr_table_select", void 0);
__decorate([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    __metadata("design:type", Boolean)
], ThreejsViewerComponent.prototype, "selectSwitch", void 0);
__decorate([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    __metadata("design:type", String)
], ThreejsViewerComponent.prototype, "attribLabel", void 0);
__decorate([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"])(_html_dropdown_menu_component__WEBPACK_IMPORTED_MODULE_4__["DropdownMenuComponent"], { static: true }),
    __metadata("design:type", Object)
], ThreejsViewerComponent.prototype, "dropdown", void 0);
__decorate([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"])('document:mouseleave', []),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], ThreejsViewerComponent.prototype, "onmouseleave", null);
ThreejsViewerComponent = __decorate([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
        selector: 'threejs-viewer',
        template: __importDefault(__webpack_require__(/*! raw-loader!./threejs-viewer.component.html */ "./node_modules/raw-loader/dist/cjs.js!./src/app/gi-viewer/threejs/threejs-viewer.component.html")).default,
        styles: [__importDefault(__webpack_require__(/*! ./threejs-viewer.component.scss */ "./src/app/gi-viewer/threejs/threejs-viewer.component.scss")).default]
    }),
    __metadata("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_1__["Injector"], _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"], _threejs_viewer_service__WEBPACK_IMPORTED_MODULE_6__["ThreeJSViewerService"]])
], ThreejsViewerComponent);

var mouseLabel;
(function (mouseLabel) {
    mouseLabel["Mesh"] = "Polygon";
    mouseLabel["LineSegments"] = "Polyline/";
    mouseLabel["Points"] = "Point/Position";
})(mouseLabel || (mouseLabel = {}));


/***/ }),

/***/ "./src/app/gi-viewer/threejs/threejs-viewer.service.ts":
/*!*************************************************************!*\
  !*** ./src/app/gi-viewer/threejs/threejs-viewer.service.ts ***!
  \*************************************************************/
/*! exports provided: ThreeJSViewerService */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ThreeJSViewerService", function() { return ThreeJSViewerService; });
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};
class ThreeJSViewerService {
    initRaycaster(event) {
        const scene = this.DataThreejs;
        const rect = scene.renderer.domElement.getBoundingClientRect();
        scene.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        scene.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        scene.raycaster.setFromCamera(scene.mouse, scene.camera);
        const precision = 0.01 * scene.controls.target.distanceTo(scene.controls.object.position);
        scene.raycaster.params.Line.threshold = precision;
        scene.raycaster.params.Points.threshold = precision;
        return scene.raycaster.intersectObjects(scene.scene_objs);
    }
}


/***/ }),

/***/ "./src/assets/core/_parameterTypes.ts":
/*!********************************************!*\
  !*** ./src/assets/core/_parameterTypes.ts ***!
  \********************************************/
/*! exports provided: _parameterTypes, _varString */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_parameterTypes", function() { return _parameterTypes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_varString", function() { return _varString; });
/* harmony import */ var _modules_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modules/_model */ "./src/assets/core/modules/_model.ts");
/* harmony import */ var _assets_libs_geo_info_GIMetaData__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @assets/libs/geo-info/GIMetaData */ "./src/assets/libs/geo-info/GIMetaData.ts");
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};


const _parameterTypes = {
    constList: '__constList__',
    model: '__model__',
    input: '__input__',
    console: '__console__',
    fileName: '__fileName__',
    new: '_model.__new__',
    newFn: _modules_model__WEBPACK_IMPORTED_MODULE_0__["__new__"],
    newMeta: _assets_libs_geo_info_GIMetaData__WEBPACK_IMPORTED_MODULE_1__["GIMetaData"],
    merge: '_model.__merge__',
    mergeFn: _modules_model__WEBPACK_IMPORTED_MODULE_0__["__merge__"],
    addData: '_model.addGiData',
    preprocess: '_model.__preprocess__',
    postprocess: '_model.__postprocess__',
    setattrib: 'attrib.Set',
    getattrib: 'attrib.Get',
    queryGet: 'query.Get',
    queryFilter: 'query.Filter',
    select: '_model.__select__',
    return: '_Output.Return',
    asyncFuncs: ['util.ModelCompare',
        'io.Write', 'io.Read',
        'io.Import', 'io.Export']
};
const _varString = `
PI = Math.PI;
XY = __modules__._constants.XY;
YZ = __modules__._constants.YZ;
ZX = __modules__._constants.ZX;
YX = __modules__._constants.YX;
ZY = __modules__._constants.ZY;
XZ = __modules__._constants.XZ;
isNum = __modules__._types.isNum;
isInt = __modules__._types.isInt;
isFlt = __modules__._types.isFlt;
isBool = __modules__._types.isBool;
isStr = __modules__._types.isStr;
isList = __modules__._types.isList;
isDict = __modules__._types.isDict;
isVec2 = __modules__._types.isVec2;
isVec3 = __modules__._types.isVec3;
isCol = __modules__._types.isCol;
isRay = __modules__._types.isRay;
isPln = __modules__._types.isPln;
isNaN = __modules__._types.isNaN;
isNull = __modules__._types.isNull;
isUndef = __modules__._types.isUndef;
strRepl = __modules__._strs.strRepl;
strUpp = __modules__._strs.strUpp;
strLow = __modules__._strs.strLow;
strTrim = __modules__._strs.strTrim;
strTrimR = __modules__._strs.strTrimR;
strTrimL = __modules__._strs.strTrimL;
strSub = __modules__._strs.strSub;
strStarts = __modules__._strs.strStarts;
strEnds = __modules__._strs.strEnds;
strPadL = __modules__._strs.strPadL;
strPadR = __modules__._strs.strPadR;
isApprox = __modules__._util.isApprox;
isIn = __modules__._util.isIn;
isWithin = __modules__._util.isWithin;
min = __modules__._math.min;
max = __modules__._math.max;
pow = Math.pow;
sqrt = Math.sqrt;
exp = Math.exp;
log = Math.log;
round = __modules__._math.round;
sigFig = __modules__._math.sigFig;
ceil = Math.ceil;
floor = Math.floor;
abs = Math.abs;
sin = Math.sin;
asin = Math.asin;
sinh = Math.sinh;
asinh = Math.asinh;
cos = Math.cos;
acos = Math.acos;
cosh = Math.cosh;
acosh = Math.acosh;
tan = Math.tan;
atan = Math.atan;
tanh = Math.tanh;
atanh = Math.atanh;
atan2 = Math.atan2;
boolean = __modules__._mathjs.boolean;
number = __modules__._mathjs.number;
string = __modules__._mathjs.string;
mad = __modules__._mathjs.mad;
mean = __modules__._mathjs.mean;
median = __modules__._mathjs.median;
mode = __modules__._mathjs.mode;
prod = __modules__._mathjs.prod;
std = __modules__._mathjs.std;
vari = __modules__._mathjs.var;
sum = __modules__._mathjs.sum;
hypot = __modules__._mathjs.hypot;
norm = __modules__._mathjs.norm;
mod = __modules__._mathjs.mod;
square = __modules__._mathjs.square;
cube = __modules__._mathjs.cube;
remap = __modules__._arithmetic.remap;
distance = __modules__._geometry.distance;
distanceM = __modules__._geometry.distanceM;
distanceMS = __modules__._geometry.distanceMS;
intersect = __modules__._geometry.intersect;
project = __modules__._geometry.project;
range = __modules__._list.range;
isList = __modules__._list.isList;
len = __modules__._list.listLen;
listLen = __modules__._list.listLen;
listCount = __modules__._list.listCount;
listCopy = __modules__._list.listCopy;
listRep = __modules__._list.listRep;
listLast = __modules__._list.listLast;
listGet = __modules__._list.listGet;
listFind = __modules__._list.listFind;
listHas = __modules__._list.listHas;
listJoin = __modules__._list.listJoin;
listFlat = __modules__._list.listFlat;
listSlice = __modules__._list.listSlice;
listCull = __modules__._list.listCull;
listZip = __modules__._list.listZip;
listZip2 = __modules__._list.listZip2;
setMake = __modules__._set.setMake;
setUni = __modules__._set.setUni;
setInt = __modules__._set.setInt;
setDif = __modules__._set.setDif;
length = __modules__._list.length;
shuffle = __modules__._list.shuffle;
concat = __modules__._list.concat;
zip = __modules__._list.zip;
zip2 = __modules__._list.zip2;
vecAdd = __modules__._vec.vecAdd;
vecSub = __modules__._vec.vecSub;
vecDiv = __modules__._vec.vecDiv;
vecMult = __modules__._vec.vecMult;
vecSum = __modules__._vec.vecSum;
vecLen = __modules__._vec.vecLen;
vecSetLen = __modules__._vec.vecSetLen;
vecNorm = __modules__._vec.vecNorm;
vecRev = __modules__._vec.vecRev;
vecFromTo = __modules__._vec.vecFromTo;
vecAng = __modules__._vec.vecAng;
vecAng2 = __modules__._vec.vecAng2;
vecDot = __modules__._vec.vecDot;
vecCross = __modules__._vec.vecCross;
vecEqual = __modules__._vec.vecEqual;
vecLtoG = __modules__._vec.vecLtoG;
vecGtoL = __modules__._vec.vecGtoL;
plnMake = __modules__._plane.plnMake;
plnCopy = __modules__._plane.plnCopy;
plnMove = __modules__._plane.plnMove;
plnRot = __modules__._plane.plnRot;
plnLMove = __modules__._plane.plnLMove;
plnLRotX = __modules__._plane.plnLRotX;
plnLRotY = __modules__._plane.plnLRotY;
plnLRotZ = __modules__._plane.plnLRotZ;
rayMake = __modules__._ray.rayMake;
rayCopy = __modules__._ray.rayCopy;
rayMove = __modules__._ray.rayMove;
rayRot = __modules__._ray.rayRot;
rayLMove = __modules__._ray.rayLMove;
rayFromPln = __modules__._ray.rayFromPln;
rayLtoG = __modules__._ray.rayLtoG;
rayGtoL = __modules__._ray.rayGtoL;
colFalse = __modules__._colors.colFalse;
colScale = __modules__._colors.colScale;
radToDeg = __modules__._conversion.radToDeg;
degToRad = __modules__._conversion.degToRad;
numToStr = __modules__._conversion.numToStr;
rand = __modules__._rand.rand;
randInt = __modules__._rand.randInt;
randPick = __modules__._rand.randPick;
setattr = __modules__._model.__setAttrib__;
getattr = __modules__._model.__getAttrib__;
`;


/***/ }),

/***/ "./src/assets/core/inline/_arithmetic.ts":
/*!***********************************************!*\
  !*** ./src/assets/core/inline/_arithmetic.ts ***!
  \***********************************************/
/*! exports provided: remap */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "remap", function() { return remap; });
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};
function remap(num, d1, d2) {
    if (Array.isArray(num)) {
        return num.map(num_val => remap(num_val, d1, d2));
    }
    return (d2[0] +
        (((num - d1[0]) / (d1[1] - d1[0])) * (d2[1] - d2[0])));
}


/***/ }),

/***/ "./src/assets/core/inline/_colors.ts":
/*!*******************************************!*\
  !*** ./src/assets/core/inline/_colors.ts ***!
  \*******************************************/
/*! exports provided: colFalse, colScale */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "colFalse", function() { return colFalse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "colScale", function() { return colScale; });
/* harmony import */ var chroma_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! chroma-js */ "./node_modules/chroma-js/chroma.js");
/* harmony import */ var chroma_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(chroma_js__WEBPACK_IMPORTED_MODULE_0__);
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};

const false_col = chroma_js__WEBPACK_IMPORTED_MODULE_0__["scale"](['blue', 'cyan', 'green', 'yellow', 'red']);
function colFalse(vals, min, max) {
    const col_domain = false_col.domain([min, max]);
    if (!Array.isArray(vals)) {
        const col = col_domain(vals).gl();
        return [col[0], col[1], col[2]];
    }
    else {
        const cols = [];
        for (const val of vals) {
            const col = col_domain(val).gl();
            cols.push([col[0], col[1], col[2]]);
        }
        return cols;
    }
}
function colScale(vals, min, max, scale) {
    const col_scale = chroma_js__WEBPACK_IMPORTED_MODULE_0__["scale"](scale);
    const col_domain = col_scale.domain([min, max]);
    if (!Array.isArray(vals)) {
        const col = col_domain(vals).gl();
        return [col[0], col[1], col[2]];
    }
    else {
        const cols = [];
        for (const val of vals) {
            const col = col_domain(val).gl();
            cols.push([col[0], col[1], col[2]]);
        }
        return cols;
    }
}


/***/ }),

/***/ "./src/assets/core/inline/_constants.ts":
/*!**********************************************!*\
  !*** ./src/assets/core/inline/_constants.ts ***!
  \**********************************************/
/*! exports provided: XY, YZ, ZX, YX, ZY, XZ */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "XY", function() { return XY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "YZ", function() { return YZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ZX", function() { return ZX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "YX", function() { return YX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ZY", function() { return ZY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "XZ", function() { return XZ; });
/* harmony import */ var _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @libs/geo-info/common */ "./src/assets/libs/geo-info/common.ts");
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};

const XY = _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_0__["XYPLANE"];
const YZ = _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_0__["YZPLANE"];
const ZX = _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_0__["ZXPLANE"];
const YX = _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_0__["YXPLANE"];
const ZY = _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_0__["ZYPLANE"];
const XZ = _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_0__["XZPLANE"];


/***/ }),

/***/ "./src/assets/core/inline/_conversion.ts":
/*!***********************************************!*\
  !*** ./src/assets/core/inline/_conversion.ts ***!
  \***********************************************/
/*! exports provided: radToDeg, degToRad, numToStr, numToCurr */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "radToDeg", function() { return radToDeg; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "degToRad", function() { return degToRad; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "numToStr", function() { return numToStr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "numToCurr", function() { return numToCurr; });
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};
function radToDeg(rad) {
    if (Array.isArray(rad)) {
        return rad.map(a_rad => radToDeg(a_rad));
    }
    return rad * (180 / Math.PI);
}
function degToRad(deg) {
    if (Array.isArray(deg)) {
        return deg.map(a_deg => degToRad(a_deg));
    }
    return deg * (Math.PI / 180);
}
function numToStr(num, frac_digits, locale) {
    if (Array.isArray(num)) {
        for (let i = 0; i < num.length; i++) {
            num[i] = typeof num === 'number' ? num : Number(num);
        }
    }
    else {
        num = typeof num === 'number' ? num : Number(num);
    }
    const options = {};
    if (frac_digits !== undefined) {
        options['maximumFractionDigits'] = frac_digits;
        options['minimumFractionDigits'] = frac_digits;
    }
    locale = locale === undefined ? 'en-GB' : locale;
    if (Array.isArray(num)) {
        return num.map(a_num => a_num.toLocaleString(locale, options));
    }
    return num.toLocaleString(locale, options);
}
function numToCurr(num, currency, locale) {
    if (Array.isArray(num)) {
        for (let i = 0; i < num.length; i++) {
            num[i] = typeof num === 'number' ? num : Number(num);
        }
    }
    else {
        num = typeof num === 'number' ? num : Number(num);
    }
    const options = {};
    options['style'] = 'currency';
    options['currency'] = currency;
    locale = locale === undefined ? 'en-GB' : locale;
    if (Array.isArray(num)) {
        return num.map(a_num => a_num.toLocaleString(locale, options));
    }
    return num.toLocaleString(locale, options);
}


/***/ }),

/***/ "./src/assets/core/inline/_geometry.ts":
/*!*********************************************!*\
  !*** ./src/assets/core/inline/_geometry.ts ***!
  \*********************************************/
/*! exports provided: intersect, project, distance, distanceM, distanceMS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "intersect", function() { return intersect; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "project", function() { return project; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distance", function() { return distance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distanceM", function() { return distanceM; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distanceMS", function() { return distanceMS; });
/* harmony import */ var _libs_geom_intersect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @libs/geom/intersect */ "./src/assets/libs/geom/intersect.ts");
/* harmony import */ var _libs_geom_distance__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @libs/geom/distance */ "./src/assets/libs/geom/distance.ts");
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};


const intersect = _libs_geom_intersect__WEBPACK_IMPORTED_MODULE_0__["intersect"];
const project = _libs_geom_intersect__WEBPACK_IMPORTED_MODULE_0__["project"];
const distance = _libs_geom_distance__WEBPACK_IMPORTED_MODULE_1__["distance"];
const distanceM = _libs_geom_distance__WEBPACK_IMPORTED_MODULE_1__["distanceManhattan"];
const distanceMS = _libs_geom_distance__WEBPACK_IMPORTED_MODULE_1__["distanceManhattanSq"];


/***/ }),

/***/ "./src/assets/core/inline/_list.ts":
/*!*****************************************!*\
  !*** ./src/assets/core/inline/_list.ts ***!
  \*****************************************/
/*! exports provided: range, isList, listLen, listCount, listCopy, listRep, listLast, listGet, listFind, listHas, listJoin, listFlat, listSlice, listCull, listZip, listZip2, shuffle, zip, zip2, length */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "range", function() { return range; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isList", function() { return isList; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "listLen", function() { return listLen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "listCount", function() { return listCount; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "listCopy", function() { return listCopy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "listRep", function() { return listRep; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "listLast", function() { return listLast; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "listGet", function() { return listGet; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "listFind", function() { return listFind; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "listHas", function() { return listHas; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "listJoin", function() { return listJoin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "listFlat", function() { return listFlat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "listSlice", function() { return listSlice; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "listCull", function() { return listCull; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "listZip", function() { return listZip; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "listZip2", function() { return listZip2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "shuffle", function() { return shuffle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zip", function() { return zip; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zip2", function() { return zip2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "length", function() { return length; });
/* harmony import */ var _libs_util_arrs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @libs/util/arrs */ "./src/assets/libs/util/arrs.ts");
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};
/**
 * list functions that obtain and return information from an input list. Does not modify input list.
 */

function range(start, end, step) {
    if (start === undefined) {
        throw new Error('Invalid inline arg: min must be defined.');
    }
    if (end === undefined) {
        end = start;
        start = 0;
    }
    if (step === 0) {
        throw new Error('Invalid inline arg: step must not be 0.');
    }
    const len = end - start;
    if (step === undefined) {
        step = len > 0 ? 1 : -1;
    }
    const negStep = step < 0;
    if (len > 0 !== step > 0) {
        return [];
    }
    const list = [];
    let current = start;
    while (current !== end && (current < end) !== negStep) {
        list.push(current);
        current += step;
    }
    return list;
}
function isList(list) {
    return Array.isArray(list);
}
function listLen(list) {
    return list.length;
}
function listCount(list, val) {
    let count = 0;
    for (let i = 0; i < list.length; i++) {
        if (list[i] === val) {
            count += 1;
        }
    }
    return count;
}
function listCopy(list) {
    return list.slice();
}
function listRep(list, n) {
    list = Array.isArray(list) ? list : [list];
    const result = [];
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < list.length; j++) {
            result.push(list[j]);
        }
    }
    return result;
}
function listLast(list) {
    return list[list.length - 1];
}
function listGet(list, index) {
    if (Array.isArray(index)) {
        return index.map(i => listGet(list, i));
    }
    if (index < 0) {
        index = list.length + index;
    }
    return list[index];
}
function listFind(list, val) {
    const index = list.indexOf(val);
    if (index === -1) {
        return null;
    }
    return index;
}
function listHas(list, val) {
    for (let i = list.length - 1; i >= 0; i--) {
        if (list[i] === val) {
            return true;
        }
    }
    return false;
}
function listJoin(list1, list2) {
    if (!Array.isArray(list1)) {
        list1 = [list1];
    }
    if (!Array.isArray(list2)) {
        list2 = [list2];
    }
    return list1.concat(list2);
}
function listFlat(list, depth) {
    if (depth !== undefined) {
        // @ts-ignore
        return list.flat(depth);
    }
    return Object(_libs_util_arrs__WEBPACK_IMPORTED_MODULE_0__["arrMakeFlat"])(list);
}
function listSlice(list, start, end) {
    return list.slice(start, end);
}
function listCull(list, list2) {
    list2 = list2 ? list2 : list;
    const result = [];
    const list2_len = list2.length;
    for (let i = 0; i < list.length; i++) {
        const val = (i < list2_len) ? list2[i] : list2[i % list2_len];
        if (val) {
            result.push(list[i]);
        }
    }
    return result;
}
function listZip(lists) {
    const shortest = lists.length === 0 ? [] : lists.reduce((a, b) => {
        return a.length < b.length ? a : b;
    });
    return shortest.map((_, i) => lists.map(array => array[i]));
}
function listZip2(lists) {
    const longest = lists.length === 0 ? [] : lists.reduce((a, b) => {
        return a.length > b.length ? a : b;
    });
    return longest.map((_, i) => lists.map(array => array[i]));
}
// =============================== DEPRECATED
function shuffle(list) {
    console.log('WARNING: This function has been deprecated. Please use the list.Sort() function, and select random.');
    const new_list = list.slice();
    new_list.sort(() => .5 - Math.random());
    return new_list;
}
function zip(lists) {
    console.log('WARNING: This function has been deprecated. Please use the inline listZip() function.');
    return listZip(lists);
}
function zip2(lists) {
    console.log('WARNING: This function has been deprecated. Please use the inline listZip2() function.');
    return listZip2(lists);
}
function length(list) {
    if (list === undefined) {
        throw new Error('Invalid inline arg: list must be defined.');
    }
    return list.length;
}


/***/ }),

/***/ "./src/assets/core/inline/_math.ts":
/*!*****************************************!*\
  !*** ./src/assets/core/inline/_math.ts ***!
  \*****************************************/
/*! exports provided: min, max, round, sigFig */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "min", function() { return min; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "max", function() { return max; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "round", function() { return round; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sigFig", function() { return sigFig; });
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};
function min(list) {
    const args = Array.prototype.slice.call(arguments, min.length);
    if (args.length === 0) {
        if (list.constructor === [].constructor) {
            return Math.min.apply(Math, list);
        }
        return list;
    }
    args.push(list);
    return Math.min.apply(Math, args);
}
// max(1,2,3)
// max([1,2,3])
function max(list) {
    const args = Array.prototype.slice.call(arguments, min.length);
    if (args.length === 0) {
        if (list.constructor === [].constructor) {
            return Math.max.apply(Math, list);
        }
        return list;
    }
    args.push(list);
    return Math.max.apply(Math, args);
}
function round(num, decimal_places = 0) {
    if (Array.isArray(num)) {
        return num.map(a_num => round(a_num, decimal_places));
    }
    num = num;
    if (decimal_places === 0) {
        return Math.round(num);
    }
    if (decimal_places > 0) {
        const dec = Math.pow(10, decimal_places);
        return Math.round(num * dec) / dec;
    }
    else {
        const dec = Math.pow(10, Math.abs(decimal_places));
        return Math.round(num / dec) * dec;
    }
}
function sigFig(num, sig_figs) {
    if (Array.isArray(num)) {
        return num.map(a_num => sigFig(a_num, sig_figs));
    }
    if (num === 0) {
        return 0;
    }
    num = num;
    const round_val = sig_figs - 1 - Math.floor(Math.log10(Math.abs(num)));
    return round(num, round_val);
    // return parseFloat(num.toPrecision(sig_figs));
}


/***/ }),

/***/ "./src/assets/core/inline/_mathjs.ts":
/*!*******************************************!*\
  !*** ./src/assets/core/inline/_mathjs.ts ***!
  \*******************************************/
/*! exports provided: boolean, number, string, mad, mean, median, mode, prod, std, vari, sum, hypot, norm, mod, square, cube, distance, intersect, random, randomInt, pickRandom */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "boolean", function() { return boolean; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "number", function() { return number; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "string", function() { return string; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mad", function() { return mad; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mean", function() { return mean; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "median", function() { return median; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mode", function() { return mode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "prod", function() { return prod; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "std", function() { return std; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vari", function() { return vari; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sum", function() { return sum; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hypot", function() { return hypot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "norm", function() { return norm; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mod", function() { return mod; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "square", function() { return square; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cube", function() { return cube; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distance", function() { return distance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "intersect", function() { return intersect; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "random", function() { return random; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "randomInt", function() { return randomInt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pickRandom", function() { return pickRandom; });
/* harmony import */ var mathjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mathjs */ "./node_modules/mathjs/index.js");
/* harmony import */ var mathjs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(mathjs__WEBPACK_IMPORTED_MODULE_0__);
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};

const boolean = mathjs__WEBPACK_IMPORTED_MODULE_0__["boolean"];
const number = mathjs__WEBPACK_IMPORTED_MODULE_0__["number"];
const string = mathjs__WEBPACK_IMPORTED_MODULE_0__["string"];
const mad = mathjs__WEBPACK_IMPORTED_MODULE_0__["mad"];
const mean = mathjs__WEBPACK_IMPORTED_MODULE_0__["mean"];
const median = mathjs__WEBPACK_IMPORTED_MODULE_0__["median"];
const mode = mathjs__WEBPACK_IMPORTED_MODULE_0__["mode"];
const prod = mathjs__WEBPACK_IMPORTED_MODULE_0__["prod"];
const std = mathjs__WEBPACK_IMPORTED_MODULE_0__["std"];
const vari = mathjs__WEBPACK_IMPORTED_MODULE_0__["var"];
const sum = mathjs__WEBPACK_IMPORTED_MODULE_0__["sum"];
const hypot = mathjs__WEBPACK_IMPORTED_MODULE_0__["hypot"];
const norm = mathjs__WEBPACK_IMPORTED_MODULE_0__["norm"];
const mod = mathjs__WEBPACK_IMPORTED_MODULE_0__["mod"];
const square = mathjs__WEBPACK_IMPORTED_MODULE_0__["square"];
const cube = mathjs__WEBPACK_IMPORTED_MODULE_0__["cube"];
const distance = mathjs__WEBPACK_IMPORTED_MODULE_0__["distance"];
const intersect = mathjs__WEBPACK_IMPORTED_MODULE_0__["intersect"];
const random = mathjs__WEBPACK_IMPORTED_MODULE_0__["random"];
const randomInt = mathjs__WEBPACK_IMPORTED_MODULE_0__["randomInt"];
const pickRandom = mathjs__WEBPACK_IMPORTED_MODULE_0__["pickRandom"];


/***/ }),

/***/ "./src/assets/core/inline/_plane.ts":
/*!******************************************!*\
  !*** ./src/assets/core/inline/_plane.ts ***!
  \******************************************/
/*! exports provided: plnMake, plnCopy, plnMove, plnRot, plnLMove, plnLRotX, plnLRotY, plnLRotZ, plnFromRay */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "plnMake", function() { return plnMake; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "plnCopy", function() { return plnCopy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "plnMove", function() { return plnMove; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "plnRot", function() { return plnRot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "plnLMove", function() { return plnLMove; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "plnLRotX", function() { return plnLRotX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "plnLRotY", function() { return plnLRotY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "plnLRotZ", function() { return plnLRotZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "plnFromRay", function() { return plnFromRay; });
/* harmony import */ var _assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @assets/libs/geom/vectors */ "./src/assets/libs/geom/vectors.ts");
/* harmony import */ var _assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @assets/libs/util/arrs */ "./src/assets/libs/util/arrs.ts");
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};


/**
 * Plane functions that modify planes. These functions do not modify input plane.
 *
 * Overloaded:
 * - origin[], x_vec,   xy_vec
 * - origin,   x_vec[], xy_vec[]
 * - origin[], x_vec[], xy_vec[]
 */
function plnMake(origin, x_vec, xy_vec) {
    // overloaded case
    const origin_dep = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_1__["getArrDepth2"])(origin);
    const x_vec_dep = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_1__["getArrDepth2"])(x_vec);
    const xy_vec_dep = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_1__["getArrDepth2"])(xy_vec);
    if (origin_dep === 2 || x_vec_dep === 2) {
        if (x_vec_dep === 1) {
            // only origin is Txyz[]
            return origin.map(origin_val => plnMake(origin_val, x_vec, xy_vec));
        }
        else if (origin_dep === 1) {
            // only x_vec and xy_vec are Txyz[], they must be equal length
            if (xy_vec_dep === 2 && x_vec.length === xy_vec.length) {
                const vecs = [];
                for (let i = 0; i < origin.length; i++) {
                    vecs.push(plnMake(origin, x_vec[i], xy_vec[i]));
                }
                return vecs;
            }
            else {
                throw new Error('Error making planes with lists of vectors: The x_vec and xy_vec lists must be of equal length.');
            }
        }
        else {
            // all origin, x_vec and xy_vec are Txyz[], they must be equal length
            if (origin.length === x_vec.length && origin.length === xy_vec.length) {
                const vecs = [];
                for (let i = 0; i < origin.length; i++) {
                    vecs.push(plnMake(origin[i], x_vec[i], xy_vec[i]));
                }
                return vecs;
            }
            else {
                throw new Error('Error making planes with lists of vectors: The three lists must be of equal length.');
            }
        }
    }
    // normal case, both origin and x_vec and xy_vec are Txyz
    const x_axis = Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecNorm"])(x_vec);
    const y_axis = Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecNorm"])(Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecMakeOrtho"])(xy_vec, x_vec));
    return [origin.slice(), x_axis, y_axis];
}
function plnCopy(pln) {
    // overloaded case
    const pln_dep = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_1__["getArrDepth2"])(pln);
    if (pln_dep === 3) {
        return pln.map(pln_one => plnCopy(pln_one));
    }
    // normal case
    pln = pln;
    return [pln[0].slice(), pln[1].slice(), pln[2].slice()];
}
function plnMove(pln, vec) {
    // overloaded case
    const pln_dep = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_1__["getArrDepth2"])(pln);
    const vec_dep = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_1__["getArrDepth2"])(vec);
    if (pln_dep === 3) {
        pln = pln;
        if (vec_dep === 1) {
            vec = vec;
            return pln.map(pln_one => plnMove(pln_one, vec));
        }
        else if (vec_dep === 2 && pln.length === vec.length) {
            vec = vec;
            const planes = [];
            for (let i = 0; i < pln.length; i++) {
                planes.push(plnMove(pln[i], vec[i]));
            }
        }
        else {
            throw new Error('Error moving a list planes with a list of vectors: The two lists must be of equal length.');
        }
    }
    // normal case
    pln = pln;
    vec = vec;
    return [Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecAdd"])(pln[0], vec), pln[1].slice(), pln[2].slice()];
}
function plnRot(pln, ray, ang) {
    // overloaded case
    const pln_dep = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_1__["getArrDepth2"])(pln);
    const ray_dep = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_1__["getArrDepth2"])(ray);
    const ang_dep = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_1__["getArrDepth2"])(ang);
    if (pln_dep === 3) {
        pln = pln;
        if (ray_dep === 2 && ang_dep === 0) {
            ray = ray;
            ang = ang;
            return pln.map(pln_one => plnRot(pln_one, ray, ang));
        }
        else if (ray_dep === 3 && ang_dep === 1 && pln.length === ray.length && pln.length === ang.length) {
            ray = ray;
            ang = ang;
            const planes = [];
            for (let i = 0; i < pln.length; i++) {
                planes.push(plnRot(pln[i], ray[i], ang[i]));
            }
            return planes;
        }
        else {
            throw new Error('Error rotating a list planes with a list of rays and angles: The three lists must be of equal length.');
        }
    }
    // normal case
    pln = pln;
    ray = ray;
    ang = ang;
    const from_ray_o_to_pln_o = Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecFromTo"])(ray[0], pln[0]);
    const rot_pln_origin = Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecAdd"])(ray[0], Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecRot"])(from_ray_o_to_pln_o, ray[1], ang));
    return [rot_pln_origin, Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecRot"])(pln[1], ray[1], ang), Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecRot"])(pln[2], ray[1], ang)];
}
function plnLMove(pln, vec) {
    // overloaded case
    const pln_dep = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_1__["getArrDepth2"])(pln);
    const vec_dep = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_1__["getArrDepth2"])(vec);
    if (pln_dep === 3) {
        pln = pln;
        if (vec_dep === 1) {
            vec = vec;
            return pln.map(pln_one => plnMove(pln_one, vec));
        }
        else if (vec_dep === 2 && pln.length === vec.length) {
            vec = vec;
            const planes = [];
            for (let i = 0; i < pln.length; i++) {
                planes.push(plnMove(pln[i], vec[i]));
            }
        }
        else {
            throw new Error('Error moving a list planes with a list of vectors: The two lists must be of equal length.');
        }
    }
    // normal case
    pln = pln;
    vec = vec;
    const z_vec = Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecCross"])(pln[1], pln[2]);
    const x_move_vec = Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecMult"])(pln[1], vec[0]);
    const y_move_vec = Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecMult"])(pln[2], vec[1]);
    const z_move_vec = Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecMult"])(z_vec, vec[2]);
    const origin = Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecsAdd"])([pln[0], x_move_vec, y_move_vec, z_move_vec], false);
    return [origin, pln[1].slice(), pln[2].slice()];
}
function plnLRotX(pln, ang) {
    // overloaded case
    const pln_dep = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_1__["getArrDepth2"])(pln);
    const ang_dep = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_1__["getArrDepth2"])(ang);
    if (pln_dep === 3) {
        pln = pln;
        if (ang_dep === 0) {
            // many pln, one ang
            ang = ang;
            return pln.map(pln_one => plnLRotX(pln_one, ang));
        }
        else if (ang_dep === 12 && pln.length === ang.length) {
            // many pln, many ang
            ang = ang;
            const planes = [];
            for (let i = 0; i < pln.length; i++) {
                planes.push(plnLRotX(pln[i], ang[i]));
            }
            return planes;
        }
        else {
            throw new Error('Error rotating a list planes with a list of angles: The two lists must be of equal length.');
        }
    }
    // normal case
    pln = pln;
    ang = ang;
    const y_axis = Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecRot"])(pln[2], pln[1], ang);
    return [pln[0].slice(), pln[1].slice(), y_axis];
}
function plnLRotY(pln, ang) {
    // overloaded case
    const pln_dep = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_1__["getArrDepth2"])(pln);
    const ang_dep = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_1__["getArrDepth2"])(ang);
    if (pln_dep === 3) {
        pln = pln;
        if (ang_dep === 0) {
            // many pln, one ang
            ang = ang;
            return pln.map(pln_one => plnLRotY(pln_one, ang));
        }
        else if (ang_dep === 1 && pln.length === ang.length) {
            // many pln, many ang
            ang = ang;
            const planes = [];
            for (let i = 0; i < pln.length; i++) {
                planes.push(plnLRotY(pln[i], ang[i]));
            }
            return planes;
        }
        else {
            throw new Error('Error rotating a list planes with a list of angles: The two lists must be of equal length.');
        }
    }
    // normal case
    pln = pln;
    ang = ang;
    const x_axis = Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecRot"])(pln[1], pln[2], ang);
    return [pln[0].slice(), x_axis, pln[2].slice()];
}
function plnLRotZ(pln, ang) {
    // overloaded case
    const pln_dep = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_1__["getArrDepth2"])(pln);
    const ang_dep = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_1__["getArrDepth2"])(ang);
    if (pln_dep === 3) {
        pln = pln;
        if (ang_dep === 0) {
            // many pln, one ang
            ang = ang;
            return pln.map(pln_one => plnLRotZ(pln_one, ang));
        }
        else if (ang_dep === 1 && pln.length === ang.length) {
            // many pln, many ang
            ang = ang;
            const planes = [];
            for (let i = 0; i < pln.length; i++) {
                planes.push(plnLRotZ(pln[i], ang[i]));
            }
            return planes;
        }
        else {
            throw new Error('Error rotating a list planes with a list of angles: The two lists must be of equal length.');
        }
    }
    // normal case
    pln = pln;
    ang = ang;
    const z_vec = Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecCross"])(pln[1], pln[2]);
    const x_axis = Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecRot"])(pln[1], z_vec, ang);
    const y_axis = Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecRot"])(pln[2], z_vec, ang);
    return [pln[0].slice(), x_axis, y_axis];
}
function plnFromRay(ray) {
    // overloaded case
    const ray_dep = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_1__["getArrDepth2"])(ray);
    if (ray_dep === 3) {
        return ray.map(ray_one => plnFromRay(ray_one));
    }
    // normal case
    ray = ray;
    const z_vec = Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecNorm"])(ray[1]);
    let vec = [0, 0, 1];
    if (Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecDot"])(vec, z_vec) === 1) {
        vec = [1, 0, 0];
    }
    const x_axis = Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecCross"])(vec, z_vec);
    const y_axis = Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecCross"])(x_axis, z_vec);
    return [ray[0].slice(), x_axis, y_axis];
}


/***/ }),

/***/ "./src/assets/core/inline/_rand.ts":
/*!*****************************************!*\
  !*** ./src/assets/core/inline/_rand.ts ***!
  \*****************************************/
/*! exports provided: rand, randInt, randPick */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rand", function() { return rand; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "randInt", function() { return randInt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "randPick", function() { return randPick; });
/* harmony import */ var mathjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mathjs */ "./node_modules/mathjs/index.js");
/* harmony import */ var mathjs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(mathjs__WEBPACK_IMPORTED_MODULE_0__);
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};

function rand(min, max, seed) {
    if (seed !== undefined) {
        return min + (_randWithSeed(seed) * (max - min));
    }
    else {
        return mathjs__WEBPACK_IMPORTED_MODULE_0__["random"](min, max);
    }
}
function randInt(min, max, seed) {
    if (seed !== undefined) {
        return Math.floor(min + (_randWithSeed(seed) * (max - min)));
    }
    else {
        return mathjs__WEBPACK_IMPORTED_MODULE_0__["randomInt"](min, max);
    }
}
function randPick(list, num, seed) {
    const list_copy = list.slice();
    _randShuffleWithSeed(list_copy, seed);
    return list_copy.slice(0, num);
}
// TODO is there a better random function than this?
function _randWithSeed(s) {
    // const x = (Math.sin(s) + Math.sin(s * Math.E / 2) + Math.sin((s + 1) * (Math.PI / 3))) * 10000;
    // return x - Math.floor(x);
    // return (Math.sin(s / 2 + 1) + Math.cos(s + 2) * 5) * 10000 % 1;
    // https://stackoverflow.com/questions/521295/seeding-the-random-number-generator-in-javascript
    /* tslint:disable */
    var x = Math.sin(s++) * 10000;
    return x - Math.floor(x);
    //return (2**31-1&(s=Math.imul(48271,s)))/2**31;
    /* tslint:enable */
}
function _randShuffleWithSeed(arr, s) {
    let ctr = arr.length;
    while (ctr > 0) {
        const r = (s === undefined) ? Math.random() : _randWithSeed(ctr + s);
        const index = Math.floor(r * ctr);
        ctr--;
        const temp = arr[ctr];
        arr[ctr] = arr[index];
        arr[index] = temp;
    }
    return arr;
}


/***/ }),

/***/ "./src/assets/core/inline/_ray.ts":
/*!****************************************!*\
  !*** ./src/assets/core/inline/_ray.ts ***!
  \****************************************/
/*! exports provided: rayMake, rayCopy, rayMove, rayRot, rayLMove, rayFromPln, rayLtoG, rayGtoL */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rayMake", function() { return rayMake; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rayCopy", function() { return rayCopy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rayMove", function() { return rayMove; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rayRot", function() { return rayRot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rayLMove", function() { return rayLMove; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rayFromPln", function() { return rayFromPln; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rayLtoG", function() { return rayLtoG; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rayGtoL", function() { return rayGtoL; });
/* harmony import */ var _assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @assets/libs/geom/vectors */ "./src/assets/libs/geom/vectors.ts");
/* harmony import */ var _assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @assets/libs/util/arrs */ "./src/assets/libs/util/arrs.ts");
/* harmony import */ var _assets_libs_geom_matrix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @assets/libs/geom/matrix */ "./src/assets/libs/geom/matrix.ts");
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};



/**
 * Ray functions that modify rays. These functions do not modify input ray.
 *
 * The function is overloaded.
 */
function rayMake(origin, dir, len) {
    // overloaded case
    const origin_dep = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_1__["getArrDepth2"])(origin);
    const dir_dep = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_1__["getArrDepth2"])(dir);
    if (origin_dep === 2 || dir_dep === 2) {
        if (dir_dep === 1) {
            // only origin is Txyz[]
            return origin.map(origin_val => rayMake(origin_val, dir, len));
        }
        else if (origin_dep === 1) {
            // only dir is Txyz[]
            return dir.map(dir_val => rayMake(origin, dir_val, len));
        }
        else {
            // both origin and dir are Txyz[], they must be equal length
            if (origin.length === dir.length) {
                const vecs = [];
                for (let i = 0; i < origin.length; i++) {
                    vecs.push(rayMake(origin[i], dir[i], len));
                }
                return vecs;
            }
            else {
                throw new Error('Error making rays with lists of vectors: The two lists must be of equal length.');
            }
        }
    }
    // normal case, both origin and dir are Txyz
    const ray_vec = len ? Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecSetLen"])(dir, len) : dir;
    return [origin.slice(), ray_vec];
}
function rayCopy(ray) {
    // overloaded case
    const ray_dep = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_1__["getArrDepth2"])(ray);
    if (ray_dep === 3) {
        return ray.map(ray_one => rayCopy(ray_one));
    }
    // normal case
    return [ray[0].slice(), ray[1].slice()];
}
function rayMove(ray, vec) {
    // overloaded case
    const ray_dep = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_1__["getArrDepth2"])(ray);
    const vec_dep = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_1__["getArrDepth2"])(vec);
    if (ray_dep === 3) {
        ray = ray;
        if (vec_dep === 1) {
            vec = vec;
            return ray.map(ray_one => rayMove(ray_one, vec));
        }
        else if (vec_dep === 2 && ray.length === vec.length) {
            vec = vec;
            const rays = [];
            for (let i = 0; i < ray.length; i++) {
                rays.push(rayMove(ray[i], vec[i]));
            }
        }
        else {
            throw new Error('Error moving a list rays with a list of vectors: The two lists must be of equal length.');
        }
    }
    // normal case
    ray = ray;
    vec = vec;
    return [Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecAdd"])(ray[0], vec), ray[1].slice()];
}
function rayRot(ray1, ray2, ang) {
    // overloaded case
    const ray1_dep = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_1__["getArrDepth2"])(ray1);
    const ray2_dep = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_1__["getArrDepth2"])(ray2);
    const ang_dep = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_1__["getArrDepth2"])(ang);
    if (ray1_dep === 3) {
        ray1 = ray1;
        if (ray2_dep === 2 && ang_dep === 0) {
            ray2 = ray2;
            ang = ang;
            return ray1.map(ray1_one => rayRot(ray1_one, ray2, ang));
        }
        else if (ray2_dep === 3 && ang_dep === 1 && ray1.length === ray2.length && ray1.length === ang.length) {
            ray2 = ray2;
            ang = ang;
            const rays = [];
            for (let i = 0; i < ray1.length; i++) {
                rays.push(rayRot(ray1[i], ray2[i], ang[i]));
            }
            return rays;
        }
        else {
            throw new Error('Error rotating a list planes with a list of ray2s and angles: The three lists must be of equal length.');
        }
    }
    // normal case
    ray1 = ray1;
    ray2 = ray2;
    ang = ang;
    const from_ray2_o_to_ray1_o = Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecFromTo"])(ray2[0], ray1[0]);
    const rot_ray1_origin = Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecAdd"])(ray2[0], Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecRot"])(from_ray2_o_to_ray1_o, ray2[1], ang));
    return [rot_ray1_origin, Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecRot"])(ray1[1], ray2[1], ang)];
}
function rayLMove(ray, dist) {
    // overloaded case
    const ray_dep = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_1__["getArrDepth2"])(ray);
    const dist_dep = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_1__["getArrDepth2"])(dist);
    if (ray_dep === 3) {
        ray = ray;
        if (dist_dep === 0) {
            dist = dist;
            return ray.map(ray_one => rayLMove(ray_one, dist));
        }
        else if (dist_dep === 1 && ray.length === dist.length) {
            dist = dist;
            const rays = [];
            for (let i = 0; i < ray.length; i++) {
                rays.push(rayLMove(ray[i], dist[i]));
            }
        }
        else {
            throw new Error('Error moving a list rays with a list of distances: The two lists must be of equal length.');
        }
    }
    // normal case
    ray = ray;
    dist = dist;
    const vec = Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecMult"])(Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecNorm"])(ray[1]), dist);
    return [Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecAdd"])(ray[0], vec), ray[1].slice()];
}
function rayFromPln(pln) {
    // overloaded case
    const pln_dep = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_1__["getArrDepth2"])(pln);
    if (pln_dep === 3) {
        return pln.map(pln_one => rayFromPln(pln_one));
    }
    // normal case
    pln = pln;
    return [pln[0].slice(), Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecCross"])(pln[1], pln[2])];
}
// ================================================================================================
function rayLtoG(r, p) {
    return rayXForm(r, p, true);
}
function rayGtoL(r, p) {
    return rayXForm(r, p, false);
}
function rayXForm(r, p, to_global) {
    // overloaded case
    const depth1 = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_1__["getArrDepth2"])(r);
    const depth2 = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_1__["getArrDepth2"])(p);
    if (depth1 === 2 && depth2 === 2) {
        // r is TRay and p is TPlane
        r = r;
        p = p;
        const p2 = [[0, 0, 0], p[1], p[2]];
        const origin = Object(_assets_libs_geom_matrix__WEBPACK_IMPORTED_MODULE_2__["multMatrix"])(r[0], Object(_assets_libs_geom_matrix__WEBPACK_IMPORTED_MODULE_2__["xformMatrix"])(p, to_global));
        const dir = Object(_assets_libs_geom_matrix__WEBPACK_IMPORTED_MODULE_2__["multMatrix"])(r[1], Object(_assets_libs_geom_matrix__WEBPACK_IMPORTED_MODULE_2__["xformMatrix"])(p2, to_global));
        return [origin, dir];
    }
    else if (depth1 === 3 && depth2 === 2) {
        // r is TRay[] and p is TPlane
        r = r;
        p = p;
        const p2 = [[0, 0, 0], p[1], p[2]];
        const m = Object(_assets_libs_geom_matrix__WEBPACK_IMPORTED_MODULE_2__["xformMatrix"])(p, to_global);
        const m2 = Object(_assets_libs_geom_matrix__WEBPACK_IMPORTED_MODULE_2__["xformMatrix"])(p2, to_global);
        const result = [];
        for (const a_r of r) {
            const origin = Object(_assets_libs_geom_matrix__WEBPACK_IMPORTED_MODULE_2__["multMatrix"])(a_r[0], m);
            const dir = Object(_assets_libs_geom_matrix__WEBPACK_IMPORTED_MODULE_2__["multMatrix"])(a_r[1], m2);
            result.push([origin, dir]);
        }
        return result;
    }
    else if (depth1 === 2 && depth2 === 3) {
        // r is TRay and p is TPlane[]
        r = r;
        p = p;
        const result = [];
        for (const a_p of p) {
            const p2 = [[0, 0, 0], a_p[1], a_p[2]];
            const origin = Object(_assets_libs_geom_matrix__WEBPACK_IMPORTED_MODULE_2__["multMatrix"])(r[0], Object(_assets_libs_geom_matrix__WEBPACK_IMPORTED_MODULE_2__["xformMatrix"])(a_p, to_global));
            const dir = Object(_assets_libs_geom_matrix__WEBPACK_IMPORTED_MODULE_2__["multMatrix"])(r[1], Object(_assets_libs_geom_matrix__WEBPACK_IMPORTED_MODULE_2__["xformMatrix"])(p2, to_global));
            result.push([origin, dir]);
        }
        return result;
    }
    else if (depth1 === 3 && depth2 === 3) {
        // r is TRay[] p is TPlane[], they must be equal length
        r = r;
        p = p;
        if (r.length !== p.length) {
            throw new Error('Error transforming rays: The list of rays and list of planes must be of equal length.');
        }
        const result = [];
        for (let i = 0; i < r.length; i++) {
            const p2 = [[0, 0, 0], p[i][1], p[i][2]];
            const origin = Object(_assets_libs_geom_matrix__WEBPACK_IMPORTED_MODULE_2__["multMatrix"])(r[i][0], Object(_assets_libs_geom_matrix__WEBPACK_IMPORTED_MODULE_2__["xformMatrix"])(p[i], to_global));
            const dir = Object(_assets_libs_geom_matrix__WEBPACK_IMPORTED_MODULE_2__["multMatrix"])(r[i][1], Object(_assets_libs_geom_matrix__WEBPACK_IMPORTED_MODULE_2__["xformMatrix"])(p2, to_global));
            result.push([origin, dir]);
        }
        return result;
    }
    throw new Error('Error transforming rays: Cannot process the input lists.');
}


/***/ }),

/***/ "./src/assets/core/inline/_set.ts":
/*!****************************************!*\
  !*** ./src/assets/core/inline/_set.ts ***!
  \****************************************/
/*! exports provided: setMake, setUni, setInt, setDif */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setMake", function() { return setMake; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setUni", function() { return setUni; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setInt", function() { return setInt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setDif", function() { return setDif; });
/* harmony import */ var mathjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mathjs */ "./node_modules/mathjs/index.js");
/* harmony import */ var mathjs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(mathjs__WEBPACK_IMPORTED_MODULE_0__);
/**
 * Set functions for working with sets, using lists as a data structure. Does not modify input list.
 */
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};

function setMake(list) {
    return Array.from(new Set(list));
}
function setUni(list1, list2) {
    return mathjs__WEBPACK_IMPORTED_MODULE_0__["setUnion"](list1, list2);
}
function setInt(list1, list2) {
    return mathjs__WEBPACK_IMPORTED_MODULE_0__["setIntersect"](list1, list2);
}
function setDif(list1, list2) {
    return mathjs__WEBPACK_IMPORTED_MODULE_0__["setDifference"](list1, list2);
}


/***/ }),

/***/ "./src/assets/core/inline/_strs.ts":
/*!*****************************************!*\
  !*** ./src/assets/core/inline/_strs.ts ***!
  \*****************************************/
/*! exports provided: strRepl, strUpp, strLow, strTrim, strTrimR, strTrimL, strPadL, strPadR, strSub, strStarts, strEnds */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "strRepl", function() { return strRepl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "strUpp", function() { return strUpp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "strLow", function() { return strLow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "strTrim", function() { return strTrim; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "strTrimR", function() { return strTrimR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "strTrimL", function() { return strTrimL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "strPadL", function() { return strPadL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "strPadR", function() { return strPadR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "strSub", function() { return strSub; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "strStarts", function() { return strStarts; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "strEnds", function() { return strEnds; });
/**
 * Functions to work with strings.
 */
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};
// ['strRepl(s,search,new)', 'Replace all instances of specified search string with a new string.'],
// ['strUpp(s), 'Converts all the alphabetic characters in a string to uppercase.']
// ['strLow(s), 'Converts all the alphabetic characters in a string to lowercase.']
// ['strTrim(s), 'Removes the leading and trailing white space and line terminator characters from a string.
// ['strTrimL(s), 'Removes whitespace from the left end of a string.
// ['strTrimR(s), 'Removes whitespace from the right end of a string.
// ['strPadL(s1, m), 'Pads the start of the s1 string with white spaces so that the resulting string reaches a given length.
// ['strPadL(s1, m, s2), 'Pads the start of the s1 string with the s2 string so that the resulting string reaches a given length.
// ['strPadR(s1, m), 'Pads the end of the s1 string with white spaces so that the resulting string reaches a given length.
// ['strPadR(s1, m, s2), 'Pads the end of the s1 string with the s2 string so that the resulting string reaches a given length.
// ['strSub(s, from), 'Gets a substring beginning at the specified location.
// ['strSub(s, from, length), 'Gets a substring beginning at the specified location and having the specified length.
// ['strStarts(s1, s2), 'Returns true if the string s1 starts with s3, false otherwise.
// ['strEnds(s1, s2), 'Returns true if the string s1 ends with s3, false otherwise.
function strRepl(str, search_str, new_str) {
    if (Array.isArray(str)) {
        return str.map(a_str => a_str.replace(search_str, new_str));
    }
    return str.replace(search_str, new_str);
}
function strUpp(str) {
    if (Array.isArray(str)) {
        return str.map(a_str => a_str.toUpperCase());
    }
    return str.toUpperCase();
}
function strLow(str) {
    if (Array.isArray(str)) {
        return str.map(a_str => a_str.toLowerCase());
    }
    return str.toLowerCase();
}
function strTrim(str) {
    if (Array.isArray(str)) {
        return str.map(a_str => a_str.trim());
    }
    return str.trim();
}
function strTrimR(str) {
    if (Array.isArray(str)) {
        return str.map(a_str => a_str.trimRight());
    }
    return str.trimRight();
}
function strTrimL(str) {
    if (Array.isArray(str)) {
        return str.map(a_str => a_str.trimLeft());
    }
    return str.trimLeft();
}
function strPadL(str, max, fill) {
    if (Array.isArray(str)) {
        return str.map(a_str => a_str.padStart(max, fill));
    }
    return str.padStart(max, fill);
}
function strPadR(str, max, fill) {
    if (Array.isArray(str)) {
        return str.map(a_str => a_str.padEnd(max, fill));
    }
    return str.padEnd(max, fill);
}
function strSub(str, from, length) {
    if (Array.isArray(str)) {
        return str.map(a_str => a_str.substr(from, length));
    }
    return str.substr(from, length);
}
function strStarts(str, starts) {
    if (Array.isArray(str)) {
        return str.map(a_str => a_str.startsWith(starts));
    }
    return str.startsWith(starts);
}
function strEnds(str, ends) {
    if (Array.isArray(str)) {
        return str.map(a_str => a_str.endsWith(ends));
    }
    return str.endsWith(ends);
}


/***/ }),

/***/ "./src/assets/core/inline/_types.ts":
/*!******************************************!*\
  !*** ./src/assets/core/inline/_types.ts ***!
  \******************************************/
/*! exports provided: isNum, isInt, isFlt, isBool, isStr, isList, isDict, isVec2, isVec3, isCol, isRay, isPln, isNaN, isNull, isUndef, isIn, isWithin */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isNum", function() { return isNum; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isInt", function() { return isInt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isFlt", function() { return isFlt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isBool", function() { return isBool; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isStr", function() { return isStr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isList", function() { return isList; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isDict", function() { return isDict; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isVec2", function() { return isVec2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isVec3", function() { return isVec3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isCol", function() { return isCol; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isRay", function() { return isRay; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isPln", function() { return isPln; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isNaN", function() { return isNaN; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isNull", function() { return isNull; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isUndef", function() { return isUndef; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isIn", function() { return isIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isWithin", function() { return isWithin; });
/**
 * Functions to check types.
 */
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};
// ['isNum(v)', 'Returns true if the value is a number, false otherwise.'],
// ['isInt(v)', 'Returns true if the value is a integer, false otherwise.'],
// ['isFlt(v)', 'Returns true if the value is a floating point number, false otherwise.'],
// ['isBool(v)', 'Returns true if the value is a boolean, false otherwise.'],
// ['isStr(v)', 'Returns true if the value is a string, false otherwise.'],
// ['isList(v)', 'Returns true if the value is a list, false otherwise.'],
// ['isDict(v)', 'Returns true if the value is a dictionary, false otherwise.'],
// ['isVec2(v)', 'Returns true if the value is a list of two numbers, false otherwise.'],
// ['isVec3(v)', 'Returns true if the value is a list of three numbers, false otherwise.'],
// ['isCol(v)', 'Returns true if the value is a list of three numbers in the range [0, 1], false otherwise.'],
// ['isRay(v)', 'Returns true if the value is a ray, false otherwise.'],
// ['isPln(v)', 'Returns true if the value is a plane, false otherwise.'],
// ['isNaN(v)', 'Returns true is the value is not a number (NaN), false otherwise.'],
// ['isNull(v)', 'Returns true is the value is null, false otherwise.'],
// ['isUndef(v)', 'Returns true is the value is undefined, false otherwise.'],
function isNum(v) {
    return typeof v === 'number';
}
function isInt(v) {
    return Number.isInteger(v);
}
function isFlt(v) {
    // return !Number.isNaN(v) && v % 1 > 0;
    return typeof v === 'number';
}
function isBool(v) {
    return typeof v === 'boolean';
}
function isStr(v) {
    return typeof v === 'string';
}
function isList(v) {
    return Array.isArray(v);
}
function isDict(v) {
    // return typeof v === 'object' && !Array.isArray(v);
    return v.constructor === Object;
}
function isVec2(v) {
    return Array.isArray(v) && v.length === 2 &&
        typeof v[0] === 'number' && typeof v[1] === 'number';
}
function isVec3(v) {
    return Array.isArray(v) && v.length === 3 &&
        typeof v[0] === 'number' && typeof v[1] === 'number' && typeof v[2] === 'number';
}
function isCol(v) {
    return isVec3(v) && isWithin(0, v[0], 1) && isWithin(0, v[1], 1) && isWithin(0, v[2], 1);
}
function isRay(v) {
    return Array.isArray(v) && v.length === 2 && isVec3(v[0]) && isVec3(v[1]);
}
function isPln(v) {
    return Array.isArray(v) && v.length === 3 && isVec3(v[0]) && isVec3(v[1]) && isVec3(v[2]);
}
function isNaN(v) {
    return Number.isNaN(v);
}
function isNull(v) {
    return v === null;
}
function isUndef(v) {
    return v === undefined;
}
function isIn(v1, v2, v3) {
    return typeof v1 === 'number' && typeof v2 === 'number' && typeof v3 === 'number' &&
        v1 < v2 && v2 < v3;
}
function isWithin(v1, v2, v3) {
    return typeof v1 === 'number' && typeof v2 === 'number' && typeof v3 === 'number' &&
        v1 <= v2 && v2 <= v3;
}


/***/ }),

/***/ "./src/assets/core/inline/_util.ts":
/*!*****************************************!*\
  !*** ./src/assets/core/inline/_util.ts ***!
  \*****************************************/
/*! exports provided: isApprox, isIn, isWithin */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isApprox", function() { return isApprox; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isIn", function() { return isIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isWithin", function() { return isWithin; });
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};
function isApprox(n1, n2, t) {
    return Math.abs(n1 - n2) < t;
}
function isIn(v1, v2, v3) {
    return typeof v1 === 'number' && typeof v2 === 'number' && typeof v3 === 'number' &&
        v1 < v2 && v2 < v3;
}
function isWithin(v1, v2, v3) {
    return typeof v1 === 'number' && typeof v2 === 'number' && typeof v3 === 'number' &&
        v1 <= v2 && v2 <= v3;
}


/***/ }),

/***/ "./src/assets/core/inline/_vec.ts":
/*!****************************************!*\
  !*** ./src/assets/core/inline/_vec.ts ***!
  \****************************************/
/*! exports provided: vecSum, vecAdd, vecSub, vecDiv, vecMult, vecSetLen, vecDot, vecCross, vecAng, vecFromTo, vecEqual, vecAng2, vecRot, vecLen, vecNorm, vecRev, vecLtoG, vecGtoL */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vecSum", function() { return vecSum; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vecAdd", function() { return vecAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vecSub", function() { return vecSub; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vecDiv", function() { return vecDiv; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vecMult", function() { return vecMult; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vecSetLen", function() { return vecSetLen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vecDot", function() { return vecDot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vecCross", function() { return vecCross; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vecAng", function() { return vecAng; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vecFromTo", function() { return vecFromTo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vecEqual", function() { return vecEqual; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vecAng2", function() { return vecAng2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vecRot", function() { return vecRot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vecLen", function() { return vecLen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vecNorm", function() { return vecNorm; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vecRev", function() { return vecRev; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vecLtoG", function() { return vecLtoG; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vecGtoL", function() { return vecGtoL; });
/* harmony import */ var _libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @libs/geom/vectors */ "./src/assets/libs/geom/vectors.ts");
/* harmony import */ var _assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @assets/libs/util/arrs */ "./src/assets/libs/util/arrs.ts");
/* harmony import */ var _assets_libs_geom_matrix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @assets/libs/geom/matrix */ "./src/assets/libs/geom/matrix.ts");
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};



// export const vecAdd = vec.vecAdd;
// export const vecSub = vec.vecSub;
// export const vecDiv = vec.vecDiv;
// export const vecMult = vec.vecMult;
// export const vecSetLen = vec.vecSetLen;
// export const vecDot = vec.vecDot;
// export const vecCross = vec.vecCross;
// export const vecAng = vec.vecAng;
// export const vecFromTo = vec.vecFromTo;
// export const vecEqual = vec.vecEqual;
// export const vecAng2 = vec.vecAng2;
// export const vecRot = vec.vecRot;
// export const vecLen = vec.vecLen;
// export const vecNorm = vec.vecNorm;
// export const vecRev = vec.vecRev;
// Overloaded vector functions
// ================================================================================================
function vecSum(...v) {
    const depth1 = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_1__["getArrDepth2"])(v);
    if (depth1 > 2) {
        // @ts-ignore
        v = v.slice().flat(depth1 - 2);
    }
    else if (depth1 < 2) {
        throw new Error('Error summing vectors: The vectors are bad.' + JSON.stringify(v));
    }
    // return the sum
    return _libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecSum"](v, false);
}
// ================================================================================================
function vecAdd(v1, v2, norm = false) {
    // overloaded case
    const depth1 = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_1__["getArrDepth2"])(v1);
    const depth2 = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_1__["getArrDepth2"])(v2);
    if (depth1 === 2 || depth2 === 2) {
        if (depth2 === 1) {
            // only v1 is Txyz[]
            return v1.map(v1_val => _libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecAdd"](v1_val, v2, norm));
        }
        else if (depth1 === 1) {
            // only v2 is Txyz[]
            return v2.map(v2_val => _libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecAdd"](v1, v2_val, norm));
        }
        else {
            // both v1 and v2 are Txyz[], they must be equal length
            if (v1.length === v2.length) {
                const vecs = [];
                for (let i = 0; i < v1.length; i++) {
                    vecs.push(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecAdd"](v1[i], v2[i], norm));
                }
                return vecs;
            }
            else {
                throw new Error('Error adding lists of vectors: The two lists must be of equal length.');
            }
        }
    }
    // normal case, both v1 and v2 are Txyz
    return _libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecAdd"](v1, v2, norm);
}
// ================================================================================================
function vecSub(v1, v2, norm = false) {
    // overloaded case
    const depth1 = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_1__["getArrDepth2"])(v1);
    const depth2 = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_1__["getArrDepth2"])(v2);
    if (depth1 === 2 || depth2 === 2) {
        if (depth2 === 1) {
            // only v1 is Txyz[]
            return v1.map(v1_val => _libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecSub"](v1_val, v2, norm));
        }
        else if (depth1 === 1) {
            // only v2 is Txyz[]
            return v2.map(v2_val => _libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecSub"](v1, v2_val, norm));
        }
        else {
            // both v1 and v2 are Txyz[], they must be equal length
            if (v1.length === v2.length) {
                const vecs = [];
                for (let i = 0; i < v1.length; i++) {
                    vecs.push(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecSub"](v1[i], v2[i], norm));
                }
                return vecs;
            }
            else {
                throw new Error('Error adding lists of vectors: The two lists must be of equal length.');
            }
        }
    }
    // normal case, both v1 and v2 are Txyz
    return _libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecSub"](v1, v2, norm);
}
// ================================================================================================
function vecDiv(v, num) {
    // overloaded case
    const depth1 = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_1__["getArrDepth2"])(v);
    const depth2 = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_1__["getArrDepth2"])(num);
    if (depth1 === 2 || depth2 === 1) {
        if (depth2 === 0) {
            // only vec is Txyz[]
            return v.map(v_val => _libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecDiv"](v_val, num));
        }
        else if (depth1 === 1) {
            // only num is number[]
            return num.map(num_val => _libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecDiv"](v, num_val));
        }
        else {
            // vec is Txyz and num is number[], they must be equal length
            num = num;
            if (v.length === num.length) {
                const vecs = [];
                for (let i = 0; i < v.length; i++) {
                    vecs.push(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecDiv"](_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__[i], num[i]));
                }
                return vecs;
            }
            else {
                throw new Error('Error dividing a lists of vectors: The list of divisors must be the same length as the list of vectors.');
            }
        }
    }
    // normal case, vec is Txyz and num is number
    return _libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecDiv"](v, num);
}
// ================================================================================================
function vecMult(v, num) {
    // overloaded case
    const depth1 = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_1__["getArrDepth2"])(v);
    const depth2 = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_1__["getArrDepth2"])(num);
    if (depth1 === 2 || depth2 === 1) {
        if (depth2 === 0) {
            // only vec is Txyz[]
            return v.map(v_val => _libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecMult"](v_val, num));
        }
        else if (depth1 === 1) {
            // only num is number[]
            return num.map(num_val => _libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecMult"](v, num_val));
        }
        else {
            // vec is Txyz and num is number[], they must be equal length
            num = num;
            if (v.length === num.length) {
                const vecs = [];
                for (let i = 0; i < v.length; i++) {
                    vecs.push(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecMult"](v[i], num[i]));
                }
                return vecs;
            }
            else {
                throw new Error('Error dividing a lists of vectors: The list of multipliers must be the same length as the list of vectors.');
            }
        }
    }
    // normal case, vec is Txyz and num is number
    return _libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecMult"](v, num);
}
// ================================================================================================
function vecSetLen(v, num) {
    // overloaded case
    const depth1 = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_1__["getArrDepth2"])(v);
    const depth2 = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_1__["getArrDepth2"])(num);
    if (depth1 === 2 || depth2 === 1) {
        if (depth2 === 0) {
            // only vec is Txyz[]
            return v.map(v_val => _libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecSetLen"](v_val, num));
        }
        else if (depth1 === 1) {
            // only num is number[]
            return num.map(num_val => _libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecSetLen"](v, num_val));
        }
        else {
            // vec is Txyz and num is number[], they must be equal length
            num = num;
            if (v.length === num.length) {
                const vecs = [];
                for (let i = 0; i < v.length; i++) {
                    vecs.push(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecSetLen"](v[i], num[i]));
                }
                return vecs;
            }
            else {
                throw new Error('Error setting lengths for a lists of vectors: The list of vector lengths must be the same length as the list of vectors.');
            }
        }
    }
    // normal case, vec is Txyz and num is number
    return _libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecSetLen"](v, num);
}
// ================================================================================================
function vecDot(v1, v2) {
    // overloaded case
    const depth1 = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_1__["getArrDepth2"])(v1);
    const depth2 = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_1__["getArrDepth2"])(v2);
    if (depth1 === 2 || depth2 === 2) {
        if (depth2 === 1) {
            // only v1 is Txyz[]
            return v1.map(v1_val => _libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecDot"](v1_val, v2));
        }
        else if (depth1 === 1) {
            // only v2 is Txyz[]
            return v2.map(v2_val => _libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecDot"](v1, v2_val));
        }
        else {
            // both v1 and v2 are Txyz[], they must be equal length
            if (v1.length === v2.length) {
                const vals = [];
                for (let i = 0; i < v1.length; i++) {
                    vals.push(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecDot"](v1[i], v2[i]));
                }
                return vals;
            }
            else {
                throw new Error('Error calculating dot product of two lists of vectors: The two lists must be of equal length.');
            }
        }
    }
    // normal case, both v1 and v2 are Txyz
    return _libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecDot"](v1, v2);
}
// ================================================================================================
function vecCross(v1, v2) {
    // overloaded case
    const depth1 = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_1__["getArrDepth2"])(v1);
    const depth2 = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_1__["getArrDepth2"])(v2);
    if (depth1 === 2 || depth2 === 2) {
        if (depth2 === 1) {
            // only v1 is Txyz[]
            return v1.map(v1_val => _libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecCross"](v1_val, v2));
        }
        else if (depth1 === 1) {
            // only v2 is Txyz[]
            return v2.map(v2_val => _libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecCross"](v1, v2_val));
        }
        else {
            // both v1 and v2 are Txyz[], they must be equal length
            if (v1.length === v2.length) {
                const vecs = [];
                for (let i = 0; i < v1.length; i++) {
                    vecs.push(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecCross"](v1[i], v2[i]));
                }
                return vecs;
            }
            else {
                throw new Error('Error calculating cross product of two lists of vectors: The two lists must be of equal length.');
            }
        }
    }
    // normal case, both v1 and v2 are Txyz
    return _libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecCross"](v1, v2);
}
// ================================================================================================
function vecAng(v1, v2) {
    // overloaded case
    const depth1 = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_1__["getArrDepth2"])(v1);
    const depth2 = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_1__["getArrDepth2"])(v2);
    if (depth1 === 2 || depth2 === 2) {
        if (depth2 === 1) {
            // only v1 is Txyz[]
            return v1.map(v1_val => _libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecAng"](v1_val, v2));
        }
        else if (depth1 === 1) {
            // only v2 is Txyz[]
            return v2.map(v2_val => _libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecAng"](v1, v2_val));
        }
        else {
            // both v1 and v2 are Txyz[], they must be equal length
            if (v1.length === v2.length) {
                const angs = [];
                for (let i = 0; i < v1.length; i++) {
                    angs.push(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecAng"](v1[i], v2[i]));
                }
                return angs;
            }
            else {
                throw new Error('Error calculating angle between two lists of vectors: The two lists must be of equal length.');
            }
        }
    }
    // normal case, both v1 and v2 are Txyz
    return _libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecAng"](v1, v2);
}
// ================================================================================================
function vecFromTo(v1, v2) {
    // overloaded case
    const depth1 = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_1__["getArrDepth2"])(v1);
    const depth2 = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_1__["getArrDepth2"])(v2);
    if (depth1 === 2 || depth2 === 2) {
        if (depth2 === 1) {
            // only v1 is Txyz[]
            return v1.map(v1_val => _libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecFromTo"](v1_val, v2));
        }
        else if (depth1 === 1) {
            // only v2 is Txyz[]
            return v2.map(v2_val => _libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecFromTo"](v1, v2_val));
        }
        else {
            // both v1 and v2 are Txyz[], they must be equal length
            if (v1.length === v2.length) {
                const vecs = [];
                for (let i = 0; i < v1.length; i++) {
                    vecs.push(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecFromTo"](v1[i], v2[i]));
                }
                return vecs;
            }
            else {
                throw new Error('Error calculating vectors between two between lists of coordinates: The two lists must be of equal length.');
            }
        }
    }
    // normal case, both v1 and v2 are Txyz
    return _libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecFromTo"](v1, v2);
}
// ================================================================================================
function vecEqual(v1, v2, tol) {
    // overloaded case
    const depth1 = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_1__["getArrDepth2"])(v1);
    const depth2 = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_1__["getArrDepth2"])(v2);
    if (depth1 === 2 || depth2 === 2) {
        if (depth2 === 1 || depth2 === 1) {
            throw new Error('Error calculating vector equality between multiple vectors: The two lists must be of equal length.');
        }
        else {
            // both v1 and v2 are Txyz[], they must be equal length
            if (v1.length === v2.length) {
                const eq = [];
                for (let i = 0; i < v1.length; i++) {
                    eq.push(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecEqual"](v1[i], v2[i], tol));
                }
                return eq;
            }
            else {
                throw new Error('Error calculating vectors between two between lists of coordinates: The two lists must be of equal length.');
            }
        }
    }
    // normal case, both v1 and v2 are Txyz
    return _libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecEqual"](v1, v2, tol);
}
// ================================================================================================
function vecAng2(v1, v2, v3) {
    // overloaded case
    const depth1 = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_1__["getArrDepth2"])(v1);
    const depth2 = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_1__["getArrDepth2"])(v2);
    const depth3 = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_1__["getArrDepth2"])(v3);
    if (depth1 === 2 || depth2 === 2 || depth3 === 2) {
        if (depth2 === 1 && depth3 === 1) {
            // only v1 is Txyz[]
            return v1.map(v1_val => _libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecAng2"](v1_val, v2, v3));
        }
        else if (depth1 === 1 && depth3 === 1) {
            // only v2 is Txyz[]
            return v2.map(v2_val => _libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecAng2"](v1, v2_val, v3));
        }
        else if (depth1 === 1 && depth2 === 1) {
            // only v3 is Txyz[]
            return v3.map(v3_val => _libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecAng2"](v1, v2, v3_val));
        }
        else if (depth1 === 1) {
            // v2 and v3 are Txyz[], they must be equal length
            if (v2.length === v3.length) {
                const angs = [];
                for (let i = 0; i < v2.length; i++) {
                    angs.push(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecAng2"](v1, v2[i], v3[i]));
                }
                return angs;
            }
            else {
                throw new Error('Error calculating angles between two between lists of vectors: The two lists must be of equal length.');
            }
        }
        else if (depth2 === 1) {
            // v1 and v3 are Txyz[], they must be equal length
            if (v1.length === v3.length) {
                const angs = [];
                for (let i = 0; i < v1.length; i++) {
                    angs.push(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecAng2"](v1[i], v2, v3[i]));
                }
                return angs;
            }
            else {
                throw new Error('Error calculating angles between between lists of vectors: The two lists must be of equal length.');
            }
        }
        else if (depth3 === 1) {
            // v1 and v2 are Txyz[], they must be equal length
            if (v1.length === v2.length) {
                const angs = [];
                for (let i = 0; i < v1.length; i++) {
                    angs.push(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecAng2"](v1[i], v2[i], v3));
                }
                return angs;
            }
            else {
                throw new Error('Error calculating angles between two between lists of vectors and normals: The two lists must be of equal length.');
            }
        }
        else {
            // all three v1 and v2 and v3 are Txyz[], they must be all equal length
            if (v1.length === v2.length && v2.length === v3.length) {
                const angs = [];
                for (let i = 0; i < v1.length; i++) {
                    angs.push(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecAng2"](v1[i], v2[i], v3[i]));
                }
                return angs;
            }
            else {
                throw new Error('Error calculating vectors between two between lists of vectors and normals: The two lists must be of equal length.');
            }
        }
    }
    // normal case, v1 and v2 and v3 are Txyz
    return _libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecAng2"](v1, v2, v3);
}
// ================================================================================================
function vecRot(v1, v2, ang) {
    // overloaded case
    const depth1 = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_1__["getArrDepth2"])(v1);
    const depth2 = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_1__["getArrDepth2"])(v2);
    const depth3 = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_1__["getArrDepth2"])(ang);
    if (depth1 === 2 || depth2 === 2 || depth3 === 2) {
        if (depth2 === 1 && depth3 === 1) {
            // only v1 is Txyz[]
            return v1.map(v1_val => _libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecRot"](v1_val, v2, ang));
        }
        else if (depth1 === 1 && depth3 === 1) {
            // only v2 is Txyz[]
            return v2.map(v2_val => _libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecRot"](v1, v2_val, ang));
        }
        else if (depth1 === 1 && depth2 === 1) {
            // only ang is number[]
            return ang.map(ang_val => _libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecRot"](v1, v2, ang_val));
        }
        else if (depth1 === 1) {
            // v2 is Txyz[] and ang is number[], they must be equal length
            ang = ang;
            if (v2.length === ang.length) {
                const vecs = [];
                for (let i = 0; i < v2.length; i++) {
                    vecs.push(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecRot"](v1, v2[i], ang[i]));
                }
                return vecs;
            }
            else {
                throw new Error('Error calculating angles between two between lists of vectors: The two lists must be of equal length.');
            }
        }
        else if (depth2 === 1) {
            // v1 is Txyz[] and ang is number[], they must be equal length
            ang = ang;
            if (v1.length === ang.length) {
                const vecs = [];
                for (let i = 0; i < v1.length; i++) {
                    vecs.push(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecRot"](v1[i], v2, ang[i]));
                }
                return vecs;
            }
            else {
                throw new Error('Error calculating angles between between lists of vectors: The two lists must be of equal length.');
            }
        }
        else if (depth3 === 1) {
            // v1 and v2 are Txyz[], they must be equal length
            if (v1.length === v2.length) {
                const vecs = [];
                for (let i = 0; i < v1.length; i++) {
                    vecs.push(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecRot"](v1[i], v2[i], ang));
                }
                return vecs;
            }
            else {
                throw new Error('Error calculating angles between two between lists of vectors and normals: The two lists must be of equal length.');
            }
        }
        else {
            // all three v1 and v2 are Txyz[] and ang is number[], they must be all equal length
            ang = ang;
            if (v1.length === v2.length && v2.length === ang.length) {
                const vecs = [];
                for (let i = 0; i < v1.length; i++) {
                    vecs.push(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecRot"](v1[i], v2[i], ang[i]));
                }
                return vecs;
            }
            else {
                throw new Error('Error calculating vectors between two between lists of vectors and normals: The two lists must be of equal length.');
            }
        }
    }
    // normal case, v1 and v2 and ang are Txyz
    return _libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecRot"](v1, v2, ang);
}
// ================================================================================================
function vecLen(v) {
    // overloaded case
    const depth1 = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_1__["getArrDepth2"])(v);
    if (depth1 === 2) {
        return v.map(v_val => _libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecLen"](v_val));
    }
    // normal case, vec is Txyz
    return _libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecLen"](v);
}
// ================================================================================================
function vecNorm(v) {
    // overloaded case
    const depth1 = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_1__["getArrDepth2"])(v);
    if (depth1 === 2) {
        return v.map(v_val => _libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecNorm"](v_val));
    }
    // normal case, vec is Txyz
    return _libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecNorm"](v);
}
// ================================================================================================
function vecRev(v) {
    // overloaded case
    const depth1 = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_1__["getArrDepth2"])(v);
    if (depth1 === 2) {
        return v.map(v_val => _libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecRev"](v_val));
    }
    // normal case, vec is Txyz
    return _libs_geom_vectors__WEBPACK_IMPORTED_MODULE_0__["vecRev"](v);
}
// ================================================================================================
function vecLtoG(v, p) {
    return vecXForm(v, p, true);
}
function vecGtoL(v, p) {
    return vecXForm(v, p, false);
}
function vecXForm(v, p, to_global) {
    // overloaded case
    const depth1 = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_1__["getArrDepth2"])(v);
    const depth2 = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_1__["getArrDepth2"])(p);
    if (depth1 === 1 && depth2 === 2) {
        // v is Txyz and p is TPlane
        return Object(_assets_libs_geom_matrix__WEBPACK_IMPORTED_MODULE_2__["multMatrix"])(v, Object(_assets_libs_geom_matrix__WEBPACK_IMPORTED_MODULE_2__["xformMatrix"])(p, to_global));
    }
    else if (depth1 === 2 && depth2 === 2) {
        // v is Txyz[] and p is TPlane
        const matrix = Object(_assets_libs_geom_matrix__WEBPACK_IMPORTED_MODULE_2__["xformMatrix"])(p, to_global);
        return v.map(a_v => Object(_assets_libs_geom_matrix__WEBPACK_IMPORTED_MODULE_2__["multMatrix"])(a_v, matrix));
    }
    else if (depth1 === 1 && depth2 === 3) {
        // v is Txyz and p is TPlane[]
        const result = [];
        for (const a_p of p) {
            const matrix = Object(_assets_libs_geom_matrix__WEBPACK_IMPORTED_MODULE_2__["xformMatrix"])(a_p, to_global);
            result.push(Object(_assets_libs_geom_matrix__WEBPACK_IMPORTED_MODULE_2__["multMatrix"])(v, matrix));
        }
        return result;
    }
    else if (depth1 === 2 && depth2 === 3) {
        // v is Txyz[] p is TPlane[], they must be equal length
        if (v.length === p.length) {
            const result = [];
            for (let i = 0; i < v.length; i++) {
                const matrix = Object(_assets_libs_geom_matrix__WEBPACK_IMPORTED_MODULE_2__["xformMatrix"])(p[i], to_global);
                result.push(Object(_assets_libs_geom_matrix__WEBPACK_IMPORTED_MODULE_2__["multMatrix"])(v[i], matrix));
            }
            return result;
        }
        else {
            throw new Error('Error transforming vectors: The list of vectors and list of planes must be of equal length.');
        }
    }
    throw new Error('Error transforming vectors: Cannot process the input lists.');
}


/***/ }),

/***/ "./src/assets/core/modules/_check_args.ts":
/*!************************************************!*\
  !*** ./src/assets/core/modules/_check_args.ts ***!
  \************************************************/
/*! exports provided: ArgCh, checkArgs */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ArgCh", function() { return ArgCh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkArgs", function() { return checkArgs; });
/* harmony import */ var _check_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_check_types */ "./src/assets/core/modules/_check_types.ts");
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};

class ArgCh {
    static isAny(fn_name, arg_name, arg) {
        _check_types__WEBPACK_IMPORTED_MODULE_0__["isAny"](fn_name, arg_name, arg);
    }
    // null: allow Null input
    static isNull(fn_name, arg_name, arg) {
        _check_types__WEBPACK_IMPORTED_MODULE_0__["isNull"](fn_name, arg_name, arg);
    }
    // dict
    static isDict(fn_name, arg_name, arg) {
        _check_types__WEBPACK_IMPORTED_MODULE_0__["isDict"](fn_name, arg_name, arg);
    }
    // list
    static isList(fn_name, arg_name, arg) {
        _check_types__WEBPACK_IMPORTED_MODULE_0__["isList"](fn_name, arg_name, arg);
    }
    // booleans
    static isBool(fn_name, arg_name, arg) {
        _check_types__WEBPACK_IMPORTED_MODULE_0__["isBool"](fn_name, arg_name, arg);
    }
    static isBoolL(fn_name, arg_name, arg) {
        _check_types__WEBPACK_IMPORTED_MODULE_0__["isBoolL"](fn_name, arg_name, arg);
    }
    // strings
    static isStr(fn_name, arg_name, arg) {
        _check_types__WEBPACK_IMPORTED_MODULE_0__["isStr"](fn_name, arg_name, arg);
    }
    static isStrL(fn_name, arg_name, arg) {
        _check_types__WEBPACK_IMPORTED_MODULE_0__["isStrL"](fn_name, arg_name, arg);
    }
    static isStrStr(fn_name, arg_name, arg) {
        _check_types__WEBPACK_IMPORTED_MODULE_0__["isStrL"](fn_name, arg_name, arg);
        _check_types__WEBPACK_IMPORTED_MODULE_0__["isLLen"](fn_name, arg_name, arg, 2);
    }
    static isStrNum(fn_name, arg_name, arg) {
        _check_types__WEBPACK_IMPORTED_MODULE_0__["isLLen"](fn_name, arg_name, arg, 2);
        _check_types__WEBPACK_IMPORTED_MODULE_0__["isStr"](fn_name, arg_name, arg[0]);
        _check_types__WEBPACK_IMPORTED_MODULE_0__["isNum"](fn_name, arg_name, arg[1]);
    }
    static isNum(fn_name, arg_name, arg) {
        _check_types__WEBPACK_IMPORTED_MODULE_0__["isNum"](fn_name, arg_name, arg);
    }
    static isNum01(fn_name, arg_name, arg) {
        _check_types__WEBPACK_IMPORTED_MODULE_0__["isNum01"](fn_name, arg_name, arg);
    }
    static isNumL(fn_name, arg_name, arg) {
        _check_types__WEBPACK_IMPORTED_MODULE_0__["isNumL"](fn_name, arg_name, arg);
    }
    static isNullL(fn_name, arg_name, arg) {
        _check_types__WEBPACK_IMPORTED_MODULE_0__["isNullL"](fn_name, arg_name, arg);
    }
    static isInt(fn_name, arg_name, arg) {
        _check_types__WEBPACK_IMPORTED_MODULE_0__["isInt"](fn_name, arg_name, arg);
    }
    static isXY(fn_name, arg_name, arg) {
        _check_types__WEBPACK_IMPORTED_MODULE_0__["isNumL"](fn_name, arg_name, arg);
        _check_types__WEBPACK_IMPORTED_MODULE_0__["isLLen"](fn_name, arg_name, arg, 2);
        _check_types__WEBPACK_IMPORTED_MODULE_0__["isNumL"](fn_name, arg_name, arg);
    }
    static isXYInt(fn_name, arg_name, arg) {
        _check_types__WEBPACK_IMPORTED_MODULE_0__["isIntL"](fn_name, arg_name, arg);
        _check_types__WEBPACK_IMPORTED_MODULE_0__["isLLen"](fn_name, arg_name, arg, 2);
        _check_types__WEBPACK_IMPORTED_MODULE_0__["isIntL"](fn_name, arg_name, arg);
    }
    static isColor(fn_name, arg_name, arg) {
        _check_types__WEBPACK_IMPORTED_MODULE_0__["isNumL"](fn_name, arg_name, arg);
        _check_types__WEBPACK_IMPORTED_MODULE_0__["isLLen"](fn_name, arg_name, arg, 3);
        _check_types__WEBPACK_IMPORTED_MODULE_0__["isNum01L"](fn_name, arg_name, arg);
        return;
    }
    static isXYZ(fn_name, arg_name, arg) {
        _check_types__WEBPACK_IMPORTED_MODULE_0__["isNumL"](fn_name, arg_name, arg);
        _check_types__WEBPACK_IMPORTED_MODULE_0__["isLLen"](fn_name, arg_name, arg, 3);
    }
    static isXYZL(fn_name, arg_name, arg) {
        _check_types__WEBPACK_IMPORTED_MODULE_0__["isList"](fn_name, arg_name, arg);
        for (let i = 0; i < arg.length; i++) {
            ArgCh.isXYZ(fn_name, arg_name, arg[i]);
        }
    }
    static isXYZLL(fn_name, arg_name, arg) {
        _check_types__WEBPACK_IMPORTED_MODULE_0__["isList"](fn_name, arg_name, arg);
        for (let i = 0; i < arg.length; i++) {
            ArgCh.isXYZL(fn_name, arg_name + '[' + i + ']', arg[i]);
        }
    }
    static isPln(fn_name, arg_name, arg) {
        ArgCh.isXYZL(fn_name, arg_name, arg);
        _check_types__WEBPACK_IMPORTED_MODULE_0__["isLLen"](fn_name, arg_name, arg, 3);
    }
    static isPlnL(fn_name, arg_name, arg) {
        _check_types__WEBPACK_IMPORTED_MODULE_0__["isList"](fn_name, arg_name, arg);
        for (let i = 0; i < arg.length; i++) {
            ArgCh.isPln(fn_name, arg_name + '[' + i + ']', arg[i]);
        }
    }
    static isBBox(fn_name, arg_name, arg) {
        ArgCh.isXYZL(fn_name, arg_name, arg);
        _check_types__WEBPACK_IMPORTED_MODULE_0__["isLLen"](fn_name, arg_name, arg, 4);
    }
    static isBBoxL(fn_name, arg_name, arg) {
        _check_types__WEBPACK_IMPORTED_MODULE_0__["isList"](fn_name, arg_name, arg);
        for (let i = 0; i < arg.length; i++) {
            ArgCh.isBBox(fn_name, arg_name + '[' + i + ']', arg[i]);
        }
    }
    static isRay(fn_name, arg_name, arg) {
        ArgCh.isXYZL(fn_name, arg_name, arg);
        _check_types__WEBPACK_IMPORTED_MODULE_0__["isLLen"](fn_name, arg_name, arg, 2);
    }
    static isRayL(fn_name, arg_name, arg) {
        _check_types__WEBPACK_IMPORTED_MODULE_0__["isList"](fn_name, arg_name, arg);
        for (let i = 0; i < arg.length; i++) {
            ArgCh.isRay(fn_name, arg_name + '[' + i + ']', arg[i]);
        }
    }
    static isRayLL(fn_name, arg_name, arg) {
        _check_types__WEBPACK_IMPORTED_MODULE_0__["isList"](fn_name, arg_name, arg);
        for (let i = 0; i < arg.length; i++) {
            ArgCh.isRayL(fn_name, arg_name + '[' + i + ']', arg[i]);
        }
    }
}
function checkArgs(fn_name, arg_name, arg, check_fns) {
    let pass = false;
    const err_arr = [];
    let ret;
    if (arg === undefined) {
        throw new Error(fn_name + ': ' + arg_name + ' is undefined' + '<br>');
    }
    for (let i = 0; i < check_fns.length; i++) {
        try {
            ret = check_fns[i](fn_name, arg_name, arg);
        }
        catch (err) {
            err_arr.push(err.message + '<br>');
            continue;
        }
        pass = true;
        break; // passed
    }
    if (pass === false) { // Failed all tests: argument does not fall into any valid types
        const ret_msg = fn_name + ': ' + arg_name + ' failed the following tests:<br>';
        throw new Error(ret_msg + err_arr.join(''));
    }
    return ret;
}


/***/ }),

/***/ "./src/assets/core/modules/_check_attribs.ts":
/*!***************************************************!*\
  !*** ./src/assets/core/modules/_check_attribs.ts ***!
  \***************************************************/
/*! exports provided: checkAttribName, checkAttribIdxKey, checkAttribNameIdxKey, splitAttribNameIdxKey, checkAttribValue */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkAttribName", function() { return checkAttribName; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkAttribIdxKey", function() { return checkAttribIdxKey; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkAttribNameIdxKey", function() { return checkAttribNameIdxKey; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "splitAttribNameIdxKey", function() { return splitAttribNameIdxKey; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkAttribValue", function() { return checkAttribValue; });
/* harmony import */ var _check_args__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_check_args */ "./src/assets/core/modules/_check_args.ts");
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};

// =========================================================================================================================================
// Attribute Checks
// =========================================================================================================================================
function checkAttribName(fn_name, attrib_name) {
    _check_args__WEBPACK_IMPORTED_MODULE_0__["ArgCh"].isStr(fn_name, 'attrib_name', attrib_name); // check arg is string
    if (attrib_name === undefined) {
        throw new Error(fn_name + ': ' + 'attrib_name is undefined');
    }
    if (attrib_name.length === 0) {
        throw new Error(fn_name + ': ' + 'attrib_name not specified');
    }
    if (attrib_name.search(/\W/) !== -1) {
        throw new Error(fn_name + ': ' + 'attrib_name contains restricted characters');
    }
    if (attrib_name[0].search(/[0-9]/) !== -1) {
        throw new Error(fn_name + ': ' + 'attrib_name should not start with numbers');
    }
    // blocks writing to id
    if (attrib_name === 'id') {
        throw new Error(fn_name + ': id is not modifiable!');
    }
}
function checkAttribIdxKey(fn_name, idx_or_key) {
    // -- check defined index
    if (typeof idx_or_key === 'number') {
        // check if index is number
        _check_args__WEBPACK_IMPORTED_MODULE_0__["ArgCh"].isNum(fn_name, 'attrib_index', idx_or_key);
        // this is an item in a list, the item value can be any
    }
    else if (typeof idx_or_key === 'string') {
        // check if index is number
        _check_args__WEBPACK_IMPORTED_MODULE_0__["ArgCh"].isStr(fn_name, 'attrib_key', idx_or_key);
        // this is an item in an object, the item value can be any
    }
    else {
        throw new Error(fn_name + ': index or key is not a valid type: ' + idx_or_key);
    }
}
function checkAttribNameIdxKey(fn_name, attrib) {
    let attrib_name = null;
    let attrib_idx_key = null;
    // deconstruct the attrib arg
    if (Array.isArray(attrib)) {
        if (attrib.length !== 2) {
            throw new Error(fn_name + ': ' + 'attrib_name not specified');
        }
        attrib_name = attrib[0];
        attrib_idx_key = attrib[1];
    }
    else {
        attrib_name = attrib;
    }
    // check that the name is ok
    checkAttribName(fn_name, attrib_name);
    // check that the array index or object key is ok
    if (attrib_idx_key !== null) {
        checkAttribIdxKey(fn_name, attrib_idx_key);
    }
    // return the deconstructed attrib arg, attrib_idx_key may be null
    return [attrib_name, attrib_idx_key];
}
function splitAttribNameIdxKey(fn_name, attrib) {
    let attrib_name = null;
    let attrib_idx_key = null;
    // deconstruct the attrib arg
    if (Array.isArray(attrib)) {
        attrib_name = attrib[0];
        attrib_idx_key = attrib[1];
    }
    else {
        attrib_name = attrib;
    }
    // return the deconstructed attrib arg, attrib_idx_key may be null
    return [attrib_name, attrib_idx_key];
}
function checkAttribValue(fn_name, attrib_value) {
    // check the actual value
    Object(_check_args__WEBPACK_IMPORTED_MODULE_0__["checkArgs"])(fn_name, 'attrib_value', attrib_value, [_check_args__WEBPACK_IMPORTED_MODULE_0__["ArgCh"].isStr, _check_args__WEBPACK_IMPORTED_MODULE_0__["ArgCh"].isNum, _check_args__WEBPACK_IMPORTED_MODULE_0__["ArgCh"].isBool,
        _check_args__WEBPACK_IMPORTED_MODULE_0__["ArgCh"].isNull, _check_args__WEBPACK_IMPORTED_MODULE_0__["ArgCh"].isList, _check_args__WEBPACK_IMPORTED_MODULE_0__["ArgCh"].isDict]);
}


/***/ }),

/***/ "./src/assets/core/modules/_check_ids.ts":
/*!***********************************************!*\
  !*** ./src/assets/core/modules/_check_ids.ts ***!
  \***********************************************/
/*! exports provided: IdCh, checkIDs */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IdCh", function() { return IdCh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkIDs", function() { return checkIDs; });
/* harmony import */ var _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @libs/geo-info/common */ "./src/assets/libs/geo-info/common.ts");
/* harmony import */ var _libs_geo_info_id__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @libs/geo-info/id */ "./src/assets/libs/geo-info/id.ts");
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};


class IdCh {
    static isId(fn_name, arg_name, arg, ent_type_strs) {
        let ent_arr;
        try {
            ent_arr = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_1__["idsBreak"])(arg); // split
        }
        catch (err) {
            throw new Error(fn_name + ': ' + arg_name + ' is not a valid Entity ID'); // check valid id
        }
        if (ent_type_strs === null) {
            ent_type_strs = IdCh.default_ent_type_strs;
        }
        let pass = false;
        for (let i = 0; i < ent_type_strs.length; i++) {
            if (ent_arr[0] === ent_type_strs[i]) {
                pass = true;
                break;
            }
        }
        if (pass === false) {
            throw new Error(fn_name + ': ' + arg_name + ' is not one of the following valid types - ' +
                ent_type_strs.map((test_ent) => _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"][test_ent]).toString());
        }
        return ent_arr;
    }
    static isIdL(fn_name, arg_name, arg_list, ent_type_strs) {
        if (!Array.isArray(arg_list)) {
            throw new Error(fn_name + ': ' + arg_name + ' is not list.');
        }
        const ret_arr = [];
        if (ent_type_strs === null) {
            ent_type_strs = IdCh.default_ent_type_strs;
        }
        for (let i = 0; i < arg_list.length; i++) {
            ret_arr.push(IdCh.isId(fn_name, arg_name + '[' + i + ']', arg_list[i], ent_type_strs));
        }
        return ret_arr;
    }
    static isIdLL(fn_name, arg_name, arg_list, ent_type_strs) {
        if (!Array.isArray(arg_list)) {
            throw new Error(fn_name + ': ' + arg_name + ' is not list.');
        }
        const ret_arr = [];
        if (ent_type_strs === null) {
            ent_type_strs = IdCh.default_ent_type_strs;
        }
        for (let i = 0; i < arg_list.length; i++) {
            ret_arr.push(IdCh.isIdL(fn_name, arg_name + '[' + i + ']', arg_list[i], ent_type_strs));
        }
        return ret_arr;
    }
}
IdCh.default_ent_type_strs = [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POSI,
    _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].TRI,
    _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].VERT,
    _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].EDGE,
    _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].WIRE,
    _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].FACE,
    _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POINT,
    _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PLINE,
    _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PGON,
    _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].COLL];
function checkIDs(fn_name, arg_name, arg, check_fns, IDchecks) {
    let pass = false;
    const err_arr = [];
    let ret;
    if (arg === undefined) {
        throw new Error(fn_name + ': ' + arg_name + ' is undefined' + '<br>');
    }
    for (let i = 0; i < check_fns.length; i++) {
        try {
            ret = check_fns[i](fn_name, arg_name, arg, IDchecks);
        }
        catch (err) {
            err_arr.push(err.message + '<br>');
            continue;
        }
        pass = true;
        break; // passed
    }
    if (pass === false) { // Failed all tests: argument does not fall into any valid types
        const ret_msg = fn_name + ': ' + arg_name + ' failed the following tests:<br>';
        throw new Error(ret_msg + err_arr.join(''));
    }
    return ret; // returns TEntTypeIdx|TEntTypeIdx[]|TEntTypeIdx[][]; depends on which passes
}


/***/ }),

/***/ "./src/assets/core/modules/_check_types.ts":
/*!*************************************************!*\
  !*** ./src/assets/core/modules/_check_types.ts ***!
  \*************************************************/
/*! exports provided: isDict, isList, isLLen, isAny, isAnyL, isNull, isNullL, isBool, isBoolL, isStr, isStrL, isNum, isNumL, isNum01, isNum01L, isInt, isIntL */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isDict", function() { return isDict; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isList", function() { return isList; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isLLen", function() { return isLLen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isAny", function() { return isAny; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isAnyL", function() { return isAnyL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isNull", function() { return isNull; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isNullL", function() { return isNullL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isBool", function() { return isBool; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isBoolL", function() { return isBoolL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isStr", function() { return isStr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isStrL", function() { return isStrL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isNum", function() { return isNum; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isNumL", function() { return isNumL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isNum01", function() { return isNum01; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isNum01L", function() { return isNum01L; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isInt", function() { return isInt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isIntL", function() { return isIntL; });
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};
// =====================================================================================================================
// util - check type
// =====================================================================================================================
// Dict
function isDict(fn_name, arg_name, arg) {
    if (Array.isArray(arg) || typeof arg !== 'object') {
        throw new Error(fn_name + ': ' + arg_name + ' is not a dict');
    }
}
// List
function isList(fn_name, arg_name, arg) {
    if (!Array.isArray(arg)) {
        throw new Error(fn_name + ': ' + arg_name + ' is not a list');
    }
}
// List of specified length
function isLLen(fn_name, arg_name, arg, len) {
    if (arg.length !== len) {
        throw new Error(fn_name + ': ' + arg_name + ' is not a list of length ' + len);
    }
}
// Any
function isAny(fn_name, arg_name, arg) {
    if (arg === undefined) {
        throw new Error(fn_name + ': ' + arg_name + ' must be defined');
    }
}
// Any list
function isAnyL(fn_name, arg_name, arg) {
    isList(fn_name, arg_name, arg);
    for (let i = 0; i < arg.length; i++) {
        isAny(fn_name, arg_name + '[' + i + ']', arg[i]);
    }
}
// Null
function isNull(fn_name, arg_name, arg) {
    if (arg !== null) {
        throw new Error(fn_name + ': ' + arg_name + ' is not null');
    }
}
// Null list
function isNullL(fn_name, arg_name, arg) {
    isList(fn_name, arg_name, arg);
    for (let i = 0; i < arg.length; i++) {
        isNull(fn_name, arg_name + '[' + i + ']', arg[i]);
    }
}
// Boolean
function isBool(fn_name, arg_name, arg) {
    if (typeof arg !== 'boolean') {
        throw new Error(fn_name + ': ' + arg_name + ' is not a boolean');
    }
}
// Boolean list
function isBoolL(fn_name, arg_name, arg) {
    isList(fn_name, arg_name, arg);
    for (let i = 0; i < arg.length; i++) {
        isBool(fn_name, arg_name + '[' + i + ']', arg[i]);
    }
}
// String
function isStr(fn_name, arg_name, arg) {
    if (typeof arg !== 'string') {
        throw new Error(fn_name + ': ' + arg_name + ' is not a string');
    }
}
// String list
function isStrL(fn_name, arg_name, arg) {
    isList(fn_name, arg_name, arg);
    for (let i = 0; i < arg.length; i++) {
        isStr(fn_name, arg_name + '[' + i + ']', arg[i]);
    }
}
// Numbers
function isNum(fn_name, arg_name, arg) {
    if (isNaN(arg)) { // } || isNaN(parseInt(arg, 10))) {
        throw new Error(fn_name + ': ' + arg_name + ' is not a number');
    }
}
// Number list
function isNumL(fn_name, arg_name, arg) {
    isList(fn_name, arg_name, arg);
    for (let i = 0; i < arg.length; i++) {
        isNum(fn_name, arg_name + '[' + i + ']', arg[i]);
    }
}
// Number between 0 and 1
function isNum01(fn_name, arg_name, arg) {
    isNum(fn_name, arg_name, arg);
    if (arg < 0 || arg > 1) {
        throw new Error(fn_name + ': ' + arg_name + ' must be between 0 and 1');
    }
}
// Number list between 0 and 1
function isNum01L(fn_name, arg_name, arg) {
    isNumL(fn_name, arg_name, arg);
    for (let i = 0; i < arg.length; i++) {
        isNum01(fn_name, arg_name + '[' + i + ']', arg[i]);
    }
}
// Integer
function isInt(fn_name, arg_name, arg) {
    if (!Number.isInteger(arg)) {
        throw new Error(fn_name + ': ' + arg_name + ' is not an integer');
    }
}
// Integer list
function isIntL(fn_name, arg_name, arg) {
    isList(fn_name, arg_name, arg);
    for (let i = 0; i < arg.length; i++) {
        isInt(fn_name, arg_name, arg[i]);
    }
}


/***/ }),

/***/ "./src/assets/core/modules/_model.ts":
/*!*******************************************!*\
  !*** ./src/assets/core/modules/_model.ts ***!
  \*******************************************/
/*! exports provided: __new__, __preprocess__, __postprocess__, __merge__, __stringify__, __select__, __checkModel__ */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__new__", function() { return __new__; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__preprocess__", function() { return __preprocess__; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__postprocess__", function() { return __postprocess__; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__merge__", function() { return __merge__; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__stringify__", function() { return __stringify__; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__select__", function() { return __select__; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__checkModel__", function() { return __checkModel__; });
/* harmony import */ var _libs_geo_info_GIModel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @libs/geo-info/GIModel */ "./src/assets/libs/geo-info/GIModel.ts");
/* harmony import */ var _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @libs/geo-info/common */ "./src/assets/libs/geo-info/common.ts");
/* harmony import */ var _libs_geo_info_id__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @libs/geo-info/id */ "./src/assets/libs/geo-info/id.ts");
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};



//  ===============================================================================================
//  Functions used by Mobius
//  ===============================================================================================
/**
 * Creates a new empty model.
 *
 * @returns New model empty.
 */
function __new__() {
    const model = new _libs_geo_info_GIModel__WEBPACK_IMPORTED_MODULE_0__["GIModel"]();
    model.modeldata.attribs.add.addAttrib(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_1__["EEntType"].POSI, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_1__["EAttribNames"].COORDS, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_1__["EAttribDataTypeStrs"].LIST);
    return model;
}
//  ===============================================================================================
/**
 * A function to preprocess the model, before it enters the node.
 * In cases where there is more than one model connected to a node,
 * the preprocess function will be called before the merge function.
 *
 * @param model The model to preprocess.
 */
function __preprocess__(__model__) {
    // TODO
}
//  ===============================================================================================
/**
 * A function to postprocess the model, after it enters the node.
 *
 * @param model The model to postprocess.
 */
function __postprocess__(__model__) {
    // TODO
    // Remove all undefined values for the arrays
}
//  ===============================================================================================
/**
 * Merges the second model into the first model. The geometry, attribues, and groups are all merged.
 * If the models contain contain groups with the same names, then the groups will be merged.
 *
 * @param model1 The model to merge into.
 * @param model2 The model to merge from    .
 */
function __merge__(model1, model2) {
    model1.merge(model2);
}
//  ===============================================================================================
/**
 * Returns a string representation of this model.
 * @param __model__
 */
function __stringify__(__model__) {
    return JSON.stringify(__model__.getModelData());
}
//  ===============================================================================================
/**
 * Select entities in the model.
 * @param __model__
 */
function __select__(__model__, ents_id, var_name) {
    const start = performance.now();
    __model__.modeldata.geom.selected = [];
    ents_id = ((Array.isArray(ents_id)) ? ents_id : [ents_id]);
    const [ents_id_flat, ents_indices] = _flatten(ents_id);
    const ents_arr = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_2__["idsBreak"])(ents_id_flat);
    const attrib_name = '_' + var_name;
    for (let i = 0; i < ents_arr.length; i++) {
        const ent_arr = ents_arr[i];
        const ent_indices = ents_indices[i];
        const attrib_value = var_name + '[' + ent_indices.join('][') + ']';
        __model__.modeldata.geom.selected.push(ent_arr);
        if (!__model__.modeldata.attribs.query.hasAttrib(ent_arr[0], attrib_name)) {
            __model__.modeldata.attribs.add.addAttrib(ent_arr[0], attrib_name, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_1__["EAttribDataTypeStrs"].STRING);
        }
        __model__.modeldata.attribs.add.setEntAttribVal(ent_arr[0], ent_arr[1], attrib_name, attrib_value);
    }
}
function _flatten(arrs) {
    const arr_flat = [];
    const arr_indices = [];
    let count = 0;
    for (const item of arrs) {
        if (Array.isArray(item)) {
            const [arr_flat2, arr_indices2] = _flatten(item);
            for (let i = 0; i < arr_flat2.length; i++) {
                if (arr_flat.indexOf(arr_flat2[i]) !== -1) {
                    continue;
                }
                arr_flat.push(arr_flat2[i]);
                arr_indices2[i].unshift(count);
                arr_indices.push(arr_indices2[i]);
            }
        }
        else {
            arr_flat.push(item);
            arr_indices.push([count]);
        }
        count += 1;
    }
    return [arr_flat, arr_indices];
}
//  ===============================================================================================
/**
 * Checks the model for internal consistency.
 * @param __model__
 */
function __checkModel__(__model__) {
    return __model__.check();
}
// Moved to attrib.ts
//  ===============================================================================================
/**
//  * Sets an attribute value in the model.
//  * @param __model__
//  */
// export function __setAttrib__(__model__: GIModel, entities: TId|TId[]|TId[][],
//                               attrib_name: string, attrib_values: TAttribDataTypes|TAttribDataTypes[], attrib_index?: number): void {
//     // @ts-ignore
//     if (entities !== null && getArrDepth(entities) === 2) { entities = __.flatten(entities); }
//     // --- Error Check ---
//     const fn_name = 'entities@' + attrib_name;
//     let ents_arr: TEntTypeIdx|TEntTypeIdx[] = null;
//     if (entities !== null && entities !== undefined) {
//         ents_arr = checkIDs(fn_name, 'entities', entities, [IDcheckObj.isID, IDcheckObj.isIDList], null) as TEntTypeIdx|TEntTypeIdx[];
//     }
//     checkAttribName(fn_name , attrib_name);
//     // --- Error Check ---
//     _setAttrib(__model__, ents_arr, attrib_name, attrib_values, attrib_index);
// }
// function _setAttrib(__model__: GIModel, ents_arr: TEntTypeIdx|TEntTypeIdx[],
//         attrib_name: string, attrib_values: TAttribDataTypes|TAttribDataTypes[], attrib_index?: number): void {
//     // check the ents_arr
//     if (ents_arr === null) {
//         _setModelAttrib(__model__, attrib_name, attrib_values as TAttribDataTypes, attrib_index);
//         return;
//     } else if (ents_arr.length === 0) {
//         return;
//     } else if (getArrDepth(ents_arr) === 1) {
//         ents_arr = [ents_arr] as TEntTypeIdx[];
//     }
//     ents_arr = ents_arr as TEntTypeIdx[];
//     // check attrib_values
//     // are we setting a list of ents to a list of values?
//     const attrib_values_depth: number = getArrDepth(attrib_values);
//     if (attrib_values_depth === 2) {
//         // attrib values is a list of lists
//         // we assume that we are trying to set a different value for each ent
//         // so we expect the list lengths to be equal
//         _setEachEntDifferentAttribValue(__model__, ents_arr, attrib_name, attrib_values as TAttribDataTypes[], attrib_index);
//         return;
//     } else if (attrib_values_depth === 1) {
//         // check if ents_arr.length equals attrib_values.length
//         // then check if the first ent already has an attrib with the specified name
//         // if both are true, then we assume we are trying to set each ent to each value
//         const attrib_values_arr: number[]|string[] = attrib_values as number[]|string[];
//         if (ents_arr.length === attrib_values_arr.length) {
//             const first_ent_type: number = ents_arr[0][0];
//             if (__model__.modeldata.attribs.query.hasAttrib(first_ent_type, attrib_name)) {
//                 _setEachEntDifferentAttribValue(__model__, ents_arr, attrib_name, attrib_values as TAttribDataTypes[], attrib_index);
//                 return;
//             }
//         }
//     }
//     // all ents get the same attribute value
//     _setEachEntSameAttribValue(__model__, ents_arr, attrib_name, attrib_values as TAttribDataTypes, attrib_index);
//     return;
// }
// function _setModelAttrib(__model__: GIModel, attrib_name: string, attrib_value: TAttribDataTypes, idx_or_key?: number): void {
//     if (typeof idx_or_key === 'number') {
//         __model__.modeldata.attribs.add.setModelAttribListIdxVal(attrib_name, idx_or_key, attrib_value);
//     } if (typeof idx_or_key === 'string') {
//         __model__.modeldata.attribs.add.setModelAttribDictKeyVal(attrib_name, idx_or_key, attrib_value);
//     } else {
//         __model__.modeldata.attribs.add.setModelAttribVal(attrib_name, attrib_value);
//     }
// }
// function _setEachEntDifferentAttribValue(__model__: GIModel, ents_arr: TEntTypeIdx[],
//         attrib_name: string, attrib_values: TAttribDataTypes[], attrib_index?: number): void {
//     if (ents_arr.length !== attrib_values.length) {
//         throw new Error(
//             'If multiple attributes are being set to multiple values, then the number of entities must match the number of values.');
//     }
//     const ent_type: number = ents_arr[0][0];
//     const ents_i: number[] = _getEntsIndices(__model__, ents_arr);
//     for (let i = 0; i < ents_arr.length; i++) {
//         // --- Error Check ---
//         const fn_name = 'entities@' + attrib_name;
//         checkAttribValue(fn_name , attrib_values[i], attrib_index);
//         // --- Error Check ---
//         if (attrib_index !== null && attrib_index !== undefined) {
//             __model__.modeldata.attribs.add.setAttribListIdxVal(ent_type, ents_i[i], attrib_name, attrib_index, attrib_values[i] as number|string);
//         } else {
//             __model__.modeldata.attribs.add.setAttribVal(ent_type, ents_i[i], attrib_name, attrib_values[i]);
//         }
//     }
// }
// function _setEachEntSameAttribValue(__model__: GIModel, ents_arr: TEntTypeIdx[],
//         attrib_name: string, attrib_value: TAttribDataTypes, attrib_index?: number): void {
//     // --- Error Check ---
//     const fn_name = 'entities@' + attrib_name;
//     checkAttribValue(fn_name , attrib_value, attrib_index);
//     // --- Error Check ---
//     const ent_type: number = ents_arr[0][0];
//     const ents_i: number[] = _getEntsIndices(__model__, ents_arr);
//     if (attrib_index !== null && attrib_index !== undefined) {
//         __model__.modeldata.attribs.add.setAttribListIdxVal(ent_type, ents_i, attrib_name, attrib_index, attrib_value as number|string);
//     } else {
//         __model__.modeldata.attribs.add.setAttribVal(ent_type, ents_i, attrib_name, attrib_value);
//     }
// }
// function _getEntsIndices(__model__: GIModel, ents_arr: TEntTypeIdx[]): number[] {
//     const ent_type: number = ents_arr[0][0];
//     const ents_i: number[] = [];
//     for (let i = 0; i < ents_arr.length; i++) {
//         if (ents_arr[i][0] !== ent_type) {
//             throw new Error('If an attribute is being set for multiple entities, then they must all be of the same type.');
//         }
//         ents_i.push(ents_arr[i][1]);
//     }
//     return ents_i;
// }
// //  ===============================================================================================
// /**
//  * Gets an attribute value from the model.
//  * @param __model__
//  */
// export function __getAttrib__(__model__: GIModel, entities: TId|TId[]|TId[][],
//         attrib_name: string, idx_or_key?: number|string): TAttribDataTypes|TAttribDataTypes[] {
//     // @ts-ignore
//     if (entities !== null && getArrDepth(entities) === 2) { entities = __.flatten(entities); }
//     // --- Error Check ---
//     const fn_name = 'Inline.__getAttrib__';
//     let ents_arr: TEntTypeIdx|TEntTypeIdx[] = null;
//     if (entities !== null && entities !== undefined) {
//         ents_arr = checkIDs(fn_name, 'entities', entities, [IDcheckObj.isID, IDcheckObj.isIDList], null) as TEntTypeIdx|TEntTypeIdx[];
//     }
//     checkCommTypes(fn_name, 'attrib_name', attrib_name, [TypeCheckObj.isString]);
//     if (idx_or_key !== null && idx_or_key !== undefined) {
//         checkCommTypes(fn_name, 'attrib_index', idx_or_key, [TypeCheckObj.isNumber, TypeCheckObj.isString]);
//     }
//     // --- Error Check ---
//     return _getAttrib(__model__, ents_arr, attrib_name, idx_or_key);
// }
// function _getAttrib(__model__: GIModel, ents_arr: TEntTypeIdx|TEntTypeIdx[],
//         attrib_name: string, idx_or_key?: number|string): TAttribDataTypes|TAttribDataTypes[] {
//     const has_idx_or_key: boolean = idx_or_key !== null && idx_or_key !== undefined;
//     if (ents_arr === null) {
//         if (has_idx_or_key && typeof idx_or_key === 'number') {
//             return __model__.modeldata.attribs.query.getModelAttribListIdxVal(attrib_name, idx_or_key);
//         } else if (has_idx_or_key && typeof idx_or_key === 'string') {
//             return __model__.modeldata.attribs.query.getModelAttribDictKeyVal(attrib_name, idx_or_key);
//         } else {
//             return __model__.modeldata.attribs.query.getModelAttribVal(attrib_name);
//         }
//     } else if (ents_arr.length === 0) {
//         return;
//     } else if (getArrDepth(ents_arr) === 1) {
//         const [ent_type, ent_i]: TEntTypeIdx = ents_arr as TEntTypeIdx;
//         if (attrib_name === 'id') {
//             if (has_idx_or_key) { throw new Error('The "id" attribute does have an index or key.'); }
//             return EEntTypeStr[ent_type] + ent_i as TAttribDataTypes;
//         } else if (has_idx_or_key && typeof idx_or_key === 'number') {
//             return __model__.modeldata.attribs.query.getAttribListIdxVal(ent_type, attrib_name, ent_i, idx_or_key);
//         } else if (has_idx_or_key && typeof idx_or_key === 'string') {
//             return __model__.modeldata.attribs.query.getAttribDictKeyVal(ent_type, attrib_name, ent_i, idx_or_key);
//         } else {
//             return __model__.modeldata.attribs.query.getAttribVal(ent_type, attrib_name, ent_i);
//         }
//     } else {
//         return (ents_arr as TEntTypeIdx[]).map( ent_arr =>
//             _getAttrib(__model__, ent_arr, attrib_name, idx_or_key) ) as TAttribDataTypes[];
//     }
// }


/***/ }),

/***/ "./src/assets/core/modules/_output.ts":
/*!********************************************!*\
  !*** ./src/assets/core/modules/_output.ts ***!
  \********************************************/
/*! exports provided: Return */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Return", function() { return Return; });
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};
/**
* Return certain value from the model for the flowchart's end node
 * @summary Return a specific value
 * @param {any[]} __model__  Model of the node.
 * @param {number} value  Index of the value to be returned.
 * @returns {any} Value
 */
function Return(__model__, value) {
    return value;
}


/***/ }),

/***/ "./src/assets/core/modules/basic/_common.ts":
/*!**************************************************!*\
  !*** ./src/assets/core/modules/basic/_common.ts ***!
  \**************************************************/
/*! exports provided: getOrigin, getRay, getPlane, getCentoridFromEnts, getCentroid, getCenterOfMass, getPlanesSeq, _copyGeom, _copyGeomPosis */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getOrigin", function() { return getOrigin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getRay", function() { return getRay; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPlane", function() { return getPlane; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCentoridFromEnts", function() { return getCentoridFromEnts; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCentroid", function() { return getCentroid; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCenterOfMass", function() { return getCenterOfMass; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPlanesSeq", function() { return getPlanesSeq; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_copyGeom", function() { return _copyGeom; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_copyGeomPosis", function() { return _copyGeomPosis; });
/* harmony import */ var _check_ids__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_check_ids */ "./src/assets/core/modules/_check_ids.ts");
/* harmony import */ var _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @libs/geo-info/common */ "./src/assets/libs/geo-info/common.ts");
/* harmony import */ var _assets_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @assets/libs/geo-info/id */ "./src/assets/libs/geo-info/id.ts");
/* harmony import */ var _assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @assets/libs/geom/vectors */ "./src/assets/libs/geom/vectors.ts");
/* harmony import */ var _assets_libs_geo_info_virtual__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @assets/libs/geo-info/virtual */ "./src/assets/libs/geo-info/virtual.ts");
/* harmony import */ var _assets_core_inline_ray__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @assets/core/inline/_ray */ "./src/assets/core/inline/_ray.ts");
/* harmony import */ var _assets_core_inline_plane__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @assets/core/inline/_plane */ "./src/assets/core/inline/_plane.ts");
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/**
 * Shared utility functions
 * ~
 * ~
 */
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};
/**
 *
 */








const EPS = 1e-8;
// ================================================================================================
function getOrigin(__model__, data, fn_name) {
    if (Object(_assets_libs_geo_info_virtual__WEBPACK_IMPORTED_MODULE_4__["isXYZ"])(data)) {
        return data;
    }
    if (Object(_assets_libs_geo_info_virtual__WEBPACK_IMPORTED_MODULE_4__["isRay"])(data)) {
        return data[0];
    }
    if (Object(_assets_libs_geo_info_virtual__WEBPACK_IMPORTED_MODULE_4__["isPlane"])(data)) {
        return data[0];
    }
    const ents = data;
    const origin = getCentoridFromEnts(__model__, ents, fn_name);
    return origin;
}
// ================================================================================================
function getRay(__model__, data, fn_name) {
    if (Object(_assets_libs_geo_info_virtual__WEBPACK_IMPORTED_MODULE_4__["isXYZ"])(data)) {
        return [data, [0, 0, 1]];
    }
    if (Object(_assets_libs_geo_info_virtual__WEBPACK_IMPORTED_MODULE_4__["isRay"])(data)) {
        return data;
    }
    if (Object(_assets_libs_geo_info_virtual__WEBPACK_IMPORTED_MODULE_4__["isPlane"])(data)) {
        return Object(_assets_core_inline_ray__WEBPACK_IMPORTED_MODULE_5__["rayFromPln"])(data);
    }
    const ents = data;
    const origin = getCentoridFromEnts(__model__, ents, fn_name);
    return [origin, [0, 0, 1]];
}
// ================================================================================================
function getPlane(__model__, data, fn_name) {
    if (Object(_assets_libs_geo_info_virtual__WEBPACK_IMPORTED_MODULE_4__["isXYZ"])(data)) {
        return [data, [1, 0, 0], [0, 1, 0]];
    }
    if (Object(_assets_libs_geo_info_virtual__WEBPACK_IMPORTED_MODULE_4__["isRay"])(data)) {
        return Object(_assets_core_inline_plane__WEBPACK_IMPORTED_MODULE_6__["plnFromRay"])(data);
    }
    if (Object(_assets_libs_geo_info_virtual__WEBPACK_IMPORTED_MODULE_4__["isPlane"])(data)) {
        return data;
    }
    const ents = data;
    const origin = getCentoridFromEnts(__model__, ents, fn_name);
    return [origin, [1, 0, 0], [0, 1, 0]];
}
// ================================================================================================
function getCentoridFromEnts(__model__, ents, fn_name) {
    // this must be an ID or an array of IDs, so lets get the centroid
    // TODO this error message is confusing
    const ents_arr = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])(fn_name, 'ents', ents, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isId, _check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL], [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_1__["EEntType"].POSI, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_1__["EEntType"].VERT, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_1__["EEntType"].POINT, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_1__["EEntType"].EDGE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_1__["EEntType"].WIRE,
        _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_1__["EEntType"].PLINE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_1__["EEntType"].FACE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_1__["EEntType"].PGON, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_1__["EEntType"].COLL]);
    const centroid = getCentroid(__model__, ents_arr);
    if (Array.isArray(centroid[0])) {
        return Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_3__["vecAvg"])(centroid);
    }
    return centroid;
}
// ================================================================================================
function getCentroid(__model__, ents_arr) {
    if (Object(_assets_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_2__["getArrDepth"])(ents_arr) === 1) {
        const [ent_type, index] = ents_arr;
        const posis_i = __model__.modeldata.geom.nav.navAnyToPosi(ent_type, index);
        return _centroidPosis(__model__, posis_i);
    }
    else {
        // divide the input into posis and non posis
        ents_arr = ents_arr;
        const posis_i = [];
        const np_ents_arr = [];
        for (const ent_arr of ents_arr) {
            if (ent_arr[0] === _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_1__["EEntType"].POSI) {
                posis_i.push(ent_arr[1]);
            }
            else {
                np_ents_arr.push(ent_arr);
            }
        }
        // if we only have posis, just return one centorid
        // in all other cases return a list of centroids
        const np_cents = np_ents_arr.map(ent_arr => getCentroid(__model__, ent_arr));
        if (posis_i.length > 0) {
            const cen_posis = _centroidPosis(__model__, posis_i);
            if (np_cents.length === 0) {
                return cen_posis;
            }
            else {
                np_cents.push(cen_posis);
            }
        }
        return np_cents;
    }
}
function _centroidPosis(__model__, posis_i) {
    const unique_posis_i = Array.from(new Set(posis_i));
    const unique_xyzs = unique_posis_i.map(posi_i => __model__.modeldata.attribs.query.getPosiCoords(posi_i));
    return Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_3__["vecDiv"])(Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_3__["vecSum"])(unique_xyzs), unique_xyzs.length);
}
// ================================================================================================
function getCenterOfMass(__model__, ents_arr) {
    if (Object(_assets_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_2__["getArrDepth"])(ents_arr) === 1) {
        const [ent_type, ent_i] = ents_arr;
        const faces_i = __model__.modeldata.geom.nav.navAnyToFace(ent_type, ent_i);
        if (faces_i.length === 0) {
            return null;
        }
        return _centerOfMass(__model__, faces_i);
    }
    else {
        const cents = [];
        ents_arr = ents_arr;
        for (const [ent_type, ent_i] of ents_arr) {
            const faces_i = __model__.modeldata.geom.nav.navAnyToFace(ent_type, ent_i);
            if (faces_i.length === 0) {
                cents.push(null);
            }
            cents.push(_centerOfMass(__model__, faces_i));
        }
        return cents;
    }
}
function _centerOfMass(__model__, faces_i) {
    const face_midpoints = [];
    const face_areas = [];
    let total_area = 0;
    for (const face_i of faces_i) {
        const [midpoint_xyz, area] = _centerOfMassOfFace(__model__, face_i);
        face_midpoints.push(midpoint_xyz);
        face_areas.push(area);
        total_area += area;
    }
    const cent = [0, 0, 0];
    for (let i = 0; i < face_midpoints.length; i++) {
        const weight = face_areas[i] / total_area;
        cent[0] = cent[0] + face_midpoints[i][0] * weight;
        cent[1] = cent[1] + face_midpoints[i][1] * weight;
        cent[2] = cent[2] + face_midpoints[i][2] * weight;
    }
    return cent;
}
function _centerOfMassOfFace(__model__, face_i) {
    const tri_midpoints = [];
    const tri_areas = [];
    let total_area = 0;
    const map_posi_to_v3 = new Map();
    for (const tri_i of __model__.modeldata.geom.nav.navFaceToTri(face_i)) {
        const posis_i = __model__.modeldata.geom.nav.navAnyToPosi(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_1__["EEntType"].TRI, tri_i);
        const posis_v3 = [];
        for (const posi_i of posis_i) {
            let posi_v3 = map_posi_to_v3.get(posi_i);
            if (posi_v3 === undefined) {
                const xyz = __model__.modeldata.attribs.query.getPosiCoords(posi_i);
                posi_v3 = new three__WEBPACK_IMPORTED_MODULE_7__["Vector3"](xyz[0], xyz[1], xyz[2]);
            }
            posis_v3.push(posi_v3);
        }
        const tri_tjs = new three__WEBPACK_IMPORTED_MODULE_7__["Triangle"](posis_v3[0], posis_v3[1], posis_v3[2]);
        let midpoint;
        midpoint = tri_tjs.getMidpoint(midpoint);
        const midpoint_xyz = [midpoint.x, midpoint.y, midpoint.z];
        const area = tri_tjs.getArea();
        tri_midpoints.push(midpoint_xyz);
        tri_areas.push(area);
        total_area += area;
    }
    const cent = [0, 0, 0];
    for (let i = 0; i < tri_midpoints.length; i++) {
        const weight = tri_areas[i] / total_area;
        cent[0] = cent[0] + tri_midpoints[i][0] * weight;
        cent[1] = cent[1] + tri_midpoints[i][1] * weight;
        cent[2] = cent[2] + tri_midpoints[i][2] * weight;
    }
    return [cent, total_area];
}
// ================================================================================================
// used by sweep
// TODO update offset code to use this as well
/* Function to get a set of planes along the length of a wire.
 * The planes are orientated perpendicular to the wire.
 *
 */
function getPlanesSeq(xyzs, normal, close) {
    normal = Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_3__["vecNorm"])(normal);
    // if closed, add a posi to the end
    if (close) {
        xyzs.splice(0, 0, xyzs[xyzs.length - 1]);
        xyzs.push(xyzs[1]);
    }
    // get the perp vectors
    let perp_vec = null;
    let has_bad_edges = false;
    const perp_vecs = []; // normalise dvectors
    for (let i = 0; i < xyzs.length - 1; i++) {
        const xyz0 = xyzs[i];
        const xyz1 = xyzs[i + 1];
        const edge_vec = Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_3__["vecFromTo"])(xyz0, xyz1);
        if (Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_3__["vecLen"])(edge_vec) > 0) {
            perp_vec = Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_3__["vecCross"])(Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_3__["vecNorm"])(edge_vec), normal);
        }
        else {
            perp_vec = null;
            has_bad_edges = true;
        }
        perp_vecs.push(perp_vec);
    }
    // fix any bad pairs, by setting the perp vec to its next neighbour
    if (has_bad_edges) {
        if (perp_vecs[perp_vecs.length - 1] === null) {
            throw new Error('Error: could not process wire.');
        }
        for (let i = perp_vecs.length - 1; i >= 0; i--) {
            if (perp_vecs[i] === null) {
                perp_vecs[i] = perp_vec;
            }
            else {
                perp_vec = perp_vecs[i];
            }
        }
    }
    // array for planes
    const planes = [];
    // if not closed, we need to deal with the first and last planes
    if (!close) {
        // first plane
        const first_xyz = xyzs[0];
        const x_axis = perp_vecs[0];
        const first2_perp_vec = perp_vecs[1];
        let y_axis = normal;
        if (Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_3__["vecDot"])(x_axis, first2_perp_vec) < EPS) { // TODOD < what is a good value for this?
            y_axis = Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_3__["vecCross"])(x_axis, first2_perp_vec);
        }
        const first_plane = [first_xyz, x_axis, y_axis];
        planes.push(first_plane);
    }
    // loop through all the edges and create a plane at the end of the edge
    for (let i = 0; i < perp_vecs.length - 1; i++) {
        // get the xyz
        const xyz = xyzs[i + 1];
        // get the two perpendicular vectors
        const this_perp_vec = perp_vecs[i];
        const next_perp_vec = perp_vecs[i + 1];
        // calc the local norm
        let y_axis = normal;
        if (Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_3__["vecDot"])(this_perp_vec, next_perp_vec) < EPS) { // TODOD < what is a good value for this?
            y_axis = Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_3__["vecCross"])(this_perp_vec, next_perp_vec);
        }
        // calc the offset vector
        let x_axis = Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_3__["vecNorm"])(Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_3__["vecAdd"])(this_perp_vec, next_perp_vec));
        const dot = Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_3__["vecDot"])(this_perp_vec, x_axis);
        const vec_len = 1 / dot;
        x_axis = Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_3__["vecSetLen"])(x_axis, vec_len);
        // create the plane
        const plane = [xyz, x_axis, y_axis];
        planes.push(plane);
    }
    // if not closed, we need to deal with the first and last planes
    if (!close) {
        // last plane
        const last_xyz = xyzs[xyzs.length - 1];
        const x_axis = perp_vecs[perp_vecs.length - 1];
        const last2_perp_vec = perp_vecs[perp_vecs.length - 2];
        let y_axis = normal;
        if (Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_3__["vecDot"])(last2_perp_vec, x_axis) < EPS) { // TODOD < what is a good value for this?
            y_axis = Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_3__["vecCross"])(last2_perp_vec, x_axis);
        }
        const last_plane = [last_xyz, x_axis, y_axis];
        planes.push(last_plane);
    }
    // return the planes
    return planes;
}
// ================================================================================================
// ================================================================================================
// Utility functions used in make.Copy() and in poly2d.Stitch()
/**
 * Copy posis, points, plines, pgons
 * @param __model__
 * @param ents_arr
 * @param copy_attributes
 */
function _copyGeom(__model__, ents_arr, copy_attributes) {
    const depth = Object(_assets_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_2__["getArrDepth"])(ents_arr);
    if (depth === 1) {
        const [ent_type, index] = ents_arr;
        if (Object(_assets_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_2__["isColl"])(ent_type)) {
            const coll_i = __model__.modeldata.geom.add.copyColls(index, copy_attributes);
            return [ent_type, coll_i];
        }
        else if (Object(_assets_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_2__["isPgon"])(ent_type)) {
            const obj_i = __model__.modeldata.geom.add.copyPgons(index, copy_attributes);
            return [ent_type, obj_i];
        }
        else if (Object(_assets_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_2__["isPline"])(ent_type)) {
            const obj_i = __model__.modeldata.geom.add.copyPlines(index, copy_attributes);
            return [ent_type, obj_i];
        }
        else if (Object(_assets_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_2__["isPoint"])(ent_type)) {
            const obj_i = __model__.modeldata.geom.add.copyPoints(index, copy_attributes);
            return [ent_type, obj_i];
        }
        else if (Object(_assets_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_2__["isPosi"])(ent_type)) {
            const posi_i = __model__.modeldata.geom.add.copyPosis(index, copy_attributes);
            return [ent_type, posi_i];
        }
    }
    else if (depth === 2) {
        ents_arr = ents_arr;
        return ents_arr.map(ents_arr_item => _copyGeom(__model__, ents_arr_item, copy_attributes));
    }
    else { // depth > 2
        ents_arr = ents_arr;
        return ents_arr.map(ents_arr_item => _copyGeom(__model__, ents_arr_item, copy_attributes));
    }
}
function _copyGeomPosis(__model__, ents_arr, copy_attributes, vector) {
    const depth = Object(_assets_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_2__["getArrDepth"])(ents_arr);
    if (depth === 1) {
        ents_arr = [ents_arr];
    }
    else if (depth > 2) {
        // @ts-ignore
        ents_arr = ents_arr.flat(depth - 2);
    }
    // create the new positions
    const old_to_new_posis_i_map = new Map(); // count number of posis
    for (const ent_arr of ents_arr) {
        const [ent_type, index] = ent_arr;
        // something may not be right here
        // if you copy a pgon + posi, if you process the pgon first you wil make a copy of the posis
        // but the posi may already be copied by the _copyGeom function, then we get two copies of that posi
        // I think this whole copy-move function need to to be moved to the GI library, can also make it more efficient
        if (Object(_assets_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_2__["isPosi"])(ent_type) && vector !== null) { // positions
            const old_posi_i = index;
            let new_posi_i;
            if (old_to_new_posis_i_map.has(old_posi_i)) {
                new_posi_i = old_to_new_posis_i_map.get(old_posi_i);
            }
            else {
                const xyz = __model__.modeldata.attribs.query.getPosiCoords(old_posi_i);
                __model__.modeldata.attribs.add.setPosiCoords(old_posi_i, Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_3__["vecAdd"])(xyz, vector));
                old_to_new_posis_i_map.set(old_posi_i, new_posi_i);
            }
        }
        else { // obj or coll
            const old_posis_i = __model__.modeldata.geom.nav.navAnyToPosi(ent_type, index);
            const ent_new_posis_i = [];
            for (const old_posi_i of old_posis_i) {
                let new_posi_i;
                if (old_to_new_posis_i_map.has(old_posi_i)) {
                    new_posi_i = old_to_new_posis_i_map.get(old_posi_i);
                }
                else {
                    new_posi_i = __model__.modeldata.geom.add.copyMovePosis(old_posi_i, vector, copy_attributes);
                    old_to_new_posis_i_map.set(old_posi_i, new_posi_i);
                }
                ent_new_posis_i.push(new_posi_i);
            }
            __model__.modeldata.geom.modify.replacePosis(ent_type, index, ent_new_posis_i);
        }
    }
    // return all the new points
    // const all_new_posis_i: number[] = Array.from(old_to_new_posis_i_map.values());
    // return all_new_posis_i.map( posi_i => [EEntType.POSI, posi_i] ) as TEntTypeIdx[];
}


/***/ }),

/***/ "./src/assets/core/modules/basic/analyze.ts":
/*!**************************************************!*\
  !*** ./src/assets/core/modules/basic/analyze.ts ***!
  \**************************************************/
/*! exports provided: _ERaytraceMethod, Raytrace, Isovist, _ESkyMethod, Sky, _ESolarMethod, Sun, _ESunPathMethod, SkyDome, Nearest, _EShortestPathMethod, _EShortestPathResult, ShortestPath, ClosestPath, _ECentralityMethod, Degree, _ECentralityType, Centrality */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_ERaytraceMethod", function() { return _ERaytraceMethod; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Raytrace", function() { return Raytrace; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Isovist", function() { return Isovist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_ESkyMethod", function() { return _ESkyMethod; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Sky", function() { return Sky; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_ESolarMethod", function() { return _ESolarMethod; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Sun", function() { return Sun; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_ESunPathMethod", function() { return _ESunPathMethod; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SkyDome", function() { return SkyDome; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Nearest", function() { return Nearest; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_EShortestPathMethod", function() { return _EShortestPathMethod; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_EShortestPathResult", function() { return _EShortestPathResult; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShortestPath", function() { return ShortestPath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ClosestPath", function() { return ClosestPath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_ECentralityMethod", function() { return _ECentralityMethod; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Degree", function() { return Degree; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_ECentralityType", function() { return _ECentralityType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Centrality", function() { return Centrality; });
/* harmony import */ var _check_ids__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_check_ids */ "./src/assets/core/modules/_check_ids.ts");
/* harmony import */ var _check_args__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_check_args */ "./src/assets/core/modules/_check_args.ts");
/* harmony import */ var _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @libs/geo-info/common */ "./src/assets/libs/geo-info/common.ts");
/* harmony import */ var _libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @libs/geo-info/id */ "./src/assets/libs/geo-info/id.ts");
/* harmony import */ var _libs_geom_distance__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @libs/geom/distance */ "./src/assets/libs/geom/distance.ts");
/* harmony import */ var _libs_geom_vectors__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @libs/geom/vectors */ "./src/assets/libs/geom/vectors.ts");
/* harmony import */ var underscore__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! underscore */ "./node_modules/underscore/modules/index-all.js");
/* harmony import */ var _assets_core_inline_math__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @assets/core/inline/_math */ "./src/assets/core/inline/_math.ts");
/* harmony import */ var _assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @assets/libs/util/arrs */ "./src/assets/libs/util/arrs.ts");
/* harmony import */ var _assets_core_inline_conversion__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @assets/core/inline/_conversion */ "./src/assets/core/inline/_conversion.ts");
/* harmony import */ var _libs_geom_matrix__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @libs/geom/matrix */ "./src/assets/libs/geom/matrix.ts");
/* harmony import */ var _assets_libs_geom_constants__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @assets/libs/geom/constants */ "./src/assets/libs/geom/constants.ts");
/* harmony import */ var cytoscape__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! cytoscape */ "./node_modules/cytoscape/dist/cytoscape.cjs.js");
/* harmony import */ var cytoscape__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(cytoscape__WEBPACK_IMPORTED_MODULE_12__);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/* harmony import */ var _libs_TypedArrayUtils_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @libs/TypedArrayUtils.js */ "./src/assets/libs/TypedArrayUtils.js");
/* harmony import */ var mathjs__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! mathjs */ "./node_modules/mathjs/index.js");
/* harmony import */ var mathjs__WEBPACK_IMPORTED_MODULE_15___default = /*#__PURE__*/__webpack_require__.n(mathjs__WEBPACK_IMPORTED_MODULE_15__);
/* harmony import */ var _assets_libs_geom_mesh__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @assets/libs/geom/mesh */ "./src/assets/libs/geom/mesh.ts");
/* harmony import */ var _assets_libs_geo_info_virtual__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @assets/libs/geo-info/virtual */ "./src/assets/libs/geo-info/virtual.ts");
/**
 * The `analysis` module has functions for performing various types of analysis with entities in the model.
 * These functions all return dictionaries containing the results of the analysis.
 */
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};
/**
 *
 */


















var _ERaytraceMethod;
(function (_ERaytraceMethod) {
    _ERaytraceMethod["STATS"] = "stats";
    _ERaytraceMethod["DISTANCES"] = "distances";
    _ERaytraceMethod["HIT_PGONS"] = "hit_pgons";
    _ERaytraceMethod["INTERSECTIONS"] = "intersections";
    _ERaytraceMethod["ALL"] = "all";
})(_ERaytraceMethod || (_ERaytraceMethod = {}));
/**
 * Shoot a set of rays into a set of obstructions, consisting of polygon faces.
 * One can imagine particles being shot from the ray origin in the ray direction, hitting the obstructions.
 * ~
 * Each ray will either hit an obstruction, or will hit no obstructions.
 * The length of the ray vector is ignored, only the ray origin and direction is taken into account.
 * Each particle shot out from a ray will travel a certain distance.
 * The minimum and maximum distance that the particle will travel is defined by the 'dist' argument.
 * ~
 * If a ray particle hits an obstruction, then the 'distance' for that ray is the distance from the ray origin
 * to the point of intersection.
 * If the ray particle does not hit an obstruction, then the 'distance' for that ray is equal to
 * the max for the 'dist' argument.
 * ~
 * Returns a dictionary containing the following data.
 * ~
 * If 'stats' is selected, the dictionary will contain the following numbers:
 * 1) 'hit_count': the total number of rays that hit an obstruction.
 * 2) 'miss_count': the total number of rays that did not hit any obstruction.
 * 3) 'total_dist': the total of all the ray distances.
 * 4) 'min_dist': the minimum distance for all the rays.
 * 5) 'max_dist': the maximum distance for all the rays.
 * 6) 'avg_dist': the average dist for all the rays.
 * 7) 'dist_ratio': the ratio of 'total_dist' to the maximum distance if not rays hit any obstructions.
  * ~
 * If 'distances' is selected, the dictionary will contain the following list:
 * 1) 'distances': A list of numbers, the distance travelled for each ray.
   * ~
 * If 'hit_pgons' is selected, the dictionary will contain the following list:
 * 1) 'hit_pgons': A list of polygon IDs, the polygons hit for each ray, or 'null' if no polygon was hit.
 * ~
 * If 'intersections' is selected, the dictionary will contain the following list:
 * 1) 'intersections': A list of XYZ coords, the point of intersection where the ray hit a polygon,
 * or 'null' if no polygon was hit.
 * ~
 * If 'all' is selected, the dictionary will contain all of the above.
 * ~
 * If the input is a list of rays, the output will be a single dictionary.
 * If the list is empty (i.e. contains no rays), then 'null' is returned.
 * If the input is a list of lists of rays, then the output will be a list of dictionaries.
 * ~
 * @param __model__
 * @param rays A ray, a list of rays, or a list of lists of rays.
 * @param entities The obstructions, faces, polygons, or collections of faces or polygons.
 * @param dist The ray limits, one or two numbers. Either max, or [min, max].
 * @param method Enum; values to return.
 */
function Raytrace(__model__, rays, entities, dist, method) {
    entities = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_8__["arrMakeFlat"])(entities);
    // --- Error Check ---
    const fn_name = 'analyze.Raytrace';
    let ents_arrs;
    if (__model__.debug) {
        Object(_check_args__WEBPACK_IMPORTED_MODULE_1__["checkArgs"])(fn_name, 'rays', rays, [_check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isRay, _check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isRayL, _check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isRayLL]);
        ents_arrs = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])(fn_name, 'entities', entities, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isId, _check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL], [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].FACE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].COLL]);
        Object(_check_args__WEBPACK_IMPORTED_MODULE_1__["checkArgs"])(fn_name, 'dist', dist, [_check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isNum, _check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isNumL]);
        if (Array.isArray(dist)) {
            if (dist.length !== 2) {
                throw new Error('If "dist" is a list, it must have a length of two: [min_dist, max_dist].');
            }
            if (dist[0] >= dist[1]) {
                throw new Error('If "dist" is a list, the "min_dist" must be less than the "max_dist": [min_dist, max_dist].');
            }
        }
    }
    else {
        // ents_arrs = splitIDs(fn_name, 'entities', entities,
        // [IDcheckObj.isID, IDcheckObj.isIDList],
        // [EEntType.FACE, EEntType.PGON, EEntType.COLL]) as TEntTypeIdx[];
        ents_arrs = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsBreak"])(entities);
    }
    // --- Error Check ---
    const mesh = Object(_assets_libs_geom_mesh__WEBPACK_IMPORTED_MODULE_16__["createSingleMeshTjs"])(__model__, ents_arrs);
    dist = Array.isArray(dist) ? dist : [0, dist];
    const result = _raytraceAll(__model__, rays, mesh, dist, method);
    // cleanup
    mesh[0].geometry.dispose();
    mesh[0].material.dispose();
    // return the results
    return result;
}
function _raytraceAll(__model__, rays, mesh, limits, method) {
    const depth = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_8__["getArrDepth2"])(rays);
    if (depth < 2) { // an empty list
        return null;
    }
    else if (depth === 2) { // just one ray
        return _raytraceAll(__model__, [rays], mesh, limits, method);
    }
    else if (depth === 3) { // a list of rays
        const [origins_tjs, dirs_tjs] = _raytraceOriginsDirsTjs(__model__, rays);
        return _raytrace(origins_tjs, dirs_tjs, mesh, limits, method);
    }
    else if (depth === 4) { // a nested list of rays
        return rays.map(a_rays => _raytraceAll(__model__, a_rays, mesh, limits, method));
    }
}
function _raytraceOriginsDirsTjs(__model__, rays) {
    const origins_tjs = [];
    const dirs_tjs = [];
    for (const ray of rays) {
        origins_tjs.push(new three__WEBPACK_IMPORTED_MODULE_13__["Vector3"](ray[0][0], ray[0][1], ray[0][2]));
        const dir = Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_5__["vecNorm"])(ray[1]);
        dirs_tjs.push(new three__WEBPACK_IMPORTED_MODULE_13__["Vector3"](dir[0], dir[1], dir[2]));
    }
    return [origins_tjs, dirs_tjs];
}
function _raytrace(origins_tjs, dirs_tjs, mesh, limits, method) {
    const result = {};
    let hit_count = 0;
    let miss_count = 0;
    const result_dists = [];
    const result_ents = [];
    const result_isects = [];
    for (let i = 0; i < origins_tjs.length; i++) {
        // get the origin and direction
        const origin_tjs = origins_tjs[i];
        const dir_tjs = dirs_tjs[i];
        // shoot
        const ray_tjs = new three__WEBPACK_IMPORTED_MODULE_13__["Raycaster"](origin_tjs, dir_tjs, limits[0], limits[1]);
        const isects = ray_tjs.intersectObject(mesh[0], false);
        // get the result
        if (isects.length === 0) {
            result_dists.push(limits[1]);
            miss_count += 1;
            if (method === _ERaytraceMethod.ALL || method === _ERaytraceMethod.HIT_PGONS) {
                result_ents.push(null);
            }
            if (method === _ERaytraceMethod.ALL || method === _ERaytraceMethod.INTERSECTIONS) {
                const origin = origin_tjs.toArray();
                const dir = dir_tjs.toArray();
                result_isects.push(Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_5__["vecAdd"])(origin, Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_5__["vecSetLen"])(dir, limits[1])));
            }
        }
        else {
            result_dists.push(isects[0]['distance']);
            hit_count += 1;
            if (method === _ERaytraceMethod.ALL || method === _ERaytraceMethod.HIT_PGONS) {
                const face_i = mesh[1][isects[0].faceIndex];
                result_ents.push(Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsMake"])([_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON, face_i]));
            }
            if (method === _ERaytraceMethod.ALL || method === _ERaytraceMethod.INTERSECTIONS) {
                const isect_tjs = isects[0].point;
                result_isects.push([isect_tjs.x, isect_tjs.y, isect_tjs.z]);
            }
        }
    }
    if ((method === _ERaytraceMethod.ALL || method === _ERaytraceMethod.STATS) && result_dists.length > 0) {
        result.hit_count = hit_count;
        result.miss_count = miss_count;
        result.total_dist = mathjs__WEBPACK_IMPORTED_MODULE_15__["sum"](result_dists);
        result.min_dist = Object(_assets_core_inline_math__WEBPACK_IMPORTED_MODULE_7__["min"])(result_dists);
        result.avg_dist = result.total_dist / result_dists.length;
        result.max_dist = Object(_assets_core_inline_math__WEBPACK_IMPORTED_MODULE_7__["max"])(result_dists);
        result.dist_ratio = result.total_dist / (result_dists.length * limits[1]);
    }
    if (method === _ERaytraceMethod.ALL || method === _ERaytraceMethod.DISTANCES) {
        result.distances = result_dists;
    }
    if (method === _ERaytraceMethod.ALL || method === _ERaytraceMethod.HIT_PGONS) {
        result.hit_pgons = result_ents;
    }
    if (method === _ERaytraceMethod.ALL || method === _ERaytraceMethod.INTERSECTIONS) {
        result.intersections = result_isects;
    }
    return result;
}
/**
 * Calculates an approximation of the isovist for a set of origins, defined by XYZ coords.
 * ~
 * The isovist is calculated by shooting rays out from the origins in a radial pattern.
 * The 'radius' argument defines the maximum radius of the isovist.
 * (The radius is used to define the maximum distance for shooting the rays.)
 * The 'num_rays' argument defines the number of rays that will be shot,
 * in a radial pattern parallel to the XY plane, with equal angle between rays.
 * More rays will result in more accurate result, but will also be slower to execute.
 * ~
 * Returns a dictionary containing different isovist metrics.
 * ~
 * 1) 'avg_dist': The average distance from origin to the perimeter.
 * 2) 'min_dist': The minimum distance from the origin to the perimeter.
 * 3) 'max_dist': The minimum distance from the origin to the perimeter.
 * 4) 'area': The area of the isovist.
 * 5) 'perimeter': The perimeter of the isovist.
 * 4) 'area_ratio': The ratio of the area of the isovist to the maximum area.
 * 5) 'perimeter_ratio': The ratio of the perimeter of the isovist to the maximum perimeter.
 * 6) 'circularity': The ratio of the square of the perimeter to area (Davis and Benedikt, 1979).
 * 7) 'compactness': The ratio of average distance to the maximum distance (Michael Batty, 2001).
 * 8) 'cluster': The ratio of the radius of an idealized circle with the actual area of the
 * isovist to the radius of an idealized circle with the actual perimeter of the circle (Michael Batty, 2001).
 * ~
 * ~
 * @param __model__
 * @param origins A list of Rays or a list of Planes, to be used as the origins for calculating the isovists.
 * @param entities The obstructions: faces, polygons, or collections.
 * @param radius The maximum radius of the isovist.
 * @param num_rays The number of rays to generate when calculating isovists.
 */
function Isovist(__model__, origins, entities, radius, num_rays) {
    entities = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_8__["arrMakeFlat"])(entities);
    // --- Error Check ---
    const fn_name = 'analyze.Isovist';
    // let origin_ents_arrs: TEntTypeIdx[];
    let ents_arrs;
    if (__model__.debug) {
        Object(_check_args__WEBPACK_IMPORTED_MODULE_1__["checkArgs"])(fn_name, 'origins', origins, [_check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isRayL, _check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isPlnL]);
        ents_arrs = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])(fn_name, 'entities', entities, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL], [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].FACE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].COLL]);
        Object(_check_args__WEBPACK_IMPORTED_MODULE_1__["checkArgs"])(fn_name, 'dist', radius, [_check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isNum, _check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isNumL]);
        if (Array.isArray(radius)) {
            if (radius.length !== 2) {
                throw new Error('If "dist" is a list, it must have a length of two: [min_dist, max_dist].');
            }
            if (radius[0] >= radius[1]) {
                throw new Error('If "dist" is a list, the "min_dist" must be less than the "max_dist": [min_dist, max_dist].');
            }
        }
    }
    else {
        // origin_ents_arrs = idsBreak(origins) as TEntTypeIdx[];
        ents_arrs = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsBreak"])(entities);
    }
    // --- Error Check ---
    // create tjs origins for xyz, ray, or plane
    const origins_tjs = _isovistOriginsTjs(__model__, origins, 0.1); // TODO Should we lift coords by 0.1 ???
    // create tjs directions
    const dirs_xyzs = [];
    const dirs_tjs = [];
    const vec = [1, 0, 0];
    for (let i = 0; i < num_rays; i++) {
        const dir_xyz = Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_5__["vecRot"])(vec, [0, 0, 1], i * (Math.PI * 2) / num_rays);
        dirs_xyzs.push(Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_5__["vecSetLen"])(dir_xyz, radius));
        const dir_tjs = new three__WEBPACK_IMPORTED_MODULE_13__["Vector3"](dir_xyz[0], dir_xyz[1], dir_xyz[2]);
        dirs_tjs.push(dir_tjs);
    }
    // calc max perim and area
    const ang = (2 * Math.PI) / num_rays;
    const opp = radius * Math.sin(ang / 2);
    const max_perim = num_rays * 2 * opp;
    const max_area = num_rays * radius * Math.cos(ang / 2) * opp;
    // create mesh
    const mesh = Object(_assets_libs_geom_mesh__WEBPACK_IMPORTED_MODULE_16__["createSingleMeshTjs"])(__model__, ents_arrs);
    // create data structure
    const result = {};
    result.avg_dist = [];
    result.min_dist = [];
    result.max_dist = [];
    result.area = [];
    result.perimeter = [];
    result.circularity = [];
    result.area_ratio = [];
    result.perimeter_ratio = [];
    result.compactness = [];
    result.cluster = [];
    // shoot rays
    for (let i = 0; i < origins_tjs.length; i++) {
        const origin_tjs = origins_tjs[i];
        const result_dists = [];
        const result_isects = [];
        for (let j = 0; j < dirs_tjs.length; j++) {
            const dir_tjs = dirs_tjs[j];
            const ray_tjs = new three__WEBPACK_IMPORTED_MODULE_13__["Raycaster"](origin_tjs, dir_tjs, 0, radius);
            const isects = ray_tjs.intersectObject(mesh[0], false);
            // get the result
            if (isects.length === 0) {
                result_dists.push(radius);
                result_isects.push(Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_5__["vecAdd"])([origin_tjs.x, origin_tjs.y, origin_tjs.z], dirs_xyzs[j]));
            }
            else {
                result_dists.push(isects[0]['distance']);
                const isect_tjs = isects[0].point;
                result_isects.push([isect_tjs.x, isect_tjs.y, isect_tjs.z]);
            }
        }
        // calc the perimeter and area
        let perim = 0;
        let area = 0;
        for (let j = 0; j < num_rays; j++) {
            const j2 = j === num_rays - 1 ? 0 : j + 1;
            // calc perim
            const c = Object(_libs_geom_distance__WEBPACK_IMPORTED_MODULE_4__["distance"])(result_isects[j], result_isects[j2]);
            perim += c;
            // calc area
            area += _isovistTriArea(result_dists[j], result_dists[j2], c);
        }
        const total_dist = mathjs__WEBPACK_IMPORTED_MODULE_15__["sum"](result_dists);
        const avg_dist = total_dist / result_dists.length;
        const min_dist = Object(_assets_core_inline_math__WEBPACK_IMPORTED_MODULE_7__["min"])(result_dists);
        const max_dist = Object(_assets_core_inline_math__WEBPACK_IMPORTED_MODULE_7__["max"])(result_dists);
        // save the data
        result.avg_dist.push(avg_dist);
        result.min_dist.push(min_dist);
        result.max_dist.push(max_dist);
        result.area.push(area);
        result.perimeter.push(perim);
        result.area_ratio.push(area / max_area);
        result.perimeter_ratio.push(perim / max_perim);
        result.circularity.push((perim * perim) / area);
        result.compactness.push(avg_dist / max_dist);
        result.cluster.push(Math.sqrt(area / Math.PI) / (perim / (2 * Math.PI)));
    }
    // cleanup
    mesh[0].geometry.dispose();
    mesh[0].material.dispose();
    // return the results
    return result;
}
function _isovistOriginsTjs(__model__, origins, offset) {
    const vectors_tjs = [];
    const is_xyz = Object(_assets_libs_geo_info_virtual__WEBPACK_IMPORTED_MODULE_17__["isXYZ"])(origins[0]);
    const is_ray = Object(_assets_libs_geo_info_virtual__WEBPACK_IMPORTED_MODULE_17__["isRay"])(origins[0]);
    const is_pln = Object(_assets_libs_geo_info_virtual__WEBPACK_IMPORTED_MODULE_17__["isPlane"])(origins[0]);
    for (const origin of origins) {
        let origin_xyz = null;
        if (is_xyz) {
            origin_xyz = origin;
        }
        else if (is_ray) {
            origin_xyz = origin[0];
        }
        else if (is_pln) {
            origin_xyz = origin[0];
        }
        else {
            throw new Error('analyze.Solar: origins arg has invalid values');
        }
        const origin_tjs = new three__WEBPACK_IMPORTED_MODULE_13__["Vector3"](origin_xyz[0], origin_xyz[1], origin_xyz[2] + offset);
        vectors_tjs.push(origin_tjs);
    }
    return vectors_tjs;
}
function _isovistTriArea(a, b, c) {
    // calc area using Heron's formula
    const s = (a + b + c) / 2;
    return Math.sqrt(s * (s - a) * (s - b) * (s - c));
}
// ================================================================================================
var _ESkyMethod;
(function (_ESkyMethod) {
    _ESkyMethod["WEIGHTED"] = "weighted";
    _ESkyMethod["UNWEIGHTED"] = "unweighted";
    _ESkyMethod["ALL"] = "all";
})(_ESkyMethod || (_ESkyMethod = {}));
/**
 * Calculate an approximation of the sky exposure factor, for a set sensors positioned at specified locations.
 * The sky exposure factor for each sensor is a value between 0 and 1, where 0 means that it has no exposure
 * and 1 means that it has maximum exposure.
 * ~
 * Each sensor has a location and direction, specified using either rays or planes.
 * The direction of the sensor specifies what is infront and what is behind the sensor.
 * For each sensor, only exposure infront of the sensor is calculated.
 * ~
 * The exposure is calculated by shooting rays in reverse.
 * from the sensor origin to a set of points on the sky dome.
 * If the rays hits an obstruction, then the sky dome is obstructed..
 * If the ray hits no obstructions, then the sky dome is not obstructed.
 * ~
 * The exposure factor at each sensor point is calculated as follows:
 * 1) Shoot rays to all sky dome points.
 * 2) If the ray hits an obstruction, assign a weight of 0 to that ray.
 * 3) If a ray does not hit any obstructions, assign a weight between 0 and 1, depending on the incidence angle.
 * 4) Calculate the total solar expouse by adding up the weights for all rays.
 * 5) Divide by the maximum possible exposure for an unobstructed sensor with a direction pointing straight up.
 * ~
 * If 'weighted' is selected, then
 * the exposure calculation takes into account the angle of incidence of the ray to the sensor direction.
 * Rays parallel to the sensor direction are assigned a weight of 1.
 * Rays at an oblique angle are assigned a weight equal to the cosine of the angle
 * betweeen the sensor direction and the ray.
 * ~
 * If 'unweighted' is selected, then all rays are assigned a weight of 1, irresepctive of angle.
 * ~
 * The detail parameter spacifies the number of rays that get generated.
 * The higher the level of detail, the more accurate but also the slower the analysis will be.
 * ~
 * The number of rays are as follows:
 * 0 = 89 rays,
 * 1 = 337 rays,
 * 2 = 1313 rays,
 * 3 = 5185 rays.
 * ~
 * Returns a dictionary containing exposure results.
 * ~
 * 1) 'exposure': A list of numbers, the exposure factors.
 * ~
 * ~
 * @param __model__
 * @param origins A list of coordinates, a list of Rays or a list of Planes, to be used as the origins for calculating exposure.
 * @param detail An integer between 1 and 3 inclusive, specifying the level of detail for the analysis.
 * @param entities The obstructions, faces, polygons, or collections of faces or polygons.
 * @param limits The max distance for raytracing.
 * @param method Enum; sky method.
 */
function Sky(__model__, origins, detail, entities, limits, method) {
    entities = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_8__["arrMakeFlat"])(entities);
    // --- Error Check ---
    const fn_name = 'analyze.Sky';
    let ents_arrs;
    // let latitude: number = null;
    // let north: Txy = [0, 1];
    if (__model__.debug) {
        Object(_check_args__WEBPACK_IMPORTED_MODULE_1__["checkArgs"])(fn_name, 'origins', origins, [_check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isXYZL, _check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isRayL, _check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isPlnL]);
        Object(_check_args__WEBPACK_IMPORTED_MODULE_1__["checkArgs"])(fn_name, 'detail', detail, [_check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isInt]);
        if (detail < 0 || detail > 3) {
            throw new Error(fn_name + ': "detail" must be an integer between 0 and 3 inclusive.');
        }
        ents_arrs = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])(fn_name, 'entities', entities, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isId, _check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL], [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].FACE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].COLL]);
    }
    else {
        ents_arrs = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsBreak"])(entities);
        // const geolocation = __model__.modeldata.attribs.query.getModelAttribVal('geolocation');
        // latitude = geolocation['latitude'];
        // if (__model__.modeldata.attribs.query.hasModelAttrib('north')) {
        //     north = __model__.modeldata.attribs.query.getModelAttribVal('north') as Txy;
        // }
    }
    // TODO
    // TODO
    // --- Error Check ---
    const sensor_oris_dirs_tjs = _rayOrisDirsTjs(__model__, origins, 0.01);
    const [mesh_tjs, idx_to_face_i] = Object(_assets_libs_geom_mesh__WEBPACK_IMPORTED_MODULE_16__["createSingleMeshTjs"])(__model__, ents_arrs);
    limits = Array.isArray(limits) ? limits : [0, limits];
    // get the direction vectors
    const ray_dirs_tjs = _skyRayDirsTjs(detail);
    // run the simulation
    const weighted = method === _ESkyMethod.WEIGHTED;
    const results = _calcExposure(sensor_oris_dirs_tjs, ray_dirs_tjs, mesh_tjs, limits, weighted);
    // cleanup
    mesh_tjs.geometry.dispose();
    mesh_tjs.material.dispose();
    // return the result
    return { 'exposure': results };
}
function _skyRayDirsTjs(detail) {
    const hedron_tjs = new three__WEBPACK_IMPORTED_MODULE_13__["IcosahedronGeometry"](1, detail + 2);
    // calc vectors
    const vecs = [];
    for (const vec of hedron_tjs.vertices) {
        // vec.applyAxisAngle(YAXIS, Math.PI / 2);
        if (vec.z > -1e-6) {
            vecs.push(vec);
        }
    }
    //console.log("num rays = ", vecs.length);
    return vecs;
}
// ================================================================================================
var _ESolarMethod;
(function (_ESolarMethod) {
    _ESolarMethod["DIRECT_WEIGHTED"] = "direct_weighted";
    _ESolarMethod["DIRECT_UNWEIGHTED"] = "direct_unweighted";
    _ESolarMethod["INDIRECT_WEIGHTED"] = "indirect_weighted";
    _ESolarMethod["INDIRECT_UNWEIGHTED"] = "indirect_unweighted";
})(_ESolarMethod || (_ESolarMethod = {}));
/**
 * Calculate an approximation of the solar exposure factor, for a set sensors positioned at specfied locations.
 * The solar exposure factor for each sensor is a value between 0 and 1, where 0 means that it has no exposure
 * and 1 means that it has maximum exposure.
 * ~
 * The calculation takes into account the geolocation and the north direction of the model.
 * Geolocation is specified by a model attributes as follows:
 * @geolocation={'longitude':123,'latitude':12}.
 * North direction is specified by a model attribute as follows, using a vector:
 * @north==[1,2]
 * If no north direction is specified, then [0,1] is the default (i.e. north is in the direction of the y-axis);
 * ~
 * Each sensor has a location and direction, specified using either rays or planes.
 * The direction of the sensor specifies what is infront and what is behind the sensor.
 * For each sensor, only exposure infront of the sensor is calculated.
 * ~
 * The exposure is calculated by shooting rays in reverse.
 * from the sensor origin to a set of points on the sky dome.
 * If the rays hits an obstruction, then the sky dome is obstructed..
 * If the ray hits no obstructions, then the sky dome is not obstructed.
 * ~
 * The exposure factor at each sensor point is calculated as follows:
 * 1) Shoot rays to all sky dome points.
 * 2) If the ray hits an obstruction, assign a wight of 0 to that ray.
 * 3) If a ray does not hit any obstructions, assign a weight between 0 and 1, depending on the incidence angle.
 * 4) Calculate the total solar expouse by adding up the weights for all rays.
 * 5) Divide by the maximum possible solar exposure for an unobstructed sensor.
 * ~
 * The solar exposure calculation takes into account the angle of incidence of the sun ray to the sensor direction.
 * Sun rays that are hitting the sensor straight on are assigned a weight of 1.
 * Sun rays that are hitting the sensor at an oblique angle are assigned a weight equal to the cosine of the angle.
 * ~
 * If 'direct_exposure' is selected, then the points on the sky dome will follow the path of the sun throughout the year.
 * If 'indirect_exposure' is selected, then the points on the sky dome will consist of points excluded by
 * the path of the sun throughout the year.
 * ~
 * The direct sky dome points cover a strip of sky where the sun travels.
 * The inderect sky dome points cover the segments of sky either side of the direct sun strip.
 * ~
 * The detail parameter spacifies the number of rays that get generated.
 * The higher the level of detail, the more accurate but also the slower the analysis will be.
 * The number of rays differs depending on the latitde.
 * ~
 * At latitude 0, the number of rays for 'direct' are as follows:
 * 0 = 44 rays,
 * 1 = 105 rays,
 * 2 = 510 rays,
 * 3 = 1287 rays.
 * ~
 * At latitude 0, the number of rays for 'indirect' are as follows:
 * 0 = 58 rays,
 * 1 = 204 rays,
 * 2 = 798 rays,
 * 3 = 3122 rays.
 * ~
 * The number of rays for 'sky' are as follows:
 * 0 = 89 rays,
 * 1 = 337 rays,
 * 2 = 1313 rays,
 * 3 = 5185 rays.
 * ~
 * Returns a dictionary containing solar exposure results.
 * ~
 * If one  of the 'direct' methods is selected, the dictionary will contain:
 * 1) 'direct': A list of numbers, the direct exposure factors.
 * ~
 * If one  of the 'indirect' methods is selected, the dictionary will contain:
 * 1) 'indirect': A list of numbers, the indirect exposure factors.
 * ~
 * ~
 * @param __model__
 * @param origins A list of coordinates, a list of Rays or a list of Planes, to be used as the origins for calculating exposure.
 * @param detail An integer between 1 and 3 inclusive, specifying the level of detail for the analysis.
 * @param entities The obstructions, faces, polygons, or collections of faces or polygons.
 * @param limits The max distance for raytracing.
 * @param method Enum; solar method.
 */
function Sun(__model__, origins, detail, entities, limits, method) {
    entities = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_8__["arrMakeFlat"])(entities);
    // --- Error Check ---
    const fn_name = 'analyze.Sun';
    let ents_arrs;
    let latitude = null;
    let north = [0, 1];
    if (__model__.debug) {
        Object(_check_args__WEBPACK_IMPORTED_MODULE_1__["checkArgs"])(fn_name, 'origins', origins, [_check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isXYZL, _check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isRayL, _check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isPlnL]);
        Object(_check_args__WEBPACK_IMPORTED_MODULE_1__["checkArgs"])(fn_name, 'detail', detail, [_check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isInt]);
        if (detail < 0 || detail > 3) {
            throw new Error(fn_name + ': "detail" must be an integer between 0 and 3 inclusive.');
        }
        ents_arrs = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])(fn_name, 'entities', entities, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isId, _check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL], [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].FACE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].COLL]);
        if (!__model__.modeldata.attribs.query.hasModelAttrib('geolocation')) {
            throw new Error('analyze.Solar: model attribute "geolocation" is missing, \
                e.g. @geolocation = {"latitude":12, "longitude":34}');
        }
        else {
            const geolocation = __model__.modeldata.attribs.query.getModelAttribVal('geolocation');
            if (underscore__WEBPACK_IMPORTED_MODULE_6__["default"].isObject(geolocation) && underscore__WEBPACK_IMPORTED_MODULE_6__["default"].has(geolocation, 'latitude')) {
                latitude = geolocation['latitude'];
            }
            else {
                throw new Error('analyze.Solar: model attribute "geolocation" is missing the "latitude" key, \
                    e.g. @geolocation = {"latitude":12, "longitude":34}');
            }
        }
        if (__model__.modeldata.attribs.query.hasModelAttrib('north')) {
            north = __model__.modeldata.attribs.query.getModelAttribVal('north');
            if (!Array.isArray(north) || north.length !== 2) {
                throw new Error('analyze.Solar: model has a "north" attribute with the wrong type, \
                it should be a vector with two values, \
                e.g. @north =  [1,2]');
            }
        }
    }
    else {
        ents_arrs = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsBreak"])(entities);
        const geolocation = __model__.modeldata.attribs.query.getModelAttribVal('geolocation');
        latitude = geolocation['latitude'];
        if (__model__.modeldata.attribs.query.hasModelAttrib('north')) {
            north = __model__.modeldata.attribs.query.getModelAttribVal('north');
        }
    }
    // TODO
    // TODO
    // --- Error Check ---
    // TODO North direction
    const sensor_oris_dirs_tjs = _rayOrisDirsTjs(__model__, origins, 0.01);
    const [mesh_tjs, idx_to_face_i] = Object(_assets_libs_geom_mesh__WEBPACK_IMPORTED_MODULE_16__["createSingleMeshTjs"])(__model__, ents_arrs);
    limits = Array.isArray(limits) ? limits : [0, limits];
    // return the result
    const results = {};
    switch (method) {
        case _ESolarMethod.DIRECT_WEIGHTED:
        case _ESolarMethod.DIRECT_UNWEIGHTED:
            // get the direction vectors
            const ray_dirs_tjs1 = underscore__WEBPACK_IMPORTED_MODULE_6__["default"].flatten(_solarDirsTjs(latitude, north, detail, method));
            // run the simulation
            const weighted1 = method === _ESolarMethod.DIRECT_WEIGHTED;
            results['direct'] = _calcExposure(sensor_oris_dirs_tjs, ray_dirs_tjs1, mesh_tjs, limits, weighted1);
            break;
        case _ESolarMethod.INDIRECT_WEIGHTED:
        case _ESolarMethod.INDIRECT_UNWEIGHTED:
            // get the direction vectors
            const ray_dirs_tjs2 = underscore__WEBPACK_IMPORTED_MODULE_6__["default"].flatten(_solarDirsTjs(latitude, north, detail, method));
            // run the simulation
            const weighted2 = method === _ESolarMethod.INDIRECT_WEIGHTED;
            results['indirect'] = _calcExposure(sensor_oris_dirs_tjs, ray_dirs_tjs2, mesh_tjs, limits, weighted2);
            break;
        default:
            throw new Error('Solar method not recognised.');
    }
    // cleanup
    mesh_tjs.geometry.dispose();
    mesh_tjs.material.dispose();
    // return dict
    return results;
}
function _rayOrisDirsTjs(__model__, origins, offset) {
    const vectors_tjs = [];
    const is_xyz = Object(_assets_libs_geo_info_virtual__WEBPACK_IMPORTED_MODULE_17__["isXYZ"])(origins[0]);
    const is_ray = Object(_assets_libs_geo_info_virtual__WEBPACK_IMPORTED_MODULE_17__["isRay"])(origins[0]);
    const is_pln = Object(_assets_libs_geo_info_virtual__WEBPACK_IMPORTED_MODULE_17__["isPlane"])(origins[0]);
    for (const origin of origins) {
        let origin_xyz = null;
        let normal_xyz = null;
        if (is_xyz) {
            origin_xyz = origin;
            normal_xyz = [0, 0, 1];
        }
        else if (is_ray) {
            origin_xyz = origin[0];
            normal_xyz = Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_5__["vecNorm"])(origin[1]);
        }
        else if (is_pln) {
            origin_xyz = origin[0];
            normal_xyz = Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_5__["vecCross"])(origin[1], origin[2]);
        }
        else {
            throw new Error('analyze.Solar: origins arg has invalid values');
        }
        const normal_tjs = new three__WEBPACK_IMPORTED_MODULE_13__["Vector3"](...normal_xyz);
        const origin_offset_xyz = Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_5__["vecAdd"])(origin_xyz, Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_5__["vecMult"])(normal_xyz, offset));
        const origin_tjs = new three__WEBPACK_IMPORTED_MODULE_13__["Vector3"](...origin_offset_xyz);
        vectors_tjs.push([origin_tjs, normal_tjs]);
    }
    return vectors_tjs;
}
function _solarDirsTjs(latitude, north, detail, method) {
    switch (method) {
        case _ESolarMethod.DIRECT_WEIGHTED:
        case _ESolarMethod.DIRECT_UNWEIGHTED:
            return _solarRaysDirectTjs(latitude, north, detail);
        case _ESolarMethod.INDIRECT_WEIGHTED:
        case _ESolarMethod.INDIRECT_UNWEIGHTED:
            return _solarRaysIndirectTjs(latitude, north, detail);
        // case _ESolarMethod.ALL:
        //     throw new Error('Not implemented');
        default:
            throw new Error('Solar method not recognised.');
    }
}
function _solarRot(day_ang, day, hour_ang, hour, latitude, north) {
    const vec = new three__WEBPACK_IMPORTED_MODULE_13__["Vector3"](0, 0, -1);
    vec.applyAxisAngle(_assets_libs_geom_constants__WEBPACK_IMPORTED_MODULE_11__["XAXIS"], day_ang * day);
    vec.applyAxisAngle(_assets_libs_geom_constants__WEBPACK_IMPORTED_MODULE_11__["YAXIS"], hour_ang * hour);
    vec.applyAxisAngle(_assets_libs_geom_constants__WEBPACK_IMPORTED_MODULE_11__["XAXIS"], latitude);
    vec.applyAxisAngle(_assets_libs_geom_constants__WEBPACK_IMPORTED_MODULE_11__["ZAXIS"], -north);
    return vec;
}
function _solarRaysDirectTjs(latitude, north, detail) {
    const directions = [];
    // set the level of detail
    // const day_step = [182 / 4, 182 / 5, 182 / 6, 182 / 7, 182 / 8, 182 / 9, 182 / 10][detail];
    const day_step = [182 / 3, 182 / 6, 182 / 9, 182 / 12][detail];
    const num_day_steps = Math.round(182 / day_step) + 1;
    // const hour_step = [0.25 * 6, 0.25 * 5, 0.25 * 4, 0.25 * 3, 0.25 * 2, 0.25 * 1, 0.25 * 0.5][detail];
    const hour_step = [0.25 * 6, 0.25 * 4, 0.25 * 1, 0.25 * 0.5][detail];
    // get the angles in radians
    const day_ang_rad = Object(_assets_core_inline_conversion__WEBPACK_IMPORTED_MODULE_9__["degToRad"])(47) / 182;
    const hour_ang_rad = (2 * Math.PI) / 24;
    // get the atitude angle in radians
    const latitude_rad = Object(_assets_core_inline_conversion__WEBPACK_IMPORTED_MODULE_9__["degToRad"])(latitude);
    // get the angle from y-axis to north vector in radians
    const north_rad = Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_5__["vecAng2"])([north[0], north[1], 0], [0, 1, 0], [0, 0, 1]);
    // create the vectors
    for (let day_count = 0; day_count < num_day_steps; day_count++) {
        const day = -91 + (day_count * day_step);
        const one_day_path = [];
        // get sunrise
        let sunrise = 0;
        let sunset = 0;
        for (let hour = 0; hour < 24; hour = hour + 0.1) {
            const sunrise_vec = _solarRot(day_ang_rad, day, hour_ang_rad, hour, latitude_rad, north_rad);
            if (sunrise_vec.z > -1e-6) {
                sunrise = hour;
                sunset = 24 - hour;
                one_day_path.push(sunrise_vec);
                break;
            }
        }
        // morning sun path, count down from midday
        for (let hour = 12; hour > sunrise; hour = hour - hour_step) {
            const am_vec = _solarRot(day_ang_rad, day, hour_ang_rad, hour, latitude_rad, north_rad);
            if (am_vec.z > -1e-6) {
                one_day_path.splice(1, 0, am_vec);
            }
            else {
                break;
            }
        }
        // afternoon sunpath, count up from midday
        for (let hour = 12 + hour_step; hour < sunset; hour = hour + hour_step) {
            const pm_vec = _solarRot(day_ang_rad, day, hour_ang_rad, hour, latitude_rad, north_rad);
            if (pm_vec.z > -1e-6) {
                one_day_path.push(pm_vec);
            }
            else {
                break;
            }
        }
        // sunset
        const sunset_vec = _solarRot(day_ang_rad, day, hour_ang_rad, sunset, latitude_rad, north_rad);
        one_day_path.push(sunset_vec);
        // add it to the list
        directions.push(one_day_path);
    }
    // console.log("num rays = ", arrMakeFlat(directions).length);
    return directions;
}
function _solarRaysIndirectTjs(latitude, north, detail) {
    const hedron_tjs = new three__WEBPACK_IMPORTED_MODULE_13__["IcosahedronGeometry"](1, detail + 2);
    const solar_offset = Math.cos(Object(_assets_core_inline_conversion__WEBPACK_IMPORTED_MODULE_9__["degToRad"])(66.5));
    // get the atitude angle in radians
    const latitude_rad = Object(_assets_core_inline_conversion__WEBPACK_IMPORTED_MODULE_9__["degToRad"])(latitude);
    // get the angle from y-axis to north vector in radians
    const north_rad = Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_5__["vecAng2"])([north[0], north[1], 0], [0, 1, 0], [0, 0, 1]);
    // calc vectors
    const indirect_vecs = [];
    for (const vec of hedron_tjs.vertices) {
        if (Math.abs(vec.y) > solar_offset) {
            vec.applyAxisAngle(_assets_libs_geom_constants__WEBPACK_IMPORTED_MODULE_11__["XAXIS"], latitude_rad);
            vec.applyAxisAngle(_assets_libs_geom_constants__WEBPACK_IMPORTED_MODULE_11__["ZAXIS"], -north_rad);
            if (vec.z > -1e-6) {
                indirect_vecs.push(vec);
            }
        }
    }
    // console.log("num rays = ", indirect_vecs.length);
    return indirect_vecs;
}
// calc the max solar exposure for a point with no obstructions facing straight up
function _calcMaxExposure(directions_tjs, weighted) {
    if (!weighted) {
        return directions_tjs.length;
    }
    let result = 0;
    const normal_tjs = new three__WEBPACK_IMPORTED_MODULE_13__["Vector3"](0, 0, 1);
    for (const direction_tjs of directions_tjs) {
        // calc the weighted result based on the angle between the dir and normal
        // this applies the cosine weighting rule
        const result_weighted = normal_tjs.dot(direction_tjs);
        if (result_weighted > 0) {
            result = result + result_weighted;
        }
    }
    return result;
}
function _calcExposure(origins_normals_tjs, directions_tjs, mesh_tjs, limits, weighted) {
    const results = [];
    const result_max = _calcMaxExposure(directions_tjs, weighted);
    for (const [origin_tjs, normal_tjs] of origins_normals_tjs) {
        let result = 0;
        for (const direction_tjs of directions_tjs) {
            const dot_normal_direction = normal_tjs.dot(direction_tjs);
            if (dot_normal_direction > 0) {
                const ray_tjs = new three__WEBPACK_IMPORTED_MODULE_13__["Raycaster"](origin_tjs, direction_tjs, limits[0], limits[1]);
                const isects = ray_tjs.intersectObject(mesh_tjs, false);
                if (isects.length === 0) {
                    if (weighted) {
                        // this applies the cosine weighting rule
                        result = result + dot_normal_direction;
                    }
                    else {
                        // this applies no cosine weighting
                        result = result + 1;
                    }
                }
            }
        }
        results.push(result / result_max);
    }
    return results;
}
// ================================================================================================
var _ESunPathMethod;
(function (_ESunPathMethod) {
    _ESunPathMethod["DIRECT"] = "direct";
    _ESunPathMethod["INDIRECT"] = "indirect";
    _ESunPathMethod["SKY"] = "sky";
})(_ESunPathMethod || (_ESunPathMethod = {}));
/**
 * Generates a sun path, oriented according to the geolocation and north direction.
 * The sun path is generated as an aid to visualize the orientation of the sun relative to the model.
 * Note that the solar exposure calculations do not require the sub path to be visualized.
 * ~
 * The sun path takes into account the geolocation and the north direction of the model.
 * Geolocation is specified by a model attributes as follows:
 * @geolocation={'longitude':123,'latitude':12}.
 * North direction is specified by a model attribute as follows, using a vector:
 * @north==[1,2]
 * If no north direction is specified, then [0,1] is the default (i.e. north is in the direction of the y-axis);
 * ~
 * @param __model__
 * @param origins The origins of the rays
 * @param detail The level of detail for the analysis
 * @param radius The radius of the sun path
 * @param method Enum, the type of sky to generate.
 */
function SkyDome(__model__, origin, detail, radius, method) {
    // --- Error Check ---
    const fn_name = 'analyze.SkyDome';
    let latitude = null;
    let north = [0, 1];
    if (__model__.debug) {
        Object(_check_args__WEBPACK_IMPORTED_MODULE_1__["checkArgs"])(fn_name, 'origin', origin, [_check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isXYZ, _check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isRay, _check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isPln]);
        Object(_check_args__WEBPACK_IMPORTED_MODULE_1__["checkArgs"])(fn_name, 'detail', detail, [_check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isInt]);
        if (detail < 0 || detail > 6) {
            throw new Error(fn_name + ': "detail" must be an integer between 0 and 6.');
        }
        Object(_check_args__WEBPACK_IMPORTED_MODULE_1__["checkArgs"])(fn_name, 'radius', radius, [_check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isNum]);
        if (method !== _ESunPathMethod.SKY) {
            if (!__model__.modeldata.attribs.query.hasModelAttrib('geolocation')) {
                throw new Error('analyze.Solar: model attribute "geolocation" is missing, \
                    e.g. @geolocation = {"latitude":12, "longitude":34}');
            }
            else {
                const geolocation = __model__.modeldata.attribs.query.getModelAttribVal('geolocation');
                if (underscore__WEBPACK_IMPORTED_MODULE_6__["default"].isObject(geolocation) && underscore__WEBPACK_IMPORTED_MODULE_6__["default"].has(geolocation, 'latitude')) {
                    latitude = geolocation['latitude'];
                }
                else {
                    throw new Error('analyze.Solar: model attribute "geolocation" is missing the "latitude" key, \
                        e.g. @geolocation = {"latitude":12, "longitude":34}');
                }
            }
            if (__model__.modeldata.attribs.query.hasModelAttrib('north')) {
                north = __model__.modeldata.attribs.query.getModelAttribVal('north');
                if (!Array.isArray(north) || north.length !== 2) {
                    throw new Error('analyze.Solar: model has a "north" attribute with the wrong type, \
                    it should be a vector with two values, \
                    e.g. @north =  [1,2]');
                }
            }
        }
    }
    else {
        const geolocation = __model__.modeldata.attribs.query.getModelAttribVal('geolocation');
        latitude = geolocation['latitude'];
        if (__model__.modeldata.attribs.query.hasModelAttrib('north')) {
            north = __model__.modeldata.attribs.query.getModelAttribVal('north');
        }
    }
    // --- Error Check ---
    // create the matrix one time
    const matrix = new three__WEBPACK_IMPORTED_MODULE_13__["Matrix4"]();
    const origin_depth = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["getArrDepth"])(origin);
    if (origin_depth === 2 && origin.length === 2) {
        // origin is a ray
        matrix.makeTranslation(...origin[0]);
    }
    else if (origin_depth === 2 && origin.length === 3) {
        // origin is a plane
        // matrix = xfromSourceTargetMatrix(XYPLANE, origin as TPlane); // TODO xform not nceessary
        matrix.makeTranslation(...origin[0]);
    }
    else {
        // origin is Txyz
        matrix.makeTranslation(...origin);
    }
    // generate the positions on the sky dome
    switch (method) {
        case _ESunPathMethod.DIRECT:
            const rays_dirs_tjs1 = _solarRaysDirectTjs(latitude, north, detail);
            return _sunPathGenPosisNested(__model__, rays_dirs_tjs1, radius, matrix);
        case _ESunPathMethod.INDIRECT:
            const rays_dirs_tjs2 = _solarRaysIndirectTjs(latitude, north, detail);
            return _sunPathGenPosis(__model__, rays_dirs_tjs2, radius, matrix);
        case _ESunPathMethod.SKY:
            const rays_dirs_tjs3 = _skyRayDirsTjs(detail);
            return _sunPathGenPosis(__model__, rays_dirs_tjs3, radius, matrix);
        default:
            throw new Error('Sunpath method not recognised.');
    }
}
function _sunPathGenPosisNested(__model__, rays_dirs_tjs, radius, matrix) {
    const posis = [];
    for (const one_day_tjs of rays_dirs_tjs) {
        posis.push(_sunPathGenPosis(__model__, one_day_tjs, radius, matrix));
    }
    return posis;
}
function _sunPathGenPosis(__model__, rays_dirs_tjs, radius, matrix) {
    const posis_i = [];
    for (const direction_tjs of rays_dirs_tjs) {
        let xyz = Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_5__["vecMult"])([direction_tjs.x, direction_tjs.y, direction_tjs.z], radius);
        xyz = Object(_libs_geom_matrix__WEBPACK_IMPORTED_MODULE_10__["multMatrix"])(xyz, matrix);
        const posi_i = __model__.modeldata.geom.add.addPosi();
        __model__.modeldata.attribs.add.setPosiCoords(posi_i, xyz);
        posis_i.push(posi_i);
    }
    return Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsMakeFromIndicies"])(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].POSI, posis_i);
}
// ================================================================================================
/**
 * Finds the nearest positions within a certain maximum radius.
 * ~
 * The neighbors to each source position is calculated as follows:
 * 1) Calculate the distance to all target positions.
 * 2) Creat the neighbors set by filtering out target positions that are further than the maximum radius.
 * 3) If the number of neighbors is greater than 'max_neighbors',
 * then select the 'max_neighbors' closest target positions.
 * ~
 * Returns a dictionary containing the nearest positions.
 * ~
 * If 'num_neighbors' is 1, the dictionary will contain two lists:
 * 1) 'posis': a list of positions, a subset of positions from the source.
 * 2) 'neighbors': a list of neighbouring positions, a subset of positions from target.
  * ~
 * If 'num_neighbors' is greater than 1, the dictionary will contain two lists:
 * 1) 'posis': a list of positions, a subset of positions from the source.
 * 2) 'neighbors': a list of lists of neighbouring positions, a subset of positions from target.
 * ~
 * @param __model__
 * @param source A list of positions, or entities from which positions can be extracted.
 * @param target A list of positions, or entities from which positions can be extracted.
 * If null, the positions in source will be used.
 * @param radius The maximum distance for neighbors. If null, Infinity will be used.
 * @param max_neighbors The maximum number of neighbors to return.
 * If null, the number of positions in target is used.
 * @returns A dictionary containing the results.
 */
function Nearest(__model__, source, target, radius, max_neighbors) {
    if (target === null) {
        target = source;
    } // TODO optimise
    source = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_8__["arrMakeFlat"])(source);
    target = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_8__["arrMakeFlat"])(target);
    // --- Error Check ---
    const fn_name = 'analyze.Nearest';
    let source_ents_arrs;
    let target_ents_arrs;
    if (__model__.debug) {
        source_ents_arrs = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])(fn_name, 'origins', source, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isId, _check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL], null);
        target_ents_arrs = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])(fn_name, 'destinations', target, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isId, _check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL], null);
    }
    else {
        // source_ents_arrs = splitIDs(fn_name, 'origins', source,
        //     [IDcheckObj.isID, IDcheckObj.isIDList], null) as TEntTypeIdx[];
        // target_ents_arrs = splitIDs(fn_name, 'destinations', target,
        //     [IDcheckObj.isID, IDcheckObj.isIDList], null) as TEntTypeIdx[];
        source_ents_arrs = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsBreak"])(source);
        target_ents_arrs = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsBreak"])(target);
    }
    // --- Error Check ---
    const source_posis_i = _getUniquePosis(__model__, source_ents_arrs);
    const target_posis_i = _getUniquePosis(__model__, target_ents_arrs);
    const result = _nearest(__model__, source_posis_i, target_posis_i, radius, max_neighbors);
    // return dictionary with results
    return {
        'posis': Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsMakeFromIndicies"])(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].POSI, result[0]),
        'neighbors': Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsMakeFromIndicies"])(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].POSI, result[1]),
        'distances': result[2]
    };
}
function _fuseDistSq(xyz1, xyz2) {
    return Math.pow(xyz1[0] - xyz2[0], 2) + Math.pow(xyz1[1] - xyz2[1], 2) + Math.pow(xyz1[2] - xyz2[2], 2);
}
function _nearest(__model__, source_posis_i, target_posis_i, dist, num_neighbors) {
    // create a list of all posis
    const set_target_posis_i = new Set(target_posis_i);
    const set_posis_i = new Set(target_posis_i);
    for (const posi_i of source_posis_i) {
        set_posis_i.add(posi_i);
    }
    const posis_i = Array.from(set_posis_i);
    // get dist and num_neighbours
    if (dist === null) {
        dist = Infinity;
    }
    if (num_neighbors === null) {
        num_neighbors = target_posis_i.length;
    }
    // find neighbor
    const map_posi_i_to_xyz = new Map();
    const typed_positions = new Float32Array(posis_i.length * 4);
    const typed_buff = new three__WEBPACK_IMPORTED_MODULE_13__["BufferGeometry"]();
    typed_buff.setAttribute('position', new three__WEBPACK_IMPORTED_MODULE_13__["BufferAttribute"](typed_positions, 4));
    for (let i = 0; i < posis_i.length; i++) {
        const posi_i = posis_i[i];
        const xyz = __model__.modeldata.attribs.query.getPosiCoords(posi_i);
        map_posi_i_to_xyz.set(posi_i, xyz);
        typed_positions[i * 4 + 0] = xyz[0];
        typed_positions[i * 4 + 1] = xyz[1];
        typed_positions[i * 4 + 2] = xyz[2];
        typed_positions[i * 4 + 3] = posi_i;
    }
    const kdtree = new _libs_TypedArrayUtils_js__WEBPACK_IMPORTED_MODULE_14__["TypedArrayUtils"].Kdtree(typed_positions, _fuseDistSq, 4);
    // calculate the dist squared
    const num_posis = posis_i.length;
    const dist_sq = dist * dist;
    // deal with special case, num_neighbors === 1
    if (num_neighbors === 1) {
        const result1 = [[], [], []];
        for (const posi_i of source_posis_i) {
            const nn = kdtree.nearest(map_posi_i_to_xyz.get(posi_i), num_posis, dist_sq);
            let min_dist = Infinity;
            let nn_posi_i;
            for (const a_nn of nn) {
                const next_nn_posi_i = a_nn[0].obj[3];
                if (set_target_posis_i.has(next_nn_posi_i) && a_nn[1] < min_dist) {
                    min_dist = a_nn[1];
                    nn_posi_i = next_nn_posi_i;
                }
            }
            if (nn_posi_i !== undefined) {
                result1[0].push(posi_i);
                result1[1].push(nn_posi_i);
                result1[2].push(Math.sqrt(min_dist));
            }
        }
        return result1;
    }
    // create a neighbors list
    const result = [[], [], []];
    for (const posi_i of source_posis_i) {
        // TODO at the moment is gets all posis since no distinction is made between source and traget
        // TODO kdtree could be optimised
        const nn = kdtree.nearest(map_posi_i_to_xyz.get(posi_i), num_posis, dist_sq);
        const posis_i_dists = [];
        for (const a_nn of nn) {
            const nn_posi_i = a_nn[0].obj[3];
            if (set_target_posis_i.has(nn_posi_i)) {
                posis_i_dists.push([nn_posi_i, a_nn[1]]);
            }
        }
        posis_i_dists.sort((a, b) => a[1] - b[1]);
        const nn_posis_i = [];
        const nn_dists = [];
        for (const posi_i_dist of posis_i_dists) {
            nn_posis_i.push(posi_i_dist[0]);
            nn_dists.push(Math.sqrt(posi_i_dist[1]));
            if (nn_posis_i.length === num_neighbors) {
                break;
            }
        }
        if (nn_posis_i.length > 0) {
            result[0].push(posi_i);
            result[1].push(nn_posis_i);
            result[2].push(nn_dists);
        }
    }
    return result;
}
var _EShortestPathMethod;
(function (_EShortestPathMethod) {
    _EShortestPathMethod["UNDIRECTED"] = "undirected";
    _EShortestPathMethod["DIRECTED"] = "directed";
})(_EShortestPathMethod || (_EShortestPathMethod = {}));
var _EShortestPathResult;
(function (_EShortestPathResult) {
    _EShortestPathResult["DISTS"] = "distances";
    _EShortestPathResult["COUNTS"] = "counts";
    _EShortestPathResult["PATHS"] = "paths";
    _EShortestPathResult["ALL"] = "all";
})(_EShortestPathResult || (_EShortestPathResult = {}));
/**
 * Calculates the shortest path from every source position to every target position.
 * ~
 * Paths are calculated through a network of connected edges.
 * For edges to be connected, vertices must be welded.
 * For example, if the network consists of multiple polylines, then the vertcies of those polylines must be welded.
 * ~
 * If 'directed' is selected, then the edge direction is taken into account. Each edge will be one-way.
 * If 'undirected' is selected, the edge direction is ignored. Each edge will be two-way.
 * ~
 * Each edge can be assigned a weight.
 * The shortest path is the path where the sum of the weights of the edges along the path is the minimum.
 * ~
 * By default, all edges are assigned a weight of 1.
 * Default weights can be overridden by creating a numeric attribute on edges call 'weight'.
 * ~
 * Returns a dictionary containing the shortest paths.
 * ~
 * If 'distances' is selected, the dictionary will contain two list:
 * 1) 'source_posis': a list of start positions for eah path,
 * 2) 'distances': a list of distances, one list for each path starting at each source position.
 * ~
 * If 'counts' is selected, the dictionary will contain four lists:
 * 1) 'posis': a list of positions traversed by the paths,
 * 2) 'posis_count': a list of numbers that count how often each position was traversed,
 * 3) 'edges': a list of edges traversed by the paths,
 * 4) 'edges_count': a list of numbers that count how often each edge was traversed.
 * ~
 * If 'paths' is selected, the dictionary will contain two lists of lists:
 * 1) 'posi_paths': a list of lists of positions, one list for each path,
 * 2) 'edge_paths': a list of lists of edges, one list for each path.
 * ~
 * If 'all' is selected, the dictionary will contain all lists just described.
 * ~
 * @param __model__
 * @param source Path source, a list of positions, or entities from which positions can be extracted.
 * @param target Path target, a list of positions, or entities from which positions can be extracted.
 * @param entities The network, edges, or entities from which edges can be extracted.
 * @param method Enum, the method to use, directed or undirected.
 * @param result Enum, the data to return, positions, edges, or both.
 * @returns A dictionary containing the results.
 */
function ShortestPath(__model__, source, target, entities, method, result) {
    source = source === null ? [] : Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_8__["arrMakeFlat"])(source);
    target = target === null ? [] : Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_8__["arrMakeFlat"])(target);
    entities = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_8__["arrMakeFlat"])(entities);
    // --- Error Check ---
    const fn_name = 'analyze.ShortestPath';
    let source_ents_arrs;
    let target_ents_arrs;
    let ents_arrs;
    if (__model__.debug) {
        source_ents_arrs = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])(fn_name, 'origins', source, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isId, _check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL], null);
        target_ents_arrs = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])(fn_name, 'destinations', target, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isId, _check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL], null);
        ents_arrs = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])(fn_name, 'entities', entities, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isId, _check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL], null);
    }
    else {
        // source_ents_arrs = splitIDs(fn_name, 'origins', source,
        //     [IDcheckObj.isID, IDcheckObj.isIDList], null) as TEntTypeIdx[];
        // target_ents_arrs = splitIDs(fn_name, 'destinations', target,
        //     [IDcheckObj.isID, IDcheckObj.isIDList], null) as TEntTypeIdx[];
        // ents_arrs = splitIDs(fn_name, 'entities', entities,
        //     [IDcheckObj.isID, IDcheckObj.isIDList], null) as TEntTypeIdx[];
        source_ents_arrs = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsBreak"])(source);
        target_ents_arrs = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsBreak"])(target);
        ents_arrs = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsBreak"])(entities);
    }
    // --- Error Check ---
    const directed = method === _EShortestPathMethod.DIRECTED ? true : false;
    let return_dists = true;
    let return_counts = true;
    let return_paths = true;
    switch (result) {
        case _EShortestPathResult.DISTS:
            return_paths = false;
            return_counts = false;
            break;
        case _EShortestPathResult.COUNTS:
            return_dists = false;
            return_paths = false;
            break;
        case _EShortestPathResult.PATHS:
            return_dists = false;
            return_counts = false;
            break;
        default:
            // all true
            break;
    }
    const source_posis_i = _getUniquePosis(__model__, source.length === 0 ? ents_arrs : source_ents_arrs);
    const target_posis_i = _getUniquePosis(__model__, target.length === 0 ? ents_arrs : target_ents_arrs);
    const cy_elems = _cytoscapeGetElements(__model__, ents_arrs, source_posis_i, target_posis_i, directed);
    // create the cytoscape object
    const cy = cytoscape__WEBPACK_IMPORTED_MODULE_12___default()({
        elements: cy_elems,
        headless: true,
    });
    const map_edges_i = new Map();
    const map_posis_i = new Map();
    const posi_paths = [];
    const edge_paths = [];
    const all_path_dists = [];
    for (const source_posi_i of source_posis_i) {
        const path_dists = [];
        const cy_source_elem = cy.getElementById(source_posi_i.toString());
        const dijkstra = cy.elements().dijkstra({
            root: cy_source_elem,
            weight: _cytoscapeWeightFn,
            directed: directed
        });
        for (const target_posi_i of target_posis_i) {
            const cy_node = cy.getElementById(target_posi_i.toString());
            const dist = dijkstra.distanceTo(cy_node);
            const cy_path = dijkstra.pathTo(cy_node);
            const posi_path = [];
            const edge_path = [];
            for (const cy_path_elem of cy_path.toArray()) {
                if (cy_path_elem.isEdge()) {
                    const edge_i = cy_path_elem.data('idx');
                    if (return_counts) {
                        if (!map_edges_i.has(edge_i)) {
                            map_edges_i.set(edge_i, 1);
                        }
                        else {
                            map_edges_i.set(edge_i, map_edges_i.get(edge_i) + 1);
                        }
                        if (!directed) {
                            const edge2_i = cy_path_elem.data('idx2');
                            if (edge2_i !== null) {
                                if (!map_edges_i.has(edge2_i)) {
                                    map_edges_i.set(edge2_i, 1);
                                }
                                else {
                                    map_edges_i.set(edge2_i, map_edges_i.get(edge2_i) + 1);
                                }
                            }
                        }
                    }
                    if (return_paths) {
                        edge_path.push(edge_i);
                    }
                }
                else {
                    const posi_i = cy_path_elem.data('idx');
                    if (return_counts) {
                        if (!map_posis_i.has(posi_i)) {
                            map_posis_i.set(posi_i, 1);
                        }
                        else {
                            map_posis_i.set(posi_i, map_posis_i.get(posi_i) + 1);
                        }
                    }
                    if (return_paths) {
                        posi_path.push(posi_i);
                    }
                }
            }
            if (return_paths) {
                edge_paths.push(edge_path);
                posi_paths.push(posi_path);
            }
            if (return_dists) {
                path_dists.push(dist);
            }
        }
        all_path_dists.push(path_dists);
    }
    const dict = {};
    if (return_dists) {
        dict.source_posis = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsMakeFromIndicies"])(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].POSI, source_posis_i);
        dict.distances = source_posis_i.length === 1 ? all_path_dists[0] : all_path_dists;
    }
    if (return_counts) {
        dict.edges = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsMakeFromIndicies"])(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].EDGE, Array.from(map_edges_i.keys()));
        dict.edges_count = Array.from(map_edges_i.values());
        dict.posis = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsMakeFromIndicies"])(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].POSI, Array.from(map_posis_i.keys()));
        dict.posis_count = Array.from(map_posis_i.values());
    }
    if (return_paths) {
        dict.edge_paths = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsMakeFromIndicies"])(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].EDGE, edge_paths);
        dict.posi_paths = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsMakeFromIndicies"])(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].POSI, posi_paths);
    }
    return dict;
}
function _getUniquePosis(__model__, ents_arr) {
    if (ents_arr.length === 0) {
        return [];
    }
    const set_posis_i = new Set();
    for (const [ent_type, ent_i] of ents_arr) {
        const posis_i = __model__.modeldata.geom.nav.navAnyToPosi(ent_type, ent_i);
        for (const posi_i of posis_i) {
            set_posis_i.add(posi_i);
        }
    }
    return Array.from(set_posis_i);
}
function _cytoscapeWeightFn(edge) {
    return edge.data('weight');
}
function _cytoscapeWeightFn2(edge) {
    const weight = edge.data('weight');
    if (weight < 1) {
        return 1;
    }
    return weight;
}
function _cytoscapeGetElements(__model__, ents_arr, source_posis_i, target_posis_i, directed) {
    let has_weight_attrib = false;
    if (__model__.modeldata.attribs.query.hasAttrib(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].EDGE, 'weight')) {
        has_weight_attrib = __model__.modeldata.attribs.query.getAttribDataType(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].EDGE, 'weight') === _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EAttribDataTypeStrs"].NUMBER;
    }
    // edges, starts empty
    const set_edges_i = new Set();
    // posis, starts with cource and target
    const set_posis_i = new Set(source_posis_i);
    for (const target_posi_i of target_posis_i) {
        set_posis_i.add(target_posi_i);
    }
    // network
    for (const [ent_type, ent_i] of ents_arr) {
        const edges_i = __model__.modeldata.geom.nav.navAnyToEdge(ent_type, ent_i);
        for (const edge_i of edges_i) {
            set_edges_i.add(edge_i);
        }
        const posis_i = __model__.modeldata.geom.nav.navAnyToPosi(ent_type, ent_i);
        for (const posi_i of posis_i) {
            set_posis_i.add(posi_i);
        }
    }
    // create elements
    const elements = [];
    for (const posi_i of Array.from(set_posis_i)) {
        elements.push({ data: { id: posi_i.toString(), idx: posi_i } });
    }
    if (directed) {
        // directed
        for (const edge_i of Array.from(set_edges_i)) {
            const edge_posis_i = __model__.modeldata.geom.nav.navAnyToPosi(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].EDGE, edge_i);
            let weight = 1.0;
            if (has_weight_attrib) {
                weight = __model__.modeldata.attribs.query.getAttribVal(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].EDGE, 'weight', edge_i);
            }
            else {
                const c0 = __model__.modeldata.attribs.query.getPosiCoords(edge_posis_i[0]);
                const c1 = __model__.modeldata.attribs.query.getPosiCoords(edge_posis_i[1]);
                weight = Object(_libs_geom_distance__WEBPACK_IMPORTED_MODULE_4__["distance"])(c0, c1);
            }
            elements.push({ data: { id: 'e' + edge_i,
                    source: edge_posis_i[0].toString(), target: edge_posis_i[1].toString(), weight: weight, idx: edge_i } });
        }
    }
    else {
        // undirected
        const map_edges_ab = new Map();
        for (const edge_i of Array.from(set_edges_i)) {
            let edge_posis_i = __model__.modeldata.geom.nav.navAnyToPosi(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].EDGE, edge_i);
            edge_posis_i = edge_posis_i[0] < edge_posis_i[1] ? edge_posis_i : [edge_posis_i[1], edge_posis_i[0]];
            const undir_edge_id = 'e_' + edge_posis_i[0].toString() + '_' + edge_posis_i[1].toString();
            if (map_edges_ab.has(undir_edge_id)) {
                const obj = map_edges_ab.get(undir_edge_id);
                obj['data']['idx2'] = edge_i;
                // TODO should we take the average of the two weights? Could be more than two...
            }
            else {
                let weight = 1.0;
                if (has_weight_attrib) {
                    weight = __model__.modeldata.attribs.query.getAttribVal(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].EDGE, 'weight', edge_i);
                }
                else {
                    const c0 = __model__.modeldata.attribs.query.getPosiCoords(edge_posis_i[0]);
                    const c1 = __model__.modeldata.attribs.query.getPosiCoords(edge_posis_i[1]);
                    weight = Object(_libs_geom_distance__WEBPACK_IMPORTED_MODULE_4__["distance"])(c0, c1);
                }
                const obj = {
                    data: {
                        id: undir_edge_id,
                        source: edge_posis_i[0].toString(),
                        target: edge_posis_i[1].toString(),
                        weight: weight,
                        idx: edge_i,
                        idx2: null
                    }
                };
                map_edges_ab.set(undir_edge_id, obj);
                elements.push(obj);
            }
        }
    }
    return elements;
}
/**
 * Calculates the shortest path from every position in source, to the closest position in target.
 * ~
 * This differs from the 'analyze.ShortestPath()' function. If you specify multiple target positions,
 * for each cource position,
 * the 'analyze.ShortestPath()' function will calculate multiple shortest paths,
 * i.e. the shortest path to all targets.
 * This function will caculate just one shortest path,
 * i.e. the shortest path to the closest target.
 * ~
 * Paths are calculated through a network of connected edges.
 * For edges to be connected, vertices must be welded.
 * For example, if the network consists of multiple polylines, then the vertcies of those polylines must be welded.
 * ~
 * If 'directed' is selected, then the edge direction is taken into account. Each edge will be one-way.
 * If 'undirected' is selected, the edge direction is ignored. Each edge will be two-way.
 * ~
 * Each edge can be assigned a weight.
 * The shortest path is the path where the sum of the weights of the edges along the path is the minimum.
 * ~
 * By default, all edges are assigned a weight of 1.
 * Default weights can be overridden by creating a numeric attribute on edges call 'weight'.
 * ~
 * Returns a dictionary containing the shortes paths.
 * ~
 * If 'distances' is selected, the dictionary will contain one list:
 * 1) 'distances': a list of distances.
 * ~
 * If 'counts' is selected, the dictionary will contain four lists:
 * 1) 'posis': a list of positions traversed by the paths,
 * 2) 'posis_count': a list of numbers that count how often each position was traversed.
 * 3) 'edges': a list of edges traversed by the paths,
 * 4) 'edges_count': a list of numbers that count how often each edge was traversed.
 * ~
 * If 'paths' is selected, the dictionary will contain two lists of lists:
 * 1) 'posi_paths': a list of lists of positions, one list for each path.
 * 2) 'edge_paths': a list of lists of edges, one list for each path.
 * ~
 * If 'all' is selected, the dictionary will contain all lists just described.
 * ~
 * @param __model__
 * @param source Path source, a list of positions, or entities from which positions can be extracted.
 * @param target Path source, a list of positions, or entities from which positions can be extracted.
 * @param entities The network, edges, or entities from which edges can be extracted.
 * @param method Enum, the method to use, directed or undirected.
 * @param result Enum, the data to return, positions, edges, or both.
 * @returns A dictionary containing the results.
 */
function ClosestPath(__model__, source, target, entities, method, result) {
    source = source === null ? [] : Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_8__["arrMakeFlat"])(source);
    target = target === null ? [] : Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_8__["arrMakeFlat"])(target);
    entities = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_8__["arrMakeFlat"])(entities);
    // --- Error Check ---
    const fn_name = 'analyze.ClosestPath';
    let source_ents_arrs;
    let target_ents_arrs;
    let ents_arrs;
    if (__model__.debug) {
        source_ents_arrs = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])(fn_name, 'origins', source, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isId, _check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL], null);
        target_ents_arrs = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])(fn_name, 'destinations', target, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isId, _check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL], null);
        ents_arrs = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])(fn_name, 'entities', entities, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isId, _check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL], null);
    }
    else {
        // source_ents_arrs = splitIDs(fn_name, 'origins', source,
        //     [IDcheckObj.isID, IDcheckObj.isIDList], null) as TEntTypeIdx[];
        // target_ents_arrs = splitIDs(fn_name, 'destinations', target,
        //     [IDcheckObj.isID, IDcheckObj.isIDList], null) as TEntTypeIdx[];
        // ents_arrs = splitIDs(fn_name, 'entities', entities,
        //     [IDcheckObj.isID, IDcheckObj.isIDList], null) as TEntTypeIdx[];
        source_ents_arrs = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsBreak"])(source);
        target_ents_arrs = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsBreak"])(target);
        ents_arrs = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsBreak"])(entities);
    }
    // --- Error Check ---
    const directed = method === _EShortestPathMethod.DIRECTED ? true : false;
    let return_dists = true;
    let return_counts = true;
    let return_paths = true;
    switch (result) {
        case _EShortestPathResult.DISTS:
            return_paths = false;
            return_counts = false;
            break;
        case _EShortestPathResult.COUNTS:
            return_dists = false;
            return_paths = false;
            break;
        case _EShortestPathResult.PATHS:
            return_dists = false;
            return_counts = false;
            break;
        default:
            // all true
            break;
    }
    const source_posis_i = _getUniquePosis(__model__, source.length === 0 ? ents_arrs : source_ents_arrs);
    const target_posis_i = _getUniquePosis(__model__, target.length === 0 ? ents_arrs : target_ents_arrs);
    const cy_elems = _cytoscapeGetElements(__model__, ents_arrs, source_posis_i, target_posis_i, directed);
    // create the cytoscape object
    const cy = cytoscape__WEBPACK_IMPORTED_MODULE_12___default()({
        elements: cy_elems,
        headless: true,
    });
    const map_edges_i = new Map();
    const map_posis_i = new Map();
    const posi_paths = [];
    const edge_paths = [];
    const path_dists = [];
    for (const source_posi_i of source_posis_i) {
        const cy_source_elem = cy.getElementById(source_posi_i.toString());
        const dijkstra = cy.elements().dijkstra({
            root: cy_source_elem,
            weight: _cytoscapeWeightFn,
            directed: directed
        });
        let closest_target_posi_i = null;
        let closest_dist = Infinity;
        for (const target_posi_i of target_posis_i) {
            // find shortest path
            const dist = dijkstra.distanceTo(cy.getElementById(target_posi_i.toString()));
            if (dist < closest_dist) {
                closest_dist = dist;
                closest_target_posi_i = target_posi_i;
            }
        }
        if (closest_target_posi_i !== null) {
            // get shortest path
            const cy_path = dijkstra.pathTo(cy.getElementById(closest_target_posi_i.toString()));
            // get the data
            const posi_path = [];
            const edge_path = [];
            for (const cy_path_elem of cy_path.toArray()) {
                if (cy_path_elem.isEdge()) {
                    const edge_i = cy_path_elem.data('idx');
                    if (return_counts) {
                        if (!map_edges_i.has(edge_i)) {
                            map_edges_i.set(edge_i, 1);
                        }
                        else {
                            map_edges_i.set(edge_i, map_edges_i.get(edge_i) + 1);
                        }
                        if (!directed) {
                            const edge2_i = cy_path_elem.data('idx2');
                            if (edge2_i !== null) {
                                if (!map_edges_i.has(edge2_i)) {
                                    map_edges_i.set(edge2_i, 1);
                                }
                                else {
                                    map_edges_i.set(edge2_i, map_edges_i.get(edge2_i) + 1);
                                }
                            }
                        }
                    }
                    if (return_paths) {
                        edge_path.push(edge_i);
                    }
                }
                else {
                    const posi_i = cy_path_elem.data('idx');
                    if (return_counts) {
                        if (!map_posis_i.has(posi_i)) {
                            map_posis_i.set(posi_i, 1);
                        }
                        else {
                            map_posis_i.set(posi_i, map_posis_i.get(posi_i) + 1);
                        }
                    }
                    if (return_paths) {
                        posi_path.push(posi_i);
                    }
                }
            }
            if (return_paths) {
                edge_paths.push(edge_path);
                posi_paths.push(posi_path);
            }
            if (return_dists) {
                path_dists.push(closest_dist);
            }
        }
        else {
            if (return_paths) {
                edge_paths.push([]);
                posi_paths.push([]);
            }
            if (return_dists) {
                path_dists.push(1e8); // TODO, cannot pas Infinity due to JSON issues
            }
        }
    }
    const dict = {};
    if (return_dists) {
        dict.source_posis = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsMakeFromIndicies"])(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].POSI, source_posis_i);
        dict.distances = path_dists;
    }
    if (return_counts) {
        dict.edges = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsMakeFromIndicies"])(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].EDGE, Array.from(map_edges_i.keys()));
        dict.edges_count = Array.from(map_edges_i.values());
        dict.posis = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsMakeFromIndicies"])(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].POSI, Array.from(map_posis_i.keys()));
        dict.posis_count = Array.from(map_posis_i.values());
    }
    if (return_paths) {
        dict.edge_paths = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsMakeFromIndicies"])(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].EDGE, edge_paths);
        dict.posi_paths = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsMakeFromIndicies"])(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].POSI, posi_paths);
    }
    return dict;
}
// ================================================================================================
var _ECentralityMethod;
(function (_ECentralityMethod) {
    _ECentralityMethod["UNDIRECTED"] = "undirected";
    _ECentralityMethod["DIRECTED"] = "directed";
})(_ECentralityMethod || (_ECentralityMethod = {}));
function _cyGetPosisAndElements(__model__, ents_arr, posis_i, directed) {
    let has_weight_attrib = false;
    if (__model__.modeldata.attribs.query.hasAttrib(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].EDGE, 'weight')) {
        has_weight_attrib = __model__.modeldata.attribs.query.getAttribDataType(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].EDGE, 'weight') === _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EAttribDataTypeStrs"].NUMBER;
    }
    // edges, starts empty
    const set_edges_i = new Set();
    // posis, starts with posis_i
    const set_posis_i = new Set(posis_i);
    // network
    for (const [ent_type, ent_i] of ents_arr) {
        const n_edges_i = __model__.modeldata.geom.nav.navAnyToEdge(ent_type, ent_i);
        for (const edge_i of n_edges_i) {
            set_edges_i.add(edge_i);
        }
        const n_posis_i = __model__.modeldata.geom.nav.navAnyToPosi(ent_type, ent_i);
        for (const posi_i of n_posis_i) {
            set_posis_i.add(posi_i);
        }
    }
    // all unique posis
    const uniq_posis_i = Array.from(set_posis_i);
    // create elements
    const elements = [];
    for (const posi_i of uniq_posis_i) {
        elements.push({ data: { id: posi_i.toString(), idx: posi_i } });
    }
    if (directed) {
        // directed
        for (const edge_i of Array.from(set_edges_i)) {
            const edge_posis_i = __model__.modeldata.geom.nav.navAnyToPosi(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].EDGE, edge_i);
            let weight = 1.0;
            if (has_weight_attrib) {
                weight = __model__.modeldata.attribs.query.getAttribVal(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].EDGE, 'weight', edge_i);
            }
            else {
                // const c0: Txyz = __model__.modeldata.attribs.query.getPosiCoords(edge_posis_i[0]);
                // const c1: Txyz = __model__.modeldata.attribs.query.getPosiCoords(edge_posis_i[1]);
                weight = 1; // distance(c0, c1);
            }
            elements.push({ data: { id: 'e' + edge_i,
                    source: edge_posis_i[0].toString(), target: edge_posis_i[1].toString(), weight: weight, idx: edge_i } });
        }
    }
    else {
        // undirected
        const map_edges_ab = new Map();
        for (const edge_i of Array.from(set_edges_i)) {
            let edge_posis_i = __model__.modeldata.geom.nav.navAnyToPosi(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].EDGE, edge_i);
            edge_posis_i = edge_posis_i[0] < edge_posis_i[1] ? edge_posis_i : [edge_posis_i[1], edge_posis_i[0]];
            const undir_edge_id = 'e_' + edge_posis_i[0].toString() + '_' + edge_posis_i[1].toString();
            if (map_edges_ab.has(undir_edge_id)) {
                const obj = map_edges_ab.get(undir_edge_id);
                obj['data']['idx2'] = edge_i;
                // TODO should we take the average of the two weights? Could be more than two...
            }
            else {
                let weight = 1.0;
                if (has_weight_attrib) {
                    weight = __model__.modeldata.attribs.query.getAttribVal(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].EDGE, 'weight', edge_i);
                }
                else {
                    // const c0: Txyz = __model__.modeldata.attribs.query.getPosiCoords(edge_posis_i[0]);
                    // const c1: Txyz = __model__.modeldata.attribs.query.getPosiCoords(edge_posis_i[1]);
                    weight = 1; // distance(c0, c1);
                }
                const obj = {
                    data: {
                        id: undir_edge_id,
                        source: edge_posis_i[0].toString(),
                        target: edge_posis_i[1].toString(),
                        weight: weight,
                        idx: edge_i,
                        idx2: null
                    }
                };
                map_edges_ab.set(undir_edge_id, obj);
                elements.push(obj);
            }
        }
    }
    return [elements, uniq_posis_i];
}
// ================================================================================================
/**
 * Calculates degree centrality for positions in a netowrk. Values are normalized in the range 0 to 1.
 * ~
 * The network is defined by a set of connected edges, consisting of polylines and/or polygons.
 * For edges to be connected, vertices must be welded.
 * For example, if the network consists of multiple polylines, then the vertcies of those polylines must be welded.
 * ~
 * Degree centrality is based on the idea that the centrality of a position in a network is related to
 * the number of direct links that it has to other positions.
 * ~
 * If 'undirected' is selected,  degree centrality is calculated by summing up the weights
 * of all edges connected to a position.
 * If 'directed' is selected, then two types of centrality are calculated: incoming degree and
 * outgoing degree.
 * Incoming degree is calculated by summing up the weights of all incoming edges connected to a position.
 * Outgoing degree is calculated by summing up the weights of all outgoing edges connected to a position.
 * ~
 * Default weight is 1 for all edges. Weights can be specified using an attribute called 'weight' on edges.
 * ~
 * Returns a dictionary containing the results.
 * ~
 * If 'undirected' is selected, the dictionary will contain  the following:
 * 1) 'posis': a list of position IDs.
 * 2) 'degree': a list of numbers, the values for degree centrality.
 * ~
 * If 'directed' is selected, the dictionary will contain  the following:
 * 1) 'posis': a list of position IDs.
 * 2) 'indegree': a list of numbers, the values for incoming degree centrality.
 * 3) 'outdegree': a list of numbers, the values for outgoing degree centrality.
 * ~
 * @param __model__
 * @param source A list of positions, or entities from which positions can be extracted.
 * These positions should be part of the network.
 * @param entities The network, edges, or entities from which edges can be extracted.
 * @param alpha The alpha value for the centrality calculation, ranging on [0, 1]. With value 0,
 * disregards edge weights and solely uses number of edges in the centrality calculation. With value 1,
 * disregards number of edges and solely uses the edge weights in the centrality calculation.
 * @param method Enum, the method to use, directed or undirected.
 * @returns A dictionary containing the results.
 */
function Degree(__model__, source, entities, alpha, method) {
    // source posis and network entities
    if (source === null) {
        source = [];
    }
    else {
        source = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_8__["arrMakeFlat"])(source);
    }
    entities = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_8__["arrMakeFlat"])(entities);
    // --- Error Check ---
    const fn_name = 'analyze.Degree';
    let source_ents_arrs = [];
    let ents_arrs;
    if (__model__.debug) {
        if (source.length > 0) {
            source_ents_arrs = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])(fn_name, 'source', source, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isId, _check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL], null);
        }
        ents_arrs = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])(fn_name, 'entities', entities, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isId, _check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL], null);
    }
    else {
        // if (source.length > 0) {
        //     source_ents_arrs = splitIDs(fn_name, 'source', source,
        //         [IDcheckObj.isID, IDcheckObj.isIDList], null) as TEntTypeIdx[];
        // }
        // ents_arrs = splitIDs(fn_name, 'entities', entities,
        //     [IDcheckObj.isID, IDcheckObj.isIDList], null) as TEntTypeIdx[];
        source_ents_arrs = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsBreak"])(source);
        ents_arrs = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsBreak"])(entities);
    }
    // --- Error Check ---
    const directed = method === _ECentralityMethod.DIRECTED ? true : false;
    const source_posis_i = _getUniquePosis(__model__, source_ents_arrs);
    // TODO deal with source === null
    const [elements, graph_posis_i] = _cyGetPosisAndElements(__model__, ents_arrs, source_posis_i, directed);
    // create the cytoscape object
    const cy_network = cytoscape__WEBPACK_IMPORTED_MODULE_12___default()({
        elements: elements,
        headless: true,
    });
    const posis_i = source_ents_arrs.length === 0 ? graph_posis_i : source_posis_i;
    if (directed) {
        return _centralityDegreeDirected(posis_i, cy_network, alpha);
    }
    else {
        return _centralityDegreeUndirected(posis_i, cy_network, alpha);
    }
}
function _centralityDegreeDirected(posis_i, cy_network, alpha) {
    const indegree = [];
    const outdegree = [];
    const cy_centrality = cy_network.elements().degreeCentralityNormalized({
        weight: _cytoscapeWeightFn,
        alpha: alpha,
        directed: true
    });
    for (const posi_i of posis_i) {
        const source_elem = cy_network.getElementById(posi_i.toString());
        indegree.push(cy_centrality.indegree(source_elem));
        outdegree.push(cy_centrality.outdegree(source_elem));
    }
    return {
        'posis': Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsMakeFromIndicies"])(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].POSI, posis_i),
        'indegree': indegree,
        'outdegree': outdegree
    };
}
function _centralityDegreeUndirected(posis_i, cy_network, alpha) {
    const degree = [];
    const cy_centrality = cy_network.elements().degreeCentralityNormalized({
        weight: _cytoscapeWeightFn,
        alpha: alpha,
        directed: false
    });
    for (const posi_i of posis_i) {
        const source_elem = cy_network.getElementById(posi_i.toString());
        degree.push(cy_centrality.degree(source_elem));
    }
    return {
        'posis': Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsMakeFromIndicies"])(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].POSI, posis_i),
        'degree': degree
    };
}
// ================================================================================================
var _ECentralityType;
(function (_ECentralityType) {
    _ECentralityType["BETWEENNESS"] = "betweenness";
    _ECentralityType["CLOSENESS"] = "closeness";
    _ECentralityType["HARMONIC"] = "harmonic";
})(_ECentralityType || (_ECentralityType = {}));
/**
 * Calculates betweenness, closeness, and harmonic centrality
 * for positions in a netowrk. Values are normalized in the range 0 to 1.
 * ~
 * The network is defined by a set of connected edges, consisting of polylines and/or polygons.
 * For edges to be connected, vertices must be welded.
 * For example, if the network consists of multiple polylines, then the vertcies of those polylines must be welded.
 * ~
 * Centralities are calculate based on distances between positions.
 * The distance between two positions is the shortest path between those positions.
 * The shortest path is the path where the sum of the weights of the edges along the path is the minimum.
 * ~
 * Default weight is 1 for all edges. Weights can be specified using an attribute called 'weight' on edges.
 * ~
 * Closeness centrality is calculated by inverting the sum of the distances to all other positions.
 * ~
 * Harmonic centrality is calculated by summing up the inverted distances to all other positions.
 * ~
 * Betweenness centrality os calculated in two steps.
 * First, the shortest path between every pair of nodes is calculated.
 * Second, the betweenness centrality of each node is then the total number of times the node is traversed
 * by the shortest paths.
 * ~
 * For closeness centrality, the network is first split up into connected sub-networks.
 * This is because closeness centrality cannot be calculated on networks that are not fully connected.
 * The closeness centrality is then calculated for each sub-network seperately.
 * ~
 * For harmonic centrality, care must be taken when defining custom weights.
 * Weight with zero values or very small values will result in errors or will distort the results.
 * This is due to the inversion operation: 1 / weight.
 * ~
 * Returns a dictionary containing the results.
 * ~
 * 1) 'posis': a list of position IDs.
 * 2) 'centrality': a list of numbers, the values for centrality, either betweenness, closeness, or harmonic.
 * ~
 * @param __model__
 * @param source A list of positions, or entities from which positions can be extracted.
 * These positions should be part of the network.
 * @param entities The network, edges, or entities from which edges can be extracted.
 * @param method Enum, the method to use, directed or undirected.
 * @param cen_type Enum, the data to return, positions, edges, or both.
 * @returns A list of centrality values, between 0 and 1.
 */
function Centrality(__model__, source, entities, method, cen_type) {
    // source posis and network entities
    if (source === null) {
        source = [];
    }
    else {
        source = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_8__["arrMakeFlat"])(source);
    }
    entities = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_8__["arrMakeFlat"])(entities);
    // --- Error Check ---
    const fn_name = 'analyze.Centrality';
    let source_ents_arrs = [];
    let ents_arrs;
    if (__model__.debug) {
        if (source.length > 0) {
            source_ents_arrs = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])(fn_name, 'source', source, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isId, _check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL], null);
        }
        ents_arrs = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])(fn_name, 'entities', entities, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isId, _check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL], null);
    }
    else {
        // if (source.length > 0) {
        //     source_ents_arrs = splitIDs(fn_name, 'source', source,
        //         [IDcheckObj.isID, IDcheckObj.isIDList], null) as TEntTypeIdx[];
        // }
        // ents_arrs = splitIDs(fn_name, 'entities', entities,
        //     [IDcheckObj.isID, IDcheckObj.isIDList], null) as TEntTypeIdx[];
        source_ents_arrs = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsBreak"])(source);
        ents_arrs = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsBreak"])(entities);
    }
    // --- Error Check ---
    const directed = method === _ECentralityMethod.DIRECTED ? true : false;
    const source_posis_i = _getUniquePosis(__model__, source_ents_arrs);
    // TODO deal with source === null
    const [elements, graph_posis_i] = _cyGetPosisAndElements(__model__, ents_arrs, source_posis_i, directed);
    // create the cytoscape object
    const cy_network = cytoscape__WEBPACK_IMPORTED_MODULE_12___default()({
        elements: elements,
        headless: true,
    });
    // calculate the centrality
    const posis_i = source_ents_arrs.length === 0 ? graph_posis_i : source_posis_i;
    switch (cen_type) {
        case _ECentralityType.CLOSENESS:
            return _centralityCloseness(posis_i, cy_network, directed);
        case _ECentralityType.HARMONIC:
            return _centralityHarmonic(posis_i, cy_network, directed);
        case _ECentralityType.BETWEENNESS:
            return _centralityBetweenness(posis_i, cy_network, directed);
        default:
            throw new Error('Centrality type not recognised.');
    }
}
function _centralityCloseness(posis_i, cy_network, directed) {
    const results = [];
    const result_posis_i = [];
    const comps = [];
    const cy_colls = cy_network.elements().components();
    cy_colls.sort((a, b) => b.length - a.length);
    for (const cy_coll of cy_colls) {
        const comp = [];
        const cy_centrality = cy_coll.closenessCentralityNormalized({
            weight: _cytoscapeWeightFn,
            harmonic: false,
            directed: directed
        });
        for (const posi_i of posis_i) {
            const source_elem = cy_coll.getElementById(posi_i.toString());
            if (source_elem.length === 0) {
                continue;
            }
            const result = cy_centrality.closeness(source_elem);
            if (isNaN(result)) {
                throw new Error('Error calculating closeness centrality.');
            }
            result_posis_i.push(posi_i);
            comp.push(posi_i);
            results.push(result);
        }
        comps.push(comp);
    }
    return {
        'posis': Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsMakeFromIndicies"])(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].POSI, result_posis_i),
        'centrality': results
    };
}
function _centralityHarmonic(posis_i, cy_network, directed) {
    const results = [];
    const cy_centrality = cy_network.elements().closenessCentralityNormalized({
        weight: _cytoscapeWeightFn,
        harmonic: true,
        directed: directed
    });
    for (const posi_i of posis_i) {
        const source_elem = cy_network.getElementById(posi_i.toString());
        if (source_elem.length === 0) {
            continue;
        }
        const result = cy_centrality.closeness(source_elem);
        if (isNaN(result)) {
            throw new Error('Error calculating harmonic centrality.');
        }
        results.push(result);
    }
    return {
        'posis': Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsMakeFromIndicies"])(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].POSI, posis_i),
        'centrality': results
    };
}
function _centralityBetweenness(posis_i, cy_network, directed) {
    const results = [];
    const cy_centrality = cy_network.elements().betweennessCentrality({
        weight: _cytoscapeWeightFn,
        directed: directed
    });
    for (const posi_i of posis_i) {
        const source_elem = cy_network.getElementById(posi_i.toString());
        const result = cy_centrality.betweennessNormalized(source_elem);
        if (isNaN(result)) {
            throw new Error('Error calculating betweenness centrality.');
        }
        results.push(result);
    }
    return {
        'posis': Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsMakeFromIndicies"])(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].POSI, posis_i),
        'centrality': results
    };
}


/***/ }),

/***/ "./src/assets/core/modules/basic/attrib.ts":
/*!*************************************************!*\
  !*** ./src/assets/core/modules/basic/attrib.ts ***!
  \*************************************************/
/*! exports provided: _EEntType, _EEntTypeAndMod, _EAttribPushTarget, _EDataType, Set, _ESet, Get, Add, Delete, Rename, Push, _EPushMethodSel */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_EEntType", function() { return _EEntType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_EEntTypeAndMod", function() { return _EEntTypeAndMod; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_EAttribPushTarget", function() { return _EAttribPushTarget; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_EDataType", function() { return _EDataType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Set", function() { return Set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_ESet", function() { return _ESet; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Get", function() { return Get; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Add", function() { return Add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Delete", function() { return Delete; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Rename", function() { return Rename; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Push", function() { return Push; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_EPushMethodSel", function() { return _EPushMethodSel; });
/* harmony import */ var _check_ids__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_check_ids */ "./src/assets/core/modules/_check_ids.ts");
/* harmony import */ var _check_attribs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_check_attribs */ "./src/assets/core/modules/_check_attribs.ts");
/* harmony import */ var underscore__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! underscore */ "./node_modules/underscore/modules/index-all.js");
/* harmony import */ var _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @libs/geo-info/common */ "./src/assets/libs/geo-info/common.ts");
/* harmony import */ var _libs_geo_info_id__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @libs/geo-info/id */ "./src/assets/libs/geo-info/id.ts");
/**
 * The `attrib` module has functions for working with attributes in teh model.
 * Note that attributes can also be set and retrieved using the "@" symbol.
 * ~
 * ~
 */
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};
/**
 *
 */





// ================================================================================================
var _EEntType;
(function (_EEntType) {
    _EEntType["POSI"] = "ps";
    _EEntType["VERT"] = "_v";
    _EEntType["EDGE"] = "_e";
    _EEntType["WIRE"] = "_w";
    _EEntType["FACE"] = "_f";
    _EEntType["POINT"] = "pt";
    _EEntType["PLINE"] = "pl";
    _EEntType["PGON"] = "pg";
    _EEntType["COLL"] = "co";
})(_EEntType || (_EEntType = {}));
var _EEntTypeAndMod;
(function (_EEntTypeAndMod) {
    _EEntTypeAndMod["POSI"] = "ps";
    _EEntTypeAndMod["VERT"] = "_v";
    _EEntTypeAndMod["EDGE"] = "_e";
    _EEntTypeAndMod["WIRE"] = "_w";
    _EEntTypeAndMod["FACE"] = "_f";
    _EEntTypeAndMod["POINT"] = "pt";
    _EEntTypeAndMod["PLINE"] = "pl";
    _EEntTypeAndMod["PGON"] = "pg";
    _EEntTypeAndMod["COLL"] = "co";
    _EEntTypeAndMod["MOD"] = "mo";
})(_EEntTypeAndMod || (_EEntTypeAndMod = {}));
var _EAttribPushTarget;
(function (_EAttribPushTarget) {
    _EAttribPushTarget["POSI"] = "ps";
    _EAttribPushTarget["VERT"] = "_v";
    _EAttribPushTarget["EDGE"] = "_e";
    _EAttribPushTarget["WIRE"] = "_w";
    _EAttribPushTarget["FACE"] = "_f";
    _EAttribPushTarget["POINT"] = "pt";
    _EAttribPushTarget["PLINE"] = "pl";
    _EAttribPushTarget["PGON"] = "pg";
    _EAttribPushTarget["COLL"] = "co";
    _EAttribPushTarget["COLLP"] = "cop";
    _EAttribPushTarget["COLLC"] = "coc";
    _EAttribPushTarget["MOD"] = "mo";
})(_EAttribPushTarget || (_EAttribPushTarget = {}));
var _EDataType;
(function (_EDataType) {
    _EDataType["NUMBER"] = "number";
    _EDataType["STRING"] = "string";
    _EDataType["BOOLEAN"] = "boolean";
    _EDataType["LIST"] = "list";
    _EDataType["DICT"] = "dict";
})(_EDataType || (_EDataType = {}));
function _getEntTypeFromStr(ent_type_str) {
    switch (ent_type_str) {
        case _EEntTypeAndMod.POSI:
            return _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].POSI;
        case _EEntTypeAndMod.VERT:
            return _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].VERT;
        case _EEntTypeAndMod.EDGE:
            return _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].EDGE;
        case _EEntTypeAndMod.WIRE:
            return _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].WIRE;
        case _EEntTypeAndMod.FACE:
            return _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].FACE;
        case _EEntTypeAndMod.POINT:
            return _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].POINT;
        case _EEntTypeAndMod.PLINE:
            return _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].PLINE;
        case _EEntTypeAndMod.PGON:
            return _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].PGON;
        case _EEntTypeAndMod.COLL:
            return _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].COLL;
        case _EEntTypeAndMod.MOD:
            return _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].MOD;
        default:
            break;
    }
}
function _getAttribPushTarget(ent_type_str) {
    switch (ent_type_str) {
        case _EAttribPushTarget.POSI:
            return _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].POSI;
        case _EAttribPushTarget.VERT:
            return _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].VERT;
        case _EAttribPushTarget.EDGE:
            return _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].EDGE;
        case _EAttribPushTarget.WIRE:
            return _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].WIRE;
        case _EAttribPushTarget.FACE:
            return _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].FACE;
        case _EAttribPushTarget.POINT:
            return _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].POINT;
        case _EAttribPushTarget.PLINE:
            return _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].PLINE;
        case _EAttribPushTarget.PGON:
            return _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].PGON;
        case _EAttribPushTarget.COLL:
            return _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].COLL;
        case _EAttribPushTarget.COLLC:
            return 'coll_children';
        case _EAttribPushTarget.COLLP:
            return 'coll_parent';
        case _EAttribPushTarget.MOD:
            return _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].MOD;
        default:
            break;
    }
}
// ================================================================================================
/**
 * Set an attribute value for one or more entities.
 * ~
 * If entities is null, then model level attributes will be set.
 * ~
 * @param __model__
 * @param entities Entities, the entities to set the attribute value for.
 * @param attrib The attribute. Can be `name`, `[name, index]`, or `[name, key]`.
 * @param value The attribute value, or list of values.
 * @param method Enum
 */
function Set(__model__, entities, attrib, value, method) {
    // if entities is null, then we are setting model attributes
    // @ts-ignore
    if (entities !== null && Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_4__["getArrDepth"])(entities) === 2) {
        entities = underscore__WEBPACK_IMPORTED_MODULE_2__["default"].flatten(entities);
    }
    // --- Error Check ---
    const fn_name = 'attrib.Set';
    let ents_arr = null;
    let attrib_name;
    let attrib_idx_key;
    if (__model__.debug) {
        if (value === undefined) {
            throw new Error(fn_name + ': value is undefined');
        }
        if (entities !== null && entities !== undefined) {
            ents_arr = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])(fn_name, 'entities', entities, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isId, _check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL], null);
        }
        [attrib_name, attrib_idx_key] = Object(_check_attribs__WEBPACK_IMPORTED_MODULE_1__["checkAttribNameIdxKey"])(fn_name, attrib);
        Object(_check_attribs__WEBPACK_IMPORTED_MODULE_1__["checkAttribName"])(fn_name, attrib_name);
    }
    else {
        if (entities !== null && entities !== undefined) {
            // ents_arr = splitIDs(fn_name, 'entities', entities,
            // [IDcheckObj.isID, IDcheckObj.isIDList], null) as TEntTypeIdx|TEntTypeIdx[];
            ents_arr = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_4__["idsBreak"])(entities);
        }
        [attrib_name, attrib_idx_key] = Object(_check_attribs__WEBPACK_IMPORTED_MODULE_1__["splitAttribNameIdxKey"])(fn_name, attrib);
    }
    // --- Error Check ---
    _setAttrib(__model__, ents_arr, attrib_name, value, attrib_idx_key, method);
}
var _ESet;
(function (_ESet) {
    _ESet["ONE_VALUE"] = "one_value";
    _ESet["MANY_VALUES"] = "many_values";
})(_ESet || (_ESet = {}));
function _setAttrib(__model__, ents_arr, attrib_name, attrib_values, idx_or_key, method) {
    // check the ents_arr
    if (ents_arr === null) {
        _setModelAttrib(__model__, attrib_name, attrib_values, idx_or_key);
        return;
    }
    else if (ents_arr.length === 0) {
        return;
    }
    else if (Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_4__["getArrDepth"])(ents_arr) === 1) {
        ents_arr = [ents_arr];
    }
    ents_arr = ents_arr;
    // all ents get the same attribute value
    if (method === _ESet.MANY_VALUES) {
        _setEachEntDifferentAttribValue(__model__, ents_arr, attrib_name, attrib_values, idx_or_key);
    }
    else {
        _setEachEntSameAttribValue(__model__, ents_arr, attrib_name, attrib_values, idx_or_key);
    }
    return;
}
function _setModelAttrib(__model__, attrib_name, attrib_value, idx_or_key) {
    if (typeof idx_or_key === 'number') {
        __model__.modeldata.attribs.add.setModelAttribListIdxVal(attrib_name, idx_or_key, attrib_value);
    }
    if (typeof idx_or_key === 'string') {
        __model__.modeldata.attribs.add.setModelAttribDictKeyVal(attrib_name, idx_or_key, attrib_value);
    }
    else {
        __model__.modeldata.attribs.add.setModelAttribVal(attrib_name, attrib_value);
    }
}
function _setEachEntDifferentAttribValue(__model__, ents_arr, attrib_name, attrib_values, idx_or_key) {
    if (ents_arr.length !== attrib_values.length) {
        throw new Error('If multiple entities are being set to multiple values, then the number of entities must match the number of values.');
    }
    const ent_type = ents_arr[0][0];
    const ents_i = _getEntsIndices(__model__, ents_arr);
    for (let i = 0; i < ents_arr.length; i++) {
        // --- Error Check ---
        if (__model__.debug) {
            const fn_name = 'entities@' + attrib_name;
            Object(_check_attribs__WEBPACK_IMPORTED_MODULE_1__["checkAttribValue"])(fn_name, attrib_values[i]);
            if (idx_or_key !== null) {
                Object(_check_attribs__WEBPACK_IMPORTED_MODULE_1__["checkAttribIdxKey"])(fn_name, idx_or_key);
            }
        }
        // --- Error Check ---
        if (typeof idx_or_key === 'number') {
            __model__.modeldata.attribs.add.setEntAttribListIdxVal(ent_type, ents_i[i], attrib_name, idx_or_key, attrib_values[i]);
        }
        if (typeof idx_or_key === 'string') {
            __model__.modeldata.attribs.add.setEntAttribDictKeyVal(ent_type, ents_i[i], attrib_name, idx_or_key, attrib_values[i]);
        }
        else {
            __model__.modeldata.attribs.add.setEntAttribVal(ent_type, ents_i[i], attrib_name, attrib_values[i]);
        }
    }
}
function _setEachEntSameAttribValue(__model__, ents_arr, attrib_name, attrib_value, idx_or_key) {
    // --- Error Check ---
    if (__model__.debug) {
        const fn_name = 'entities@' + attrib_name;
        Object(_check_attribs__WEBPACK_IMPORTED_MODULE_1__["checkAttribValue"])(fn_name, attrib_value);
    }
    // --- Error Check ---
    const ent_type = ents_arr[0][0];
    const ents_i = _getEntsIndices(__model__, ents_arr);
    if (typeof idx_or_key === 'number') {
        __model__.modeldata.attribs.add.setEntAttribListIdxVal(ent_type, ents_i, attrib_name, idx_or_key, attrib_value);
    }
    else if (typeof idx_or_key === 'string') {
        __model__.modeldata.attribs.add.setEntAttribDictKeyVal(ent_type, ents_i, attrib_name, idx_or_key, attrib_value);
    }
    else {
        __model__.modeldata.attribs.add.setEntAttribVal(ent_type, ents_i, attrib_name, attrib_value);
    }
}
function _getEntsIndices(__model__, ents_arr) {
    const ent_type = ents_arr[0][0];
    const ents_i = [];
    for (let i = 0; i < ents_arr.length; i++) {
        if (ents_arr[i][0] !== ent_type) {
            throw new Error('If an attribute is being set for multiple entities, then they must all be of the same type.');
        }
        ents_i.push(ents_arr[i][1]);
    }
    return ents_i;
}
// ================================================================================================
/**
 * Get attribute values for one or more entities.
 * ~
 * If entities is null, then model level attributes will be returned.
 * ~
 * @param __model__
 * @param entities Entities, the entities to get the attribute values for.
 * @param attrib The attribute. Can be `name`, `[name, index]`, or `[name, key]`.
 * @returns One attribute value, or a list of attribute values.
 */
function Get(__model__, entities, attrib) {
    // @ts-ignore
    if (entities !== null && Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_4__["getArrDepth"])(entities) === 2) {
        entities = underscore__WEBPACK_IMPORTED_MODULE_2__["default"].flatten(entities);
    }
    // --- Error Check ---
    let ents_arr = null;
    let attrib_name;
    let attrib_idx_key;
    const fn_name = 'attrib.Get';
    if (__model__.debug) {
        if (entities !== null && entities !== undefined) {
            ents_arr = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])(fn_name, 'entities', entities, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isId, _check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL], null);
        }
        [attrib_name, attrib_idx_key] = Object(_check_attribs__WEBPACK_IMPORTED_MODULE_1__["checkAttribNameIdxKey"])(fn_name, attrib);
        Object(_check_attribs__WEBPACK_IMPORTED_MODULE_1__["checkAttribName"])(fn_name, attrib_name);
    }
    else {
        if (entities !== null && entities !== undefined) {
            // ents_arr = splitIDs(fn_name, 'entities', entities,
            // [IDcheckObj.isID, IDcheckObj.isIDList], null) as TEntTypeIdx|TEntTypeIdx[];
            ents_arr = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_4__["idsBreak"])(entities);
        }
        [attrib_name, attrib_idx_key] = Object(_check_attribs__WEBPACK_IMPORTED_MODULE_1__["splitAttribNameIdxKey"])(fn_name, attrib);
    }
    // --- Error Check ---
    return _get(__model__, ents_arr, attrib_name, attrib_idx_key);
}
function _get(__model__, ents_arr, attrib_name, attrib_idx_key) {
    const has_idx_key = attrib_idx_key !== null && attrib_idx_key !== undefined;
    if (ents_arr === null) {
        // get the attrib values from the model
        if (typeof attrib_idx_key === 'number') {
            return __model__.modeldata.attribs.query.getModelAttribListIdxVal(attrib_name, attrib_idx_key);
        }
        else if (typeof attrib_idx_key === 'string') {
            return __model__.modeldata.attribs.query.getModelAttribDictKeyVal(attrib_name, attrib_idx_key);
        }
        else {
            return __model__.modeldata.attribs.query.getModelAttribVal(attrib_name);
        }
    }
    else if (ents_arr.length === 0) {
        return [];
    }
    else if (Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_4__["getArrDepth"])(ents_arr) === 1) {
        const [ent_type, ent_i] = ents_arr;
        // check if this is ID
        if (attrib_name === '_id') {
            if (has_idx_key) {
                throw new Error('The "_id" attribute does have an index.');
            }
            return _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntTypeStr"][ent_type] + ent_i;
        }
        // get the attrib values from the ents
        if (typeof attrib_idx_key === 'number') {
            return __model__.modeldata.attribs.query.getAttribListIdxVal(ent_type, attrib_name, ent_i, attrib_idx_key);
        }
        else if (typeof attrib_idx_key === 'string') {
            return __model__.modeldata.attribs.query.getAttribDictKeyVal(ent_type, attrib_name, ent_i, attrib_idx_key);
        }
        else {
            return __model__.modeldata.attribs.query.getAttribVal(ent_type, attrib_name, ent_i);
        }
    }
    else {
        return ents_arr.map(ent_arr => _get(__model__, ent_arr, attrib_name, attrib_idx_key));
    }
}
// ================================================================================================
/**
 * Add one or more attributes to the model.
 * The attribute will appear as a new column in the attribute table.
 * All attribute values will be set to null.
 * ~
 * @param __model__
 * @param ent_type_sel Enum, the attribute entity type.
 * @param data_type_sel Enum, the data type for this attribute
 * @param attribs A single attribute name, or a list of attribute names.
 */
function Add(__model__, ent_type_sel, data_type_sel, attribs) {
    // --- Error Check ---
    const fn_name = 'attrib.Add';
    const arg_name = 'ent_type_sel';
    let ent_type;
    if (__model__.debug) {
        if (ent_type_sel === 'ps' && attribs === 'xyz') {
            throw new Error(fn_name + ': ' + arg_name + ' The xyz attribute already exists.');
        }
        // convert the ent_type_str to an ent_type
        ent_type = _getEntTypeFromStr(ent_type_sel);
        if (ent_type === undefined) {
            throw new Error(fn_name + ': ' + arg_name + ' is not one of the following valid types - ' +
                'ps, _v, _e, _w, _f, pt, pl, pg, co, mo.');
        }
        // create an array of attrib names
        if (!Array.isArray(attribs)) {
            attribs = [attribs];
        }
        attribs = attribs;
        for (const attrib of attribs) {
            Object(_check_attribs__WEBPACK_IMPORTED_MODULE_1__["checkAttribName"])(fn_name, attrib);
        }
    }
    else {
        // convert the ent_type_str to an ent_type
        ent_type = _getEntTypeFromStr(ent_type_sel);
        // create an array of attrib names
        attribs = attribs;
    }
    // --- Error Check ---
    // set the data type
    let data_type = null;
    switch (data_type_sel) {
        case _EDataType.NUMBER:
            data_type = _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EAttribDataTypeStrs"].NUMBER;
            break;
        case _EDataType.STRING:
            data_type = _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EAttribDataTypeStrs"].STRING;
            break;
        case _EDataType.BOOLEAN:
            data_type = _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EAttribDataTypeStrs"].BOOLEAN;
            break;
        case _EDataType.LIST:
            data_type = _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EAttribDataTypeStrs"].LIST;
            break;
        case _EDataType.DICT:
            data_type = _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EAttribDataTypeStrs"].DICT;
            break;
        default:
            throw new Error('Data type not recognised.');
            break;
    }
    // create the attribute
    for (const attrib of attribs) {
        __model__.modeldata.attribs.add.addAttrib(ent_type, attrib, data_type);
    }
}
// ================================================================================================
/**
 * Delete one or more attributes from the model.
 * The column in the attribute table will be deleted.
 * All values will also be deleted.
 * ~
 * @param __model__
 * @param ent_type_sel Enum, the attribute entity type.
 * @param attribs A single attribute name, or a list of attribute names. In 'null' all attributes will be deleted.
 */
function Delete(__model__, ent_type_sel, attribs) {
    // --- Error Check ---
    const fn_name = 'attrib.Delete';
    const arg_name = 'ent_type_sel';
    let ent_type;
    if (__model__.debug) {
        if (ent_type_sel === 'ps' && attribs === 'xyz') {
            throw new Error(fn_name + ': ' + arg_name + ' Deleting xyz attribute is not allowed.');
        }
        // convert the ent_type_str to an ent_type
        ent_type = _getEntTypeFromStr(ent_type_sel);
        if (ent_type === undefined) {
            throw new Error(fn_name + ': ' + arg_name + ' is not one of the following valid types - ' +
                'ps, _v, _e, _w, _f, pt, pl, pg, co, mo.');
        }
        // create an array of attrib names
        if (attribs === null) {
            attribs = __model__.modeldata.attribs.query.getAttribNamesUser(ent_type);
        }
        if (!Array.isArray(attribs)) {
            attribs = [attribs];
        }
        attribs = attribs;
        for (const attrib of attribs) {
            Object(_check_attribs__WEBPACK_IMPORTED_MODULE_1__["checkAttribName"])(fn_name, attrib);
        }
    }
    else {
        // convert the ent_type_str to an ent_type
        ent_type = _getEntTypeFromStr(ent_type_sel);
        // create an array of attrib names
        if (attribs === null) {
            attribs = __model__.modeldata.attribs.query.getAttribNamesUser(ent_type);
        }
        if (!Array.isArray(attribs)) {
            attribs = [attribs];
        }
        attribs = attribs;
    }
    // --- Error Check ---
    // delete the attributes
    for (const attrib of attribs) {
        __model__.modeldata.attribs.modify.delAttrib(ent_type, attrib);
    }
}
// ================================================================================================
/**
 * Rename an attribute in the model.
 * The header for column in the attribute table will be renamed.
 * All values will remain the same.
 * ~
 * @param __model__
 * @param ent_type_sel Enum, the attribute entity type.
 * @param old_attrib The old attribute name.
 * @param new_attrib The old attribute name.
 */
function Rename(__model__, ent_type_sel, old_attrib, new_attrib) {
    if (ent_type_sel === 'ps' && old_attrib === 'xyz') {
        return;
    }
    // --- Error Check ---
    const fn_name = 'attrib.Rename';
    const arg_name = 'ent_type_sel';
    const ent_type = _getEntTypeFromStr(ent_type_sel);
    if (__model__.debug) {
        Object(_check_attribs__WEBPACK_IMPORTED_MODULE_1__["checkAttribName"])(fn_name, old_attrib);
        Object(_check_attribs__WEBPACK_IMPORTED_MODULE_1__["checkAttribName"])(fn_name, new_attrib);
        // --- Error Check ---
        // convert the ent_type_str to an ent_type
        if (ent_type === undefined) {
            throw new Error(fn_name + ': ' + arg_name + ' is not one of the following valid types - ' +
                'ps, _v, _e, _w, _f, pt, pl, pg, co, mo.');
        }
    }
    // create the attribute
    __model__.modeldata.attribs.modify.renameAttrib(ent_type, old_attrib, new_attrib);
}
// ================================================================================================
/**
 * Push attributes up or down the hierarchy. The original attribute is not changed.
 * ~
 * @param __model__
 * @param entities Entities, the entities to push the attribute values for.
 * @param attrib The attribute. Can be `name`, `[name, index_or_key]`,
 * `[source_name, source_index_or_key, target_name]` or `[source_name, source_index_or_key, target_name, target_index_or_key]`.
 * @param ent_type_sel Enum, the target entity type where the attribute values should be pushed to.
 * @param method_sel Enum, the method for aggregating attribute values in cases where aggregation is necessary.
 */
function Push(__model__, entities, attrib, ent_type_sel, method_sel) {
    if (entities !== null) {
        const depth = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_4__["getArrDepth"])(entities);
        if (depth === 0) {
            entities = [entities];
        }
        else if (depth === 2) {
            // @ts-ignore
            entities = underscore__WEBPACK_IMPORTED_MODULE_2__["default"].flatten(entities);
        }
    }
    // --- Error Check ---
    const fn_name = 'attrib.Push';
    let ents_arr = null;
    let source_attrib_name;
    let source_attrib_idx_key;
    let target_attrib_name;
    let target_attrib_idx_key;
    let source_ent_type;
    const indices = [];
    let target;
    let source_attrib = null;
    let target_attrib = null;
    if (Array.isArray(attrib)) {
        // set source attrib
        source_attrib = [
            attrib[0],
            (attrib.length > 1 ? attrib[1] : null)
        ];
        // set target attrib
        target_attrib = [
            (attrib.length > 2 ? attrib[2] : attrib[0]),
            (attrib.length > 3 ? attrib[3] : null)
        ];
    }
    else {
        source_attrib = [attrib, null];
        target_attrib = [attrib, null];
    }
    if (__model__.debug) {
        if (entities !== null && entities !== undefined) {
            ents_arr = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])(fn_name, 'entities', entities, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isId, _check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL], null);
        }
        [source_attrib_name, source_attrib_idx_key] = Object(_check_attribs__WEBPACK_IMPORTED_MODULE_1__["checkAttribNameIdxKey"])(fn_name, source_attrib);
        [target_attrib_name, target_attrib_idx_key] = Object(_check_attribs__WEBPACK_IMPORTED_MODULE_1__["checkAttribNameIdxKey"])(fn_name, target_attrib);
        // --- Error Check ---
        // get the source ent_type and indices
        source_ent_type = ents_arr[0][0];
        for (const ent_arr of ents_arr) {
            if (ent_arr[0] !== source_ent_type) {
                throw new Error('The entities must all be of the same type.');
            }
            indices.push(ent_arr[1]);
        }
        // check the names
        Object(_check_attribs__WEBPACK_IMPORTED_MODULE_1__["checkAttribName"])(fn_name, source_attrib_name);
        Object(_check_attribs__WEBPACK_IMPORTED_MODULE_1__["checkAttribName"])(fn_name, target_attrib_name);
        // get the target ent_type
        target = _getAttribPushTarget(ent_type_sel);
        if (source_ent_type === target) {
            throw new Error('The new attribute is at the same level as the existing attribute.');
        }
    }
    else {
        if (entities !== null && entities !== undefined) {
            // ents_arr = splitIDs(fn_name, 'entities', entities,
            // [IDcheckObj.isID, IDcheckObj.isIDList], null) as TEntTypeIdx[];
            ents_arr = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_4__["idsBreak"])(entities);
        }
        [source_attrib_name, source_attrib_idx_key] = Object(_check_attribs__WEBPACK_IMPORTED_MODULE_1__["splitAttribNameIdxKey"])(fn_name, source_attrib);
        [target_attrib_name, target_attrib_idx_key] = Object(_check_attribs__WEBPACK_IMPORTED_MODULE_1__["splitAttribNameIdxKey"])(fn_name, target_attrib);
        // get the source ent_type and indices
        source_ent_type = ents_arr[0][0];
        for (const ent_arr of ents_arr) {
            indices.push(ent_arr[1]);
        }
        // get the target ent_type
        target = _getAttribPushTarget(ent_type_sel);
    }
    // let ents_arr: TEntTypeIdx[] = null;
    // if (entities !== null && entities !== undefined) {
    //     ents_arr = checkIDs(fn_name, 'entities', entities, [IDcheckObj.isID, IDcheckObj.isIDList], null) as TEntTypeIdx[];
    // }
    // let source_attrib: [string, number|string] = null;
    // let target_attrib: [string, number|string] = null;
    // if (Array.isArray(attrib)) {
    //     // set source attrib
    //     source_attrib = [
    //         attrib[0] as string,
    //         (attrib.length > 1 ? attrib[1] : null) as number|string
    //     ];
    //     // set target attrib
    //     target_attrib = [
    //         (attrib.length > 2 ? attrib[2] : attrib[0]) as string,
    //         (attrib.length > 3 ? attrib[3] : null) as number|string
    //     ];
    // } else {
    //     source_attrib = [attrib, null];
    //     target_attrib = [attrib, null];
    // }
    // const [source_attrib_name, source_attrib_idx_key]: [string, number|string] = checkAttribNameIdxKey(fn_name, source_attrib);
    // const [target_attrib_name, target_attrib_idx_key]: [string, number|string] = checkAttribNameIdxKey(fn_name, target_attrib);
    // // --- Error Check ---
    // // get the source ent_type and indices
    // const source_ent_type: EEntType = ents_arr[0][0];
    // const indices: number[] = [];
    // for (const ent_arr of ents_arr) {
    //     if (ent_arr[0] !== source_ent_type) {
    //         throw new Error('The entities must all be of the same type.');
    //     }
    //     indices.push(ent_arr[1]);
    // }
    // // check the names
    // checkAttribName(fn_name, source_attrib_name);
    // checkAttribName(fn_name, target_attrib_name);
    // // get the target ent_type
    // const target: EEntType|string = _getAttribPushTarget(ent_type_sel);
    // if (source_ent_type === target) {
    //     throw new Error('The new attribute is at the same level as the existing attribute.');
    // }
    // get the method
    const method = _convertPushMethod(method_sel);
    // do the push
    __model__.modeldata.attribs.add.pushAttribVals(source_ent_type, source_attrib_name, source_attrib_idx_key, indices, target, target_attrib_name, target_attrib_idx_key, method);
}
var _EPushMethodSel;
(function (_EPushMethodSel) {
    _EPushMethodSel["FIRST"] = "first";
    _EPushMethodSel["LAST"] = "last";
    _EPushMethodSel["AVERAGE"] = "average";
    _EPushMethodSel["MEDIAN"] = "median";
    _EPushMethodSel["SUM"] = "sum";
    _EPushMethodSel["MIN"] = "min";
    _EPushMethodSel["MAX"] = "max";
})(_EPushMethodSel || (_EPushMethodSel = {}));
function _convertPushMethod(select) {
    switch (select) {
        case _EPushMethodSel.AVERAGE:
            return _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EAttribPush"].AVERAGE;
        case _EPushMethodSel.MEDIAN:
            return _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EAttribPush"].MEDIAN;
        case _EPushMethodSel.SUM:
            return _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EAttribPush"].SUM;
        case _EPushMethodSel.MIN:
            return _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EAttribPush"].MIN;
        case _EPushMethodSel.MAX:
            return _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EAttribPush"].MAX;
        case _EPushMethodSel.FIRST:
            return _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EAttribPush"].FIRST;
        case _EPushMethodSel.LAST:
            return _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EAttribPush"].LAST;
        default:
            break;
    }
}
// ================================================================================================


/***/ }),

/***/ "./src/assets/core/modules/basic/calc.ts":
/*!***********************************************!*\
  !*** ./src/assets/core/modules/basic/calc.ts ***!
  \***********************************************/
/*! exports provided: _EDistanceMethod, Distance, Length, Area, Vector, _ECentroidMethod, Centroid, Normal, _normal, Eval, _ParamXyzToT, Ray, Plane, BBox */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_EDistanceMethod", function() { return _EDistanceMethod; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Distance", function() { return Distance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Length", function() { return Length; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Area", function() { return Area; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Vector", function() { return Vector; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_ECentroidMethod", function() { return _ECentroidMethod; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Centroid", function() { return Centroid; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Normal", function() { return Normal; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_normal", function() { return _normal; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Eval", function() { return Eval; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_ParamXyzToT", function() { return _ParamXyzToT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Ray", function() { return Ray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Plane", function() { return Plane; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BBox", function() { return BBox; });
/* harmony import */ var _check_ids__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_check_ids */ "./src/assets/core/modules/_check_ids.ts");
/* harmony import */ var _check_args__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_check_args */ "./src/assets/core/modules/_check_args.ts");
/* harmony import */ var _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @libs/geo-info/common */ "./src/assets/libs/geo-info/common.ts");
/* harmony import */ var _libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @libs/geo-info/id */ "./src/assets/libs/geo-info/id.ts");
/* harmony import */ var _libs_geom_distance__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @libs/geom/distance */ "./src/assets/libs/geom/distance.ts");
/* harmony import */ var _libs_geom_vectors__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @libs/geom/vectors */ "./src/assets/libs/geom/vectors.ts");
/* harmony import */ var _libs_triangulate_triangulate__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @libs/triangulate/triangulate */ "./src/assets/libs/triangulate/triangulate.ts");
/* harmony import */ var _libs_geom_triangle__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @libs/geom/triangle */ "./src/assets/libs/geom/triangle.ts");
/* harmony import */ var underscore__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! underscore */ "./node_modules/underscore/modules/index-all.js");
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./_common */ "./src/assets/core/modules/basic/_common.ts");
/* harmony import */ var _assets_core_inline_ray__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @assets/core/inline/_ray */ "./src/assets/core/inline/_ray.ts");
/* harmony import */ var _assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @assets/libs/util/arrs */ "./src/assets/libs/util/arrs.ts");
/**
 * The `calc` module has functions for performing various types of calculations with entities in the model.
 * These functions neither make nor modify anything in the model.
 * These functions all return either numbers or lists of numbers.
 */
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};
/**
 *
 */












// ================================================================================================
var _EDistanceMethod;
(function (_EDistanceMethod) {
    _EDistanceMethod["PS_PS_DISTANCE"] = "ps_to_ps_distance";
    _EDistanceMethod["PS_E_DISTANCE"] = "ps_to_e_distance";
    _EDistanceMethod["PS_W_DISTANCE"] = "ps_to_w_distance";
})(_EDistanceMethod || (_EDistanceMethod = {}));
/**
 * Calculates the minimum distance from one position to other entities in the model.
 * ~
 * @param __model__
 * @param entities1 Position to calculate distance from.
 * @param entities2 List of entities to calculate distance to.
 * @param method Enum; distance method.
 * @returns Distance, or list of distances (if position2 is a list).
 * @example distance1 = calc.Distance (position1, position2, p_to_p_distance)
 * @example_info position1 = [0,0,0], position2 = [[0,0,10],[0,0,20]], Expected value of distance is 10.
 */
function Distance(__model__, entities1, entities2, method) {
    if (Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_11__["isEmptyArr2"])(entities1)) {
        return [];
    }
    if (Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_11__["isEmptyArr2"])(entities2)) {
        return [];
    }
    if (Array.isArray(entities1)) {
        entities1 = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_11__["arrMakeFlat"])(entities1);
    }
    entities2 = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_11__["arrMakeFlat"])(entities2);
    // --- Error Check ---
    const fn_name = 'calc.Distance';
    let ents_arr1;
    let ents_arr2;
    if (__model__.debug) {
        ents_arr1 = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])(fn_name, 'entities1', entities1, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isId, _check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL], null);
        ents_arr2 = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])(fn_name, 'entities2', entities2, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL], null);
    }
    else {
        // ents_arr1 = splitIDs(fn_name, 'entities1', entities1, [IDcheckObj.isID, IDcheckObj.isIDList],
        //     null)  as TEntTypeIdx|TEntTypeIdx[];
        // ents_arr2 = splitIDs(fn_name, 'entities2', entities2, [IDcheckObj.isIDList],
        //     null) as TEntTypeIdx[];
        ents_arr1 = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsBreak"])(entities1);
        ents_arr2 = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsBreak"])(entities2);
    }
    // --- Error Check ---
    // get the from posis
    let from_posis_i;
    if (Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_11__["arrMaxDepth"])(ents_arr1) === 1 && ents_arr1[0] === _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].POSI) {
        from_posis_i = ents_arr1[1];
    }
    else {
        from_posis_i = [];
        for (const [ent_type, ent_i] of ents_arr1) {
            if (ent_type === _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].POSI) {
                from_posis_i.push(ent_i);
            }
            else {
                const ent_posis_i = __model__.modeldata.geom.nav.navAnyToPosi(ent_type, ent_i);
                for (const ent_posi_i of ent_posis_i) {
                    from_posis_i.push(ent_posi_i);
                }
            }
        }
    }
    // get the to ent_type
    let to_ent_type;
    switch (method) {
        case _EDistanceMethod.PS_PS_DISTANCE:
            to_ent_type = _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].POSI;
            break;
        case _EDistanceMethod.PS_W_DISTANCE:
        case _EDistanceMethod.PS_E_DISTANCE:
            to_ent_type = _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].EDGE;
            break;
        default:
            break;
    }
    // get the ents and posis sets
    const set_to_ents_i = new Set();
    let set_to_posis_i = new Set();
    for (const [ent_type, ent_i] of ents_arr2) {
        // ents
        if (ent_type === to_ent_type) {
            set_to_ents_i.add(ent_i);
        }
        else {
            const sub_ents_i = __model__.modeldata.geom.nav.navAnyToAny(ent_type, to_ent_type, ent_i);
            for (const sub_ent_i of sub_ents_i) {
                set_to_ents_i.add(sub_ent_i);
            }
        }
        // posis
        if (to_ent_type !== _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].POSI) {
            const sub_posis_i = __model__.modeldata.geom.nav.navAnyToPosi(ent_type, ent_i);
            for (const sub_posi_i of sub_posis_i) {
                set_to_posis_i.add(sub_posi_i);
            }
        }
    }
    // create an array of to_ents
    const to_ents_i = Array.from(set_to_ents_i);
    // cerate a posis xyz map
    const map_posi_i_xyz = new Map();
    if (to_ent_type === _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].POSI) {
        set_to_posis_i = set_to_ents_i;
    }
    for (const posi_i of set_to_posis_i) {
        const xyz = __model__.modeldata.attribs.query.getPosiCoords(posi_i);
        map_posi_i_xyz.set(posi_i, xyz);
    }
    // calc the distance
    switch (method) {
        case _EDistanceMethod.PS_PS_DISTANCE:
            return _distanceManyPosisToPosis(__model__, from_posis_i, to_ents_i, map_posi_i_xyz, method);
        case _EDistanceMethod.PS_W_DISTANCE:
        case _EDistanceMethod.PS_E_DISTANCE:
            return _distanceManyPosisToEdges(__model__, from_posis_i, to_ents_i, map_posi_i_xyz, method);
        default:
            break;
    }
}
function _distanceManyPosisToPosis(__model__, from_posi_i, to_ents_i, map_posi_i_xyz, method) {
    if (!Array.isArray(from_posi_i)) {
        from_posi_i = from_posi_i;
        return _distancePstoPs(__model__, from_posi_i, to_ents_i, map_posi_i_xyz);
    }
    else {
        from_posi_i = from_posi_i;
        // TODO This can be optimised
        // From posis may have duplicates, only calc once
        return from_posi_i.map(one_from => _distanceManyPosisToPosis(__model__, one_from, to_ents_i, map_posi_i_xyz, method));
    }
}
// function _distanceManyPosisToWires(__model__: GIModel, from_posi_i: number|number[], to_ents_i: number[],
//         method: _EDistanceMethod): number|number[] {
//     if (!Array.isArray(from_posi_i)) {
//         from_posi_i = from_posi_i as number;
//         return _distancePstoW(__model__, from_posi_i, to_ents_i) as number;
//     } else  {
//         from_posi_i = from_posi_i as number[];
//         // TODO This can be optimised
//         // There is some vector stuff that gets repeated for each posi to line dist calc
//         return from_posi_i.map( one_from => _distanceManyPosisToWires(__model__, one_from, to_ents_i, method) ) as number[];
//     }
// }
function _distanceManyPosisToEdges(__model__, from_posi_i, to_ents_i, map_posi_i_xyz, method) {
    if (!Array.isArray(from_posi_i)) {
        from_posi_i = from_posi_i;
        return _distancePstoE(__model__, from_posi_i, to_ents_i, map_posi_i_xyz);
    }
    else {
        from_posi_i = from_posi_i;
        // TODO This can be optimised
        // From posis may have duplicates, only calc once
        // Adjacent edges could be calculated once only
        return from_posi_i.map(one_from => _distanceManyPosisToEdges(__model__, one_from, to_ents_i, map_posi_i_xyz, method));
    }
}
function _distancePstoPs(__model__, from_posi_i, to_posis_i, map_posi_i_xyz) {
    const from_xyz = __model__.modeldata.attribs.query.getPosiCoords(from_posi_i);
    let min_dist = Infinity;
    // loop, measure dist
    for (const to_posi_i of to_posis_i) {
        // get xyz
        const to_xyz = map_posi_i_xyz.get(to_posi_i);
        // calc dist
        const dist = _distancePointToPoint(from_xyz, to_xyz);
        if (dist < min_dist) {
            min_dist = dist;
        }
    }
    return min_dist;
}
// function _distancePstoW(__model__: GIModel, from_posi_i: number, to_wires_i: number[]): number {
//     const from_xyz: Txyz = __model__.modeldata.attribs.query.getPosiCoords(from_posi_i);
//     let min_dist = Infinity;
//     const map_posi_xyz: Map<number, Txyz> = new Map();
//     for (const wire_i of to_wires_i) {
//         // get the posis
//         const to_posis_i: number[] = __model__.modeldata.geom.nav.navAnyToPosi(EEntType.WIRE, wire_i);
//         // if closed, add first posi to end
//         if (__model__.modeldata.geom.query.isWireClosed(wire_i)) { to_posis_i.push(to_posis_i[0]); }
//         // add the first xyz to the list, this will be prev
//         let prev_xyz: Txyz = __model__.modeldata.attribs.query.getPosiCoords(to_posis_i[0]);
//         map_posi_xyz.set(to_posis_i[0], prev_xyz);
//         // loop, measure dist
//         for (let i = 1; i < to_posis_i.length; i++) {
//             // get xyz
//             const curr_posi_i: number = to_posis_i[i];
//             let curr_xyz: Txyz = map_posi_xyz.get(curr_posi_i);
//             if (curr_xyz === undefined) {
//                 curr_xyz = __model__.modeldata.attribs.query.getPosiCoords(curr_posi_i);
//                 map_posi_xyz.set(curr_posi_i, curr_xyz);
//             }
//             // calc dist
//             const dist: number = _distancePointToLine(from_xyz, prev_xyz, curr_xyz);
//             if (dist < min_dist) { min_dist = dist; }
//             // next
//             prev_xyz = curr_xyz;
//         }
//     }
//     return min_dist;
// }
function _distancePstoE(__model__, from_posi_i, to_edges_i, map_posi_i_xyz) {
    const from_xyz = __model__.modeldata.attribs.query.getPosiCoords(from_posi_i);
    let min_dist = Infinity;
    for (const edge_i of to_edges_i) {
        // get the posis
        const edge_posis_i = __model__.modeldata.geom.nav.navAnyToPosi(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].EDGE, edge_i);
        const xyz_start = map_posi_i_xyz.get(edge_posis_i[0]);
        const xyz_end = map_posi_i_xyz.get(edge_posis_i[1]);
        // calc dist
        const dist = _distancePointToLine(from_xyz, xyz_start, xyz_end);
        if (dist < min_dist) {
            min_dist = dist;
        }
    }
    return min_dist;
}
function _distancePointToPoint(from, to) {
    const a = from[0] - to[0];
    const b = from[1] - to[1];
    const c = from[2] - to[2];
    return Math.sqrt(a * a + b * b + c * c);
}
function _distancePointToLine(from, start, end) {
    const vec_from = Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_5__["vecFromTo"])(start, from);
    const vec_line = Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_5__["vecFromTo"])(start, end);
    const len = Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_5__["vecLen"])(vec_line);
    const vec_line_norm = Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_5__["vecDiv"])(vec_line, len);
    const dot = Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_5__["vecDot"])(vec_from, vec_line_norm);
    if (dot <= 0) {
        return _distancePointToPoint(from, start);
    }
    else if (dot >= len) {
        return _distancePointToPoint(from, end);
    }
    const close = Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_5__["vecAdd"])(start, Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_5__["vecSetLen"])(vec_line, dot));
    return _distancePointToPoint(from, close);
}
// ================================================================================================
/**
 * Calculates the length of an entity.
 * ~
 * The entity can be an edge, a wire, a polyline, or anything from which wires can be extracted.
 * This includes polylines, polygons, faces, and collections.
 * ~
 * Given a list of edges, wires, or polylines, a list of lengths are returned.
 * ~
 * Given any types of entities from which wires can be extracted, a list of lengths are returned.
 * For example, given a single polygon, a list of lengths are returned (since a polygon may have multiple wires).
 * ~
 * @param __model__
 * @param entities Single or list of edges, wires, or polylines, or other entities from which wires can be extracted.
 * @returns Lengths, a number or list of numbers.
 * @example length1 = calc.Length(line1)
 */
function Length(__model__, entities) {
    if (Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_11__["isEmptyArr2"])(entities)) {
        return [];
    }
    // --- Error Check ---
    const fn_name = 'calc.Length';
    let ents_arr;
    if (__model__.debug) {
        ents_arr = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])(fn_name, 'entities', entities, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isId, _check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL], [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].EDGE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].WIRE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].FACE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].COLL]);
    }
    else {
        // ents_arr = splitIDs(fn_name, 'entities', entities, [IDcheckObj.isID, IDcheckObj.isIDList],
        // [EEntType.EDGE, EEntType.WIRE, EEntType.PLINE, EEntType.PGON, EEntType.FACE, EEntType.COLL]) as TEntTypeIdx|TEntTypeIdx[];
        ents_arr = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsBreak"])(entities);
    }
    // --- Error Check ---
    return _length(__model__, ents_arr);
}
function _length(__model__, ents_arrs) {
    if (Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["getArrDepth"])(ents_arrs) === 1) {
        const [ent_type, index] = ents_arrs;
        if (ent_type === _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].EDGE) {
            return _edgeLength(__model__, index);
        }
        else if (ent_type === _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].WIRE) {
            return _wireLength(__model__, index);
        }
        else if (ent_type === _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE) {
            const wire_i = __model__.modeldata.geom.nav.navPlineToWire(index);
            return _wireLength(__model__, wire_i);
        }
        else {
            const wires_i = __model__.modeldata.geom.nav.navAnyToWire(ent_type, index);
            return wires_i.map(wire_i => _wireLength(__model__, wire_i));
        }
    }
    else {
        const lengths = ents_arrs.map(ents_arr => _length(__model__, ents_arr));
        return underscore__WEBPACK_IMPORTED_MODULE_8__["default"].flatten(lengths);
    }
}
function _edgeLength(__model__, edge_i) {
    const posis_i = __model__.modeldata.geom.nav.navAnyToPosi(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].EDGE, edge_i);
    const xyz_0 = __model__.modeldata.attribs.query.getPosiCoords(posis_i[0]);
    const xyz_1 = __model__.modeldata.attribs.query.getPosiCoords(posis_i[1]);
    return Object(_libs_geom_distance__WEBPACK_IMPORTED_MODULE_4__["distance"])(xyz_0, xyz_1);
}
function _wireLength(__model__, wire_i) {
    const posis_i = __model__.modeldata.geom.nav.navAnyToPosi(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].WIRE, wire_i);
    let dist = 0;
    for (let i = 0; i < posis_i.length - 1; i++) {
        const xyz_0 = __model__.modeldata.attribs.query.getPosiCoords(posis_i[i]);
        const xyz_1 = __model__.modeldata.attribs.query.getPosiCoords(posis_i[i + 1]);
        dist += Object(_libs_geom_distance__WEBPACK_IMPORTED_MODULE_4__["distance"])(xyz_0, xyz_1);
    }
    if (__model__.modeldata.geom.query.isWireClosed(wire_i)) {
        const xyz_0 = __model__.modeldata.attribs.query.getPosiCoords(posis_i[posis_i.length - 1]);
        const xyz_1 = __model__.modeldata.attribs.query.getPosiCoords(posis_i[0]);
        dist += Object(_libs_geom_distance__WEBPACK_IMPORTED_MODULE_4__["distance"])(xyz_0, xyz_1);
    }
    return dist;
}
// ================================================================================================
/**
 * Calculates the area of en entity.
 * ~
 * The entity can be a polygon, a face, a closed polyline, a closed wire, or a collection.
 * ~
 * Given a list of entities, a list of areas are returned.
 * ~
 * @param __model__
 * @param entities Single or list of polygons, faces, closed polylines, closed wires, collections.
 * @returns Area.
 * @example area1 = calc.Area (surface1)
 */
function Area(__model__, entities) {
    if (Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_11__["isEmptyArr2"])(entities)) {
        return [];
    }
    // --- Error Check ---
    const fn_name = 'calc.Area';
    let ents_arr;
    if (__model__.debug) {
        ents_arr = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])(fn_name, 'entities', entities, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isId, _check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL], [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].FACE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].WIRE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].COLL]);
    }
    else {
        // ents_arr = splitIDs(fn_name, 'entities', entities,
        // [IDcheckObj.isID, IDcheckObj.isIDList],
        // [EEntType.PGON, EEntType.FACE, EEntType.PLINE, EEntType.WIRE, EEntType.COLL]) as TEntTypeIdx|TEntTypeIdx[];
        ents_arr = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsBreak"])(entities);
    }
    // --- Error Check ---
    return _area(__model__, ents_arr);
}
function _area(__model__, ents_arrs) {
    if (Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["getArrDepth"])(ents_arrs) === 1) {
        const [ent_type, index] = ents_arrs;
        if (Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["isPgon"])(ent_type) || Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["isFace"])(ent_type)) {
            // faces, these are already triangulated
            let face_i = index;
            if (Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["isPgon"])(ent_type)) {
                face_i = __model__.modeldata.geom.nav.navPgonToFace(index);
            }
            const tris_i = __model__.modeldata.geom.nav.navFaceToTri(face_i);
            let total_area = 0;
            for (const tri_i of tris_i) {
                const corners_i = __model__.modeldata.geom.nav.navAnyToPosi(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].TRI, tri_i);
                const corners_xyzs = corners_i.map(corner_i => __model__.modeldata.attribs.query.getPosiCoords(corner_i));
                const tri_area = Object(_libs_geom_triangle__WEBPACK_IMPORTED_MODULE_7__["area"])(corners_xyzs[0], corners_xyzs[1], corners_xyzs[2]);
                total_area += tri_area;
            }
            return total_area;
        }
        else if (Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["isPline"])(ent_type) || Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["isWire"])(ent_type)) {
            // wires, these need to be triangulated
            let wire_i = index;
            if (Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["isPline"])(ent_type)) {
                wire_i = __model__.modeldata.geom.nav.navPlineToWire(index);
            }
            if (!__model__.modeldata.geom.query.isWireClosed(wire_i)) {
                throw new Error('To calculate area, wire must be closed');
            }
            const posis_i = __model__.modeldata.geom.nav.navAnyToPosi(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].WIRE, index);
            const xyzs = posis_i.map(posi_i => __model__.modeldata.attribs.query.getPosiCoords(posi_i));
            const tris = Object(_libs_triangulate_triangulate__WEBPACK_IMPORTED_MODULE_6__["triangulate"])(xyzs);
            let total_area = 0;
            for (const tri of tris) {
                const corners_xyzs = tri.map(corner_i => xyzs[corner_i]);
                const tri_area = Object(_libs_geom_triangle__WEBPACK_IMPORTED_MODULE_7__["area"])(corners_xyzs[0], corners_xyzs[1], corners_xyzs[2]);
                total_area += tri_area;
            }
            return total_area;
        }
        else {
            return 0;
        }
    }
    else {
        const areas = ents_arrs.map(ents_arr => _area(__model__, ents_arr));
        return underscore__WEBPACK_IMPORTED_MODULE_8__["default"].flatten(areas);
    }
}
// ================================================================================================
/**
 * Returns a vector along an edge, from the start position to the end position.
 * The vector is not normalized.
 * ~
 * Given a single edge, a single vector will be returned. Given a list of edges, a list of vectors will be returned.
 * ~
 * Given any entity that has edges (collection, polygons, polylines, faces, and wires),
 * a list of edges will be extracted, and a list of vectors will be returned.
 * ~
 * @param __model__
 * @param entities Single or list of edges, or any entity from which edges can be extracted.
 * @returns The vector [x, y, z] or a list of vectors.
 */
function Vector(__model__, entities) {
    if (Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_11__["isEmptyArr2"])(entities)) {
        return [];
    }
    // --- Error Check ---
    const fn_name = 'calc.Vector';
    let ents_arrs;
    if (__model__.debug) {
        ents_arrs = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])(fn_name, 'entities', entities, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isId, _check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL], [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].FACE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].WIRE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].EDGE]);
    }
    else {
        // ents_arrs = splitIDs(fn_name, 'entities', entities,
        // [IDcheckObj.isID, IDcheckObj.isIDList],
        // [EEntType.PGON, EEntType.FACE, EEntType.PLINE, EEntType.WIRE, EEntType.EDGE]) as TEntTypeIdx|TEntTypeIdx[];
        ents_arrs = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsBreak"])(entities);
    }
    // --- Error Check ---
    return _vector(__model__, ents_arrs);
}
function _vector(__model__, ents_arrs) {
    if (Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["getArrDepth"])(ents_arrs) === 1) {
        const [ent_type, index] = ents_arrs;
        if (ent_type === _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].EDGE) {
            const posis_i = __model__.modeldata.geom.nav.navAnyToPosi(ent_type, index);
            const start = __model__.modeldata.attribs.query.getPosiCoords(posis_i[0]);
            const end = __model__.modeldata.attribs.query.getPosiCoords(posis_i[1]);
            // console.log(">>>>", start, end);
            return Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_5__["vecSub"])(end, start);
        }
        else {
            const edges_i = __model__.modeldata.geom.nav.navAnyToEdge(ent_type, index);
            const edges_arrs = edges_i.map(edge_i => [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].EDGE, edge_i]);
            return edges_arrs.map(edges_arr => _vector(__model__, edges_arr));
        }
    }
    else {
        const vectors_arrs = ents_arrs.map(ents_arr => _vector(__model__, ents_arr));
        const all_vectors = [];
        for (const vectors_arr of vectors_arrs) {
            if (Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["getArrDepth"])(vectors_arr) === 1) {
                all_vectors.push(vectors_arr);
            }
            else {
                for (const vector_arr of vectors_arr) {
                    all_vectors.push(vector_arr);
                }
            }
        }
        return all_vectors;
    }
}
// ================================================================================================
var _ECentroidMethod;
(function (_ECentroidMethod) {
    _ECentroidMethod["PS_AVERAGE"] = "ps_average";
    _ECentroidMethod["CENTER_OF_MASS"] = "center_of_mass";
})(_ECentroidMethod || (_ECentroidMethod = {}));
/**
 * Calculates the centroid of an entity.
 * ~
 * If 'ps_average' is selected, the centroid is the average of the positions that make up that entity.
 * ~
 * If 'center_of_mass' is selected, the centroid is the centre of mass of the faces that make up that entity.
 * Note that only faces are deemed to have mass.
 * ~
 * Given a list of entities, a list of centroids will be returned.
 * ~
 * Given a list of positions, a single centroid that is the average of all those positions will be returned.
 * ~
 * @param __model__
 * @param entities Single or list of entities. (Can be any type of entities.)
 * @param method Enum, the method for calculating the centroid.
 * @returns A centroid [x, y, z] or a list of centroids.
 * @example centroid1 = calc.Centroid (polygon1)
 */
function Centroid(__model__, entities, method) {
    if (Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_11__["isEmptyArr2"])(entities)) {
        return [];
    }
    // --- Error Check ---
    const fn_name = 'calc.Centroid';
    let ents_arrs;
    if (__model__.debug) {
        ents_arrs = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])(fn_name, 'entities', entities, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isId, _check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL], null);
    }
    else {
        // ents_arrs = splitIDs(fn_name, 'entities', entities,
        // [IDcheckObj.isID, IDcheckObj.isIDList], null) as TEntTypeIdx|TEntTypeIdx[];
        ents_arrs = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsBreak"])(entities);
    }
    // --- Error Check ---
    switch (method) {
        case _ECentroidMethod.PS_AVERAGE:
            return Object(_common__WEBPACK_IMPORTED_MODULE_9__["getCentroid"])(__model__, ents_arrs);
        case _ECentroidMethod.CENTER_OF_MASS:
            return Object(_common__WEBPACK_IMPORTED_MODULE_9__["getCenterOfMass"])(__model__, ents_arrs);
        default:
            break;
    }
}
// ================================================================================================
/**
 * Calculates the normal vector of an entity or list of entities. The vector is normalised, and scaled
 * by the specified scale factor.
 * ~
 * Given a single entity, a single normal will be returned. Given a list of entities, a list of normals will be returned.
 * ~
 * For polygons, faces, and face wires the normal is calculated by taking the average of all the normals of the face triangles.
 * ~
 * For polylines and polyline wires, the normal is calculated by triangulating the positions, and then
 * taking the average of all the normals of the triangles.
 * ~
 * For edges, the normal is calculated by takingthe avery of the normals of the two vertices.
 * ~
 * For vertices, the normal is calculated by creating a triangle out of the two adjacent edges,
 * and then calculating the normal of the triangle.
 * (If there is only one edge, or if the two adjacent edges are colinear, the the normal of the wire is returned.)
 * ~
 * For positions, the normal is calculated by taking the average of the normals of all the vertices linked to the position.
 * ~
 * If the normal cannot be calculated, [0, 0, 0] will be returned.
 *
 * @param __model__
 * @param entities Single or list of entities. (Can be any type of entities.)
 * @param scale The scale factor for the normal vector. (This is equivalent to the length of the normal vector.)
 * @returns The normal vector [x, y, z] or a list of normal vectors.
 * @example normal1 = calc.Normal (polygon1, 1)
 * @example_info If the input is non-planar, the output vector will be an average of all normals vector of the polygon triangles.
 */
function Normal(__model__, entities, scale) {
    if (Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_11__["isEmptyArr2"])(entities)) {
        return [];
    }
    // --- Error Check ---
    const fn_name = 'calc.Normal';
    let ents_arr;
    if (__model__.debug) {
        ents_arr = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])(fn_name, 'entities', entities, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isId, _check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL], null);
        Object(_check_args__WEBPACK_IMPORTED_MODULE_1__["checkArgs"])(fn_name, 'scale', scale, [_check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isNum]);
    }
    else {
        // ents_arr = splitIDs(fn_name, 'entities', entities,
        // [IDcheckObj.isID, IDcheckObj.isIDList], null) as  TEntTypeIdx|TEntTypeIdx[];
        ents_arr = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsBreak"])(entities);
    }
    // --- Error Check ---
    return _normal(__model__, ents_arr, scale);
}
function _normal(__model__, ents_arr, scale) {
    if (Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["getArrDepth"])(ents_arr) === 1) {
        const ent_type = ents_arr[0];
        const index = ents_arr[1];
        if (Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["isPgon"])(ent_type)) {
            const norm_vec = __model__.modeldata.geom.query.getFaceNormal(__model__.modeldata.geom.nav.navPgonToFace(index));
            return Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_5__["vecMult"])(norm_vec, scale);
        }
        else if (Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["isFace"])(ent_type)) {
            const norm_vec = __model__.modeldata.geom.query.getFaceNormal(index);
            return Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_5__["vecMult"])(norm_vec, scale);
        }
        else if (Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["isPline"])(ent_type)) {
            const norm_vec = __model__.modeldata.geom.query.getWireNormal(__model__.modeldata.geom.nav.navPlineToWire(index));
            return Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_5__["vecMult"])(norm_vec, scale);
        }
        else if (Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["isWire"])(ent_type)) {
            const norm_vec = __model__.modeldata.geom.query.getWireNormal(index);
            return Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_5__["vecMult"])(norm_vec, scale);
        }
        else if (Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["isEdge"])(ent_type)) {
            const verts_i = __model__.modeldata.geom.nav.navEdgeToVert(index);
            const norm_vecs = verts_i.map(vert_i => _vertNormal(__model__, vert_i));
            const norm_vec = Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_5__["vecDiv"])(Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_5__["vecSum"])(norm_vecs), norm_vecs.length);
            return Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_5__["vecMult"])(norm_vec, scale);
        }
        else if (Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["isVert"])(ent_type)) {
            const norm_vec = _vertNormal(__model__, index);
            return Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_5__["vecMult"])(norm_vec, scale);
        }
        else if (Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["isPosi"])(ent_type)) {
            const verts_i = __model__.modeldata.geom.nav.navPosiToVert(index);
            if (verts_i.length > 0) {
                const norm_vecs = verts_i.map(vert_i => _vertNormal(__model__, vert_i));
                const norm_vec = Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_5__["vecDiv"])(Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_5__["vecSum"])(norm_vecs), norm_vecs.length);
                return Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_5__["vecMult"])(norm_vec, scale);
            }
            return [0, 0, 0];
        }
        else if (Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["isPoint"])(ent_type)) {
            return [0, 0, 0];
        }
    }
    else {
        return ents_arr.map(ent_arr => _normal(__model__, ent_arr, scale));
    }
}
function _vertNormal(__model__, index) {
    let norm_vec;
    const edges_i = __model__.modeldata.geom.nav.navVertToEdge(index);
    if (edges_i.length === 1) {
        const posis0_i = __model__.modeldata.geom.nav.navAnyToPosi(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].EDGE, edges_i[0]);
        const posis1_i = __model__.modeldata.geom.nav.navAnyToPosi(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].EDGE, edges_i[1]);
        const p_mid = __model__.modeldata.attribs.query.getPosiCoords(posis0_i[1]); // same as posis1_i[0]
        const p_a = __model__.modeldata.attribs.query.getPosiCoords(posis0_i[0]);
        const p_b = __model__.modeldata.attribs.query.getPosiCoords(posis1_i[1]);
        norm_vec = Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_5__["vecCross"])(Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_5__["vecFromTo"])(p_mid, p_a), Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_5__["vecFromTo"])(p_mid, p_b), true);
        if (Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_5__["vecLen"])(norm_vec) > 0) {
            return norm_vec;
        }
    }
    const wire_i = __model__.modeldata.geom.nav.navEdgeToWire(edges_i[0]);
    norm_vec = __model__.modeldata.geom.query.getWireNormal(wire_i);
    return norm_vec;
}
// ================================================================================================
/**
 * Calculates the xyz coord along an edge, wire, or polyline given a t parameter.
 * ~
 * The 't' parameter varies between 0 and 1, where 0 indicates the start and 1 indicates the end.
 * For example, given a polyline,
 * evaluating at t=0 gives that xyz at the start,
 * evaluating at t=0.5 gives the xyz halfway along the polyline,
 * evaluating at t=1 gives the xyz at the end of the polyline.
 * ~
 * Given a single edge, wire, or polyline, a single xyz coord will be returned.
 * ~
 * Given a list of edges, wires, or polylines, a list of xyz coords will be returned.
 * ~
 * Given any entity that has wires (faces, polygons and collections),
 * a list of wires will be extracted, and a list of coords will be returned.
 * ~
 * @param __model__
 * @param entities Single or list of edges, wires, polylines, or faces, polygons, or collections.
 * @param t_param A value between 0 to 1.
 * @returns The coordinates [x, y, z], or a list of coordinates.
 * @example coord1 = calc.Eval (polyline1, 0.23)
 */
function Eval(__model__, entities, t_param) {
    if (Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_11__["isEmptyArr2"])(entities)) {
        return [];
    }
    // --- Error Check ---
    const fn_name = 'calc.Eval';
    let ents_arrs;
    if (__model__.debug) {
        ents_arrs = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])(fn_name, 'entities', entities, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isId, _check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL], [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].EDGE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].WIRE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].FACE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].COLL]);
        Object(_check_args__WEBPACK_IMPORTED_MODULE_1__["checkArgs"])(fn_name, 'param', t_param, [_check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isNum01]);
    }
    else {
        // ents_arrs = splitIDs(fn_name, 'entities', entities,
        //     [IDcheckObj.isID, IDcheckObj.isIDList],
        //     [EEntType.EDGE, EEntType.WIRE, EEntType.FACE, EEntType.PLINE, EEntType.PGON, EEntType.COLL]) as TEntTypeIdx|TEntTypeIdx[];
        ents_arrs = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsBreak"])(entities);
    }
    // --- Error Check ---
    return _eval(__model__, ents_arrs, t_param);
}
function _eval(__model__, ents_arr, t_param) {
    if (Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["getArrDepth"])(ents_arr) === 1) {
        const [ent_type, index] = ents_arr;
        if (ent_type === _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].EDGE || ent_type === _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].WIRE || ent_type === _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE) {
            const edges_i = __model__.modeldata.geom.nav.navAnyToEdge(ent_type, index);
            const num_edges = edges_i.length;
            // get all the edge lengths
            let total_dist = 0;
            const dists = [];
            const xyz_pairs = [];
            for (const edge_i of edges_i) {
                const posis_i = __model__.modeldata.geom.nav.navAnyToPosi(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].EDGE, edge_i);
                const xyz_0 = __model__.modeldata.attribs.query.getPosiCoords(posis_i[0]);
                const xyz_1 = __model__.modeldata.attribs.query.getPosiCoords(posis_i[1]);
                const dist = Object(_libs_geom_distance__WEBPACK_IMPORTED_MODULE_4__["distance"])(xyz_0, xyz_1);
                total_dist += dist;
                dists.push(total_dist);
                xyz_pairs.push([xyz_0, xyz_1]);
            }
            // map the t_param
            const t_param_mapped = t_param * total_dist;
            // loop through and find the point
            for (let i = 0; i < num_edges; i++) {
                if (t_param_mapped < dists[i]) {
                    const xyz_pair = xyz_pairs[i];
                    let dist_a = 0;
                    if (i > 0) {
                        dist_a = dists[i - 1];
                    }
                    const dist_b = dists[i];
                    const edge_length = dist_b - dist_a;
                    const to_t = t_param_mapped - dist_a;
                    const vec_len = to_t / edge_length;
                    return Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_5__["vecAdd"])(xyz_pair[0], Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_5__["vecMult"])(Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_5__["vecSub"])(xyz_pair[1], xyz_pair[0]), vec_len));
                }
            }
            // t param must be 1 (or greater)
            return xyz_pairs[num_edges - 1][1];
        }
        else {
            const wires_i = __model__.modeldata.geom.nav.navAnyToWire(ent_type, index);
            const wires_arrs = wires_i.map(wire_i => [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].WIRE, wire_i]);
            return wires_arrs.map(wires_arr => _eval(__model__, wires_arr, t_param));
        }
    }
    else {
        return ents_arr.map(ent_arr => _eval(__model__, ent_arr, t_param));
    }
}
// ================================================================================================
/**
 * Calculates the 't' parameter along a linear entity, given a location.
 * The 't' parameter varies between 0 and 1, where 0 indicates the start and 1 indicates the end.
 *
 * @param __model__
 * @param lines List of edges, wires, or polylines.
 * @param locations List of positions, vertices, points, or coordinates.
 * @return The 't' parameter vale, between 0 and 1.
 * @example coord1 = calc.ParamXyzToT (polyline1, [1,2,3])
 */
function _ParamXyzToT(__model__, lines, locations) {
    // --- Error Check ---
    // const fn_name = 'calc.ParamXyzToT';
    // checkIDs(fn_name, 'lines', lines, [IDcheckObj.isID, IDcheckObj.isIDList], [EEntType.EDGE, EEntType.WIRE, EEntType.PLINE]);
    // checkIDnTypes(fn_name, 'locations', locations,
    //               [IDcheckObj.isID, IDcheckObj.isIDList, TypeCheckObj.isNumberList], [EEntType.POSI, EEntType.VERT, EEntType.POINT]);
    // --- Error Check ---
    throw new Error('Not implemented.');
    return null;
}
// ================================================================================================
// ================================================================================================
/**
 * Returns a ray for an edge, a face, or a polygons. For edges, it returns a ray along the edge, from teh start vertex to the end vertex
 * For a face or polygon, it returns the ray that is the z-axis of the plane.
 * ~
 * For an edge, the ray vector is not normalised. For a face or polygon, the ray vector is normalised.
 *
 * @param __model__
 * @param entities An edge, a face, or a polygon, or a list.
 * @returns The ray.
 */
function Ray(__model__, entities) {
    if (Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_11__["isEmptyArr2"])(entities)) {
        return [];
    }
    // --- Error Check ---
    const fn_name = 'calc.Ray';
    let ents_arr;
    if (__model__.debug) {
        ents_arr = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])(fn_name, 'entities', entities, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isId, _check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL], [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].EDGE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].FACE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON]);
    }
    else {
        // ents_arr = splitIDs(fn_name, 'entities', entities,
        // [IDcheckObj.isID, IDcheckObj.isIDList], [EEntType.EDGE, EEntType.PLINE, EEntType.FACE, EEntType.PGON]) as TEntTypeIdx|TEntTypeIdx[];
        ents_arr = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsBreak"])(entities);
    }
    // --- Error Check ---
    return _getRay(__model__, ents_arr);
}
function _getRayFromEdge(__model__, ent_arr) {
    const posis_i = __model__.modeldata.geom.nav.navAnyToPosi(ent_arr[0], ent_arr[1]);
    const xyzs = posis_i.map(posi_i => __model__.modeldata.attribs.query.getPosiCoords(posi_i));
    return [xyzs[0], Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_5__["vecSub"])(xyzs[1], xyzs[0])];
}
function _getRayFromFace(__model__, ent_arr) {
    const plane = _getPlane(__model__, ent_arr);
    return Object(_assets_core_inline_ray__WEBPACK_IMPORTED_MODULE_10__["rayFromPln"])(plane);
}
function _getRayFromPline(__model__, ent_arr) {
    const edges_i = __model__.modeldata.geom.nav.navAnyToEdge(ent_arr[0], ent_arr[1]);
    return edges_i.map(edge_i => _getRayFromEdge(__model__, [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].EDGE, edge_i]));
}
function _getRay(__model__, ents_arr) {
    if (Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["getArrDepth"])(ents_arr) === 1) {
        const ent_arr = ents_arr;
        if (ent_arr[0] === _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].EDGE) {
            return _getRayFromEdge(__model__, ent_arr);
        }
        else if (ent_arr[0] === _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE) {
            return _getRayFromPline(__model__, ent_arr);
        }
        else if (ent_arr[0] === _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].FACE) {
            return _getRayFromFace(__model__, ent_arr);
        }
        else { // must be a polygon
            const face_i = __model__.modeldata.geom.nav.navPgonToFace(ent_arr[1]);
            return _getRayFromFace(__model__, [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].FACE, face_i]);
        }
    }
    else {
        return ents_arr.map(ent_arr => _getRay(__model__, ent_arr));
    }
}
// ================================================================================================
/**
 * Returns a plane from a polygon, a face, a polyline, or a wire.
 * For polylines or wires, there must be at least three non-colinear vertices.
 * ~
 * The winding order is counter-clockwise.
 * This means that if the vertices are ordered counter-clockwise relative to your point of view,
 * then the z axis of the plane will be pointing towards you.
 *
 * @param entities Any entities
 * @returns The plane.
 */
function Plane(__model__, entities) {
    if (Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_11__["isEmptyArr2"])(entities)) {
        return [];
    }
    // --- Error Check ---
    const fn_name = 'calc.Plane';
    let ents_arr;
    if (__model__.debug) {
        ents_arr = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])(fn_name, 'entities', entities, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isId, _check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL], null); // takes in any
    }
    else {
        // ents_arr = splitIDs(fn_name, 'entities', entities,
        //     [IDcheckObj.isID, IDcheckObj.isIDList], null) as TEntTypeIdx|TEntTypeIdx[]; // takes in any
        ents_arr = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsBreak"])(entities);
    }
    // TODO [EEntType.PGON, EEntType.FACE, EEntType.PLINE, EEntType.WIRE]);
    // --- Error Check ---
    return _getPlane(__model__, ents_arr);
}
function _getPlane(__model__, ents_arr) {
    if (Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["getArrDepth"])(ents_arr) === 1) {
        const ent_arr = ents_arr;
        const posis_i = __model__.modeldata.geom.nav.navAnyToPosi(ent_arr[0], ent_arr[1]);
        const unique_posis_i = Array.from(new Set(posis_i));
        if (unique_posis_i.length < 3) {
            throw new Error('Too few points to calculate plane.');
        }
        const unique_xyzs = unique_posis_i.map(posi_i => __model__.modeldata.attribs.query.getPosiCoords(posi_i));
        const origin = Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_5__["vecDiv"])(Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_5__["vecSum"])(unique_xyzs), unique_xyzs.length);
        // const normal: Txyz = newellNorm(unique_xyzs);
        const normal = _normal(__model__, ent_arr, 1);
        const x_vec = Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_5__["vecNorm"])(Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_5__["vecFromTo"])(unique_xyzs[0], unique_xyzs[1]));
        const y_vec = Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_5__["vecCross"])(normal, x_vec); // must be z-axis, x-axis
        return [origin, x_vec, y_vec];
    }
    else {
        return ents_arr.map(ent_arr => _getPlane(__model__, ent_arr));
    }
}
// ================================================================================================
/**
 * Returns the bounding box of the entities.
 * The bounding box is an imaginary box that completley contains all the geometry.
 * The box is always aligned with the global x, y, and z axes.
 * The bounding box consists of a list of lists, as follows [[x, y, z], [x, y, z], [x, y, z], [x, y, z]].
 * - The first [x, y, z] is the coordinates of the centre of the bounding box.
 * - The second [x, y, z] is the corner of the bounding box with the lowest x, y, z values.
 * - The third [x, y, z] is the corner of the bounding box with the highest x, y, z values.
 * - The fourth [x, y, z] is the dimensions of the bounding box.
 * ~
 * @param __model__
 * @param entities The etities for which to calculate the bounding box.
 * @returns The bounding box consisting of a list of four lists.
 */
function BBox(__model__, entities) {
    if (!Array.isArray(entities)) {
        entities = [entities];
    }
    // --- Error Check ---
    const fn_name = 'calc.BBox';
    let ents_arr;
    if (__model__.debug) {
        ents_arr = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])(fn_name, 'entities', entities, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL], null); // all
    }
    else {
        // ents_arr = splitIDs(fn_name, 'entities', entities, [IDcheckObj.isIDList], null) as TEntTypeIdx[]; // all
        ents_arr = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsBreak"])(entities);
    }
    // --- Error Check ---
    return _getBoundingBox(__model__, ents_arr);
}
function _getBoundingBox(__model__, ents_arr) {
    const posis_set_i = new Set();
    for (const ent_arr of ents_arr) {
        const ent_posis_i = __model__.modeldata.geom.nav.navAnyToPosi(ent_arr[0], ent_arr[1]);
        for (const ent_posi_i of ent_posis_i) {
            posis_set_i.add(ent_posi_i);
        }
    }
    const unique_posis_i = Array.from(posis_set_i);
    const unique_xyzs = unique_posis_i.map(posi_i => __model__.modeldata.attribs.query.getPosiCoords(posi_i));
    const corner_min = [Infinity, Infinity, Infinity];
    const corner_max = [-Infinity, -Infinity, -Infinity];
    for (const unique_xyz of unique_xyzs) {
        if (unique_xyz[0] < corner_min[0]) {
            corner_min[0] = unique_xyz[0];
        }
        if (unique_xyz[1] < corner_min[1]) {
            corner_min[1] = unique_xyz[1];
        }
        if (unique_xyz[2] < corner_min[2]) {
            corner_min[2] = unique_xyz[2];
        }
        if (unique_xyz[0] > corner_max[0]) {
            corner_max[0] = unique_xyz[0];
        }
        if (unique_xyz[1] > corner_max[1]) {
            corner_max[1] = unique_xyz[1];
        }
        if (unique_xyz[2] > corner_max[2]) {
            corner_max[2] = unique_xyz[2];
        }
    }
    return [
        [(corner_min[0] + corner_max[0]) / 2, (corner_min[1] + corner_max[1]) / 2, (corner_min[2] + corner_max[2]) / 2],
        corner_min,
        corner_max,
        [corner_max[0] - corner_min[0], corner_max[1] - corner_min[1], corner_max[2] - corner_min[2]]
    ];
}
// ================================================================================================
// /**
//  * Calculates the distance between a ray or plane and a list of positions.
//  * ~
//  * @param __model__
//  * @param ray_or_plane Ray or a plane.
//  * @param entities A position or list of positions.
//  * @param method Enum; all_distances or min_distance.
//  * @returns Distance, or list of distances.
//  * @example distance1 = virtual.Distance(ray, positions, all_distances)
//  * @example_info Returns a list of distances between the ray and each position.
//  */
// export function Distance(__model__: GIModel, ray_or_plane: TRay|TPlane, entities: TId|TId[], method: _EDistanceMethod): number|number[] {
//     // --- Error Check ---
//     const fn_name = 'virtual.Distance';
//     checkCommTypes(fn_name, 'ray_or_plane', ray_or_plane, [TypeCheckObj.isRay, TypeCheckObj.isPlane]);
//     const ents_arr = checkIDs(fn_name, 'entities', entities, [IDcheckObj.isID, IDcheckObj.isIDList],
//         [EEntType.POSI]) as TEntTypeIdx|TEntTypeIdx[];
//     // --- Error Check ---
//     const one_posi: boolean = getArrDepth(ents_arr) === 1;
//     // get the to posis_i
//     let posis_i: number|number[] = null;
//     if (one_posi) {
//         posis_i = ents_arr[1] as number;
//     } else {
//         posis_i = (ents_arr as TEntTypeIdx[]).map( ent_arr => ent_arr[1] ) as number[];
//     }
//     // get a list of distances
//     let dists: number|number[] = null;
//     if (ray_or_plane.length === 2) { // ray
//         const ray_tjs: THREE.Ray = new THREE.Ray(new THREE.Vector3(...ray_or_plane[0]), new THREE.Vector3(...ray_or_plane[1]));
//         dists = _distanceRaytoP(__model__, ray_tjs, posis_i);
//     } else if (ray_or_plane.length === 3) { // plane
//         const plane_normal: Txyz = vecCross(ray_or_plane[1], ray_or_plane[2]);
//         const plane_tjs: THREE.Plane = new THREE.Plane();
//         plane_tjs.setFromNormalAndCoplanarPoint( new THREE.Vector3(...plane_normal), new THREE.Vector3(...ray_or_plane[0]) );
//         dists = _distancePlanetoP(__model__, plane_tjs, posis_i);
//     }
//     // return either the min or the whole list
//     if (method === _EDistanceMethod.MIN_DISTANCE && !one_posi) {
//         return Math.min(...dists as number[]);
//     }
//     return dists;
// }
// function _distanceRaytoP(__model__: GIModel, ray_tjs: THREE.Ray, posis_i: number|number[]): number|number[] {
//     if (!Array.isArray(posis_i)) {
//         const xyz: Txyz = __model__.modeldata.attribs.query.getPosiCoords(posis_i);
//         return ray_tjs.distanceToPoint( new THREE.Vector3(...xyz) ) as number;
//     } else {
//         return posis_i.map( posi_i => _distanceRaytoP(__model__, ray_tjs, posi_i) ) as number[];
//     }
// }
// function _distancePlanetoP(__model__: GIModel, plane_tjs: THREE.Plane, posis_i: number|number[]): number|number[] {
//     if (!Array.isArray(posis_i)) {
//         const xyz: Txyz = __model__.modeldata.attribs.query.getPosiCoords(posis_i);
//         return plane_tjs.distanceToPoint( new THREE.Vector3(...xyz) ) as number;
//     } else {
//         return posis_i.map( posi_i => _distancePlanetoP(__model__, plane_tjs, posi_i) ) as number[];
//     }
// }
// export enum _EDistanceMethod {
//     ALL_DISTANCES = 'all_distances',
//     MIN_DISTANCE = 'min_distance'
// }


/***/ }),

/***/ "./src/assets/core/modules/basic/collection.ts":
/*!*****************************************************!*\
  !*** ./src/assets/core/modules/basic/collection.ts ***!
  \*****************************************************/
/*! exports provided: Create, Get, Add, Remove, Delete */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Create", function() { return Create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Get", function() { return Get; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Add", function() { return Add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Remove", function() { return Remove; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Delete", function() { return Delete; });
/* harmony import */ var _check_ids__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_check_ids */ "./src/assets/core/modules/_check_ids.ts");
/* harmony import */ var _check_args__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_check_args */ "./src/assets/core/modules/_check_args.ts");
/* harmony import */ var _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @libs/geo-info/common */ "./src/assets/libs/geo-info/common.ts");
/* harmony import */ var _libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @libs/geo-info/id */ "./src/assets/libs/geo-info/id.ts");
/* harmony import */ var _libs_util_arrs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @libs/util/arrs */ "./src/assets/libs/util/arrs.ts");
/**
 * The `collections` module has functions for creating and modifying collections.
 */
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};
/**
 *
 */





// ================================================================================================
/**
 * Adds one or more new collections to the model.
 * ~
 * If the list of entities contains other collections, these other collections will then become
 * children of the new collection that will be created.
 * ~
 * @param __model__
 * @param entities List or nested lists of points, polylines, polygons, and other colletions.
 * @param name The name to give to this collection, resulting in an attribute called `name`. If `null`, no attribute will be created.
 * @returns Entities, new collection, or a list of new collections.
 * @example collection1 = collection.Create([point1,polyine1,polygon1], 'my_coll')
 * @example_info Creates a collection containing point1, polyline1, polygon1, with an attribute `name = 'my_coll'`.
 * @example collections = collection.Create([[point1,polyine1],[polygon1]], ['coll1', 'coll2'])
 * @example_info Creates two collections, the first containing point1 and polyline1, the second containing polygon1.
 */
function Create(__model__, entities, name) {
    // --- Error Check ---
    const fn_name = 'collection.Create';
    let ents_arr;
    if (__model__.debug) {
        ents_arr = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])(fn_name, 'entities', entities, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isId, _check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL, _check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdLL], [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].POINT, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].COLL]);
        Object(_check_args__WEBPACK_IMPORTED_MODULE_1__["checkArgs"])(fn_name, 'name', name, [_check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isStr, _check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isStrL]);
    }
    else {
        // ents_arr = splitIDs(fn_name, 'entities', entities,
        //     [IDcheckObj.isID, IDcheckObj.isIDList, IDcheckObj.isIDList_list],
        //     [EEntType.POINT, EEntType.PLINE, EEntType.PGON, EEntType.COLL]) as TEntTypeIdx[];
        ents_arr = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsBreak"])(entities);
    }
    // --- Error Check ---
    const new_ent_arrs = _create(__model__, ents_arr);
    // set the name
    if (name !== null) {
        let colls_i = [];
        if (Array.isArray(new_ent_arrs[0])) {
            colls_i = new_ent_arrs.map(new_ent_arr => new_ent_arr[1]);
        }
        else {
            colls_i = [new_ent_arrs[1]];
        }
        if (Array.isArray(name)) {
            if (name.length !== colls_i.length) {
                throw new Error(fn_name +
                    ': The list of collection names must be equal in length to the list of collections that get created.');
            }
            for (let i = 0; i < name.length; i++) {
                __model__.modeldata.attribs.add.setEntAttribVal(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].COLL, colls_i[i], 'name', name[i]);
            }
        }
        else {
            __model__.modeldata.attribs.add.setEntAttribVal(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].COLL, colls_i, 'name', name);
        }
    }
    // return the collection id
    return Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsMake"])(new_ent_arrs);
}
function _create(__model__, ents_arr) {
    const depth = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["getArrDepth"])(ents_arr);
    if (depth === 1) {
        ents_arr = [ents_arr];
    }
    else if (depth === 3) {
        ents_arr = ents_arr;
        return ents_arr.map(ents_arr_item => _create(__model__, ents_arr_item));
    }
    const points_i = [];
    const plines_i = [];
    const pgons_i = [];
    const child_colls_i = [];
    for (const ent_arr of ents_arr) {
        if (Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["isPoint"])(ent_arr[0])) {
            points_i.push(ent_arr[1]);
        }
        if (Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["isPline"])(ent_arr[0])) {
            plines_i.push(ent_arr[1]);
        }
        if (Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["isPgon"])(ent_arr[0])) {
            pgons_i.push(ent_arr[1]);
        }
        if (Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["isColl"])(ent_arr[0])) {
            child_colls_i.push(ent_arr[1]);
        }
    }
    // create the collection, setting tha parent to -1
    const coll_i = __model__.modeldata.geom.add.addColl(-1, points_i, plines_i, pgons_i);
    // set the parents
    for (const child_coll_i of child_colls_i) {
        __model__.modeldata.geom.modify_coll.setCollParent(child_coll_i, coll_i);
    }
    // return the new collection
    return [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].COLL, coll_i];
}
// ================================================================================================
/**
 * Get one or more collections from the model, given a name or list of names.
 * Collections with an attribute called 'name' and with a value that matches teh given vale will be returned.
 * ~
 * The value for name can include wildcards: '?' matches any single character and '*' matches any sequence of characters.
 * For example, 'coll?' will match 'coll1' and 'colla'. 'coll*' matches any name that starts with 'coll'.
 * ~
 * If a single collection is found, the collection will be returned as a single item (not a list).
 * This is a convenience so that there is no need to get the first item out of the returned list.
 * ~
 * If no collections are found, then an empty list is returned.
 * ~
 * @param __model__
 * @param names A name or list of names. May include wildcards, '?' and '*'.
 * @returns The collection, or a list of collections.
 */
function Get(__model__, names) {
    // --- Error Check ---
    if (__model__.debug) {
        const fn_name = 'collection.Get';
        Object(_check_args__WEBPACK_IMPORTED_MODULE_1__["checkArgs"])(fn_name, 'names', names, [_check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isStr, _check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isStrL]);
    }
    // --- Error Check ---
    const colls_i = _get(__model__, names);
    if (colls_i.length === 0) {
        return []; // return an empty list
    }
    else if (colls_i.length === 1) {
        return Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsMake"])([_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].COLL, colls_i[0]]);
    }
    return Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsMake"])(colls_i.map(coll_i => [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].COLL, coll_i]));
}
function _get(__model__, names) {
    if (!Array.isArray(names)) {
        // wildcards
        if (names.indexOf('*') !== -1 || names.indexOf('?') !== -1) {
            const reg_exp = new RegExp(names.replace('?', '\\w').replace('*', '\\w*'));
            const all_colls_i = __model__.modeldata.geom.query.getEnts(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].COLL);
            const all_names = __model__.modeldata.attribs.query.getAttribVal(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].COLL, 'name', all_colls_i);
            const unique_names = Array.from(new Set(all_names));
            const match_names = [];
            for (const name1 of unique_names) {
                if (reg_exp.test(name1)) {
                    match_names.push(name1);
                }
            }
            return _get(__model__, match_names);
        }
        const colls_i = __model__.modeldata.geom.query.getEnts(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].COLL);
        const query_result = __model__.modeldata.attribs.query.filterByAttribs(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].COLL, colls_i, 'name', null, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EFilterOperatorTypes"].IS_EQUAL, names);
        return query_result;
    }
    else {
        const all_colls_i = [];
        for (const name1 of names) {
            for (const coll_i of _get(__model__, name1)) {
                all_colls_i.push(coll_i);
            }
        }
        return all_colls_i;
    }
}
// ================================================================================================
/**
 * Addes entities to a collection.
 * ~
 * @param __model__
 * @param coll The collection to be updated.
 * @param entities Points, polylines, polygons, and collections to add.
 * @returns void
 */
function Add(__model__, coll, entities) {
    entities = Object(_libs_util_arrs__WEBPACK_IMPORTED_MODULE_4__["arrMakeFlat"])(entities);
    if (!Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["isEmptyArr"])(entities)) {
        // --- Error Check ---
        const fn_name = 'collection.Add';
        let coll_arr;
        let ents_arr;
        if (__model__.debug) {
            coll_arr = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])(fn_name, 'coll', coll, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isId], [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].COLL]);
            ents_arr = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])(fn_name, 'entities', entities, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isId, _check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL], [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].POINT, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].COLL]);
        }
        else {
            // coll_arr = splitIDs(fn_name, 'coll', coll, [IDcheckObj.isID], [EEntType.COLL]) as TEntTypeIdx;
            // ents_arr = splitIDs(fn_name, 'entities', entities,
            //     [IDcheckObj.isID, IDcheckObj.isIDList],
            //     [EEntType.POINT, EEntType.PLINE, EEntType.PGON, EEntType.COLL]) as TEntTypeIdx[];
            coll_arr = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsBreak"])(coll);
            ents_arr = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsBreak"])(entities);
        }
        // --- Error Check ---
        _collectionAdd(__model__, coll_arr[1], ents_arr);
    }
}
function _collectionAdd(__model__, coll_i, ents_arr) {
    const points_i = [];
    const plines_i = [];
    const pgons_i = [];
    for (const [ent_type, ent_i] of ents_arr) {
        switch (ent_type) {
            case _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].POINT:
                points_i.push(ent_i);
                break;
            case _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE:
                plines_i.push(ent_i);
                break;
            case _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON:
                pgons_i.push(ent_i);
                break;
            case _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].COLL:
                __model__.modeldata.geom.modify_coll.setCollParent(ent_i, coll_i);
                break;
            default:
                throw new Error('Error adding entities to a collection. \
                A collection can only contain points, polylines, polygons, and other collections.');
        }
    }
    __model__.modeldata.geom.modify_coll.collAddEnts(coll_i, points_i, plines_i, pgons_i);
}
// ================================================================================================
/**
 * Removes entities from a collection.
 * ~
 * @param __model__
 * @param coll The collection to be updated.
 * @param entities Points, polylines, polygons, and collections to add. Or null to empty the collection.
 * @returns void
 */
function Remove(__model__, coll, entities) {
    // --- Error Check ---
    const fn_name = 'collection.Remove';
    let ents_arr = null;
    let coll_arr;
    if (__model__.debug) {
        if (entities !== null) {
            entities = Object(_libs_util_arrs__WEBPACK_IMPORTED_MODULE_4__["arrMakeFlat"])(entities);
            ents_arr = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])(fn_name, 'entities', entities, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isId, _check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL], [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].POINT, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].COLL]);
        }
        coll_arr = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])(fn_name, 'coll', coll, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isId], [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].COLL]);
    }
    else {
        if (entities !== null) {
            entities = Object(_libs_util_arrs__WEBPACK_IMPORTED_MODULE_4__["arrMakeFlat"])(entities);
            // ents_arr = splitIDs(fn_name, 'entities', entities,
            //     [IDcheckObj.isID, IDcheckObj.isIDList],
            //     [EEntType.POINT, EEntType.PLINE, EEntType.PGON, EEntType.COLL]) as TEntTypeIdx[];
            ents_arr = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsBreak"])(entities);
        }
        // coll_arr = splitIDs(fn_name, 'coll', coll, [IDcheckObj.isID], [EEntType.COLL]) as TEntTypeIdx;
        coll_arr = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsBreak"])(coll);
    }
    // --- Error Check ---
    if (ents_arr === null) {
        _collectionEmpty(__model__, coll_arr[1]);
    }
    else {
        _collectionRemove(__model__, coll_arr[1], ents_arr);
    }
}
function _collectionRemove(__model__, coll_i, ents_arr) {
    const points_i = [];
    const plines_i = [];
    const pgons_i = [];
    for (const [ent_type, ent_i] of ents_arr) {
        switch (ent_type) {
            case _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].POINT:
                points_i.push(ent_i);
                break;
            case _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE:
                plines_i.push(ent_i);
                break;
            case _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON:
                pgons_i.push(ent_i);
                break;
            case _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].COLL:
                if (__model__.modeldata.geom.query.getCollParent(ent_i) === coll_i) {
                    __model__.modeldata.geom.modify_coll.setCollParent(ent_i, -1);
                }
                break;
            default:
                throw new Error('Error removing entities from a collection. \
                A collection can only contain points, polylines, polygons, and other collections.');
        }
    }
    __model__.modeldata.geom.modify_coll.collRemoveEnts(coll_i, points_i, plines_i, pgons_i);
}
function _collectionEmpty(__model__, coll_i) {
    const points_i = __model__.modeldata.geom.nav.navCollToPoint(coll_i);
    const plines_i = __model__.modeldata.geom.nav.navCollToPline(coll_i);
    const pgons_i = __model__.modeldata.geom.nav.navCollToPgon(coll_i);
    __model__.modeldata.geom.modify_coll.collRemoveEnts(coll_i, points_i, plines_i, pgons_i);
    // remove the collections that are children of this collection
    const child_colls_i = __model__.modeldata.geom.query.getCollChildren(coll_i);
    for (const child_coll_i of child_colls_i) {
        __model__.modeldata.geom.modify_coll.setCollParent(child_coll_i, -1);
    }
}
// ================================================================================================
/**
 * Deletes a collection without deleting the entities in the collection.
 * ~
 * @param __model__
 * @param coll The collection or list of collections to be deleted.
 * @returns void
 */
function Delete(__model__, coll) {
    coll = Object(_libs_util_arrs__WEBPACK_IMPORTED_MODULE_4__["arrMakeFlat"])(coll);
    // --- Error Check ---
    const fn_name = 'collection.Delete';
    let colls_arrs;
    if (__model__.debug) {
        colls_arrs = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])(fn_name, 'coll', coll, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL], [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].COLL]);
    }
    else {
        // colls_arrs = splitIDs(fn_name, 'coll', coll, [IDcheckObj.isIDList], [EEntType.COLL]) as TEntTypeIdx[];
        colls_arrs = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsBreak"])(coll);
    }
    // --- Error Check ---
    const colls_i = [];
    for (const [ent_type, ent_i] of colls_arrs) {
        colls_i.push(ent_i);
    }
    __model__.modeldata.geom.del.delColls(colls_i, false);
}
// ================================================================================================


/***/ }),

/***/ "./src/assets/core/modules/basic/dict.ts":
/*!***********************************************!*\
  !*** ./src/assets/core/modules/basic/dict.ts ***!
  \***********************************************/
/*! exports provided: Add, Remove, Replace */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Add", function() { return Add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Remove", function() { return Remove; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Replace", function() { return Replace; });
/* harmony import */ var _check_args__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_check_args */ "./src/assets/core/modules/_check_args.ts");
/**
 * The `dict` module has functions for working with dictionaries.
 * These functions have no direct link with the model, the are generic functions for manipulating dictionaries.
 * These functions neither make nor modify anything in the model.
 * In addition to these functions, there are also inline functions available for working with dictionaries.

 */
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};
/**
 *
 */

// ================================================================================================
/**
 * Adds one or more key-value pairs to a dict. Existing keys with the same name will be overwritten.
 * ~
 * @param dict Dictionary to add the key-value pairs to.
 * @param keys A key or list of keys.
 * @param values A value of list of values.
 * @returns void
 */
function Add(dict, keys, values) {
    // --- Error Check ---
    const fn_name = 'dict.Add';
    Object(_check_args__WEBPACK_IMPORTED_MODULE_0__["checkArgs"])(fn_name, 'keys', keys, [_check_args__WEBPACK_IMPORTED_MODULE_0__["ArgCh"].isStr, _check_args__WEBPACK_IMPORTED_MODULE_0__["ArgCh"].isStrL]);
    Object(_check_args__WEBPACK_IMPORTED_MODULE_0__["checkArgs"])(fn_name, 'values', keys, [_check_args__WEBPACK_IMPORTED_MODULE_0__["ArgCh"].isAny, _check_args__WEBPACK_IMPORTED_MODULE_0__["ArgCh"].isList]);
    keys = Array.isArray(keys) ? keys : [keys];
    values = Array.isArray(values) ? values : [values];
    if (keys.length !== values.length) {
        throw new Error(fn_name + ': The list of keys must be the same length as the list of values.');
    }
    // --- Error Check ---
    for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        const value = values[i];
        dict[key] = dict[value];
    }
}
// ================================================================================================
/**
 * Removes keys from a dict. If the key does not exist, no action is taken and no error is thrown.
 * ~
 * @param dict The dict in which to remove keys
 * @param keys The key or list of keys to remove.
 * @returns void
 */
function Remove(dict, keys) {
    // --- Error Check ---
    const fn_name = 'dict.Remove';
    Object(_check_args__WEBPACK_IMPORTED_MODULE_0__["checkArgs"])(fn_name, 'key', keys, [_check_args__WEBPACK_IMPORTED_MODULE_0__["ArgCh"].isStr, _check_args__WEBPACK_IMPORTED_MODULE_0__["ArgCh"].isStrL]);
    // --- Error Check ---
    if (!Array.isArray(keys)) {
        keys = [keys];
    }
    keys = keys;
    for (const key of keys) {
        if (typeof key !== 'string') {
            throw new Error('dict.Remove: Keys must be strings; \
                the following key is not valid:"' + key + '".');
        }
        if (key in dict) {
            delete dict[key];
        }
    }
}
// ================================================================================================
/**
 * Replaces keys in a dict. If the key does not exist, no action is taken and no error is thrown.
 * ~
 * @param dict The dict in which to replace keys
 * @param old_keys The old key or list of keys.
 * @param new_keys The new key or list of keys.
 * @returns void
 */
function Replace(dict, old_keys, new_keys) {
    // --- Error Check ---
    const fn_name = 'dict.Replace';
    Object(_check_args__WEBPACK_IMPORTED_MODULE_0__["checkArgs"])(fn_name, 'old_keys', old_keys, [_check_args__WEBPACK_IMPORTED_MODULE_0__["ArgCh"].isStr, _check_args__WEBPACK_IMPORTED_MODULE_0__["ArgCh"].isStrL]);
    Object(_check_args__WEBPACK_IMPORTED_MODULE_0__["checkArgs"])(fn_name, 'new_keys', new_keys, [_check_args__WEBPACK_IMPORTED_MODULE_0__["ArgCh"].isStr, _check_args__WEBPACK_IMPORTED_MODULE_0__["ArgCh"].isStrL]);
    old_keys = Array.isArray(old_keys) ? old_keys : [old_keys];
    new_keys = Array.isArray(new_keys) ? new_keys : [new_keys];
    if (old_keys.length !== new_keys.length) {
        throw new Error(fn_name + ': The list of new keys must be the same length as the list of old keys.');
    }
    // --- Error Check ---
    for (let i = 0; i < old_keys.length; i++) {
        const old_key = old_keys[i];
        const new_key = new_keys[i];
        if (old_key in dict) {
            dict[new_key] = dict[old_key];
            delete dict[old_key];
        }
    }
}
// ================================================================================================


/***/ }),

/***/ "./src/assets/core/modules/basic/intersect.ts":
/*!****************************************************!*\
  !*** ./src/assets/core/modules/basic/intersect.ts ***!
  \****************************************************/
/*! exports provided: RayFace, PlaneEdge */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RayFace", function() { return RayFace; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PlaneEdge", function() { return PlaneEdge; });
/* harmony import */ var _check_ids__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_check_ids */ "./src/assets/core/modules/_check_ids.ts");
/* harmony import */ var _check_args__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_check_args */ "./src/assets/core/modules/_check_args.ts");
/* harmony import */ var _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @libs/geo-info/common */ "./src/assets/libs/geo-info/common.ts");
/* harmony import */ var _libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @libs/geo-info/id */ "./src/assets/libs/geo-info/id.ts");
/* harmony import */ var _libs_geom_vectors__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @libs/geom/vectors */ "./src/assets/libs/geom/vectors.ts");
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/**
 * The `intersect` module has functions for calculating intersections between different types of entities.
 */
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};
/**
 *
 */






// ================================================================================================
/**
 * Calculates the xyz intersection between a ray or a plane and a list of entities.
 * ~
 * For a ray, the intersection between the ray and one or more faces is return.
 * The intersection between each face triangle and the ray is caclulated.
 * This ignores the intersections between rays and edges (including polyline edges).
 * ~
 * For a plane, the intersection between the plane and one or more edges is returned.
 * This ignores the intersections between planes and face triangles (including polygon faces).
 * ~
 * @param __model__
 * @param ray A ray.
 * @param entities List of entities.
 * @return A list of xyz intersection coordinates.
 * @example coords = virtual.Intersect(plane, polyline1)
 * @example_info Returns a list of coordinates where the plane intersects with polyline1.
 */
function RayFace(__model__, ray, entities) {
    // --- Error Check ---
    const fn_name = 'intersect.RayFace';
    let ents_arr;
    if (__model__.debug) {
        Object(_check_args__WEBPACK_IMPORTED_MODULE_1__["checkArgs"])(fn_name, 'ray', ray, [_check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isRay]);
        ents_arr = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])(fn_name, 'entities', entities, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isId, _check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL], [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].FACE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].COLL]);
    }
    else {
        // ents_arr = splitIDs(fn_name, 'entities', entities,
        //     [IDcheckObj.isID, IDcheckObj.isIDList],
        //     [EEntType.FACE, EEntType.PGON, EEntType.COLL]) as TEntTypeIdx|TEntTypeIdx[];
        ents_arr = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsBreak"])(entities);
    }
    // --- Error Check ---
    // create the threejs entity and calc intersections
    const ray_tjs = new three__WEBPACK_IMPORTED_MODULE_5__["Ray"](new three__WEBPACK_IMPORTED_MODULE_5__["Vector3"](...ray[0]), new three__WEBPACK_IMPORTED_MODULE_5__["Vector3"](...ray[1]));
    return _intersectRay(__model__, ents_arr, ray_tjs);
}
function _intersectRay(__model__, ents_arr, ray_tjs) {
    if (Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["getArrDepth"])(ents_arr) === 1) {
        const [ent_type, index] = ents_arr;
        const posis_i = __model__.modeldata.geom.nav.navAnyToPosi(ent_type, index);
        const posis_tjs = [];
        for (const posi_i of posis_i) {
            const xyz = __model__.modeldata.attribs.query.getPosiCoords(posi_i);
            const posi_tjs = new three__WEBPACK_IMPORTED_MODULE_5__["Vector3"](...xyz);
            posis_tjs[posi_i] = posi_tjs;
        }
        const isect_xyzs = [];
        // triangles
        const tris_i = __model__.modeldata.geom.nav.navAnyToTri(ent_type, index);
        for (const tri_i of tris_i) {
            const tri_posis_i = __model__.modeldata.geom.nav.navAnyToPosi(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].TRI, tri_i);
            const tri_posis_tjs = tri_posis_i.map(tri_posi_i => posis_tjs[tri_posi_i]);
            const isect_tjs = new three__WEBPACK_IMPORTED_MODULE_5__["Vector3"]();
            const result = ray_tjs.intersectTriangle(tri_posis_tjs[0], tri_posis_tjs[1], tri_posis_tjs[2], false, isect_tjs);
            if (result !== undefined && result !== null) {
                isect_xyzs.push([isect_tjs.x, isect_tjs.y, isect_tjs.z]);
            }
        }
        // return the intersection xyzs
        return isect_xyzs;
    }
    else {
        const all_isect_xyzs = [];
        for (const ent_arr of ents_arr) {
            const isect_xyzs = _intersectRay(__model__, ent_arr, ray_tjs);
            for (const isect_xyz of isect_xyzs) {
                all_isect_xyzs.push(isect_xyz);
            }
        }
        return all_isect_xyzs;
    }
}
// ================================================================================================
/**
 * Calculates the xyz intersection between a ray or a plane and a list of entities.
 * ~
 * For a ray, the intersection between the ray and one or more faces is return.
 * The intersection between each face triangle and the ray is caclulated.
 * This ignores the intersections between rays and edges (including polyline edges).
 * ~
 * For a plane, the intersection between the plane and one or more edges is returned.
 * This ignores the intersections between planes and face triangles (including polygon faces).
 * ~
 * @param __model__
 * @param plane A plane.
 * @param entities List of entities.
 * @return A list of xyz intersection coordinates.
 * @example coords = virtual.Intersect(plane, polyline1)
 * @example_info Returns a list of coordinates where the plane intersects with polyline1.
 */
function PlaneEdge(__model__, plane, entities) {
    // --- Error Check ---
    const fn_name = 'intersect.PlaneEdge';
    let ents_arr;
    if (__model__.debug) {
        Object(_check_args__WEBPACK_IMPORTED_MODULE_1__["checkArgs"])(fn_name, 'plane', plane, [_check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isPln]);
        ents_arr = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])(fn_name, 'entities', entities, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isId, _check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL], [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].EDGE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].WIRE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].FACE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].COLL]);
    }
    else {
        // ents_arr = splitIDs(fn_name, 'entities', entities,
        //     [IDcheckObj.isID, IDcheckObj.isIDList],
        //     [EEntType.EDGE, EEntType.WIRE, EEntType.FACE, EEntType.PLINE, EEntType.PGON, EEntType.COLL]) as TEntTypeIdx|TEntTypeIdx[];
        ents_arr = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsBreak"])(entities);
    }
    // --- Error Check ---
    // create the threejs entity and calc intersections
    const plane_normal = Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_4__["vecCross"])(plane[1], plane[2]);
    const plane_tjs = new three__WEBPACK_IMPORTED_MODULE_5__["Plane"]();
    plane_tjs.setFromNormalAndCoplanarPoint(new three__WEBPACK_IMPORTED_MODULE_5__["Vector3"](...plane_normal), new three__WEBPACK_IMPORTED_MODULE_5__["Vector3"](...plane[0]));
    return _intersectPlane(__model__, ents_arr, plane_tjs);
}
function _intersectPlane(__model__, ents_arr, plane_tjs) {
    if (Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["getArrDepth"])(ents_arr) === 1) {
        const [ent_type, index] = ents_arr;
        const isect_xyzs = [];
        const wires_i = __model__.modeldata.geom.nav.navAnyToWire(ent_type, index);
        for (const wire_i of wires_i) {
            const wire_posis_i = __model__.modeldata.geom.nav.navAnyToPosi(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].WIRE, wire_i);
            // create threejs posis for all posis
            const posis_tjs = [];
            for (const wire_posi_i of wire_posis_i) {
                const xyz = __model__.modeldata.attribs.query.getPosiCoords(wire_posi_i);
                const posi_tjs = new three__WEBPACK_IMPORTED_MODULE_5__["Vector3"](...xyz);
                posis_tjs.push(posi_tjs);
            }
            if (__model__.modeldata.geom.query.isWireClosed(wire_i)) {
                posis_tjs.push(posis_tjs[0]);
            }
            // for each pair of posis, create a threejs line and do the intersect
            for (let i = 0; i < posis_tjs.length - 1; i++) {
                const line_tjs = new three__WEBPACK_IMPORTED_MODULE_5__["Line3"](posis_tjs[i], posis_tjs[i + 1]);
                const isect_tjs = new three__WEBPACK_IMPORTED_MODULE_5__["Vector3"]();
                const result = plane_tjs.intersectLine(line_tjs, isect_tjs);
                if (result !== undefined && result !== null) {
                    isect_xyzs.push([isect_tjs.x, isect_tjs.y, isect_tjs.z]);
                }
            }
        }
        return isect_xyzs;
    }
    else {
        const all_isect_xyzs = [];
        for (const ent_arr of ents_arr) {
            const isect_xyzs = _intersectPlane(__model__, ent_arr, plane_tjs);
            for (const isect_xyz of isect_xyzs) {
                all_isect_xyzs.push(isect_xyz);
            }
        }
        return all_isect_xyzs;
    }
}


/***/ }),

/***/ "./src/assets/core/modules/basic/io.ts":
/*!*********************************************!*\
  !*** ./src/assets/core/modules/basic/io.ts ***!
  \*********************************************/
/*! exports provided: _EIODataFormat, _EIODataSource, _EIODataTarget, Read, Write, Import, _EIOExportDataFormat, Export, _getFile */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_EIODataFormat", function() { return _EIODataFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_EIODataSource", function() { return _EIODataSource; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_EIODataTarget", function() { return _EIODataTarget; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Read", function() { return Read; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Write", function() { return Write; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Import", function() { return Import; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_EIOExportDataFormat", function() { return _EIOExportDataFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Export", function() { return Export; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_getFile", function() { return _getFile; });
/* harmony import */ var _check_ids__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_check_ids */ "./src/assets/core/modules/_check_ids.ts");
/* harmony import */ var _check_args__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_check_args */ "./src/assets/core/modules/_check_args.ts");
/* harmony import */ var _libs_geo_info_GIModel__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @libs/geo-info/GIModel */ "./src/assets/libs/geo-info/GIModel.ts");
/* harmony import */ var _libs_geo_info_io_obj__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @libs/geo-info/io_obj */ "./src/assets/libs/geo-info/io_obj.ts");
/* harmony import */ var _libs_geo_info_io_geojson__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @libs/geo-info/io_geojson */ "./src/assets/libs/geo-info/io_geojson.ts");
/* harmony import */ var _libs_filesys_download__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @libs/filesys/download */ "./src/assets/libs/filesys/download.ts");
/* harmony import */ var _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @libs/geo-info/common */ "./src/assets/libs/geo-info/common.ts");
/* harmony import */ var _libs_geo_info_id__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @libs/geo-info/id */ "./src/assets/libs/geo-info/id.ts");
/* harmony import */ var _assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @assets/libs/util/arrs */ "./src/assets/libs/util/arrs.ts");
/* harmony import */ var jszip__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! jszip */ "./node_modules/jszip/dist/jszip.min.js");
/* harmony import */ var jszip__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(jszip__WEBPACK_IMPORTED_MODULE_9__);
/**
 * The `io` module has functions for importing and exporting.
 */
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};
/**
 *
 */










const requestedBytes = 1024 * 1024 * 200; // 200 MB local storage quota
// ================================================================================================
// Import / Export data types
var _EIODataFormat;
(function (_EIODataFormat) {
    _EIODataFormat["GI"] = "gi";
    _EIODataFormat["OBJ"] = "obj";
    _EIODataFormat["GEOJSON"] = "geojson";
})(_EIODataFormat || (_EIODataFormat = {}));
var _EIODataSource;
(function (_EIODataSource) {
    _EIODataSource["DEFAULT"] = "From URL";
    _EIODataSource["FILESYS"] = "From Local Storage";
})(_EIODataSource || (_EIODataSource = {}));
var _EIODataTarget;
(function (_EIODataTarget) {
    _EIODataTarget["DEFAULT"] = "Save to Hard Disk";
    _EIODataTarget["FILESYS"] = "Save to Local Storage";
})(_EIODataTarget || (_EIODataTarget = {}));
// ================================================================================================
/**
 * Read data from a Url or from local storage.
 *
 * @param data The data to be read (from URL or from Local Storage).
 * @returns the data.
 */
function Read(__model__, data) {
    return __awaiter(this, void 0, void 0, function* () {
        return _getFile(data);
    });
}
// ================================================================================================
/**
 * Write data to the hard disk or to the local storage.
 *
 * @param data The data to be saved (can be the url to the file).
 * @param file_name The name to be saved in the file system (file extension should be included).
 * @param data_target Enum, where the data is to be exported to.
 * @returns whether the data is successfully saved.
 */
function Write(__model__, data, file_name, data_target) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            if (data_target === _EIODataTarget.DEFAULT) {
                return Object(_libs_filesys_download__WEBPACK_IMPORTED_MODULE_5__["download"])(data, file_name);
            }
            return saveResource(data, file_name);
        }
        catch (ex) {
            return false;
        }
    });
}
// ================================================================================================
/**
 * Imports data into the model.
 * ~
 * Model data can be pasted in directly as a string, or can be retrieved as a file.
 * ~
 * If model data is retrieved from a file, there are two ways of specifying the file location:
 * - A url, e.g. "https://www.dropbox.com/xxxx/my_data.obj"
 * - A file name in the local storage, e.g. "my_data.obj".
 * ~
 * To place a file in local storage, go to the Mobius menu, and select 'Local Storage' from the dropdown.
 * Note that a codescript using a file in local storage will not be shareable with others.
 * ~
 * @param model_data The model data
 * @param data_format Enum, the file format.
 * @returns A list of the positions, points, polylines, polygons and collections added to the model.
 * @example io.Import ("my_data.obj", obj)
 * @example_info Imports the data from my_data.obj, from local storage.
 */
function Import(__model__, input_data, data_format) {
    return __awaiter(this, void 0, void 0, function* () {
        const model_data = yield _getFile(input_data);
        if (!model_data) {
            throw new Error('Invalid imported model data');
        }
        let coll_i = null;
        if (model_data.constructor === {}.constructor) {
            let import_func;
            switch (data_format) {
                case _EIODataFormat.GI:
                    import_func = _importGI;
                    break;
                case _EIODataFormat.OBJ:
                    import_func = _importObj;
                    break;
                case _EIODataFormat.GEOJSON:
                    import_func = _importGeojson;
                    break;
                default:
                    throw new Error('Import type not recognised');
            }
            const coll_results = {};
            for (const data_name in model_data) {
                if (model_data[data_name]) {
                    coll_i = import_func(__model__, model_data[data_name]);
                    coll_results[data_name] = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_7__["idsMake"])([_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_6__["EEntType"].COLL, coll_i]);
                }
            }
            return coll_results;
        }
        switch (data_format) {
            case _EIODataFormat.GI:
                coll_i = _importGI(__model__, model_data);
                break;
            case _EIODataFormat.OBJ:
                coll_i = _importObj(__model__, model_data);
                break;
            case _EIODataFormat.GEOJSON:
                coll_i = _importGeojson(__model__, model_data);
                break;
            default:
                throw new Error('Import type not recognised');
        }
        return Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_7__["idsMake"])([_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_6__["EEntType"].COLL, coll_i]);
    });
}
function _importGI(__model__, json_str) {
    // get number of ents before merge
    const num_ents_before = __model__.modeldata.geom.query.numEntsAll();
    // import
    const gi_model = new _libs_geo_info_GIModel__WEBPACK_IMPORTED_MODULE_2__["GIModel"](__model__.getMetaData());
    gi_model.setJSONStr(json_str);
    __model__.mergeAndPurge(gi_model);
    // get number of ents after merge
    const num_ents_after = __model__.modeldata.geom.query.numEntsAll();
    // return the result
    return _createGIColl(__model__, num_ents_before, num_ents_after);
}
function _importObj(__model__, model_data) {
    // get number of ents before merge
    const num_ents_before = __model__.modeldata.geom.query.numEntsAll();
    // import
    const obj_model = Object(_libs_geo_info_io_obj__WEBPACK_IMPORTED_MODULE_3__["importObj"])(model_data);
    __model__.merge(obj_model);
    // get number of ents after merge
    const num_ents_after = __model__.modeldata.geom.query.numEntsAll();
    // return the result
    return _createColl(__model__, num_ents_before, num_ents_after);
}
function _importGeojson(__model__, model_data) {
    // get number of ents before merge
    const num_ents_before = __model__.modeldata.geom.query.numEntsAll();
    // import
    Object(_libs_geo_info_io_geojson__WEBPACK_IMPORTED_MODULE_4__["importGeojson"])(__model__, model_data, 0);
    // get number of ents after merge
    const num_ents_after = __model__.modeldata.geom.query.numEntsAll();
    // return the result
    return _createColl(__model__, num_ents_before, num_ents_after);
}
function _createGIColl(__model__, before, after) {
    const points_i = [];
    const plines_i = [];
    const pgons_i = [];
    for (let point_i = before[1]; point_i < after[1]; point_i++) {
        if (__model__.modeldata.geom.query.entExists(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_6__["EEntType"].POINT, point_i)) {
            points_i.push(point_i);
        }
    }
    for (let pline_i = before[2]; pline_i < after[2]; pline_i++) {
        if (__model__.modeldata.geom.query.entExists(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_6__["EEntType"].PLINE, pline_i)) {
            plines_i.push(pline_i);
        }
    }
    for (let pgon_i = before[3]; pgon_i < after[3]; pgon_i++) {
        if (__model__.modeldata.geom.query.entExists(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_6__["EEntType"].PGON, pgon_i)) {
            pgons_i.push(pgon_i);
        }
    }
    if (points_i.length + plines_i.length + pgons_i.length === 0) {
        return null;
    }
    const container_coll_i = __model__.modeldata.geom.add.addColl(null, points_i, plines_i, pgons_i);
    for (let coll_i = before[4]; coll_i < after[4]; coll_i++) {
        if (__model__.modeldata.geom.query.entExists(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_6__["EEntType"].COLL, coll_i)) {
            __model__.modeldata.geom.modify_coll.setCollParent(coll_i, container_coll_i);
        }
    }
    return container_coll_i;
}
function _createColl(__model__, before, after) {
    const points_i = [];
    const plines_i = [];
    const pgons_i = [];
    for (let point_i = before[1]; point_i < after[1]; point_i++) {
        points_i.push(point_i);
    }
    for (let pline_i = before[2]; pline_i < after[2]; pline_i++) {
        plines_i.push(pline_i);
    }
    for (let pgon_i = before[3]; pgon_i < after[3]; pgon_i++) {
        pgons_i.push(pgon_i);
    }
    if (points_i.length + plines_i.length + pgons_i.length === 0) {
        return null;
    }
    const container_coll_i = __model__.modeldata.geom.add.addColl(null, points_i, plines_i, pgons_i);
    for (let coll_i = before[4]; coll_i < after[4]; coll_i++) {
        __model__.modeldata.geom.modify_coll.setCollParent(coll_i, container_coll_i);
    }
    return container_coll_i;
}
// ================================================================================================
var _EIOExportDataFormat;
(function (_EIOExportDataFormat) {
    _EIOExportDataFormat["GI"] = "gi";
    _EIOExportDataFormat["OBJ_VERT"] = "obj_v";
    _EIOExportDataFormat["OBJ_POSI"] = "obj_ps";
    // DAE = 'dae',
    _EIOExportDataFormat["GEOJSON"] = "geojson";
})(_EIOExportDataFormat || (_EIOExportDataFormat = {}));
/**
 * Export data from the model as a file.
 * ~
 * If you expore to your  hard disk,
 * it will result in a popup in your browser, asking you to save the file.
 * ~
 * If you export to Local Storage, there will be no popup.
 * ~
 * @param __model__
 * @param entities Optional. Entities to be exported. If null, the whole model will be exported.
 * @param file_name Name of the file as a string.
 * @param data_format Enum, the file format.
 * @param data_target Enum, where the data is to be exported to.
 * @returns void.
 * @example io.Export (#pg, 'my_model.obj', obj)
 * @example_info Exports all the polgons in the model as an OBJ.
 */
function Export(__model__, entities, file_name, data_format, data_target) {
    return __awaiter(this, void 0, void 0, function* () {
        if (typeof localStorage === 'undefined') {
            return;
        }
        // --- Error Check ---
        const fn_name = 'io.Export';
        let ents_arr = null;
        if (__model__.debug) {
            if (entities !== null) {
                entities = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_8__["arrMakeFlat"])(entities);
                ents_arr = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])(fn_name, 'entities', entities, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL], [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_6__["EEntType"].PLINE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_6__["EEntType"].PGON, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_6__["EEntType"].COLL]);
            }
            Object(_check_args__WEBPACK_IMPORTED_MODULE_1__["checkArgs"])(fn_name, 'file_name', file_name, [_check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isStr, _check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isStrL]);
        }
        else {
            if (entities !== null) {
                entities = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_8__["arrMakeFlat"])(entities);
                // ents_arr = splitIDs(fn_name, 'entities', entities,
                //     [IDcheckObj.isIDList], [EEntType.PLINE, EEntType.PGON, EEntType.COLL])  as TEntTypeIdx[];
                ents_arr = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_7__["idsBreak"])(entities);
            }
        }
        // --- Error Check ---
        yield _export(__model__, ents_arr, file_name, data_format, data_target);
    });
}
function _export(__model__, ents_arr, file_name, data_format, data_target) {
    return __awaiter(this, void 0, void 0, function* () {
        switch (data_format) {
            case _EIOExportDataFormat.GI:
                // === get model data ===
                let model_data = '';
                // clone the model
                const model_clone = __model__.clone();
                if (ents_arr !== null) {
                    // get the ents
                    const ent_sets = model_clone.modeldata.geom.query.getDelEntSets(ents_arr);
                    // delete the ents
                    model_clone.delete(ent_sets, true);
                }
                // === get meta data ===
                model_data = model_clone.getJSONStr();
                // gi_data = gi_data.replace(/\\\"/g, '\\\\\\"'); // TODO temporary fix
                model_data = model_data.replace(/\\/g, '\\\\\\'); // TODO temporary fix
                // === save the file ===
                if (data_target === _EIODataTarget.DEFAULT) {
                    return Object(_libs_filesys_download__WEBPACK_IMPORTED_MODULE_5__["download"])(model_data, file_name);
                }
                return saveResource(model_data, file_name);
            case _EIOExportDataFormat.OBJ_VERT:
                const obj_verts_data = Object(_libs_geo_info_io_obj__WEBPACK_IMPORTED_MODULE_3__["exportVertBasedObj"])(__model__, ents_arr);
                // obj_data = obj_data.replace(/#/g, '%23'); // TODO temporary fix
                if (data_target === _EIODataTarget.DEFAULT) {
                    return Object(_libs_filesys_download__WEBPACK_IMPORTED_MODULE_5__["download"])(obj_verts_data, file_name);
                }
                return saveResource(obj_verts_data, file_name);
            case _EIOExportDataFormat.OBJ_POSI:
                const obj_posis_data = Object(_libs_geo_info_io_obj__WEBPACK_IMPORTED_MODULE_3__["exportPosiBasedObj"])(__model__, ents_arr);
                // obj_data = obj_data.replace(/#/g, '%23'); // TODO temporary fix
                if (data_target === _EIODataTarget.DEFAULT) {
                    return Object(_libs_filesys_download__WEBPACK_IMPORTED_MODULE_5__["download"])(obj_posis_data, file_name);
                }
                return saveResource(obj_posis_data, file_name);
            // case _EIOExportDataFormat.DAE:
            //     const dae_data: string = exportDae(__model__);
            //     // dae_data = dae_data.replace(/#/g, '%23'); // TODO temporary fix
            //     if (data_target === _EIODataTarget.DEFAULT) {
            //         return download(dae_data, file_name);
            //     }
            //     return saveResource(dae_data, file_name);
            //     break;
            case _EIOExportDataFormat.GEOJSON:
                const geojson_data = Object(_libs_geo_info_io_geojson__WEBPACK_IMPORTED_MODULE_4__["exportGeojson"])(__model__, ents_arr, true); // flatten
                if (data_target === _EIODataTarget.DEFAULT) {
                    return Object(_libs_filesys_download__WEBPACK_IMPORTED_MODULE_5__["download"])(geojson_data, file_name);
                }
                return saveResource(geojson_data, file_name);
            default:
                throw new Error('Data type not recognised');
        }
    });
}
// ================================================================================================
/**
 * Functions for saving and loading resources to file system.
 */
function saveResource(file, name) {
    return __awaiter(this, void 0, void 0, function* () {
        const itemstring = localStorage.getItem('mobius_backup_list');
        if (!itemstring) {
            localStorage.setItem('mobius_backup_list', `["${name}"]`);
            localStorage.setItem('mobius_backup_date_dict', `{ "${name}": "${(new Date()).toLocaleString()}"}`);
        }
        else {
            const items = JSON.parse(itemstring);
            let check = false;
            for (let i = 0; i < items.length; i++) {
                const item = items[i];
                if (item === name) {
                    items.splice(i, 1);
                    items.unshift(item);
                    check = true;
                    break;
                }
            }
            if (!check) {
                items.unshift(name);
                // if (items.length > 10) {
                //     const item = items.pop();
                //     localStorage.removeItem(item);
                // }
            }
            localStorage.setItem('mobius_backup_list', JSON.stringify(items));
            const itemDates = JSON.parse(localStorage.getItem('mobius_backup_date_dict'));
            itemDates[itemstring] = (new Date()).toLocaleString();
            localStorage.setItem('mobius_backup_date_dict', JSON.stringify(itemDates));
        }
        // window['_code__'] = name;
        // window['_file__'] = file;
        function saveToFS(fs) {
            const code = name;
            // console.log(code)
            fs.root.getFile(code, { create: true }, function (fileEntry) {
                fileEntry.createWriter(function (fileWriter) {
                    return __awaiter(this, void 0, void 0, function* () {
                        const bb = new Blob([file + '_|_|_'], { type: 'text/plain;charset=utf-8' });
                        yield fileWriter.write(bb);
                    });
                }, (e) => { console.log(e); });
            }, (e) => { console.log(e.code); });
        }
        navigator.webkitPersistentStorage.requestQuota(requestedBytes, function (grantedBytes) {
            // @ts-ignore
            window.webkitRequestFileSystem(PERSISTENT, grantedBytes, saveToFS, function (e) { throw e; });
        }, function (e) { throw e; });
        return true;
        // localStorage.setItem(code, file);
    });
}
function getURLContent(url) {
    return __awaiter(this, void 0, void 0, function* () {
        url = url.replace('http://', 'https://');
        if (url.indexOf('dropbox') !== -1) {
            url = url.replace('www', 'dl').replace('dl=0', 'dl=1');
        }
        if (url[0] === '"' || url[0] === '\'') {
            url = url.substring(1);
        }
        if (url[url.length - 1] === '"' || url[url.length - 1] === '\'') {
            url = url.substring(0, url.length - 1);
        }
        const p = new Promise((resolve) => {
            fetch(url).then(res => {
                if (!res.ok) {
                    resolve('HTTP Request Error: Unable to retrieve file from ' + url);
                    return '';
                }
                if (url.indexOf('.zip') !== -1) {
                    res.blob().then(body => resolve(body));
                }
                else {
                    res.text().then(body => resolve(body.replace(/(\\[bfnrtv\'\"\\])/g, '\\$1')));
                }
            });
        });
        return yield p;
    });
}
function openZipFile(zipFile) {
    return __awaiter(this, void 0, void 0, function* () {
        let result = '{';
        yield jszip__WEBPACK_IMPORTED_MODULE_9___default.a.loadAsync(zipFile).then(function (zip) {
            return __awaiter(this, void 0, void 0, function* () {
                for (const filename of Object.keys(zip.files)) {
                    // const splittedNames = filename.split('/').slice(1).join('/');
                    yield zip.files[filename].async('text').then(function (fileData) {
                        result += `"${filename}": \`${fileData.replace(/\\/g, '\\\\')}\`,`;
                    });
                }
            });
        });
        result += '}';
        return result;
    });
}
function loadFromFileSystem(filecode) {
    return __awaiter(this, void 0, void 0, function* () {
        const p = new Promise((resolve) => {
            navigator.webkitPersistentStorage.requestQuota(requestedBytes, function (grantedBytes) {
                // @ts-ignore
                window.webkitRequestFileSystem(PERSISTENT, grantedBytes, function (fs) {
                    fs.root.getFile(filecode, {}, function (fileEntry) {
                        fileEntry.file((file) => {
                            const reader = new FileReader();
                            reader.onerror = () => {
                                resolve('error');
                            };
                            reader.onloadend = () => {
                                if ((typeof reader.result) === 'string') {
                                    resolve(reader.result.split('_|_|_')[0]);
                                    // const splitted = (<string>reader.result).split('_|_|_');
                                    // let val = splitted[0];
                                    // for (const i of splitted) {
                                    //     if (val.length < i.length) {
                                    //         val = i;
                                    //     }
                                    // }
                                    // resolve(val);
                                }
                                else {
                                    resolve(reader.result);
                                }
                            };
                            reader.readAsText(file, 'text/plain;charset=utf-8');
                        });
                    });
                });
            }, function (e) { console.log('Error', e); });
        });
        return yield p;
    });
}
function _getFile(source) {
    return __awaiter(this, void 0, void 0, function* () {
        if (source.indexOf('__model_data__') !== -1) {
            return source.split('__model_data__').join('');
        }
        else if (source[0] === '{') {
            return source;
        }
        else if (source.indexOf('://') !== -1) {
            const val = source.replace(/ /g, '');
            const result = yield getURLContent(val);
            if (result === undefined) {
                return source;
            }
            else if (result.indexOf && result.indexOf('HTTP Request Error') !== -1) {
                throw new Error(result);
            }
            else if (val.indexOf('.zip') !== -1) {
                return yield openZipFile(result);
            }
            else {
                return result;
            }
        }
        else {
            if (source.length > 1 && source[0] === '{') {
                return null;
            }
            const val = source.replace(/\"|\'/g, '');
            const backup_list = JSON.parse(localStorage.getItem('mobius_backup_list'));
            if (val.indexOf('*') !== -1) {
                const splittedVal = val.split('*');
                const start = splittedVal[0] === '' ? null : splittedVal[0];
                const end = splittedVal[1] === '' ? null : splittedVal[1];
                let result = '{';
                for (const backup_name of backup_list) {
                    let valid_check = true;
                    if (start && !backup_name.startsWith(start)) {
                        valid_check = false;
                    }
                    if (end && !backup_name.endsWith(end)) {
                        valid_check = false;
                    }
                    if (valid_check) {
                        const backup_file = yield loadFromFileSystem(backup_name);
                        result += `"${backup_name}": \`${backup_file.replace(/\\/g, '\\\\')}\`,`;
                    }
                }
                result += '}';
                return result;
            }
            else {
                if (backup_list.indexOf(val) !== -1) {
                    const result = yield loadFromFileSystem(val);
                    if (!result || result === 'error') {
                        throw (new Error(`File named ${val} does not exist in the local storage`));
                        // return source;
                    }
                    else {
                        return result;
                    }
                }
                else {
                    throw (new Error(`File named ${val} does not exist in the local storage`));
                }
            }
        }
    });
}


/***/ }),

/***/ "./src/assets/core/modules/basic/list.ts":
/*!***********************************************!*\
  !*** ./src/assets/core/modules/basic/list.ts ***!
  \***********************************************/
/*! exports provided: _EAddMethod, Add, _ERemoveMethod, Remove, _EReplaceMethod, Replace, Sort, _ESortMethod, Splice */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_EAddMethod", function() { return _EAddMethod; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Add", function() { return Add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_ERemoveMethod", function() { return _ERemoveMethod; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Remove", function() { return Remove; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_EReplaceMethod", function() { return _EReplaceMethod; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Replace", function() { return Replace; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Sort", function() { return Sort; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_ESortMethod", function() { return _ESortMethod; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Splice", function() { return Splice; });
/* harmony import */ var _check_args__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_check_args */ "./src/assets/core/modules/_check_args.ts");
/* harmony import */ var _libs_geo_info_id__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @libs/geo-info/id */ "./src/assets/libs/geo-info/id.ts");
/* harmony import */ var _assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @assets/libs/util/arrs */ "./src/assets/libs/util/arrs.ts");
/**
 * The `list` module has functions for working with lists of items.
 * These functions have no direct link with the model, the are generic functions for manipulating lists.
 * The functions are often used when manipulating lists of IDs of entities in the model.
 * These functions neither make nor modify anything in the model.
 * In addition to these functions, there are also various inline functions available for working with lists.
 */
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};
/**
 *
 */



// ================================================================================================
var _EAddMethod;
(function (_EAddMethod) {
    _EAddMethod["TO_START"] = "to_start";
    _EAddMethod["TO_END"] = "to_end";
    _EAddMethod["EXTEND_START"] = "extend_start";
    _EAddMethod["EXTEND_END"] = "extend_end";
    _EAddMethod["SORTED_ALPHA"] = "alpha_descending";
    _EAddMethod["SORTED_REV_ALPHA"] = "alpha_ascending";
    _EAddMethod["SORTED_NUM"] = "numeric_descending";
    _EAddMethod["SORTED_REV_NUM"] = "numeric_ascending";
    _EAddMethod["SORTED_ID"] = "ID_descending";
    _EAddMethod["SORTED_REV_ID"] = "ID_ascending";
})(_EAddMethod || (_EAddMethod = {}));
/**
 * Adds an item to a list.
 *
 * @param list List to add the item to.
 * @param item Item to add.
 * @param method Enum, select the method.
 * @returns void
 * @example append = list.Add([1,2,3], 4, 'at_end')
 * @example_info Expected value of list is [1,2,3,4].
 * @example append = list.Add([1,2,3], [4, 5], 'at_end')
 * @example_info Expected value of list is [1,2,3,[4,5]].
 * @example append = list.Add([1,2,3], [4,5], 'extend_end')
 * @example_info Expected value of list is [1,2,3,4,5].
 * @example append = list.Add(["a", "c", "d"], "b", 'alpha_descending')
 * @example_info Expected value of list is ["a", "b", "c", "d"].
 */
function Add(list, item, method) {
    // --- Error Check ---
    const fn_name = 'list.Add';
    Object(_check_args__WEBPACK_IMPORTED_MODULE_0__["checkArgs"])(fn_name, 'list', list, [_check_args__WEBPACK_IMPORTED_MODULE_0__["ArgCh"].isList]);
    Object(_check_args__WEBPACK_IMPORTED_MODULE_0__["checkArgs"])(fn_name, 'value', item, [_check_args__WEBPACK_IMPORTED_MODULE_0__["ArgCh"].isAny]);
    // --- Error Check ---
    let str_value;
    switch (method) {
        case _EAddMethod.TO_START:
            list.unshift(item);
            break;
        case _EAddMethod.TO_END:
            list.push(item);
            break;
        case _EAddMethod.EXTEND_START:
            if (!Array.isArray(item)) {
                item = [item];
            }
            for (let i = item.length - 1; i >= 0; i--) {
                list.unshift(item[i]);
            }
            break;
        case _EAddMethod.EXTEND_END:
            if (!Array.isArray(item)) {
                item = [item];
            }
            for (let i = 0; i < item.length; i++) {
                list.push(item[i]);
            }
            break;
        case _EAddMethod.SORTED_ALPHA:
            str_value = item + '';
            for (let i = 0; i < list.length + 1; i++) {
                if (str_value < list[i] + '' || i === list.length) {
                    list.splice(i, 0, item);
                    break;
                }
            }
            break;
        case _EAddMethod.SORTED_REV_ALPHA:
            str_value = item + '';
            for (let i = 0; i < list.length + 1; i++) {
                if (str_value > list[i] + '' || i === list.length) {
                    list.splice(i, 0, item);
                    break;
                }
            }
            break;
        case _EAddMethod.SORTED_NUM:
            for (let i = 0; i < list.length + 1; i++) {
                if (item - list[i] > 0 || i === list.length) {
                    list.splice(i, 0, item);
                    break;
                }
            }
            break;
        case _EAddMethod.SORTED_REV_NUM:
            for (let i = 0; i < list.length + 1; i++) {
                if (item - list[i] < 0 || i === list.length) {
                    list.splice(i, 0, item);
                    break;
                }
            }
            break;
        case _EAddMethod.SORTED_ID:
            for (let i = 0; i < list.length + 1; i++) {
                if (_compareID(item, list[i]) > 0 || i === list.length) {
                    list.splice(i, 0, item);
                    break;
                }
            }
            break;
        case _EAddMethod.SORTED_REV_ID:
            for (let i = 0; i < list.length + 1; i++) {
                if (_compareID(item, list[i]) < 0 || i === list.length) {
                    list.splice(i, 0, item);
                    break;
                }
            }
            break;
        default:
            break;
    }
}
// ================================================================================================
var _ERemoveMethod;
(function (_ERemoveMethod) {
    _ERemoveMethod["REMOVE_INDEX"] = "index";
    _ERemoveMethod["REMOVE_FIRST_VALUE"] = "first_value";
    _ERemoveMethod["REMOVE_LAST_VALUE"] = "last_value";
    _ERemoveMethod["REMOVE_ALL_VALUES"] = "all_values";
})(_ERemoveMethod || (_ERemoveMethod = {}));
/**
 * Removes items in a list.
 * ~
 * If @param method is set to 'index', then @param item should be the index of the item to be replaced.
 * Negative indexes are allowed.
 * If @param method is not set to 'index', then @param item should be the value.
 *
 * @param list The list in which to remove items
 * @param item The item to remove, either the index of the item or the value. Negative indexes are allowed.
 * @param method Enum, select the method for removing items from the list.
 * @returns void
 */
function Remove(list, item, method) {
    // --- Error Check ---
    const fn_name = 'list.Remove';
    Object(_check_args__WEBPACK_IMPORTED_MODULE_0__["checkArgs"])(fn_name, 'list', list, [_check_args__WEBPACK_IMPORTED_MODULE_0__["ArgCh"].isList]);
    Object(_check_args__WEBPACK_IMPORTED_MODULE_0__["checkArgs"])(fn_name, 'item', item, [_check_args__WEBPACK_IMPORTED_MODULE_0__["ArgCh"].isAny]);
    // --- Error Check ---
    let index;
    switch (method) {
        case _ERemoveMethod.REMOVE_INDEX:
            index = item;
            if (!isNaN(index)) {
                if (index < 0) {
                    index = list.length + index;
                }
                list.splice(index, 1);
            }
            break;
        case _ERemoveMethod.REMOVE_FIRST_VALUE:
            index = list.indexOf(item);
            if (index !== -1) {
                list.splice(index, 1);
            }
            break;
        case _ERemoveMethod.REMOVE_LAST_VALUE:
            index = list.lastIndexOf(item);
            if (index !== -1) {
                list.splice(index, 1);
            }
            break;
        case _ERemoveMethod.REMOVE_ALL_VALUES:
            for (index = 0; index < list.length; index++) {
                if (list[index] === item) {
                    list.splice(index, 1);
                    index -= 1;
                }
            }
            break;
        default:
            throw new Error('list.Remove: Remove method not recognised.');
    }
}
// ================================================================================================
var _EReplaceMethod;
(function (_EReplaceMethod) {
    _EReplaceMethod["REPLACE_INDEX"] = "index";
    _EReplaceMethod["REPLACE_FIRST_VALUE"] = "first_value";
    _EReplaceMethod["REPLACE_LAST_VALUE"] = "last_value";
    _EReplaceMethod["REPLACE_ALL_VALUES"] = "all_values";
})(_EReplaceMethod || (_EReplaceMethod = {}));
/**
 * Replaces items in a list.
 * ~
 * If @param method is set to 'index', then @param old_item should be the index of the item to be replaced. Negative indexes are allowed.
 * If @param method is not set to 'index', then @param old_item should be the value.
 *
 * @param list The list in which to replace items
 * @param old_item The old item to replace.
 * @param new_item The new item.
 * @param method Enum, select the method for replacing items in the list.
 * @returns void
 */
function Replace(list, old_item, new_item, method) {
    // --- Error Check ---
    const fn_name = 'list.Replace';
    Object(_check_args__WEBPACK_IMPORTED_MODULE_0__["checkArgs"])(fn_name, 'list', list, [_check_args__WEBPACK_IMPORTED_MODULE_0__["ArgCh"].isList]);
    Object(_check_args__WEBPACK_IMPORTED_MODULE_0__["checkArgs"])(fn_name, 'item', old_item, [_check_args__WEBPACK_IMPORTED_MODULE_0__["ArgCh"].isAny]);
    Object(_check_args__WEBPACK_IMPORTED_MODULE_0__["checkArgs"])(fn_name, 'new_value', new_item, [_check_args__WEBPACK_IMPORTED_MODULE_0__["ArgCh"].isAny]);
    // --- Error Check ---
    let index;
    switch (method) {
        case _EReplaceMethod.REPLACE_INDEX:
            index = old_item;
            if (!isNaN(index)) {
                if (index < 0) {
                    index = list.length + index;
                }
                list[index] = new_item;
            }
            break;
        case _EReplaceMethod.REPLACE_FIRST_VALUE:
            index = list.indexOf(old_item);
            if (index !== -1) {
                list[index] = new_item;
            }
            break;
        case _EReplaceMethod.REPLACE_LAST_VALUE:
            index = list.lastIndexOf(old_item);
            if (index !== -1) {
                list[index] = new_item;
            }
            break;
        case _EReplaceMethod.REPLACE_ALL_VALUES:
            for (index = 0; index < list.length; index++) {
                if (list[index] === old_item) {
                    list[index] = new_item;
                }
            }
            break;
        default:
            throw new Error('list.Replace: Replace method not recognised.');
    }
}
// ================================================================================================
/**
 * Sorts an list, based on the values of the items in the list.
 * ~
 * For alphabetical sort, values are sorted character by character,
 * numbers before upper case alphabets, upper case alphabets before lower case alphabets.
 *
 * @param list List to sort.
 * @param method Enum; specifies the sort method to use.
 * @returns void
 * @example list.Sort(list, 'alpha')
 * @example_info where list = ["1","2","10","Orange","apple"]
 * Expected value of list is ["1","10","2","Orange","apple"].
 * @example list.Sort(list, 'numeric')
 * @example_info where list = [56,6,48]
 * Expected value of list is [6,48,56].
 */
function Sort(list, method) {
    // --- Error Check ---
    Object(_check_args__WEBPACK_IMPORTED_MODULE_0__["checkArgs"])('list.Sort', 'list', list, [_check_args__WEBPACK_IMPORTED_MODULE_0__["ArgCh"].isList]);
    // --- Error Check ---
    _sort(list, method);
}
var _ESortMethod;
(function (_ESortMethod) {
    _ESortMethod["REV"] = "reverse";
    _ESortMethod["ALPHA"] = "alpha_descending";
    _ESortMethod["REV_ALPHA"] = "alpha_ascending";
    _ESortMethod["NUM"] = "numeric_descending";
    _ESortMethod["REV_NUM"] = "numeric_ascending";
    _ESortMethod["ID"] = "ID_descending";
    _ESortMethod["REV_ID"] = "ID_ascending";
    _ESortMethod["SHIFT"] = "shift_1";
    _ESortMethod["REV_SHIFT"] = "reverse_shift_1";
    _ESortMethod["RANDOM"] = "random";
})(_ESortMethod || (_ESortMethod = {}));
function _compareID(id1, id2) {
    const [ent_type1, index1] = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_1__["idsBreak"])(id1);
    const [ent_type2, index2] = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_1__["idsBreak"])(id2);
    if (ent_type1 !== ent_type2) {
        return ent_type1 - ent_type2;
    }
    if (index1 !== index2) {
        return index1 - index2;
    }
    return 0;
}
function _compareNumList(l1, l2, depth) {
    if (depth === 1) {
        return l1[0] - l2[0];
    }
    if (depth === 2) {
        return l1[0][0] - l2[0][0];
    }
    let val1 = l1;
    let val2 = l2;
    for (let i = 0; i < depth; i++) {
        val1 = val1[0];
        val2 = val2[0];
    }
    return val1 - val2;
}
function _sort(list, method) {
    switch (method) {
        case _ESortMethod.REV:
            list.reverse();
            break;
        case _ESortMethod.ALPHA:
            list.sort().reverse();
            break;
        case _ESortMethod.REV_ALPHA:
            list.sort();
            break;
        case _ESortMethod.NUM:
            if (Array.isArray(list[0])) {
                const depth = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_2__["getArrDepth2"])(list[0]);
                list.sort((a, b) => _compareNumList(a, b, depth)).reverse();
            }
            else {
                list.sort((a, b) => b - a);
            }
            break;
        case _ESortMethod.REV_NUM:
            if (Array.isArray(list[0])) {
                const depth = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_2__["getArrDepth2"])(list[0]);
                list.sort((a, b) => _compareNumList(a, b, depth));
            }
            else {
                list.sort((a, b) => a - b);
            }
            break;
        case _ESortMethod.ID:
            list.sort(_compareID).reverse();
            break;
        case _ESortMethod.REV_ID:
            list.sort(_compareID);
            break;
        case _ESortMethod.SHIFT:
            const last = list.pop();
            list.unshift(last);
            break;
        case _ESortMethod.REV_SHIFT:
            const first = list.shift();
            list.push(first);
            break;
        case _ESortMethod.RANDOM:
            list.sort(() => .5 - Math.random());
            break;
        default:
            throw new Error('list.Sort: Sort method not recognised.');
    }
}
// ================================================================================================
/**
 * Removes and inserts items in a list.
 * ~
 * If no items_to_add are specified, then items are only removed.
 * If num_to_remove is 0, then values are only inserted.
 *
 * @param list List to splice.
 * @param index Zero-based index after which to starting removing or inserting items.
 * @param num_to_remove Number of items to remove.
 * @param items_to_insert Optional, list of items to add, or null.
 * @returns void
 * @example result = list.Splice(list1, 1, 3, [2.2, 3.3])
 * @example_info where list1 = [10, 20, 30, 40, 50]
 * Expected value of result is [10, 2.2, 3.3, 50]. New items were added where the items were removed.
 */
function Splice(list, index, num_to_remove, items_to_insert) {
    // --- Error Check ---
    const fn_name = 'list.Splice';
    Object(_check_args__WEBPACK_IMPORTED_MODULE_0__["checkArgs"])(fn_name, 'list', list, [_check_args__WEBPACK_IMPORTED_MODULE_0__["ArgCh"].isList]);
    Object(_check_args__WEBPACK_IMPORTED_MODULE_0__["checkArgs"])(fn_name, 'index', index, [_check_args__WEBPACK_IMPORTED_MODULE_0__["ArgCh"].isInt]);
    Object(_check_args__WEBPACK_IMPORTED_MODULE_0__["checkArgs"])(fn_name, 'num_to_remove', num_to_remove, [_check_args__WEBPACK_IMPORTED_MODULE_0__["ArgCh"].isInt]);
    Object(_check_args__WEBPACK_IMPORTED_MODULE_0__["checkArgs"])(fn_name, 'values_to_add', items_to_insert, [_check_args__WEBPACK_IMPORTED_MODULE_0__["ArgCh"].isList]);
    // --- Error Check ---
    // avoid the spread operator
    list.splice(index, num_to_remove);
    if (items_to_insert !== null && items_to_insert.length) {
        for (let i = 0; i < items_to_insert.length; i++) {
            list.splice(index + i, 0, items_to_insert[i]);
        }
    }
}


/***/ }),

/***/ "./src/assets/core/modules/basic/make.ts":
/*!***********************************************!*\
  !*** ./src/assets/core/modules/basic/make.ts ***!
  \***********************************************/
/*! exports provided: _EDivisorMethod, _EExtrudeMethod, Position, Point, Polyline, _EClose, Polygon, _Tin, Copy, Hole, Loft, _ELoftMethod, Extrude, Sweep, Divide, _ECutMethod, Cut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_EDivisorMethod", function() { return _EDivisorMethod; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_EExtrudeMethod", function() { return _EExtrudeMethod; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Position", function() { return Position; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Point", function() { return Point; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Polyline", function() { return Polyline; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_EClose", function() { return _EClose; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Polygon", function() { return Polygon; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_Tin", function() { return _Tin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Copy", function() { return Copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Hole", function() { return Hole; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Loft", function() { return Loft; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_ELoftMethod", function() { return _ELoftMethod; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Extrude", function() { return Extrude; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Sweep", function() { return Sweep; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Divide", function() { return Divide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_ECutMethod", function() { return _ECutMethod; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Cut", function() { return Cut; });
/* harmony import */ var _check_ids__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_check_ids */ "./src/assets/core/modules/_check_ids.ts");
/* harmony import */ var _check_args__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_check_args */ "./src/assets/core/modules/_check_args.ts");
/* harmony import */ var _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @libs/geo-info/common */ "./src/assets/libs/geo-info/common.ts");
/* harmony import */ var _libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @libs/geo-info/id */ "./src/assets/libs/geo-info/id.ts");
/* harmony import */ var _libs_geom_vectors__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @libs/geom/vectors */ "./src/assets/libs/geom/vectors.ts");
/* harmony import */ var _libs_geom_distance__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @libs/geom/distance */ "./src/assets/libs/geom/distance.ts");
/* harmony import */ var _libs_util_arrs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @libs/util/arrs */ "./src/assets/libs/util/arrs.ts");
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./_common */ "./src/assets/core/modules/basic/_common.ts");
/* harmony import */ var _assets_libs_geom_matrix__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @assets/libs/geom/matrix */ "./src/assets/libs/geom/matrix.ts");
/* harmony import */ var _assets_core_inline_list__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @assets/core/inline/_list */ "./src/assets/core/inline/_list.ts");
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/**
 * The `make` module has functions for making new entities in the model.
 * All these functions return the IDs of the entities that are created.
 */
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};
/**
 *
 */











// Divide edge modelling operation
var _EDivisorMethod;
(function (_EDivisorMethod) {
    _EDivisorMethod["BY_NUMBER"] = "by_number";
    _EDivisorMethod["BY_LENGTH"] = "by_length";
    _EDivisorMethod["BY_MAX_LENGTH"] = "by_max_length";
    _EDivisorMethod["BY_MIN_LENGTH"] = "by_min_length";
})(_EDivisorMethod || (_EDivisorMethod = {}));
var _EExtrudeMethod;
(function (_EExtrudeMethod) {
    _EExtrudeMethod["QUADS"] = "quads";
    _EExtrudeMethod["STRINGERS"] = "stringers";
    _EExtrudeMethod["RIBS"] = "ribs";
    _EExtrudeMethod["COPIES"] = "copies";
})(_EExtrudeMethod || (_EExtrudeMethod = {}));
// ================================================================================================
/**
 * Adds one or more new position to the model.
 *
 * @param __model__
 * @param coords A list of three numbers, or a list of lists of three numbers.
 * @returns A new position, or nested list of new positions.
 * @example position1 = make.Position([1,2,3])
 * @example_info Creates a position with coordinates x=1, y=2, z=3.
 * @example positions = make.Position([[1,2,3],[3,4,5],[5,6,7]])
 * @example_info Creates three positions, with coordinates [1,2,3],[3,4,5] and [5,6,7].
 * @example_link make.Position.mob&node=1
 */
function Position(__model__, coords) {
    if (Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["isEmptyArr"])(coords)) {
        return [];
    }
    // --- Error Check ---
    if (__model__.debug) {
        Object(_check_args__WEBPACK_IMPORTED_MODULE_1__["checkArgs"])('make.Position', 'coords', coords, [_check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isXYZ, _check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isXYZL, _check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isXYZLL]);
    }
    // --- Error Check ---
    const new_ents_arr = _position(__model__, coords);
    return Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsMake"])(new_ents_arr);
}
function _position(__model__, coords) {
    const depth = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["getArrDepth"])(coords);
    if (depth === 1) {
        const coord1 = coords;
        const posi_i = __model__.modeldata.geom.add.addPosi();
        __model__.modeldata.attribs.add.setEntAttribVal(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].POSI, posi_i, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EAttribNames"].COORDS, coord1);
        return [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].POSI, posi_i];
    }
    else if (depth === 2) {
        const coords2 = coords;
        return coords2.map(coord => _position(__model__, coord));
    }
    else {
        const coords3 = coords;
        return coords3.map(coord2 => _position(__model__, coord2));
    }
}
// ================================================================================================
/**
 * Adds one or more new points to the model.
 *
 * @param __model__
 * @param entities Position, or list of positions, or entities from which positions can be extracted.
 * @returns Entities, new point or a list of new points.
 * @example point1 = make.Point(position1)
 * @example_info Creates a point at position1.
 * @example_link make.Point.mob&node=1
 */
function Point(__model__, entities) {
    if (Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["isEmptyArr"])(entities)) {
        return [];
    }
    // --- Error Check ---
    let ents_arr;
    if (__model__.debug) {
        ents_arr = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])('make.Point', 'entities', entities, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isId, _check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL, _check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdLL], [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].POSI, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].VERT, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].EDGE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].WIRE,
            _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].FACE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].POINT, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON]);
    }
    else {
        // ents_arr = splitIDs('make.Point', 'entities', entities,
        // [IDcheckObj.isID, IDcheckObj.isIDList, IDcheckObj.isIDList_list],
        // [EEntType.POSI, EEntType.VERT, EEntType.EDGE, EEntType.WIRE,
        // EEntType.FACE, EEntType.POINT, EEntType.PLINE, EEntType.PGON])  as TEntTypeIdx|TEntTypeIdx[]|TEntTypeIdx[][];
        ents_arr = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsBreak"])(entities);
    }
    // --- Error Check ---
    const new_ents_arr = _point(__model__, ents_arr);
    return Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsMake"])(new_ents_arr);
}
function _point(__model__, ents_arr) {
    const depth = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["getArrDepth"])(ents_arr);
    if (depth === 1) {
        const [ent_type, index] = ents_arr; // either a posi or something else
        if (ent_type === _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].POSI) {
            const point_i = __model__.modeldata.geom.add.addPoint(index);
            return [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].POINT, point_i];
        }
        else {
            const posis_i = __model__.modeldata.geom.nav.navAnyToPosi(ent_type, index);
            return posis_i.map(posi_i => _point(__model__, [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].POSI, posi_i]));
        }
    }
    else if (depth === 2) {
        ents_arr = ents_arr;
        return ents_arr.map(ents_arr_item => _point(__model__, ents_arr_item));
    }
    else { // depth > 2
        ents_arr = ents_arr;
        return ents_arr.map(ents_arr_item => _point(__model__, ents_arr_item));
    }
}
// ================================================================================================
/**
 * Adds one or more new polylines to the model.
 *
 * @param __model__
 * @param entities List or nested lists of positions, or entities from which positions can be extracted.
 * @param close Enum, 'open' or 'close'.
 * @returns Entities, new polyline, or a list of new polylines.
 * @example polyline1 = make.Polyline([position1,position2,position3], close)
 * @example_info Creates a closed polyline with vertices position1, position2, position3 in sequence.
 * @example_link make.Polyline.mob&node=1
 */
function Polyline(__model__, entities, close) {
    if (Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["isEmptyArr"])(entities)) {
        return [];
    }
    // --- Error Check ---
    let ents_arr;
    if (__model__.debug) {
        ents_arr = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])('make.Polyline', 'entities', entities, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isId, _check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL, _check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdLL], [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].POSI, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].VERT, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].EDGE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].WIRE,
            _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].FACE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON]);
    }
    else {
        // ents_arr = splitIDs('make.Polyline', 'entities', entities,
        // [IDcheckObj.isID, IDcheckObj.isIDList, IDcheckObj.isIDListOfLists],
        // [EEntType.POSI, EEntType.VERT, EEntType.EDGE, EEntType.WIRE,
        // EEntType.FACE, EEntType.PLINE, EEntType.PGON]) as TEntTypeIdx|TEntTypeIdx[]|TEntTypeIdx[][];
        ents_arr = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsBreak"])(entities);
    }
    // --- Error Check ---
    const posis_arrs = _getPlinePosisFromEnts(__model__, ents_arr);
    const new_ents_arr = _polyline(__model__, posis_arrs, close);
    const depth = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["getArrDepth"])(ents_arr);
    if (depth === 1 || (depth === 2 && ents_arr[0][0] === _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].POSI)) {
        const first_ent = new_ents_arr[0];
        return Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsMake"])(first_ent);
    }
    else {
        return Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsMake"])(new_ents_arr);
    }
}
// Enums for Polyline()
var _EClose;
(function (_EClose) {
    _EClose["OPEN"] = "open";
    _EClose["CLOSE"] = "close";
})(_EClose || (_EClose = {}));
function _polyline(__model__, ents_arr, close) {
    const depth = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["getArrDepth"])(ents_arr);
    if (depth === 2) {
        if (ents_arr.length < 2) {
            throw new Error('Error in make.Polyline: Polylines must have at least two positions.');
        }
        const bool_close = (close === _EClose.CLOSE);
        const posis_i = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idIndicies"])(ents_arr);
        const pline_i = __model__.modeldata.geom.add.addPline(posis_i, bool_close);
        return [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE, pline_i];
    }
    else {
        ents_arr = ents_arr;
        return ents_arr.map(ents_arr_item => _polyline(__model__, ents_arr_item, close));
    }
}
function _getPlinePosisFromEnts(__model__, ents_arr) {
    // check if this is a single object ID
    if (Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["getArrDepth"])(ents_arr) === 1) {
        ents_arr = [ents_arr];
    }
    // check if this is a list of posis, verts, or points
    if (Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["getArrDepth"])(ents_arr) === 2 && Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["isDim0"])(ents_arr[0][0])) {
        const ents_arr2 = [];
        for (const ent_arr of ents_arr) {
            const [ent_type, index] = ent_arr;
            if (ent_type === _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].POSI) {
                ents_arr2.push(ent_arr);
            }
            else {
                const posis_i = __model__.modeldata.geom.nav.navAnyToPosi(ent_type, index);
                for (const posi_i of posis_i) {
                    ents_arr2.push([_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].POSI, posi_i]);
                }
            }
        }
        ents_arr = [ents_arr2];
    }
    // now process the ents
    const posis_arrs = [];
    for (const ent_arr of ents_arr) {
        if (Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["getArrDepth"])(ent_arr) === 2) { // this must be a list of posis
            posis_arrs.push(ent_arr);
            continue;
        }
        const [ent_type, index] = ent_arr;
        switch (ent_type) {
            case _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].EDGE:
            case _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].WIRE:
            case _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE:
                const posis_i = __model__.modeldata.geom.nav.navAnyToPosi(ent_type, index);
                const posis_arr = posis_i.map(posi_i => [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].POSI, posi_i]);
                posis_arrs.push(posis_arr);
                break;
            case _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].FACE:
            case _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON:
                const wires_i = __model__.modeldata.geom.nav.navAnyToWire(ent_type, index);
                for (let j = 0; j < wires_i.length; j++) {
                    const wire_i = wires_i[j];
                    const wire_posis_i = __model__.modeldata.geom.nav.navAnyToPosi(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].WIRE, wire_i);
                    const wire_posis_arr = wire_posis_i.map(posi_i => [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].POSI, posi_i]);
                    posis_arrs.push(wire_posis_arr);
                }
                break;
            default:
                break;
        }
    }
    return posis_arrs;
}
// ================================================================================================
/**
 * Adds one or more new polygons to the model.
 *
 * @param __model__
 * @param entities List or nested lists of positions, or entities from which positions can be extracted.
 * @returns Entities, new polygon, or a list of new polygons.
 * @example polygon1 = make.Polygon([pos1,pos2,pos3])
 * @example_info Creates a polygon with vertices pos1, pos2, pos3 in sequence.
 * @example polygons = make.Polygon([[pos1,pos2,pos3], [pos3,pos4,pos5]])
 * @example_info Creates two polygons, the first with vertices at [pos1,pos2,pos3], and the second with vertices at [pos3,pos4,pos5].
 * @example_link make.Polygon.mob&node=1
 */
function Polygon(__model__, entities) {
    if (Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["isEmptyArr"])(entities)) {
        return [];
    }
    // --- Error Check ---
    let ents_arr;
    if (__model__.debug) {
        ents_arr = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])('make.Polygon', 'entities', entities, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isId, _check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL, _check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdLL], [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].POSI, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].WIRE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].FACE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON]);
    }
    else {
        // ents_arr = splitIDs('make.Polygon', 'entities', entities,
        // [IDcheckObj.isID, IDcheckObj.isIDList, IDcheckObj.isIDListOfLists],
        // [EEntType.POSI, EEntType.WIRE, EEntType.FACE, EEntType.PLINE, EEntType.PGON]) as TEntTypeIdx[]|TEntTypeIdx[][];
        ents_arr = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsBreak"])(entities);
    }
    // --- Error Check ---
    const posis_arrs = _getPgonPosisFromEnts(__model__, ents_arr);
    const new_ents_arr = _polygon(__model__, posis_arrs);
    const depth = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["getArrDepth"])(ents_arr);
    if (depth === 1 || (depth === 2 && ents_arr[0][0] === _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].POSI)) {
        const first_ent = new_ents_arr[0];
        return Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsMake"])(first_ent);
    }
    else {
        return Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsMake"])(new_ents_arr);
    }
}
function _polygon(__model__, ents_arr) {
    const depth = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["getArrDepth"])(ents_arr);
    if (depth === 2) {
        if (ents_arr.length < 3) {
            throw new Error('Error in make.Polygon: Polygons must have at least three positions.');
        }
        const posis_i = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idIndicies"])(ents_arr);
        const pgon_i = __model__.modeldata.geom.add.addPgon(posis_i);
        return [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON, pgon_i];
    }
    else {
        ents_arr = ents_arr;
        return ents_arr.map(ents_arr_item => _polygon(__model__, ents_arr_item));
    }
}
function _getPgonPosisFromEnts(__model__, ents_arr) {
    // check if this is a single object ID
    if (Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["getArrDepth"])(ents_arr) === 1) {
        ents_arr = [ents_arr];
    }
    // check if this is a list of posis
    if (Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["getArrDepth"])(ents_arr) === 2 && ents_arr[0][0] === _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].POSI) {
        // ents_arr =  [ents_arr] as TEntTypeIdx[][];
        const ents_arr2 = [];
        for (const ent_arr of ents_arr) {
            const [ent_type, index] = ent_arr;
            if (ent_type === _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].POSI) {
                ents_arr2.push(ent_arr);
            }
            else {
                const posis_i = __model__.modeldata.geom.nav.navAnyToPosi(ent_type, index);
                for (const posi_i of posis_i) {
                    ents_arr2.push([_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].POSI, posi_i]);
                }
            }
        }
        ents_arr = [ents_arr2];
    }
    // now process the ents
    const posis_arrs = [];
    for (const ent_arr of ents_arr) {
        if (Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["getArrDepth"])(ent_arr) === 2) { // this must be a list of posis
            posis_arrs.push(ent_arr);
            continue;
        }
        const [ent_type, index] = ent_arr;
        switch (ent_type) {
            case _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].WIRE:
            case _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE:
                const posis_i = __model__.modeldata.geom.nav.navAnyToPosi(ent_type, index);
                const posis_arr = posis_i.map(posi_i => [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].POSI, posi_i]);
                posis_arrs.push(posis_arr);
                break;
            case _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].FACE:
            case _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON:
                const wires_i = __model__.modeldata.geom.nav.navAnyToWire(ent_type, index);
                for (let j = 0; j < wires_i.length; j++) {
                    const wire_i = wires_i[j];
                    const wire_posis_i = __model__.modeldata.geom.nav.navAnyToPosi(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].WIRE, wire_i);
                    const wire_posis_arr = wire_posis_i.map(posi_i => [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].POSI, posi_i]);
                    posis_arrs.push(wire_posis_arr);
                }
                break;
            default:
                break;
        }
    }
    return posis_arrs;
}
// ================================================================================================
/**
 * Adds a set of triangular polygons, forming a Triangulated Irregular Network (TIN).
 *
 * @param __model__
 * @param entities List or nested lists of positions, or entities from which positions can be extracted.
 * @returns Entities, a list of new polygons.
 */
function _Tin(__model__, entities) {
    if (Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["isEmptyArr"])(entities)) {
        return [];
    }
    // --- Error Check ---
    let ents_arr;
    if (__model__.debug) {
        ents_arr = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])('make.Tin', 'entities', entities, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL, _check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdLL], [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].POSI, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].WIRE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].FACE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON]);
    }
    else {
        // ents_arr = splitIDs('make.Tin', 'entities', entities,
        // [IDcheckObj.isIDList, IDcheckObj.isIDListOfLists],
        // [EEntType.POSI, EEntType.WIRE, EEntType.FACE, EEntType.PLINE, EEntType.PGON]) as TEntTypeIdx[]|TEntTypeIdx[][];
        ents_arr = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsBreak"])(entities);
    }
    // --- Error Check ---
    const posis_arrs = _getPgonPosisFromEnts(__model__, ents_arr);
    return null;
}
function _tin(__model__, ents_arr) {
    const depth = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["getArrDepth"])(ents_arr);
    if (depth === 2) {
        const posis_i = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idIndicies"])(ents_arr);
        const vtxs_tf = [];
        for (const posi_i of posis_i) {
            const xyz = __model__.modeldata.attribs.query.getPosiCoords(posi_i);
            vtxs_tf.push(xyz);
        }
        // const tin = turf.triangulate(vtxs_tf);
        // console.log(tin);
        return null;
    }
    else {
        ents_arr = ents_arr;
        return ents_arr.map(ents_arr_item => _tin(__model__, ents_arr_item));
    }
}
// ================================================================================================
/**
 * Adds a new copy of specified entities to the model.
 *
 * @param __model__
 * @param entities Entity or lists of entities to be copied. Entities can be positions, points, polylines, polygons and collections.
 * @param vector A vector to move the entities by after copying, can be `null`.
 * @returns Entities, the copied entity or a list of copied entities.
 * @example copies = make.Copy([position1,polyine1,polygon1])
 * @example_info Creates a copy of position1, polyine1, and polygon1.
 */
function Copy(__model__, entities, vector) {
    if (Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["isEmptyArr"])(entities)) {
        return [];
    }
    // --- Error Check ---
    const fn_name = 'make.Copy';
    let ents_arr;
    if (__model__.debug) {
        ents_arr = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])(fn_name, 'entities', entities, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isId, _check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL, , _check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdLL], [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].POSI, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].POINT, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].COLL]);
        Object(_check_args__WEBPACK_IMPORTED_MODULE_1__["checkArgs"])(fn_name, 'vector', vector, [_check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isNum, _check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isXYZ, _check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isNull]);
    }
    else {
        // ents_arr = splitIDs(fn_name, 'entities', entities,
        // [IDcheckObj.isID, IDcheckObj.isIDList, , IDcheckObj.isIDListOfLists],
        // [EEntType.POSI, EEntType.POINT, EEntType.PLINE, EEntType.PGON, EEntType.COLL]) as TEntTypeIdx|TEntTypeIdx[]|TEntTypeIdx[][];
        ents_arr = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsBreak"])(entities);
    }
    // --- Error Check ---
    const move_vec = (Array.isArray(vector) ? vector : [0, 0, vector]);
    const bool_copy_attribs = true;
    // copy the list of entities
    const new_ents_arr = Object(_common__WEBPACK_IMPORTED_MODULE_7__["_copyGeom"])(__model__, ents_arr, bool_copy_attribs);
    // copy the positions that belong to the list of entities
    Object(_common__WEBPACK_IMPORTED_MODULE_7__["_copyGeomPosis"])(__model__, new_ents_arr, bool_copy_attribs, move_vec);
    // return only the new entities
    return Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsMake"])(new_ents_arr);
}
// ================================================================================================
/**
 * Makes one or more holes in a polygon.
 * ~
 * The positions must be on the polygon, i.e. they must be co-planar with the polygon and
 * they must be within the boundary of the polygon.
 * ~
 * If the list of positions consists of a single list, then one hole will be generated.
 * If the list of positions consists of a list of lists, then multiple holes will be generated.
 * ~
 * @param __model__
 * @param pgon A face or polygon to make holes in.
 * @param entities List of positions, or nested lists of positions, or entities from which positions can be extracted.
 * @returns Entities, a list of wires resulting from the hole(s).
 */
function Hole(__model__, pgon, entities) {
    if (Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["isEmptyArr"])(entities)) {
        return [];
    }
    if (!Array.isArray(entities)) {
        entities = [entities];
    }
    // --- Error Check ---
    const fn_name = 'make.Hole';
    let ent_arr;
    let holes_ents_arr;
    if (__model__.debug) {
        ent_arr = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])(fn_name, 'pgon', pgon, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isId], [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].FACE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON]);
        holes_ents_arr = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])(fn_name, 'entities', entities, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isId, _check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL, _check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdLL], [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].POSI, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].WIRE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].FACE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON]);
    }
    else {
        // ent_arr = splitIDs(fn_name, 'pgon', pgon, [IDcheckObj.isID], [EEntType.FACE, EEntType.PGON]) as TEntTypeIdx;
        // holes_ents_arr = splitIDs(fn_name, 'entities', entities,
        // [IDcheckObj.isID, IDcheckObj.isIDList, IDcheckObj.isIDListOfLists],
        // [EEntType.POSI, EEntType.WIRE, EEntType.FACE, EEntType.PLINE, EEntType.PGON]) as TEntTypeIdx[]|TEntTypeIdx[][];
        ent_arr = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsBreak"])(pgon);
        holes_ents_arr = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsBreak"])(entities);
    }
    // --- Error Check ---
    // get the posis for making holes
    _getHolePosisFromEnts(__model__, holes_ents_arr);
    // make sure we have a pgon
    const pgon_i = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["isFace"])(ent_arr[0]) ? __model__.modeldata.geom.nav.navFaceToPgon(ent_arr[1]) : ent_arr[1];
    // make the holes
    const new_ents_arr = _hole(__model__, pgon_i, holes_ents_arr);
    // make and return the IDs of the hole wires
    return Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsMake"])(new_ents_arr);
}
// Hole modelling operation
function _hole(__model__, pgon_i, holes_ents_arr) {
    if (Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["getArrDepth"])(holes_ents_arr) === 2) {
        holes_ents_arr = [holes_ents_arr];
    }
    // convert the holes to lists of posis_i
    const holes_posis_i = [];
    for (const hole_ents_arr of holes_ents_arr) {
        holes_posis_i.push(hole_ents_arr.map(ent_arr => ent_arr[1]));
    }
    // create the hole
    const wires_i = __model__.modeldata.geom.modify_pgon.cutPgonHoles(pgon_i, holes_posis_i);
    return wires_i.map(wire_i => [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].WIRE, wire_i]);
}
function _getHolePosisFromEnts(__model__, ents_arr) {
    for (let i = 0; i < ents_arr.length; i++) {
        const depth = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["getArrDepth"])(ents_arr[i]);
        if (depth === 1) {
            const [ent_type, index] = ents_arr[i];
            switch (ent_type) {
                case _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].WIRE:
                case _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE:
                    const posis_i = __model__.modeldata.geom.nav.navAnyToPosi(ent_type, index);
                    const posis_arr = posis_i.map(posi_i => [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].POSI, posi_i]);
                    Array.prototype.splice.apply(ents_arr, [i, 1, posis_arr]); // TODO
                    break;
                case _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].FACE:
                case _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON:
                    // ignore holes, so only take the first wire
                    const wires_i = __model__.modeldata.geom.nav.navAnyToWire(ent_type, index);
                    const wire_i = wires_i[0];
                    const wire_posis_i = __model__.modeldata.geom.nav.navAnyToPosi(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].WIRE, wire_i);
                    const wire_posis_arr = wire_posis_i.map(posi_i => [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].POSI, posi_i]);
                    Array.prototype.splice.apply(ents_arr, [i, 1, wire_posis_arr]); // TODO
                    break;
                default:
                    break;
            }
        }
    }
}
// ================================================================================================
/**
 * Lofts between entities.
 * ~
 * The geometry that is generated depends on the method that is selected.
 * - The 'quads' methods will generate polygons.
 * - The 'stringers' and 'ribs' methods will generate polylines.
 * - The 'copies' method will generate copies of the input geometry type.
 *
 * @param __model__
 * @param entities List of entities, or list of lists of entities.
 * @param method Enum, if 'closed', then close the loft back to the first entity in the list.
 * @returns Entities, a list of new polygons or polylines resulting from the loft.
 * @example quads = make.Loft([polyline1,polyline2,polyline3], 1, 'open_quads')
 * @example_info Creates quad polygons lofting between polyline1, polyline2, polyline3.
 * @example quads = make.Loft([polyline1,polyline2,polyline3], 1, 'closed_quads')
 * @example_info Creates quad polygons lofting between polyline1, polyline2, polyline3, and back to polyline1.
 * @example quads = make.Loft([ [polyline1,polyline2], [polyline3,polyline4] ] , 1, 'open_quads')
 * @example_info Creates quad polygons lofting first between polyline1 and polyline2, and then between polyline3 and polyline4.
 */
function Loft(__model__, entities, divisions, method) {
    if (Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["isEmptyArr"])(entities)) {
        return [];
    }
    // --- Error Check ---
    let ents_arr;
    if (__model__.debug) {
        ents_arr = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])('make.Loft', 'entities', entities, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL, _check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdLL], [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].EDGE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].WIRE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].FACE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON]);
    }
    else {
        // ents_arr = splitIDs('make.Loft', 'entities', entities,
        // [IDcheckObj.isIDList, IDcheckObj.isIDListOfLists],
        // [EEntType.EDGE, EEntType.WIRE, EEntType.FACE, EEntType.PLINE, EEntType.PGON]) as TEntTypeIdx[]|TEntTypeIdx[][];
        ents_arr = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsBreak"])(entities);
    }
    // --- Error Check ---
    const new_ents_arr = _loft(__model__, ents_arr, divisions, method);
    return Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsMake"])(new_ents_arr);
}
var _ELoftMethod;
(function (_ELoftMethod) {
    _ELoftMethod["OPEN_QUADS"] = "open_quads";
    _ELoftMethod["CLOSED_QUADS"] = "closed_quads";
    _ELoftMethod["OPEN_STRINGERS"] = "open_stringers";
    _ELoftMethod["CLOSED_STRINGERS"] = "closed_stringers";
    _ELoftMethod["OPEN_RIBS"] = "open_ribs";
    _ELoftMethod["CLOSED_RIBS"] = "closed_ribs";
    _ELoftMethod["COPIES"] = "copies";
})(_ELoftMethod || (_ELoftMethod = {}));
function _loftQuads(__model__, ents_arr, divisions, method) {
    const edges_arrs_i = [];
    let num_edges = 0;
    for (const ents of ents_arr) {
        const [ent_type, index] = ents;
        const edges_i = __model__.modeldata.geom.nav.navAnyToEdge(ent_type, index);
        if (edges_arrs_i.length === 0) {
            num_edges = edges_i.length;
        }
        if (edges_i.length !== num_edges) {
            throw new Error('make.Loft: Number of edges is not consistent.');
        }
        edges_arrs_i.push(edges_i);
    }
    if (method === _ELoftMethod.CLOSED_QUADS) {
        edges_arrs_i.push(edges_arrs_i[0]);
    }
    const new_pgons_i = [];
    for (let i = 0; i < edges_arrs_i.length - 1; i++) {
        const edges_i_a = edges_arrs_i[i];
        const edges_i_b = edges_arrs_i[i + 1];
        if (divisions > 0) {
            const strip_posis_map = new Map();
            for (let j = 0; j < num_edges; j++) {
                const edge_i_a = edges_i_a[j];
                const edge_i_b = edges_i_b[j];
                // get exist two posis_i
                const exist_posis_a_i = __model__.modeldata.geom.nav.navAnyToPosi(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].EDGE, edge_i_a);
                const exist_posis_b_i = __model__.modeldata.geom.nav.navAnyToPosi(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].EDGE, edge_i_b);
                // create the new posis strip if necessary
                for (const k of [0, 1]) {
                    if (strip_posis_map.get(exist_posis_a_i[k]) === undefined) {
                        const xyz_a = __model__.modeldata.attribs.query.getPosiCoords(exist_posis_a_i[k]);
                        const xyz_b = __model__.modeldata.attribs.query.getPosiCoords(exist_posis_b_i[k]);
                        const extrude_vec_div = Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_4__["vecDiv"])(Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_4__["vecFromTo"])(xyz_a, xyz_b), divisions);
                        const strip_posis_i = [exist_posis_a_i[k]];
                        for (let d = 1; d < divisions; d++) {
                            const strip_posi_i = __model__.modeldata.geom.add.addPosi();
                            const move_xyz = Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_4__["vecMult"])(extrude_vec_div, d);
                            __model__.modeldata.attribs.add.setPosiCoords(strip_posi_i, Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_4__["vecAdd"])(xyz_a, move_xyz));
                            strip_posis_i.push(strip_posi_i);
                        }
                        strip_posis_i.push(exist_posis_b_i[k]);
                        strip_posis_map.set(exist_posis_a_i[k], strip_posis_i);
                    }
                }
                // get the two strips and make polygons
                const strip1_posis_i = strip_posis_map.get(exist_posis_a_i[0]);
                const strip2_posis_i = strip_posis_map.get(exist_posis_a_i[1]);
                for (let k = 0; k < strip1_posis_i.length - 1; k++) {
                    const c1 = strip1_posis_i[k];
                    const c2 = strip2_posis_i[k];
                    const c3 = strip2_posis_i[k + 1];
                    const c4 = strip1_posis_i[k + 1];
                    const pgon_i = __model__.modeldata.geom.add.addPgon([c1, c2, c3, c4]);
                    new_pgons_i.push(pgon_i);
                }
            }
        }
        else {
            for (let j = 0; j < num_edges; j++) {
                const posis_i_a = __model__.modeldata.geom.nav.navAnyToPosi(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].EDGE, edges_i_a[j]);
                const posis_i_b = __model__.modeldata.geom.nav.navAnyToPosi(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].EDGE, edges_i_b[j]);
                const pgon_i = __model__.modeldata.geom.add.addPgon([posis_i_a[0], posis_i_a[1], posis_i_b[1], posis_i_b[0]]);
                new_pgons_i.push(pgon_i);
            }
        }
    }
    return new_pgons_i.map(pgon_i => [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON, pgon_i]);
}
function _loftStringers(__model__, ents_arr, divisions, method) {
    const posis_arrs_i = [];
    let num_posis = 0;
    for (const ents of ents_arr) {
        const [ent_type, index] = ents;
        const posis_i = __model__.modeldata.geom.nav.navAnyToPosi(ent_type, index);
        if (posis_arrs_i.length === 0) {
            num_posis = posis_i.length;
        }
        if (posis_i.length !== num_posis) {
            throw new Error('make.Loft: Number of positions is not consistent.');
        }
        posis_arrs_i.push(posis_i);
    }
    const is_closed = method === _ELoftMethod.CLOSED_STRINGERS;
    if (is_closed) {
        posis_arrs_i.push(posis_arrs_i[0]);
    }
    const stringer_plines_i = [];
    for (let i = 0; i < num_posis; i++) {
        const stringer_posis_i = [];
        for (let j = 0; j < posis_arrs_i.length - 1; j++) {
            stringer_posis_i.push(posis_arrs_i[j][i]);
            if (divisions > 0) {
                const xyz1 = __model__.modeldata.attribs.query.getPosiCoords(posis_arrs_i[j][i]);
                const xyz2 = __model__.modeldata.attribs.query.getPosiCoords(posis_arrs_i[j + 1][i]);
                const vec = Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_4__["vecDiv"])(Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_4__["vecFromTo"])(xyz1, xyz2), divisions);
                for (let k = 1; k < divisions; k++) {
                    const new_xyz = Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_4__["vecAdd"])(xyz1, Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_4__["vecMult"])(vec, k));
                    const new_posi_i = __model__.modeldata.geom.add.addPosi();
                    __model__.modeldata.attribs.add.setPosiCoords(new_posi_i, new_xyz);
                    stringer_posis_i.push(new_posi_i);
                }
            }
        }
        if (!is_closed) {
            stringer_posis_i.push(posis_arrs_i[posis_arrs_i.length - 1][i]);
        }
        const pline_i = __model__.modeldata.geom.add.addPline(stringer_posis_i, is_closed);
        stringer_plines_i.push(pline_i);
    }
    return stringer_plines_i.map(pline_i => [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE, pline_i]);
}
function _loftRibs(__model__, ents_arr, divisions, method) {
    const posis_arrs_i = [];
    let num_posis = 0;
    for (const ents of ents_arr) {
        const [ent_type, index] = ents;
        const posis_i = __model__.modeldata.geom.nav.navAnyToPosi(ent_type, index);
        if (posis_arrs_i.length === 0) {
            num_posis = posis_i.length;
        }
        if (posis_i.length !== num_posis) {
            throw new Error('make.Loft: Number of positions is not consistent.');
        }
        posis_arrs_i.push(posis_i);
    }
    const is_closed = method === _ELoftMethod.CLOSED_RIBS;
    if (is_closed) {
        posis_arrs_i.push(posis_arrs_i[0]);
    }
    let ribs_is_closed = false;
    switch (ents_arr[0][0]) { // check if the first entity is closed
        case _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON:
        case _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].FACE:
            ribs_is_closed = true;
            break;
        case _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE:
            const wire_i = __model__.modeldata.geom.nav.navPlineToWire(ents_arr[0][1]);
            ribs_is_closed = __model__.modeldata.geom.query.isWireClosed(wire_i);
            break;
        case _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].WIRE:
            ribs_is_closed = __model__.modeldata.geom.query.isWireClosed(ents_arr[0][1]);
            break;
        default:
            break;
    }
    const rib_plines_i = [];
    for (let i = 0; i < posis_arrs_i.length - 1; i++) {
        const pline_i = __model__.modeldata.geom.add.addPline(posis_arrs_i[i], ribs_is_closed);
        rib_plines_i.push(pline_i);
        if (divisions > 0) {
            const xyzs1 = posis_arrs_i[i].map(posi_i => __model__.modeldata.attribs.query.getPosiCoords(posi_i));
            const xyzs2 = posis_arrs_i[i + 1].map(posi_i => __model__.modeldata.attribs.query.getPosiCoords(posi_i));
            const vecs = [];
            for (let k = 0; k < num_posis; k++) {
                const vec = Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_4__["vecDiv"])(Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_4__["vecFromTo"])(xyzs1[k], xyzs2[k]), divisions);
                vecs.push(vec);
            }
            for (let j = 1; j < divisions; j++) {
                const rib_posis_i = [];
                for (let k = 0; k < num_posis; k++) {
                    const new_xyz = Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_4__["vecAdd"])(xyzs1[k], Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_4__["vecMult"])(vecs[k], j));
                    const new_posi_i = __model__.modeldata.geom.add.addPosi();
                    __model__.modeldata.attribs.add.setPosiCoords(new_posi_i, new_xyz);
                    rib_posis_i.push(new_posi_i);
                }
                const new_rib_pline_i = __model__.modeldata.geom.add.addPline(rib_posis_i, ribs_is_closed);
                rib_plines_i.push(new_rib_pline_i);
            }
        }
    }
    if (!is_closed) {
        const pline_i = __model__.modeldata.geom.add.addPline(posis_arrs_i[posis_arrs_i.length - 1], ribs_is_closed);
        rib_plines_i.push(pline_i);
    }
    return rib_plines_i.map(pline_i => [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE, pline_i]);
}
function _loftCopies(__model__, ents_arr, divisions) {
    const posis_arrs_i = [];
    let num_posis = 0;
    for (const ents of ents_arr) {
        const [ent_type, index] = ents;
        const posis_i = __model__.modeldata.geom.nav.navAnyToPosi(ent_type, index);
        if (posis_arrs_i.length === 0) {
            num_posis = posis_i.length;
        }
        if (posis_i.length !== num_posis) {
            throw new Error('make.Loft: Number of positions is not consistent.');
        }
        posis_arrs_i.push(posis_i);
    }
    const copies = [];
    for (let i = 0; i < posis_arrs_i.length - 1; i++) {
        copies.push(ents_arr[i]);
        if (divisions > 0) {
            const xyzs1 = posis_arrs_i[i].map(posi_i => __model__.modeldata.attribs.query.getPosiCoords(posi_i));
            const xyzs2 = posis_arrs_i[i + 1].map(posi_i => __model__.modeldata.attribs.query.getPosiCoords(posi_i));
            const vecs = [];
            for (let k = 0; k < num_posis; k++) {
                const vec = Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_4__["vecDiv"])(Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_4__["vecFromTo"])(xyzs1[k], xyzs2[k]), divisions);
                vecs.push(vec);
            }
            for (let j = 1; j < divisions; j++) {
                const lofted_ent_arr = Object(_common__WEBPACK_IMPORTED_MODULE_7__["_copyGeom"])(__model__, ents_arr[i], true);
                Object(_common__WEBPACK_IMPORTED_MODULE_7__["_copyGeomPosis"])(__model__, lofted_ent_arr, true, null);
                const [lofted_ent_type, lofted_ent_i] = lofted_ent_arr;
                const new_posis_i = __model__.modeldata.geom.nav.navAnyToPosi(lofted_ent_type, lofted_ent_i);
                for (let k = 0; k < num_posis; k++) {
                    const new_xyz = Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_4__["vecAdd"])(xyzs1[k], Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_4__["vecMult"])(vecs[k], j));
                    __model__.modeldata.attribs.add.setPosiCoords(new_posis_i[k], new_xyz);
                }
                copies.push(lofted_ent_arr);
            }
        }
    }
    copies.push(ents_arr[ents_arr.length - 1]);
    return copies;
}
function _loft(__model__, ents_arrs, divisions, method) {
    const depth = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["getArrDepth"])(ents_arrs);
    if (depth === 2) {
        const ents_arr = ents_arrs;
        switch (method) {
            case _ELoftMethod.OPEN_QUADS:
            case _ELoftMethod.CLOSED_QUADS:
                return _loftQuads(__model__, ents_arr, divisions, method);
            case _ELoftMethod.OPEN_STRINGERS:
            case _ELoftMethod.CLOSED_STRINGERS:
                return _loftStringers(__model__, ents_arr, divisions, method);
            case _ELoftMethod.OPEN_RIBS:
            case _ELoftMethod.CLOSED_RIBS:
                return _loftRibs(__model__, ents_arr, divisions, method);
            case _ELoftMethod.COPIES:
                return _loftCopies(__model__, ents_arr, divisions);
            default:
                break;
        }
    }
    else if (depth === 3) {
        const all_loft_ents = [];
        for (const ents_arr of ents_arrs) {
            const loft_ents = _loft(__model__, ents_arr, divisions, method);
            loft_ents.forEach(loft_ent => all_loft_ents.push(loft_ent));
        }
        return all_loft_ents;
    }
}
// ================================================================================================
/**
 * Extrudes geometry by distance or by vector.
 * - Extrusion of a position, vertex, or point produces polylines;
 * - Extrusion of an edge, wire, or polyline produces polygons;
 * - Extrusion of a face or polygon produces polygons, capped at the top.
 * ~
 * The geometry that is generated depends on the method that is selected.
 * - The 'quads' methods will generate polygons.
 * - The 'stringers' and 'ribs' methods will generate polylines.
 * - The 'copies' method will generate copies of the input geometry type.
 * ~
 * @param __model__
 * @param entities Vertex, edge, wire, face, position, point, polyline, polygon, collection.
 * @param dist Number or vector. If number, assumed to be [0,0,value] (i.e. extrusion distance in z-direction).
 * @param divisions Number of divisions to divide extrusion by. Minimum is 1.
 * @param method Enum, when extruding edges, select quads, stringers, or ribs
 * @returns Entities, a list of new polygons or polylines resulting from the extrude.
 * @example extrusion1 = make.Extrude(point1, 10, 2, 'quads')
 * @example_info Creates a polyline of total length 10 (with two edges of length 5 each) in the z-direction.
 * In this case, the 'quads' setting is ignored.
 * @example extrusion2 = make.Extrude(polygon1, [0,5,0], 1, 'quads')
 * @example_info Extrudes polygon1 by 5 in the y-direction, creating a list of quad surfaces.
 */
function Extrude(__model__, entities, dist, divisions, method) {
    if (Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["isEmptyArr"])(entities)) {
        return [];
    }
    // --- Error Check ---
    const fn_name = 'make.Extrude';
    let ents_arr;
    if (__model__.debug) {
        ents_arr = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])(fn_name, 'entities', entities, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isId, _check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL], [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].VERT, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].EDGE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].WIRE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].FACE,
            _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].POSI, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].POINT, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].COLL]);
        Object(_check_args__WEBPACK_IMPORTED_MODULE_1__["checkArgs"])(fn_name, 'dist', dist, [_check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isNum, _check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isXYZ]);
        Object(_check_args__WEBPACK_IMPORTED_MODULE_1__["checkArgs"])(fn_name, 'divisions', divisions, [_check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isInt]);
    }
    else {
        // ents_arr =  splitIDs(fn_name, 'entities', entities,
        //     [IDcheckObj.isID, IDcheckObj.isIDList],
        //     [EEntType.VERT, EEntType.EDGE, EEntType.WIRE, EEntType.FACE,
        //     EEntType.POSI, EEntType.POINT, EEntType.PLINE, EEntType.PGON, EEntType.COLL]) as TEntTypeIdx|TEntTypeIdx[];
        ents_arr = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsBreak"])(entities);
    }
    // --- Error Check ---
    let new_ents_arr = null;
    // extrude
    if (method === _EExtrudeMethod.COPIES) {
        new_ents_arr = _extrudeCopies(__model__, ents_arr, dist, divisions);
    }
    else {
        new_ents_arr = _extrude(__model__, ents_arr, dist, divisions, method);
    }
    // create IDs
    if (!Array.isArray(entities) && new_ents_arr.length === 1) {
        return Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsMake"])(new_ents_arr[0]);
    }
    else {
        return Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsMake"])(new_ents_arr);
    }
}
function _extrudeCopies(__model__, ents, dist, divisions) {
    const ents_arr = (Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["getArrDepth"])(ents) === 1 ? [ents] : ents);
    const extrude_vec = (Array.isArray(dist) ? dist : [0, 0, dist]);
    const extrude_vec_div = Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_4__["vecDiv"])(extrude_vec, divisions);
    const copies = [];
    // make the copies
    for (let i = 0; i < divisions + 1; i++) {
        // copy the list of entities
        const copied_ents_arr = Object(_common__WEBPACK_IMPORTED_MODULE_7__["_copyGeom"])(__model__, ents_arr, true);
        // copy the positions that belong to the list of entities
        Object(_common__WEBPACK_IMPORTED_MODULE_7__["_copyGeomPosis"])(__model__, copied_ents_arr, true, Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_4__["vecMult"])(extrude_vec_div, i));
        // add to the array
        for (const copied_ent_arr of copied_ents_arr) {
            copies.push(copied_ent_arr);
        }
    }
    // return the copies
    return copies;
}
function _extrudeColl(__model__, index, extrude_vec, divisions, method) {
    const points_i = __model__.modeldata.geom.nav.navCollToPoint(index);
    const res1 = points_i.map(point_i => _extrude(__model__, [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].POINT, point_i], extrude_vec, divisions, method));
    const plines_i = __model__.modeldata.geom.nav.navCollToPline(index);
    const res2 = plines_i.map(pline_i => _extrude(__model__, [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE, pline_i], extrude_vec, divisions, method));
    const pgons_i = __model__.modeldata.geom.nav.navCollToPgon(index);
    const res3 = pgons_i.map(pgon_i => _extrude(__model__, [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON, pgon_i], extrude_vec, divisions, method));
    return [].concat(res1, res2, res3);
}
function _extrudeDim0(__model__, ent_type, index, extrude_vec, divisions) {
    const extrude_vec_div = Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_4__["vecDiv"])(extrude_vec, divisions);
    const exist_posi_i = __model__.modeldata.geom.nav.navAnyToPosi(ent_type, index)[0];
    const xyz = __model__.modeldata.attribs.query.getPosiCoords(exist_posi_i);
    const strip_posis_i = [exist_posi_i];
    for (let i = 1; i < divisions + 1; i++) {
        const strip_posi_i = __model__.modeldata.geom.add.addPosi();
        const move_xyz = Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_4__["vecMult"])(extrude_vec_div, i);
        __model__.modeldata.attribs.add.setPosiCoords(strip_posi_i, Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_4__["vecAdd"])(xyz, move_xyz));
        strip_posis_i.push(strip_posi_i);
    }
    // loft between the positions and create a single polyline
    const pline_i = __model__.modeldata.geom.add.addPline(strip_posis_i);
    return [[_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE, pline_i]];
}
function _extrudeQuads(__model__, ent_type, index, extrude_vec, divisions) {
    const new_pgons_i = [];
    const extrude_vec_div = Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_4__["vecDiv"])(extrude_vec, divisions);
    const edges_i = __model__.modeldata.geom.nav.navAnyToEdge(ent_type, index);
    const strip_posis_map = new Map();
    for (const edge_i of edges_i) {
        // get exist posis_i
        const exist_posis_i = __model__.modeldata.geom.nav.navAnyToPosi(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].EDGE, edge_i);
        // create the new posis strip if necessary
        for (const exist_posi_i of exist_posis_i) {
            if (strip_posis_map.get(exist_posi_i) === undefined) {
                const xyz = __model__.modeldata.attribs.query.getPosiCoords(exist_posi_i);
                const strip_posis_i = [exist_posi_i];
                for (let i = 1; i < divisions + 1; i++) {
                    const strip_posi_i = __model__.modeldata.geom.add.addPosi();
                    const move_xyz = Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_4__["vecMult"])(extrude_vec_div, i);
                    __model__.modeldata.attribs.add.setPosiCoords(strip_posi_i, Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_4__["vecAdd"])(xyz, move_xyz));
                    strip_posis_i.push(strip_posi_i);
                }
                strip_posis_map.set(exist_posi_i, strip_posis_i);
            }
        }
        // get the two strips and make polygons
        const strip1_posis_i = strip_posis_map.get(exist_posis_i[0]);
        const strip2_posis_i = strip_posis_map.get(exist_posis_i[1]);
        for (let i = 0; i < strip1_posis_i.length - 1; i++) {
            const c1 = strip1_posis_i[i];
            const c2 = strip2_posis_i[i];
            const c3 = strip2_posis_i[i + 1];
            const c4 = strip1_posis_i[i + 1];
            const pgon_i = __model__.modeldata.geom.add.addPgon([c1, c2, c3, c4]);
            new_pgons_i.push(pgon_i);
        }
    }
    // cap the top
    if (Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["isDim2"])(ent_type)) { // create a top -> polygon
        const face_i = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["isFace"])(ent_type) ? index : __model__.modeldata.geom.nav.navPgonToFace(index);
        const cap_pgon_i = _extrudeCap(__model__, face_i, strip_posis_map, divisions);
        new_pgons_i.push(cap_pgon_i);
    }
    return new_pgons_i.map(pgon_i => [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON, pgon_i]);
}
function _extrudeStringers(__model__, ent_type, index, extrude_vec, divisions) {
    const new_plines_i = [];
    const extrude_vec_div = Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_4__["vecDiv"])(extrude_vec, divisions);
    const edges_i = __model__.modeldata.geom.nav.navAnyToEdge(ent_type, index);
    const strip_posis_map = new Map();
    for (const edge_i of edges_i) {
        // get exist posis_i
        const exist_posis_i = __model__.modeldata.geom.nav.navAnyToPosi(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].EDGE, edge_i);
        // create the new posis strip if necessary
        for (const exist_posi_i of exist_posis_i) {
            if (strip_posis_map.get(exist_posi_i) === undefined) {
                const xyz = __model__.modeldata.attribs.query.getPosiCoords(exist_posi_i);
                const strip_posis_i = [exist_posi_i];
                for (let i = 1; i < divisions + 1; i++) {
                    const strip_posi_i = __model__.modeldata.geom.add.addPosi();
                    const move_xyz = Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_4__["vecMult"])(extrude_vec_div, i);
                    __model__.modeldata.attribs.add.setPosiCoords(strip_posi_i, Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_4__["vecAdd"])(xyz, move_xyz));
                    strip_posis_i.push(strip_posi_i);
                }
                strip_posis_map.set(exist_posi_i, strip_posis_i);
            }
        }
    }
    // make the stringers
    strip_posis_map.forEach(strip_posis_i => {
        const pline_i = __model__.modeldata.geom.add.addPline(strip_posis_i);
        new_plines_i.push(pline_i);
    });
    // return the stringers
    return new_plines_i.map(pline_i => [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE, pline_i]);
}
function _extrudeRibs(__model__, ent_type, index, extrude_vec, divisions) {
    const new_plines_i = [];
    const extrude_vec_div = Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_4__["vecDiv"])(extrude_vec, divisions);
    const edges_i = __model__.modeldata.geom.nav.navAnyToEdge(ent_type, index);
    const strip_posis_map = new Map();
    for (const edge_i of edges_i) {
        // get exist posis_i
        const exist_posis_i = __model__.modeldata.geom.nav.navAnyToPosi(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].EDGE, edge_i);
        // create the new posis strip if necessary
        for (const exist_posi_i of exist_posis_i) {
            if (strip_posis_map.get(exist_posi_i) === undefined) {
                const xyz = __model__.modeldata.attribs.query.getPosiCoords(exist_posi_i);
                const strip_posis_i = [exist_posi_i];
                for (let i = 1; i < divisions + 1; i++) {
                    const strip_posi_i = __model__.modeldata.geom.add.addPosi();
                    const move_xyz = Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_4__["vecMult"])(extrude_vec_div, i);
                    __model__.modeldata.attribs.add.setPosiCoords(strip_posi_i, Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_4__["vecAdd"])(xyz, move_xyz));
                    strip_posis_i.push(strip_posi_i);
                }
                strip_posis_map.set(exist_posi_i, strip_posis_i);
            }
        }
    }
    // make an array of ents to process as ribs
    let ribs_is_closed = false;
    const ribs_posis_i = [];
    switch (ent_type) { // check if the entity is closed
        case _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON:
        case _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].FACE:
            ribs_is_closed = true;
            const face_wires_i = __model__.modeldata.geom.nav.navAnyToWire(ent_type, index);
            for (const face_wire_i of face_wires_i) {
                const face_wire_posis_i = __model__.modeldata.geom.nav.navAnyToPosi(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].WIRE, face_wire_i);
                ribs_posis_i.push(face_wire_posis_i);
            }
            break;
        case _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE:
            const pline_wire_i = __model__.modeldata.geom.nav.navPlineToWire(index);
            const pline_wire_posis_i = __model__.modeldata.geom.nav.navAnyToPosi(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].WIRE, pline_wire_i);
            ribs_posis_i.push(pline_wire_posis_i);
            ribs_is_closed = __model__.modeldata.geom.query.isWireClosed(pline_wire_i);
            break;
        case _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].WIRE:
            const wire_posis_i = __model__.modeldata.geom.nav.navAnyToPosi(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].WIRE, index);
            ribs_posis_i.push(wire_posis_i);
            ribs_is_closed = __model__.modeldata.geom.query.isWireClosed(index);
            break;
        default:
            const posis_i = __model__.modeldata.geom.nav.navAnyToPosi(ent_type, index);
            ribs_posis_i.push(posis_i);
            break;
    }
    // make the ribs
    for (let i = 0; i < divisions + 1; i++) {
        for (const rib_posis_i of ribs_posis_i) {
            const mapped_rib_posis_i = rib_posis_i.map(rib_posi_i => strip_posis_map.get(rib_posi_i)[i]);
            const pline_i = __model__.modeldata.geom.add.addPline(mapped_rib_posis_i, ribs_is_closed);
            new_plines_i.push(pline_i);
        }
    }
    // return the ribs
    return new_plines_i.map(pline_i => [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE, pline_i]);
}
function _extrudeCap(__model__, index, strip_posis_map, divisions) {
    const face_i = __model__.modeldata.geom.nav.navPgonToFace(index);
    // get positions on boundary
    const old_wire_i = __model__.modeldata.geom.query.getFaceBoundary(face_i);
    const old_posis_i = __model__.modeldata.geom.nav.navAnyToPosi(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].WIRE, old_wire_i);
    const new_posis_i = old_posis_i.map(old_posi_i => strip_posis_map.get(old_posi_i)[divisions]);
    // get positions for holes
    const old_holes_wires_i = __model__.modeldata.geom.query.getFaceHoles(face_i);
    const new_holes_posis_i = [];
    for (const old_hole_wire_i of old_holes_wires_i) {
        const old_hole_posis_i = __model__.modeldata.geom.nav.navAnyToPosi(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].WIRE, old_hole_wire_i);
        const new_hole_posis_i = old_hole_posis_i.map(old_posi_i => strip_posis_map.get(old_posi_i)[divisions]);
        new_holes_posis_i.push(new_hole_posis_i);
    }
    // make new polygon
    const pgon_i = __model__.modeldata.geom.add.addPgon(new_posis_i, new_holes_posis_i);
    return pgon_i;
}
function _extrude(__model__, ents_arr, dist, divisions, method) {
    const extrude_vec = (Array.isArray(dist) ? dist : [0, 0, dist]);
    if (Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["getArrDepth"])(ents_arr) === 1) {
        const [ent_type, index] = ents_arr;
        // check if this is a collection, call this function again
        if (Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["isColl"])(ent_type)) {
            return _extrudeColl(__model__, index, extrude_vec, divisions, method);
        }
        // check if this is a position, a vertex, or a point -> pline
        if (Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["isDim0"])(ent_type)) {
            return _extrudeDim0(__model__, ent_type, index, extrude_vec, divisions);
        }
        // extrude edges -> polygons
        switch (method) {
            case _EExtrudeMethod.QUADS:
                return _extrudeQuads(__model__, ent_type, index, extrude_vec, divisions);
            case _EExtrudeMethod.STRINGERS:
                return _extrudeStringers(__model__, ent_type, index, extrude_vec, divisions);
            case _EExtrudeMethod.RIBS:
                return _extrudeRibs(__model__, ent_type, index, extrude_vec, divisions);
            default:
                throw new Error('Extrude method not recognised.');
        }
    }
    else {
        const new_ents_arr = [];
        ents_arr.forEach(ent_arr => {
            const result = _extrude(__model__, ent_arr, extrude_vec, divisions, method);
            result.forEach(new_ent_arr => new_ents_arr.push(new_ent_arr));
        });
        return new_ents_arr;
    }
}
// ================================================================================================
/**
 * Sweeps a cross section wire along a backbone wire.
 * ~
 * @param __model__
 * @param entities Wires, or entities from which wires can be extracted.
 * @param xsection Cross section wire to sweep, or entity from which a wire can be extracted.
 * @param divisions Segment length or number of segments.
 * @param method Enum, select the method for sweeping.
 * @returns Entities, a list of new polygons or polylines resulting from the sweep.
 */
function Sweep(__model__, entities, x_section, divisions, method) {
    entities = Object(_libs_util_arrs__WEBPACK_IMPORTED_MODULE_6__["arrMakeFlat"])(entities);
    if (Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["isEmptyArr"])(entities)) {
        return [];
    }
    // --- Error Check ---
    const fn_name = 'make.Sweep';
    let backbone_ents;
    let xsection_ent;
    if (__model__.debug) {
        backbone_ents = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])(fn_name, 'entities', entities, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isId, _check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL], [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].WIRE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON]);
        xsection_ent = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])(fn_name, 'xsextion', x_section, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isId], [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].EDGE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].WIRE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON]);
        Object(_check_args__WEBPACK_IMPORTED_MODULE_1__["checkArgs"])(fn_name, 'divisions', divisions, [_check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isInt]);
        if (divisions === 0) {
            throw new Error(fn_name + ' : Divisor cannot be zero.');
        }
    }
    else {
        // backbone_ents = splitIDs(fn_name, 'entities', entities,
        //     [IDcheckObj.isID, IDcheckObj.isIDList], [EEntType.WIRE, EEntType.PLINE, EEntType.PGON]) as TEntTypeIdx[];
        // xsection_ent = splitIDs(fn_name, 'xsextion', xsextion,
        //     [IDcheckObj.isID], [EEntType.EDGE, EEntType.WIRE, EEntType.PLINE, EEntType.PGON]) as TEntTypeIdx;
        backbone_ents = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsBreak"])(entities);
        xsection_ent = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsBreak"])(x_section);
    }
    // --- Error Check ---
    // the xsection
    const [xsection_ent_type, xsection_index] = xsection_ent;
    let xsection_wire_i = null;
    if (Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["isWire"])(xsection_ent_type)) {
        xsection_wire_i = xsection_index;
    }
    else {
        const xsection_wires_i = __model__.modeldata.geom.nav.navAnyToWire(xsection_ent_type, xsection_index);
        xsection_wire_i = xsection_wires_i[0]; // select the first wire that is found
    }
    // get all the wires and put them into an array
    const backbone_wires_i = [];
    for (const [ent_type, index] of backbone_ents) {
        if (Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["isWire"])(ent_type)) {
            backbone_wires_i.push(index);
        }
        else {
            const ent_wires_i = __model__.modeldata.geom.nav.navAnyToWire(ent_type, index);
            backbone_wires_i.push(...ent_wires_i);
        }
    }
    // do the sweep
    const new_ents = _sweep(__model__, backbone_wires_i, xsection_wire_i, divisions, method);
    return Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsMake"])(new_ents);
}
function _sweep(__model__, backbone_wires_i, xsection_wire_i, divisions, method) {
    if (!Array.isArray(backbone_wires_i)) {
        // extrude edges -> polygons
        switch (method) {
            case _EExtrudeMethod.QUADS:
                return _sweepQuads(__model__, backbone_wires_i, xsection_wire_i, divisions);
            case _EExtrudeMethod.STRINGERS:
                return _sweepStringers(__model__, backbone_wires_i, xsection_wire_i, divisions);
            case _EExtrudeMethod.RIBS:
                return _sweepRibs(__model__, backbone_wires_i, xsection_wire_i, divisions);
            case _EExtrudeMethod.COPIES:
                return _sweepCopies(__model__, backbone_wires_i, xsection_wire_i, divisions);
            default:
                throw new Error('Extrude method not recognised.');
        }
    }
    else {
        const new_ents = [];
        for (const wire_i of backbone_wires_i) {
            const wire_new_ents = _sweep(__model__, wire_i, xsection_wire_i, divisions, method);
            for (const wire_new_ent of wire_new_ents) {
                new_ents.push(wire_new_ent);
            }
        }
        return new_ents;
    }
}
function _sweepQuads(__model__, backbone_wire_i, xsection_wire_i, divisions) {
    const strips_posis_i = _sweepPosis(__model__, backbone_wire_i, xsection_wire_i, divisions);
    const backbone_is_closed = __model__.modeldata.geom.query.isWireClosed(backbone_wire_i);
    const xsection_is_closed = __model__.modeldata.geom.query.isWireClosed(xsection_wire_i);
    // add row if backbone_is_closed
    if (backbone_is_closed) {
        strips_posis_i.push(strips_posis_i[0].slice());
    }
    // add a posi_i to end of each strip if xsection_is_closed
    if (xsection_is_closed) {
        for (const strip_posis_i of strips_posis_i) {
            strip_posis_i.push(strip_posis_i[0]);
        }
    }
    // create quads
    const new_pgons = [];
    for (let i = 0; i < strips_posis_i.length - 1; i++) {
        const strip1_posis_i = strips_posis_i[i];
        const strip2_posis_i = strips_posis_i[i + 1];
        for (let j = 0; j < strip1_posis_i.length - 1; j++) {
            const c1 = strip1_posis_i[j];
            const c2 = strip2_posis_i[j];
            const c3 = strip2_posis_i[j + 1];
            const c4 = strip1_posis_i[j + 1];
            const pgon_i = __model__.modeldata.geom.add.addPgon([c1, c2, c3, c4]);
            new_pgons.push([_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON, pgon_i]);
        }
    }
    return new_pgons;
}
function _sweepStringers(__model__, backbone_wire_i, xsection_wire_i, divisions) {
    const backbone_is_closed = __model__.modeldata.geom.query.isWireClosed(backbone_wire_i);
    const ribs_posis_i = _sweepPosis(__model__, backbone_wire_i, xsection_wire_i, divisions);
    const stringers_posis_i = Object(_assets_core_inline_list__WEBPACK_IMPORTED_MODULE_9__["listZip"])(ribs_posis_i);
    const plines = [];
    for (const stringer_posis_i of stringers_posis_i) {
        const pline_i = __model__.modeldata.geom.add.addPline(stringer_posis_i, backbone_is_closed);
        plines.push([_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE, pline_i]);
    }
    return plines;
}
function _sweepRibs(__model__, backbone_wire_i, xsection_wire_i, divisions) {
    const xsection_is_closed = __model__.modeldata.geom.query.isWireClosed(xsection_wire_i);
    const ribs_posis_i = _sweepPosis(__model__, backbone_wire_i, xsection_wire_i, divisions);
    const plines = [];
    for (const rib_posis_i of ribs_posis_i) {
        const pline_i = __model__.modeldata.geom.add.addPline(rib_posis_i, xsection_is_closed);
        plines.push([_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE, pline_i]);
    }
    return plines;
}
function _sweepCopies(__model__, backbone_wire_i, xsection_wire_i, divisions) {
    const posis_i = _sweepPosis(__model__, backbone_wire_i, xsection_wire_i, divisions);
    // TODO
    throw new Error('Not implemented');
    // TODO
}
function _sweepPosis(__model__, backbone_wire_i, xsection_wire_i, divisions) {
    // get the xyzs of the cross section
    const xsextion_xyzs = __model__.modeldata.attribs.query.getEntCoords(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].WIRE, xsection_wire_i);
    // get the xyzs of the backbone
    const wire_normal = __model__.modeldata.geom.query.getWireNormal(backbone_wire_i);
    const wire_is_closed = __model__.modeldata.geom.query.isWireClosed(backbone_wire_i);
    const wire_xyzs = __model__.modeldata.attribs.query.getEntCoords(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].WIRE, backbone_wire_i);
    let plane_xyzs = [];
    // if not divisions is not 1, then we need to add xyzs
    if (divisions === 1) {
        plane_xyzs = wire_xyzs;
    }
    else {
        if (wire_is_closed) {
            wire_xyzs.push(wire_xyzs[0]);
        }
        for (let i = 0; i < wire_xyzs.length - 1; i++) {
            const xyz0 = wire_xyzs[i];
            const xyz1 = wire_xyzs[i + 1];
            const vec = Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_4__["vecFromTo"])(xyz0, xyz1);
            const vec_div = Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_4__["vecDiv"])(vec, divisions);
            // create additional xyzs for planes
            plane_xyzs.push(xyz0);
            for (let j = 1; j < divisions; j++) {
                plane_xyzs.push(Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_4__["vecAdd"])(xyz0, Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_4__["vecMult"])(vec_div, j)));
            }
        }
        if (!wire_is_closed) {
            plane_xyzs.push(wire_xyzs[wire_xyzs.length - 1]);
        }
    }
    // create the planes
    const planes = Object(_common__WEBPACK_IMPORTED_MODULE_7__["getPlanesSeq"])(plane_xyzs, wire_normal, wire_is_closed);
    // create the new  posis
    const XY = [[0, 0, 0], [1, 0, 0], [0, 1, 0]];
    const all_new_posis_i = [];
    for (const plane of planes) {
        const matrix = Object(_assets_libs_geom_matrix__WEBPACK_IMPORTED_MODULE_8__["xfromSourceTargetMatrix"])(XY, plane);
        const xsection_posis_i = [];
        for (const xsextion_xyz of xsextion_xyzs) {
            const new_xyz = Object(_assets_libs_geom_matrix__WEBPACK_IMPORTED_MODULE_8__["multMatrix"])(xsextion_xyz, matrix);
            const posi_i = __model__.modeldata.geom.add.addPosi();
            __model__.modeldata.attribs.add.setPosiCoords(posi_i, new_xyz);
            xsection_posis_i.push(posi_i);
        }
        all_new_posis_i.push(xsection_posis_i);
    }
    // return the new posis
    return all_new_posis_i;
}
// ================================================================================================
/**
 * Divides edges into a set of shorter edges.
 * ~
 * If the 'by_number' method is selected, then each edge is divided into a fixed number of equal length shorter edges.
 * If the 'by length' method is selected, then each edge is divided into shorter edges of the specified length.
 * The length of the last segment will be the remainder.
 * If the 'by_min_length' method is selected,
 * then the edge is divided into the maximum number of shorter edges
 * that have a new length that is equal to or greater than the minimum.
 * ~
 * @param __model__
 * @param entities Edges, or entities from which edges can be extracted.
 * @param divisor Segment length or number of segments.
 * @param method Enum, select the method for dividing edges.
 * @returns Entities, a list of new edges resulting from the divide.
 * @example segments1 = make.Divide(edge1, 5, by_number)
 * @example_info Creates a list of 5 equal segments from edge1.
 * @example segments2 = make.Divide(edge1, 5, by_length)
 * @example_info If edge1 has length 13, creates from edge a list of two segments of length 5 and one segment of length 3.
 */
function Divide(__model__, entities, divisor, method) {
    entities = Object(_libs_util_arrs__WEBPACK_IMPORTED_MODULE_6__["arrMakeFlat"])(entities);
    if (Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["isEmptyArr"])(entities)) {
        return [];
    }
    // --- Error Check ---
    const fn_name = 'make.Divide';
    let ents_arr;
    if (__model__.debug) {
        ents_arr = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])(fn_name, 'entities', entities, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isId, _check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL], [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].EDGE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].WIRE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON]);
        Object(_check_args__WEBPACK_IMPORTED_MODULE_1__["checkArgs"])(fn_name, 'divisor', divisor, [_check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isNum]);
    }
    else {
        // ents_arr = splitIDs(fn_name, 'entities', entities,
        // [IDcheckObj.isID, IDcheckObj.isIDList], [EEntType.EDGE, EEntType.WIRE, EEntType.PLINE, EEntType.PGON]) as TEntTypeIdx[];
        ents_arr = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsBreak"])(entities);
    }
    // --- Error Check ---
    const new_ents_arr = _divide(__model__, ents_arr, divisor, method);
    // return the ids
    return Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsMake"])(new_ents_arr);
}
function _divide(__model__, ents_arr, divisor, method) {
    if (Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["getArrDepth"])(ents_arr) === 1) {
        const [ent_type, index] = ents_arr;
        let exist_edges_i;
        if (!Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["isEdge"])(ent_type)) {
            exist_edges_i = __model__.modeldata.geom.nav.navAnyToEdge(ent_type, index).slice();
        }
        else {
            exist_edges_i = [index];
        }
        const all_new_edges_i = [];
        for (const exist_edge_i of exist_edges_i) {
            const new_edges_i = _divideEdge(__model__, exist_edge_i, divisor, method);
            all_new_edges_i.push(...new_edges_i);
        }
        __model__.modeldata.geom.time_stamp.updateObjsTs(ent_type, index);
        return all_new_edges_i.map(one_edge_i => [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].EDGE, one_edge_i]);
    }
    else {
        return [].concat(...ents_arr.map(one_edge => _divide(__model__, one_edge, divisor, method)));
    }
}
function _divideEdge(__model__, edge_i, divisor, method) {
    const posis_i = __model__.modeldata.geom.nav.navAnyToPosi(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].EDGE, edge_i);
    const start = __model__.modeldata.attribs.query.getPosiCoords(posis_i[0]);
    const end = __model__.modeldata.attribs.query.getPosiCoords(posis_i[1]);
    let new_xyzs;
    if (method === _EDivisorMethod.BY_NUMBER) {
        new_xyzs = Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_4__["interpByNum"])(start, end, divisor - 1);
    }
    else if (method === _EDivisorMethod.BY_LENGTH) {
        new_xyzs = Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_4__["interpByLen"])(start, end, divisor);
    }
    else if (method === _EDivisorMethod.BY_MAX_LENGTH) {
        const len = Object(_libs_geom_distance__WEBPACK_IMPORTED_MODULE_5__["distance"])(start, end);
        if (divisor === 0) {
            new_xyzs = [];
        }
        else {
            const num_div = Math.ceil(len / divisor);
            const num_div_max = num_div > 1 ? num_div - 1 : 0;
            new_xyzs = Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_4__["interpByNum"])(start, end, num_div_max);
        }
    }
    else { // BY_MIN_LENGTH
        if (divisor === 0) {
            new_xyzs = [];
        }
        else {
            const len = Object(_libs_geom_distance__WEBPACK_IMPORTED_MODULE_5__["distance"])(start, end);
            const num_div = Math.floor(len / divisor);
            const num_div_min = num_div > 1 ? num_div - 1 : 0;
            new_xyzs = Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_4__["interpByNum"])(start, end, num_div_min);
        }
    }
    const new_edges_i = [];
    let old_edge_i = edge_i;
    for (const new_xyz of new_xyzs) {
        const posi_i = __model__.modeldata.geom.add.addPosi();
        __model__.modeldata.attribs.add.setPosiCoords(posi_i, new_xyz);
        const new_edge_i = __model__.modeldata.geom.modify.insertVertIntoWire(old_edge_i, posi_i);
        new_edges_i.push(old_edge_i);
        old_edge_i = new_edge_i;
    }
    new_edges_i.push(old_edge_i);
    return new_edges_i;
}
// ================================================================================================
var _ECutMethod;
(function (_ECutMethod) {
    _ECutMethod["KEEP_ABOVE"] = "keep_above";
    _ECutMethod["KEEP_BELOW"] = "keep_below";
    _ECutMethod["KEEP_BOTH"] = "keep_both";
})(_ECutMethod || (_ECutMethod = {}));
/**
 * Cuts polygons and polylines using a plane.
 * ~
 * If the 'keep_above' method is selected, then only the part of the cut entities above the plane are kept.
 * If the 'keep_below' method is selected, then only the part of the cut entities below the plane are kept.
 * If the 'keep_both' method is selected, then both the parts of the cut entities are kept.
 * ~
 * Currently does not support cutting polygons with holes. TODO
 * ~
 * If 'keep_both' is selected, returns a list of two lists.
 * [[entities above the plane], [entities below the plane]].
 * ~
 * @param __model__
 * @param entities Polylines or polygons, or entities from which polyline or polygons can be extracted.
 * @param plane The plane to cut with.
 * @param method Enum, select the method for cutting.
 * @returns Entities, a list of three lists of entities resulting from the cut.

 */
function Cut(__model__, entities, plane, method) {
    entities = Object(_libs_util_arrs__WEBPACK_IMPORTED_MODULE_6__["arrMakeFlat"])(entities);
    if (Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["isEmptyArr"])(entities)) {
        if (method === _ECutMethod.KEEP_BOTH) {
            return [[], []];
        }
        return [];
    }
    // --- Error Check ---
    const fn_name = 'make.Cut';
    let ents_arr;
    if (__model__.debug) {
        ents_arr = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])(fn_name, 'entities', entities, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isId, _check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL], null);
        Object(_check_args__WEBPACK_IMPORTED_MODULE_1__["checkArgs"])(fn_name, 'plane', plane, [_check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isPln]);
    }
    else {
        // ents_arr = splitIDs(fn_name, 'entities', entities,
        //     [IDcheckObj.isID, IDcheckObj.isIDList], null) as TEntTypeIdx[];
        ents_arr = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsBreak"])(entities);
        // checkArgTypes(fn_name, 'plane', plane, [TypeCheckObj.isPlane]);
    }
    // --- Error Check ---
    // create the threejs entity and calc intersections
    const plane_normal = Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_4__["vecCross"])(plane[1], plane[2]);
    const plane_tjs = new three__WEBPACK_IMPORTED_MODULE_10__["Plane"]();
    plane_tjs.setFromNormalAndCoplanarPoint(new three__WEBPACK_IMPORTED_MODULE_10__["Vector3"](...plane_normal), new three__WEBPACK_IMPORTED_MODULE_10__["Vector3"](...plane[0]));
    // get polylines and polygons
    const set_plines = new Set();
    const set_pgons = new Set();
    const edges_i = []; // all edges
    for (const [ent_type, ent_i] of ents_arr) {
        if (ent_type === _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE) {
            set_plines.add(ent_i);
        }
        else if (ent_type === _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON) {
            set_pgons.add(ent_i);
        }
        else {
            const plines = __model__.modeldata.geom.nav.navAnyToPline(ent_type, ent_i);
            for (const pline of plines) {
                set_plines.add(pline);
            }
            const pgons = __model__.modeldata.geom.nav.navAnyToPline(ent_type, ent_i);
            for (const pgon of pgons) {
                set_pgons.add(pgon);
            }
        }
        const ent_edges_i = __model__.modeldata.geom.nav.navAnyToEdge(ent_type, ent_i);
        for (const ent_edge_i of ent_edges_i) {
            edges_i.push(ent_edge_i);
        }
    }
    const above = [];
    const below = [];
    // cut each edge and store the results
    const [edge_to_isect_posis, cut_posi_to_copies, posi_to_tjs] = _cutEdges(__model__, edges_i, plane_tjs, method);
    // create array to store new posis
    const posi_to_copies = [];
    // slice polylines
    for (const exist_pline_i of Array.from(set_plines)) {
        const sliced = _cutCreateEnts(__model__, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE, exist_pline_i, plane_tjs, edge_to_isect_posis, posi_to_copies, cut_posi_to_copies, posi_to_tjs, method);
        for (const new_pline_i of sliced[0]) {
            above.push([_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE, new_pline_i]);
        }
        for (const new_pline_i of sliced[1]) {
            below.push([_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE, new_pline_i]);
        }
    }
    // slice polygons
    for (const exist_pgon_i of Array.from(set_pgons)) {
        // TODO slice polygons with holes
        const sliced = _cutCreateEnts(__model__, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON, exist_pgon_i, plane_tjs, edge_to_isect_posis, posi_to_copies, cut_posi_to_copies, posi_to_tjs, method);
        for (const new_pgon_i of sliced[0]) {
            above.push([_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON, new_pgon_i]);
        }
        for (const new_pgon_i of sliced[1]) {
            below.push([_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON, new_pgon_i]);
        }
    }
    // return the result
    switch (method) {
        case _ECutMethod.KEEP_ABOVE:
            return Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsMake"])(above);
        case _ECutMethod.KEEP_BELOW:
            return Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsMake"])(below);
        default:
            return [Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsMake"])(above), Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsMake"])(below)];
    }
}
// cut each edge in the input geometry and store teh intersection posi in a sparse array
// the array is nested, the two indexes [i1][i2] is the two posi ends of the edge, the value is the isect posi
// also returns some other data
// if method is "both", then we need copies of the isect posis, so these are also generated
// finally, the tjs points that are created are also returned, they are used later for checking "starts_above"
function _cutEdges(__model__, edges_i, plane_tjs, method) {
    // create sparse arrays for storing data
    const posi_to_tjs = []; // sparse array
    const edge_to_isect_posis = []; // sparse array, map_posis[2][3] is the edge from posi 2 to posi 3 (and 3 to 2)
    const cut_posi_to_copies = []; // sparse array
    // loop through each edge
    for (const edge_i of edges_i) {
        const edge_posis_i = __model__.modeldata.geom.nav.navAnyToPosi(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].EDGE, edge_i);
        edge_posis_i.sort();
        // get the edge isect point
        if (edge_to_isect_posis[edge_posis_i[0]] === undefined) {
            edge_to_isect_posis[edge_posis_i[0]] = [];
        }
        const posi_i = edge_to_isect_posis[edge_posis_i[0]][edge_posis_i[1]];
        if (posi_i === undefined) {
            const posi0_tjs = _cutGetTjsPoint(__model__, edge_posis_i[0], posi_to_tjs);
            const posi1_tjs = _cutGetTjsPoint(__model__, edge_posis_i[1], posi_to_tjs);
            const line_tjs = new three__WEBPACK_IMPORTED_MODULE_10__["Line3"](posi0_tjs, posi1_tjs);
            const isect_tjs = new three__WEBPACK_IMPORTED_MODULE_10__["Vector3"]();
            const result = plane_tjs.intersectLine(line_tjs, isect_tjs);
            if (result !== undefined && result !== null) {
                const new_posi_i = __model__.modeldata.geom.add.addPosi();
                __model__.modeldata.attribs.add.setPosiCoords(new_posi_i, [isect_tjs.x, isect_tjs.y, isect_tjs.z]);
                edge_to_isect_posis[edge_posis_i[0]][edge_posis_i[1]] = new_posi_i;
                if (method === _ECutMethod.KEEP_BOTH) {
                    const copy_posi_i = __model__.modeldata.geom.add.addPosi();
                    __model__.modeldata.attribs.add.setPosiCoords(copy_posi_i, [isect_tjs.x, isect_tjs.y, isect_tjs.z]);
                    cut_posi_to_copies[new_posi_i] = copy_posi_i;
                }
            }
            else {
                edge_to_isect_posis[edge_posis_i[0]][edge_posis_i[1]] = null;
            }
        }
    }
    return [edge_to_isect_posis, cut_posi_to_copies, posi_to_tjs];
}
// given an exist posis, returns a tjs point
// if necessary, a new tjs point will be created
// creates a map from exist posi to tjs
function _cutGetTjsPoint(__model__, posi_i, posi_to_tjs) {
    if (posi_to_tjs[posi_i] !== undefined) {
        return posi_to_tjs[posi_i];
    }
    const xyz = __model__.modeldata.attribs.query.getPosiCoords(posi_i);
    const posi_tjs = new three__WEBPACK_IMPORTED_MODULE_10__["Vector3"](...xyz);
    posi_to_tjs[posi_i] = posi_tjs;
    return posi_tjs;
}
// given an exist posis, returns a new posi
// if necessary, a new posi point be created
// creates a map from exist posi to new posi
function _cutGetPosi(__model__, posi_i, posi_to_copies) {
    if (posi_to_copies[posi_i] !== undefined) {
        return posi_to_copies[posi_i];
    }
    const new_posi_i = __model__.modeldata.geom.add.copyPosis(posi_i, true);
    posi_to_copies[posi_i] = new_posi_i;
    return new_posi_i;
}
// given a list of exist posis, returns a list of new posi
// if necessary, new posi will be creates
function _cutGetPosis(__model__, posis_i, posi_to_copies) {
    return posis_i.map(posi_i => _cutGetPosi(__model__, posi_i, posi_to_copies));
}
// makes a copy of an existing ent
// all posis in the exist ent will be replaced by new posis
function _cutCopyEnt(__model__, ent_type, ent_i, exist_posis_i, posi_to_copies) {
    const new_posis_i = _cutGetPosis(__model__, exist_posis_i, posi_to_copies);
    switch (ent_type) {
        case _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE:
            const new_pline_i = __model__.modeldata.geom.add.copyPlines(ent_i, true);
            __model__.modeldata.geom.modify.replacePosis(ent_type, new_pline_i, new_posis_i);
            return new_pline_i;
        case _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON:
            const new_pgon_i = __model__.modeldata.geom.add.copyPgons(ent_i, true);
            __model__.modeldata.geom.modify.replacePosis(ent_type, new_pgon_i, new_posis_i);
            return new_pgon_i;
        default:
            break;
    }
}
// creates new ents
// if the ent is not cut by the plane, the ent will be copies (with new posis)
// if the ent is cut, a new ent will be created
function _cutCreateEnts(__model__, ent_type, ent_i, plane_tjs, edge_to_isect_posis, posi_to_copies, cut_posi_to_copies, posi_to_tjs, method) {
    // get wire and posis
    const wire_i = __model__.modeldata.geom.nav.navAnyToWire(ent_type, ent_i)[0];
    const wire_posis_i = __model__.modeldata.geom.nav.navAnyToPosi(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].WIRE, wire_i);
    const wire_posis_ex_i = wire_posis_i.slice();
    const is_closed = __model__.modeldata.geom.query.isWireClosed(wire_i);
    if (is_closed) {
        wire_posis_ex_i.push(wire_posis_ex_i[0]);
    }
    const num_posis = wire_posis_ex_i.length;
    // create lists to store posis
    const slice_posis_i = [[], []];
    // analyze the first point
    const dist = plane_tjs.distanceToPoint(posi_to_tjs[wire_posis_ex_i[0]]);
    const start_above = dist > 0; // is the first point above the plane?
    const first = start_above ? 0 : 1; // the first list to start adding posis
    const second = 1 - first; // the second list to add posis, after you cross the plane
    let index = first;
    // for each pair of posis, get the posi_i intersection or null
    slice_posis_i[index].push([]);
    for (let i = 0; i < num_posis - 1; i++) {
        const edge_posis_i = [wire_posis_ex_i[i], wire_posis_ex_i[i + 1]];
        edge_posis_i.sort();
        const isect_posi_i = edge_to_isect_posis[edge_posis_i[0]][edge_posis_i[1]];
        slice_posis_i[index][slice_posis_i[index].length - 1].push(wire_posis_ex_i[i]);
        if (isect_posi_i !== null) {
            // add posi before cut
            if (method === _ECutMethod.KEEP_BOTH && index === 0) {
                const isect_posi2_i = cut_posi_to_copies[isect_posi_i];
                slice_posis_i[index][slice_posis_i[index].length - 1].push(isect_posi2_i);
                posi_to_copies[isect_posi2_i] = isect_posi2_i;
            }
            else {
                slice_posis_i[index][slice_posis_i[index].length - 1].push(isect_posi_i);
                posi_to_copies[isect_posi_i] = isect_posi_i;
            }
            // switch
            index = 1 - index;
            slice_posis_i[index].push([]);
            // add posi after cut
            if (method === _ECutMethod.KEEP_BOTH && index === 0) {
                const isect_posi2_i = cut_posi_to_copies[isect_posi_i];
                slice_posis_i[index][slice_posis_i[index].length - 1].push(isect_posi2_i);
                posi_to_copies[isect_posi2_i] = isect_posi2_i;
            }
            else {
                slice_posis_i[index][slice_posis_i[index].length - 1].push(isect_posi_i);
                posi_to_copies[isect_posi_i] = isect_posi_i;
            }
        }
    }
    // deal with cases where the entity was not cut
    // make a copy of the ent, with new posis
    if (slice_posis_i[second].length === 0) {
        if (start_above && (method === _ECutMethod.KEEP_BOTH || method === _ECutMethod.KEEP_ABOVE)) {
            return [[_cutCopyEnt(__model__, ent_type, ent_i, wire_posis_i, posi_to_copies)], []];
        }
        else if (!start_above && (method === _ECutMethod.KEEP_BOTH || method === _ECutMethod.KEEP_BELOW)) {
            return [[], [_cutCopyEnt(__model__, ent_type, ent_i, wire_posis_i, posi_to_copies)]];
        }
        return [[], []];
    }
    // update the lists, to deal with the end cases
    if (is_closed) {
        // add the last list of posis to the the first list of posis
        for (const slice_posi_i of slice_posis_i[index][slice_posis_i[index].length - 1]) {
            slice_posis_i[index][0].push(slice_posi_i);
        }
        slice_posis_i[index] = slice_posis_i[index].slice(0, -1);
    }
    else {
        // add the last posi to the last list
        slice_posis_i[index][slice_posis_i[index].length - 1].push(wire_posis_ex_i[num_posis - 1]);
    }
    // make the cut entities
    const above = [];
    const below = [];
    switch (method) {
        case _ECutMethod.KEEP_BOTH:
        case _ECutMethod.KEEP_ABOVE:
            for (const posis_i of slice_posis_i[0]) {
                if (ent_type === _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE) {
                    const copy_posis_i = _cutGetPosis(__model__, posis_i, posi_to_copies);
                    above.push(__model__.modeldata.geom.add.addPline(copy_posis_i, false));
                }
                else {
                    const copy_posis_i = _cutGetPosis(__model__, posis_i, posi_to_copies);
                    above.push(__model__.modeldata.geom.add.addPgon(copy_posis_i));
                }
            }
            break;
        default:
            break;
    }
    switch (method) {
        case _ECutMethod.KEEP_BOTH:
        case _ECutMethod.KEEP_BELOW:
            for (const posis_i of slice_posis_i[1]) {
                if (ent_type === _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE) {
                    const copy_posis_i = _cutGetPosis(__model__, posis_i, posi_to_copies);
                    below.push(__model__.modeldata.geom.add.addPline(copy_posis_i, false));
                }
                else {
                    const copy_posis_i = _cutGetPosis(__model__, posis_i, posi_to_copies);
                    below.push(__model__.modeldata.geom.add.addPgon(copy_posis_i));
                }
            }
            break;
        default:
            break;
    }
    return [above, below];
}
// ================================================================================================
// // ================================================================================================
// function _polygonHoles(__model__: GIModel, ents_arr: TEntTypeIdx[],
//     holes_ents_arr: TEntTypeIdx[]|TEntTypeIdx[][]): TEntTypeIdx {
// if (getArrDepth(holes_ents_arr) === 2) {
//     holes_ents_arr = [holes_ents_arr] as TEntTypeIdx[][];
// }
// const posis_i: number[] = ents_arr.map(ent_arr => ent_arr[1]);
// const holes_posis_i: number[][] = [];
// for (const hole_ents_arr of holes_ents_arr as TEntTypeIdx[][]) {
//     holes_posis_i.push( hole_ents_arr.map(ent_arr => ent_arr[1]) );
// }
// const pgon_i: number = __model__.modeldata.geom.add.addPgon(posis_i, holes_posis_i);
// return [EEntType.PGON, pgon_i];
// }
// /**
// * Adds a single new polygon to the model with one or more holes.
// * @param __model__
// * @param positions List of positions.
// * @param hole_positions List of positions for the holes. For multiple holes, a list of list can provided.
// * @returns Entities, a list of new polygons.
// * @example polygon1 = make.Polygon([position1,position2,position3], [position4,position5,position6])
// * @example_info Creates a polygon with  a hole, with vertices in sequence from position1 to position6.
// */
// function _PolygonHoles(__model__: GIModel, positions: TId[], hole_positions: TId[]|TId[][]): TId {
// // --- Error Check ---
// const pgon_ents_arr = checkIDs('make.Polygon', 'positions', positions, [IDcheckObj.isIDList], [EEntType.POSI]) as TEntTypeIdx[];
// const holes_ents_arr = checkIDs('make.Polygon', 'positions', hole_positions,
//     [IDcheckObj.isIDList, IDcheckObj.isIDList_list], [EEntType.POSI]) as TEntTypeIdx[]|TEntTypeIdx[][];
// // --- Error Check ---
// const new_ent_arr: TEntTypeIdx = _polygonHoles(__model__, pgon_ents_arr, holes_ents_arr);
// console.log(__model__);
// return idsMake(new_ent_arr) as TId;
// }
// // ================================================================================================
// /**
//  * Joins polylines to polylines or polygons to polygons.
//  * ~
//  * New polylins or polygons are created. The original polyline or polygons are not affected.
//  *
//  * @param __model__
//  * @param geometry Polylines or polygons.
//  * @returns Entities, a list of new joined polylines or polygons.
//  * @example joined1 = make.Join([polyline1,polyline2])
//  * @example_info Creates a new polyline by joining polyline1 and polyline2. Geometries must be of the same type.
//  */
// export function _Join(__model__: GIModel, geometry: TId[]): TId {
//     // --- Error Check ---
//     // const ents_arr =  checkIDs('make.Join', 'geometry', geometry, [IDcheckObj.isIDList], [EEntType.PLINE, EEntType.PGON]);
//     // --- Error Check ---
//     throw new Error('Not implemented.'); return null;
// }


/***/ }),

/***/ "./src/assets/core/modules/basic/material.ts":
/*!***************************************************!*\
  !*** ./src/assets/core/modules/basic/material.ts ***!
  \***************************************************/
/*! exports provided: _ESide, _Ecolors, Set, Glass, Basic, Lambert, Phong, Standard, Physical */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_ESide", function() { return _ESide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_Ecolors", function() { return _Ecolors; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Set", function() { return Set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Glass", function() { return Glass; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Basic", function() { return Basic; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Lambert", function() { return Lambert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Phong", function() { return Phong; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Standard", function() { return Standard; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Physical", function() { return Physical; });
/* harmony import */ var _check_ids__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_check_ids */ "./src/assets/core/modules/_check_ids.ts");
/* harmony import */ var _check_args__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_check_args */ "./src/assets/core/modules/_check_args.ts");
/* harmony import */ var _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @libs/geo-info/common */ "./src/assets/libs/geo-info/common.ts");
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/* harmony import */ var _libs_geo_info_id__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @libs/geo-info/id */ "./src/assets/libs/geo-info/id.ts");
/* harmony import */ var _assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @assets/libs/util/arrs */ "./src/assets/libs/util/arrs.ts");
/**
 * The `material` module has functions for defining materials.
 * The material definitions are saved as attributes at the model level.
 * More advanced materials can be created.
 * For more informtion, see the threejs docs: https://threejs.org/
 */
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};
/**
 *
 */







// ================================================================================================
var _ESide;
(function (_ESide) {
    _ESide["FRONT"] = "front";
    _ESide["BACK"] = "back";
    _ESide["BOTH"] = "both";
})(_ESide || (_ESide = {}));
function _convertSelectESideToNum(select) {
    switch (select) {
        case _ESide.FRONT:
            return three__WEBPACK_IMPORTED_MODULE_3__["FrontSide"];
        case _ESide.BACK:
            return three__WEBPACK_IMPORTED_MODULE_3__["BackSide"];
        default:
            return three__WEBPACK_IMPORTED_MODULE_3__["DoubleSide"];
    }
}
var _Ecolors;
(function (_Ecolors) {
    _Ecolors["NO_VERT_COLORS"] = "none";
    _Ecolors["VERT_COLORS"] = "apply_rgb";
})(_Ecolors || (_Ecolors = {}));
function _convertSelectEcolorsToNum(select) {
    switch (select) {
        case _Ecolors.NO_VERT_COLORS:
            return three__WEBPACK_IMPORTED_MODULE_3__["NoColors"];
        default:
            return three__WEBPACK_IMPORTED_MODULE_3__["VertexColors"];
    }
}
function _clamp01(val) {
    val = (val > 1) ? 1 : val;
    val = (val < 0) ? 0 : val;
    return val;
}
function _clamp0100(val) {
    val = (val > 100) ? 100 : val;
    val = (val < 0) ? 0 : val;
    return val;
}
function _clampArr01(vals) {
    for (let i = 0; i < vals.length; i++) {
        vals[i] = _clamp01(vals[i]);
    }
}
function _getTjsColor(col) {
    return new three__WEBPACK_IMPORTED_MODULE_3__["Color"](col[0], col[1], col[2]);
}
function _setMaterialModelAttrib(__model__, name, settings_obj) {
    // if the material already exists, then existing settings will be added
    // but new settings will take precedence
    if (__model__.modeldata.attribs.query.hasModelAttrib(name)) {
        const exist_settings_obj = __model__.modeldata.attribs.query.getModelAttribVal(name);
        // check that the existing material is a Basic one
        if (exist_settings_obj['type'] !== _EMaterialType.BASIC) {
            if (settings_obj['type'] !== exist_settings_obj['type']) {
                throw new Error('Error creating material: non-basic material with this name already exists.');
            }
        }
        // copy the settings from the existing material to the new material
        for (const key of Object.keys(exist_settings_obj)) {
            if (settings_obj[key] === undefined) {
                settings_obj[key] = exist_settings_obj[key];
            }
        }
    }
    else {
        __model__.modeldata.attribs.add.addAttrib(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].MOD, name, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EAttribDataTypeStrs"].DICT);
    }
    // const settings_str: string = JSON.stringify(settings_obj);
    __model__.modeldata.attribs.add.setModelAttribVal(name, settings_obj);
}
var _EMaterialType;
(function (_EMaterialType) {
    _EMaterialType["BASIC"] = "MeshBasicMaterial";
    _EMaterialType["LAMBERT"] = "MeshLambertMaterial";
    _EMaterialType["PHONG"] = "MeshPhongMaterial";
    _EMaterialType["STANDARD"] = "MeshStandardMaterial";
    _EMaterialType["PHYSICAL"] = "MeshPhysicalMaterial";
})(_EMaterialType || (_EMaterialType = {}));
// ================================================================================================
/**
 * Sets material by creating a polygon attribute called 'material' and setting the value.
 * The value is a sitring, which is the name of the material.
 * The properties of this material must be defined at the model level, using one of the material functions.
 * ~
 * @param entities The entities for which to set the material.
 * @param material The name of the material.
 * @returns void
 */
function Set(__model__, entities, material) {
    entities = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_5__["arrMakeFlat"])(entities);
    if (!Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_4__["isEmptyArr"])(entities)) {
        // --- Error Check ---
        const fn_name = 'matrial.Set';
        let ents_arr;
        if (__model__.debug) {
            ents_arr = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])(fn_name, 'entities', entities, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isId, _check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL, _check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdLL], null);
            Object(_check_args__WEBPACK_IMPORTED_MODULE_1__["checkArgs"])(fn_name, 'material', material, [_check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isStr]);
        }
        else {
            // ents_arr = splitIDs(fn_name, 'entities', entities,
            //     [IDcheckObj.isID, IDcheckObj.isIDList, IDcheckObj.isIDListOfLists], null) as TEntTypeIdx[];
            ents_arr = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_4__["idsBreak"])(entities);
        }
        // --- Error Check ---
        _material(__model__, ents_arr, material);
    }
}
function _material(__model__, ents_arr, material) {
    if (!__model__.modeldata.attribs.query.hasAttrib(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EAttribNames"].MATERIAL)) {
        __model__.modeldata.attribs.add.addAttrib(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EAttribNames"].MATERIAL, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EAttribDataTypeStrs"].STRING);
    }
    for (const ent_arr of ents_arr) {
        const [ent_type, ent_i] = ent_arr;
        const pgons_i = __model__.modeldata.geom.nav.navAnyToPgon(ent_type, ent_i);
        for (const pgon_i of pgons_i) {
            __model__.modeldata.attribs.add.setEntAttribVal(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON, pgon_i, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EAttribNames"].MATERIAL, material);
        }
    }
}
// ================================================================================================
/**
 * Creates a glass material with an opacity setting. The material will default to a Phong material.
 * ~
 * In order to assign a material to polygons in the model, a polygon attribute called 'material'
 * needs to be created. The value for each polygon must either be null, or must be a material name.
 * ~
 * @param name The name of the material.
 * @param opacity The opacity of the glass, between 0 (totally transparent) and 1 (totally opaque).
 * @returns void
 */
function Glass(__model__, name, opacity) {
    // --- Error Check ---
    const fn_name = 'material.Glass';
    if (__model__.debug) {
        Object(_check_args__WEBPACK_IMPORTED_MODULE_1__["checkArgs"])(fn_name, 'name', name, [_check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isStr]);
        Object(_check_args__WEBPACK_IMPORTED_MODULE_1__["checkArgs"])(fn_name, 'opacity', opacity, [_check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isNum01]);
    }
    // --- Error Check ---
    opacity = _clamp01(opacity);
    const transparent = opacity < 1;
    const settings_obj = {
        type: _EMaterialType.PHONG,
        opacity: opacity,
        transparent: transparent,
        shininess: 90,
        color: new three__WEBPACK_IMPORTED_MODULE_3__["Color"](1, 1, 1),
        emissive: new three__WEBPACK_IMPORTED_MODULE_3__["Color"](0, 0, 0),
        side: three__WEBPACK_IMPORTED_MODULE_3__["DoubleSide"]
    };
    _setMaterialModelAttrib(__model__, name, settings_obj);
}
// ================================================================================================
/**
 * Creates a Basic material and saves it in the model attributes.
 * ~
 * [See the threejs docs](https://threejs.org/docs/#api/en/materials/MeshBasicMaterial)
 * ~
 * The color pf the material can either ignore or apply the vertex rgb colors.
 * If 'apply' id selected, then the actual color will be a combination of the material color
 * and the vertex colors, as specified by the a vertex attribute called 'rgb'.
 * In such a case, if material color is set to white, then it will
 * have no effect, and the color will be defined by the vertex [r,g,b] values.
 * ~
 * Additional material properties can be set by calling the functions for the more advanced materials.
 * These include LambertMaterial, PhongMaterial, StandardMaterial, and Physical Material.
 * Each of these more advanced materials allows you to specify certain additional settings.
 * ~
 * In order to assign a material to polygons in the model, a polygon attribute called 'material'.
 * needs to be created. The value for each polygon must either be null, or must be a material name.
 * ~
 * @param name The name of the material.
 * @param color The diffuse color, as [r, g, b] values between 0 and 1. White is [1, 1, 1].
 * @param opacity The opacity of the glass, between 0 (totally transparent) and 1 (totally opaque).
 * @param select_side Enum, select front, back, or both.
 * @param select_vert_colors Enum, select whether to use vertex colors if they exist.
 * @returns void
 */
function Basic(__model__, name, color, opacity, select_side, select_vert_colors) {
    // --- Error Check ---
    if (__model__.debug) {
        const fn_name = 'material.Basic';
        Object(_check_args__WEBPACK_IMPORTED_MODULE_1__["checkArgs"])(fn_name, 'name', name, [_check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isStr]);
        Object(_check_args__WEBPACK_IMPORTED_MODULE_1__["checkArgs"])(fn_name, 'color', color, [_check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isColor]);
        Object(_check_args__WEBPACK_IMPORTED_MODULE_1__["checkArgs"])(fn_name, 'opacity', opacity, [_check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isNum01]);
    }
    // --- Error Check ---
    const side = _convertSelectESideToNum(select_side);
    const vert_colors = _convertSelectEcolorsToNum(select_vert_colors);
    opacity = _clamp01(opacity);
    const transparent = opacity < 1;
    _clampArr01(color);
    const settings_obj = {
        type: _EMaterialType.BASIC,
        side: side,
        vertexColors: vert_colors,
        opacity: opacity,
        transparent: transparent,
        color: _getTjsColor(color)
    };
    _setMaterialModelAttrib(__model__, name, settings_obj);
}
// ================================================================================================
/**
 * Creates a Lambert material and saves it in the model attributes.
 * If a Basic material with the same name already exits, these settings will be added to the basic material.
 * ~
 * [See the threejs docs](https://threejs.org/docs/#api/en/materials/MeshLambertMaterial)
 * ~
 * In order to assign a material to polygons in the model, a polygon attribute called 'material'
 * needs to be created. The value for each polygon must either be null, or must be a material name.
 * ~
 * @param name The name of the material.
 * @param emissive The emissive color, as [r, g, b] values between 0 and 1. White is [1, 1, 1].
 * @returns void
 */
function Lambert(__model__, name, emissive) {
    // --- Error Check ---
    if (__model__.debug) {
        const fn_name = 'material.Lambert';
        Object(_check_args__WEBPACK_IMPORTED_MODULE_1__["checkArgs"])(fn_name, 'name', name, [_check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isStr]);
        Object(_check_args__WEBPACK_IMPORTED_MODULE_1__["checkArgs"])(fn_name, 'emissive', emissive, [_check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isXYZ]);
    }
    // --- Error Check ---
    _clampArr01(emissive);
    const settings_obj = {
        type: _EMaterialType.LAMBERT,
        emissive: _getTjsColor(emissive)
    };
    _setMaterialModelAttrib(__model__, name, settings_obj);
}
// ================================================================================================
/**
 * Creates a Phong material and saves it in the model attributes.
 * If a Basic material with the same name already exits, these settings will be added to the basic material.
 * ~
 * [See the threejs docs](https://threejs.org/docs/#api/en/materials/MeshPhongMaterial)
 * ~
 * In order to assign a material to polygons in the model, a polygon attribute called 'material'
 * needs to be created. The value for each polygon must either be null, or must be a material name.
 * ~
 * @param name The name of the material.
 * @param emissive The emissive color, as [r, g, b] values between 0 and 1. White is [1, 1, 1].
 * @param specular The specular color, as [r, g, b] values between 0 and 1. White is [1, 1, 1].
 * @param shininess The shininess, between 0 and 100.
 * @returns void
 */
function Phong(__model__, name, emissive, specular, shininess) {
    // --- Error Check ---
    if (__model__.debug) {
        const fn_name = 'material.Phong';
        Object(_check_args__WEBPACK_IMPORTED_MODULE_1__["checkArgs"])(fn_name, 'name', name, [_check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isStr]);
        Object(_check_args__WEBPACK_IMPORTED_MODULE_1__["checkArgs"])(fn_name, 'emissive', emissive, [_check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isXYZ]);
        Object(_check_args__WEBPACK_IMPORTED_MODULE_1__["checkArgs"])(fn_name, 'emissive', specular, [_check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isXYZ]);
        Object(_check_args__WEBPACK_IMPORTED_MODULE_1__["checkArgs"])(fn_name, 'shininess', shininess, [_check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isNum]);
    }
    // --- Error Check ---
    _clampArr01(emissive);
    _clampArr01(specular);
    shininess = Math.floor(_clamp0100(shininess));
    const settings_obj = {
        type: _EMaterialType.PHONG,
        emissive: _getTjsColor(emissive),
        specular: _getTjsColor(specular),
        shininess: shininess
    };
    _setMaterialModelAttrib(__model__, name, settings_obj);
}
// ================================================================================================
/**
 * Creates a Standard material and saves it in the model attributes.
 * If a Basic material with the same name already exits, these settings will be added to the basic material.
 * ~
 * [See the threejs docs](https://threejs.org/docs/#api/en/materials/MeshStandardMaterial)
 * ~
 * In order to assign a material to polygons in the model, a polygon attribute called 'material'
 * needs to be created. The value for each polygon must either be null, or must be a material name.
 * ~
 * @param name The name of the material.
 * @param emissive The emissive color, as [r, g, b] values between 0 and 1. White is [1, 1, 1].
 * @param roughness The roughness, between 0 (smooth) and 1 (rough).
 * @param metalness The metalness, between 0 (non-metalic) and 1 (metalic).
 * @param reflectivity The reflectivity, between 0 (non-reflective) and 1 (reflective).
 * @returns void
 */
function Standard(__model__, name, emissive, roughness, metalness) {
    // --- Error Check ---
    if (__model__.debug) {
        const fn_name = 'material.Standard';
        Object(_check_args__WEBPACK_IMPORTED_MODULE_1__["checkArgs"])(fn_name, 'name', name, [_check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isStr]);
        Object(_check_args__WEBPACK_IMPORTED_MODULE_1__["checkArgs"])(fn_name, 'emissive', emissive, [_check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isXYZ]);
        Object(_check_args__WEBPACK_IMPORTED_MODULE_1__["checkArgs"])(fn_name, 'roughness', roughness, [_check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isNum]);
        Object(_check_args__WEBPACK_IMPORTED_MODULE_1__["checkArgs"])(fn_name, 'metalness', metalness, [_check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isNum]);
    }
    // --- Error Check ---
    _clampArr01(emissive);
    roughness = _clamp01(roughness);
    metalness = _clamp01(metalness);
    const settings_obj = {
        type: _EMaterialType.STANDARD,
        emissive: _getTjsColor(emissive),
        roughness: roughness,
        metalness: metalness
    };
    _setMaterialModelAttrib(__model__, name, settings_obj);
}
// ================================================================================================
/**
 * Creates a Physical material and saves it in the model attributes.
 * If a Basic material with the same name already exits, these settings will be added to the basic material.
 * ~
 * [See the threejs docs](https://threejs.org/docs/#api/en/materials/MeshPhysicalMaterial)
 * ~
 * In order to assign a material to polygons in the model, a polygon attribute called 'material'
 * needs to be created. The value for each polygon must either be null, or must be a material name.
 * ~
 * @param name The name of the material.
 * @param emissive The emissive color, as [r, g, b] values between 0 and 1. White is [1, 1, 1].
 * @param roughness The roughness, between 0 (smooth) and 1 (rough).
 * @param metalness The metalness, between 0 (non-metalic) and 1 (metalic).
 * @param reflectivity The reflectivity, between 0 (non-reflective) and 1 (reflective).
 * @returns void
 */
function Physical(__model__, name, emissive, roughness, metalness, reflectivity) {
    // --- Error Check ---
    if (__model__.debug) {
        const fn_name = 'material.Physical';
        Object(_check_args__WEBPACK_IMPORTED_MODULE_1__["checkArgs"])(fn_name, 'name', name, [_check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isStr]);
        Object(_check_args__WEBPACK_IMPORTED_MODULE_1__["checkArgs"])(fn_name, 'emissive', emissive, [_check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isXYZ]);
        Object(_check_args__WEBPACK_IMPORTED_MODULE_1__["checkArgs"])(fn_name, 'roughness', roughness, [_check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isNum]);
        Object(_check_args__WEBPACK_IMPORTED_MODULE_1__["checkArgs"])(fn_name, 'metalness', metalness, [_check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isNum]);
        Object(_check_args__WEBPACK_IMPORTED_MODULE_1__["checkArgs"])(fn_name, 'reflectivity', reflectivity, [_check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isNum]);
    }
    // --- Error Check ---
    _clampArr01(emissive);
    roughness = _clamp01(roughness);
    metalness = _clamp01(metalness);
    reflectivity = _clamp01(reflectivity);
    const settings_obj = {
        type: _EMaterialType.PHYSICAL,
        emissive: _getTjsColor(emissive),
        roughness: roughness,
        metalness: metalness,
        reflectivity: reflectivity
    };
    _setMaterialModelAttrib(__model__, name, settings_obj);
}
// ================================================================================================


/***/ }),

/***/ "./src/assets/core/modules/basic/modify.ts":
/*!*************************************************!*\
  !*** ./src/assets/core/modules/basic/modify.ts ***!
  \*************************************************/
/*! exports provided: Move, Rotate, Scale, Mirror, XForm, Offset, Reverse, Shift, Ring, _ERingMethod, _EWeldMethod, Weld, Fuse, Remesh, _EDeleteMethod, Delete */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Move", function() { return Move; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Rotate", function() { return Rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Scale", function() { return Scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Mirror", function() { return Mirror; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "XForm", function() { return XForm; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Offset", function() { return Offset; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Reverse", function() { return Reverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Shift", function() { return Shift; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Ring", function() { return Ring; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_ERingMethod", function() { return _ERingMethod; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_EWeldMethod", function() { return _EWeldMethod; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Weld", function() { return Weld; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Fuse", function() { return Fuse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Remesh", function() { return Remesh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_EDeleteMethod", function() { return _EDeleteMethod; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Delete", function() { return Delete; });
/* harmony import */ var _check_ids__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_check_ids */ "./src/assets/core/modules/_check_ids.ts");
/* harmony import */ var _check_args__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_check_args */ "./src/assets/core/modules/_check_args.ts");
/* harmony import */ var _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @libs/geo-info/common */ "./src/assets/libs/geo-info/common.ts");
/* harmony import */ var _libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @libs/geo-info/id */ "./src/assets/libs/geo-info/id.ts");
/* harmony import */ var _libs_geom_vectors__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @libs/geom/vectors */ "./src/assets/libs/geom/vectors.ts");
/* harmony import */ var _libs_geom_matrix__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @libs/geom/matrix */ "./src/assets/libs/geom/matrix.ts");
/* harmony import */ var _assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @assets/libs/util/arrs */ "./src/assets/libs/util/arrs.ts");
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./_common */ "./src/assets/core/modules/basic/_common.ts");
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/* harmony import */ var _libs_TypedArrayUtils_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @libs/TypedArrayUtils.js */ "./src/assets/libs/TypedArrayUtils.js");
/**
 * The `modify` module has functions for modifying existing entities in the model.
 * These functions do not make any new entities, but they may change attribute values.
 * All these functions all return void.
 */
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};
/**
 *
 */










// ================================================================================================
/**
 * Moves entities. The directio and distance if movement is specified as a vector.
 * ~
 * If only one vector is given, then all entities are moved by the same vector.
 * If a list of vectors is given, the each entity will be moved by a different vector.
 * In this case, the number of vectors should be equal to the number of entities.
 * ~
 * If a position is shared between entites that are being moved by different vectors,
 * then the position will be moved by the average of the vectors.
 * ~
 * @param __model__
 * @param entities An entity or list of entities to move.
 * @param vector A vector or a list of vectors.
 * @returns void
 * @example modify.Move(pline1, [1,2,3])
 * @example_info Moves pline1 by [1,2,3].
 * @example modify.Move([pos1, pos2, pos3], [[0,0,1], [0,0,1], [0,1,0]] )
 * @example_info Moves pos1 by [0,0,1], pos2 by [0,0,1], and pos3 by [0,1,0].
 * @example modify.Move([pgon1, pgon2], [1,2,3] )
 * @example_info Moves both pgon1 and pgon2 by [1,2,3].
 */
function Move(__model__, entities, vectors) {
    entities = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_6__["arrMakeFlat"])(entities);
    if (!Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["isEmptyArr"])(entities)) {
        // --- Error Check ---
        const fn_name = 'modify.Move';
        let ents_arr;
        if (__model__.debug) {
            ents_arr = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])(fn_name, 'entities', entities, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isId, _check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL], null);
            Object(_check_args__WEBPACK_IMPORTED_MODULE_1__["checkArgs"])(fn_name, 'vectors', vectors, [_check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isXYZ, _check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isXYZL]);
        }
        else {
            // ents_arr = splitIDs(fn_name, 'entities', entities, [IDcheckObj.isID, IDcheckObj.isIDList],
            // [EEntType.POSI, EEntType.VERT, EEntType.EDGE, EEntType.WIRE,
            // EEntType.FACE, EEntType.POINT, EEntType.PLINE, EEntType.PGON, EEntType.COLL]) as TEntTypeIdx[];
            ents_arr = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsBreak"])(entities);
        }
        // --- Error Check ---
        _move(__model__, ents_arr, vectors);
    }
}
function _move(__model__, ents_arr, vectors) {
    if (Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["getArrDepth"])(vectors) === 1) {
        const posis_i = [];
        const vec = vectors;
        for (const ents of ents_arr) {
            __model__.modeldata.geom.nav.navAnyToPosi(ents[0], ents[1]).forEach(posi_i => posis_i.push(posi_i));
        }
        const unique_posis_i = Array.from(new Set(posis_i));
        for (const unique_posi_i of unique_posis_i) {
            const old_xyz = __model__.modeldata.attribs.query.getPosiCoords(unique_posi_i);
            const new_xyz = Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_4__["vecAdd"])(old_xyz, vec);
            __model__.modeldata.attribs.add.setPosiCoords(unique_posi_i, new_xyz);
        }
    }
    else {
        if (ents_arr.length !== vectors.length) {
            throw new Error('If multiple vectors are given, then the number of vectors must be equal to the number of entities.');
        }
        const posis_i = [];
        const vecs_map = new Map();
        for (let i = 0; i < ents_arr.length; i++) {
            const [ent_type, index] = ents_arr[i];
            const vec = vectors[i];
            const ent_posis_i = __model__.modeldata.geom.nav.navAnyToPosi(ent_type, index);
            for (const ent_posi_i of ent_posis_i) {
                posis_i.push(ent_posi_i);
                if (!vecs_map.has(ent_posi_i)) {
                    vecs_map.set(ent_posi_i, []);
                }
                vecs_map.get(ent_posi_i).push(vec);
            }
        }
        for (const posi_i of posis_i) {
            const old_xyz = __model__.modeldata.attribs.query.getPosiCoords(posi_i);
            const vecs = vecs_map.get(posi_i);
            const vec = Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_4__["vecDiv"])(Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_4__["vecSum"])(vecs), vecs.length);
            const new_xyz = Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_4__["vecAdd"])(old_xyz, vec);
            __model__.modeldata.attribs.add.setPosiCoords(posi_i, new_xyz);
        }
    }
    return; // specifies that nothing is returned
}
// ================================================================================================
/**
 * Rotates entities on plane by angle.
 * ~
 * @param __model__
 * @param entities  An entity or list of entities to rotate.
 * @param ray A ray to rotate around. \
 * Given a plane, a ray will be created from the plane z axis. \
 * Given an `xyz` location, a ray will be generated with an origin at this location, and a direction `[0, 0, 1]`. \
 * Given any entities, the centroid will be extracted, \
 * and a ray will be generated with an origin at this centroid, and a direction `[0, 0, 1]`.
 * @param angle Angle (in radians).
 * @returns void
 * @example modify.Rotate(polyline1, plane1, PI)
 * @example_info Rotates polyline1 around the z-axis of plane1 by PI (i.e. 180 degrees).
 */
function Rotate(__model__, entities, ray, angle) {
    entities = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_6__["arrMakeFlat"])(entities);
    if (!Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["isEmptyArr"])(entities)) {
        // --- Error Check ---
        const fn_name = 'modify.Rotate';
        let ents_arr;
        if (__model__.debug) {
            ents_arr = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])(fn_name, 'entities', entities, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isId, _check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL], [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].POSI, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].VERT, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].EDGE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].WIRE,
                _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].FACE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].POINT, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].COLL]);
            Object(_check_args__WEBPACK_IMPORTED_MODULE_1__["checkArgs"])(fn_name, 'angle', angle, [_check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isNum]);
        }
        else {
            // ents_arr = splitIDs(fn_name, 'entities', entities, [IDcheckObj.isID, IDcheckObj.isIDList],
            //     [EEntType.POSI, EEntType.VERT, EEntType.EDGE, EEntType.WIRE,
            //     EEntType.FACE, EEntType.POINT, EEntType.PLINE, EEntType.PGON, EEntType.COLL]) as TEntTypeIdx[];
            ents_arr = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsBreak"])(entities);
        }
        ray = Object(_common__WEBPACK_IMPORTED_MODULE_7__["getRay"])(__model__, ray, fn_name);
        // --- Error Check ---
        _rotate(__model__, ents_arr, ray, angle);
    }
}
function _rotate(__model__, ents_arr, ray, angle) {
    // rotate all positions
    const posis_i = [];
    for (const ents of ents_arr) {
        posis_i.push(...__model__.modeldata.geom.nav.navAnyToPosi(ents[0], ents[1]));
    }
    const unique_posis_i = Array.from(new Set(posis_i));
    const matrix = Object(_libs_geom_matrix__WEBPACK_IMPORTED_MODULE_5__["rotateMatrix"])(ray, angle);
    for (const unique_posi_i of unique_posis_i) {
        const old_xyz = __model__.modeldata.attribs.query.getPosiCoords(unique_posi_i);
        const new_xyz = Object(_libs_geom_matrix__WEBPACK_IMPORTED_MODULE_5__["multMatrix"])(old_xyz, matrix);
        __model__.modeldata.attribs.add.setPosiCoords(unique_posi_i, new_xyz);
    }
    return; // specifies that nothing is returned
}
// ================================================================================================
/**
 * Scales entities relative to a plane.
 * ~
 * @param __model__
 * @param entities  An entity or list of entities to scale.
 * @param plane A plane to scale around. \
 * Given a ray, a plane will be generated that is perpendicular to the ray. \
 * Given an `xyz` location, a plane will be generated with an origin at that location and with axes parallel to the global axes. \
 * Given any entities, the centroid will be extracted, \
 * and a plane will be generated with an origin at the centroid, and with axes parallel to the global axes.
 * @param scale Scale factor, a single number to scale equally, or [scale_x, scale_y, scale_z] relative to the plane.
 * @returns void
 * @example modify.Scale(entities, plane1, 0.5)
 * @example_info Scales entities by 0.5 on plane1.
 * @example modify.Scale(entities, plane1, [0.5, 1, 1])
 * @example_info Scales entities by 0.5 along the x axis of plane1, with no scaling along the y and z axes.
 */
function Scale(__model__, entities, plane, scale) {
    entities = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_6__["arrMakeFlat"])(entities);
    if (!Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["isEmptyArr"])(entities)) {
        // --- Error Check ---
        const fn_name = 'modify.Scale';
        let ents_arr;
        if (__model__.debug) {
            ents_arr = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])(fn_name, 'entities', entities, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isId, _check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL], [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].POSI, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].VERT, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].EDGE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].WIRE,
                _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].FACE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].POINT, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].COLL]);
            Object(_check_args__WEBPACK_IMPORTED_MODULE_1__["checkArgs"])(fn_name, 'scale', scale, [_check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isNum, _check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isXYZ]);
        }
        else {
            // ents_arr = splitIDs(fn_name, 'entities', entities, [IDcheckObj.isID, IDcheckObj.isIDList],
            //     [EEntType.POSI, EEntType.VERT, EEntType.EDGE, EEntType.WIRE,
            //     EEntType.FACE, EEntType.POINT, EEntType.PLINE, EEntType.PGON, EEntType.COLL]) as TEntTypeIdx[];
            ents_arr = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsBreak"])(entities);
        }
        plane = Object(_common__WEBPACK_IMPORTED_MODULE_7__["getPlane"])(__model__, plane, fn_name);
        // --- Error Check ---
        _scale(__model__, ents_arr, plane, scale);
    }
}
function _scale(__model__, ents_arr, plane, scale) {
    // handle scale type
    if (!Array.isArray(scale)) {
        scale = [scale, scale, scale];
    }
    // scale all positions
    const posis_i = [];
    for (const ents of ents_arr) {
        posis_i.push(...__model__.modeldata.geom.nav.navAnyToPosi(ents[0], ents[1]));
    }
    const unique_posis_i = Array.from(new Set(posis_i));
    const matrix = Object(_libs_geom_matrix__WEBPACK_IMPORTED_MODULE_5__["scaleMatrix"])(plane, scale);
    for (const unique_posi_i of unique_posis_i) {
        const old_xyz = __model__.modeldata.attribs.query.getPosiCoords(unique_posi_i);
        const new_xyz = Object(_libs_geom_matrix__WEBPACK_IMPORTED_MODULE_5__["multMatrix"])(old_xyz, matrix);
        __model__.modeldata.attribs.add.setPosiCoords(unique_posi_i, new_xyz);
    }
    return; // specifies that nothing is returned
}
// ================================================================================================
/**
 * Mirrors entities across a plane.
 * ~
 * @param __model__
 * @param entities An entity or list of entities to mirros.
 * @param plane A plane to scale around. \
 * Given a ray, a plane will be generated that is perpendicular to the ray. \
 * Given an `xyz` location, a plane will be generated with an origin at that location and with axes parallel to the global axes. \
 * Given any entities, the centroid will be extracted, \
 * and a plane will be generated with an origin at the centroid, and with axes parallel to the global axes.
 * @returns void
 * @example modify.Mirror(polygon1, plane1)
 * @example_info Mirrors polygon1 across plane1.
 */
function Mirror(__model__, entities, plane) {
    entities = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_6__["arrMakeFlat"])(entities);
    if (!Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["isEmptyArr"])(entities)) {
        // --- Error Check ---
        const fn_name = 'modify.Mirror';
        let ents_arr;
        if (__model__.debug) {
            ents_arr = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])(fn_name, 'entities', entities, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isId, _check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL], [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].POSI, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].VERT, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].EDGE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].WIRE,
                _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].FACE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].POINT, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].COLL]);
        }
        else {
            // ents_arr = splitIDs(fn_name, 'entities', entities, [IDcheckObj.isID, IDcheckObj.isIDList],
            //     [EEntType.POSI, EEntType.VERT, EEntType.EDGE, EEntType.WIRE,
            //     EEntType.FACE, EEntType.POINT, EEntType.PLINE, EEntType.PGON, EEntType.COLL]) as TEntTypeIdx[];
            ents_arr = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsBreak"])(entities);
        }
        plane = Object(_common__WEBPACK_IMPORTED_MODULE_7__["getPlane"])(__model__, plane, fn_name);
        // --- Error Check ---
        _mirror(__model__, ents_arr, plane);
    }
}
function _mirror(__model__, ents_arr, plane) {
    // mirror all positions
    const posis_i = [];
    for (const ents of ents_arr) {
        const [ent_type, index] = ents;
        posis_i.push(...__model__.modeldata.geom.nav.navAnyToPosi(ent_type, index));
    }
    const unique_posis_i = Array.from(new Set(posis_i));
    const matrix = Object(_libs_geom_matrix__WEBPACK_IMPORTED_MODULE_5__["mirrorMatrix"])(plane);
    for (const unique_posi_i of unique_posis_i) {
        const old_xyz = __model__.modeldata.attribs.query.getPosiCoords(unique_posi_i);
        const new_xyz = Object(_libs_geom_matrix__WEBPACK_IMPORTED_MODULE_5__["multMatrix"])(old_xyz, matrix);
        __model__.modeldata.attribs.add.setPosiCoords(unique_posi_i, new_xyz);
    }
}
// ================================================================================================
/**
 * Transforms entities from a source plane to a target plane.
 * ~
 * @param __model__
 * @param entities Vertex, edge, wire, face, position, point, polyline, polygon, collection.
 * @param from_plane Plane defining source plane for the transformation. \
 * Given a ray, a plane will be generated that is perpendicular to the ray. \
 * Given an `xyz` location, a plane will be generated with an origin at that location and with axes parallel to the global axes. \
 * Given any entities, the centroid will be extracted, \
 * and a plane will be generated with an origin at the centroid, and with axes parallel to the global axes.
 * @param to_plane Plane defining target plane for the transformation. \
 * Given a ray, a plane will be generated that is perpendicular to the ray. \
 * Given an `xyz` location, a plane will be generated with an origin at that location and with axes parallel to the global axes. \
 * Given any entities, the centroid will be extracted, \
 * and a plane will be generated with an origin at the centroid, and with axes parallel to the global axes.
 * @returns void
 * @example modify.XForm(polygon1, plane1, plane2)
 * @example_info Transforms polygon1 from plane1 to plane2.
 */
function XForm(__model__, entities, from_plane, to_plane) {
    entities = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_6__["arrMakeFlat"])(entities);
    if (!Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["isEmptyArr"])(entities)) {
        // --- Error Check ---
        const fn_name = 'modify.XForm';
        let ents_arr;
        if (__model__.debug) {
            ents_arr = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])(fn_name, 'entities', entities, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isId, _check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL], [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].POSI, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].VERT, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].EDGE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].WIRE,
                _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].FACE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].POINT, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].COLL]);
        }
        else {
            // ents_arr = splitIDs(fn_name, 'entities', entities, [IDcheckObj.isID, IDcheckObj.isIDList],
            //     [EEntType.POSI, EEntType.VERT, EEntType.EDGE, EEntType.WIRE,
            //     EEntType.FACE, EEntType.POINT, EEntType.PLINE, EEntType.PGON, EEntType.COLL]) as TEntTypeIdx[];
            ents_arr = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsBreak"])(entities);
        }
        from_plane = Object(_common__WEBPACK_IMPORTED_MODULE_7__["getPlane"])(__model__, from_plane, fn_name);
        to_plane = Object(_common__WEBPACK_IMPORTED_MODULE_7__["getPlane"])(__model__, to_plane, fn_name);
        // --- Error Check ---
        _xform(__model__, ents_arr, from_plane, to_plane);
    }
}
function _xform(__model__, ents_arr, from, to) {
    // xform all positions
    const posis_i = [];
    for (const ents of ents_arr) {
        const [ent_type, index] = ents;
        posis_i.push(...__model__.modeldata.geom.nav.navAnyToPosi(ent_type, index));
    }
    const unique_posis_i = Array.from(new Set(posis_i));
    const matrix = Object(_libs_geom_matrix__WEBPACK_IMPORTED_MODULE_5__["xfromSourceTargetMatrix"])(from, to);
    for (const unique_posi_i of unique_posis_i) {
        const old_xyz = __model__.modeldata.attribs.query.getPosiCoords(unique_posi_i);
        const new_xyz = Object(_libs_geom_matrix__WEBPACK_IMPORTED_MODULE_5__["multMatrix"])(old_xyz, matrix);
        __model__.modeldata.attribs.add.setPosiCoords(unique_posi_i, new_xyz);
    }
}
// ================================================================================================
/**
 * Offsets wires.
 * ~
 * @param __model__
 * @param entities Edges, wires, faces, polylines, polygons, collections.
 * @param dist The distance to offset by, can be either positive or negative
 * @returns void
 * @example modify.Offset(polygon1, 10)
 * @example_info Offsets the wires inside polygon1 by 10 units. Holes will also be offset.
 */
function Offset(__model__, entities, dist) {
    entities = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_6__["arrMakeFlat"])(entities);
    if (!Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["isEmptyArr"])(entities)) {
        // --- Error Check ---
        const fn_name = 'modify.Offset';
        let ents_arr;
        if (__model__.debug) {
            ents_arr = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])(fn_name, 'entities', entities, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isId, _check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL], [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].WIRE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].FACE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].COLL]);
            Object(_check_args__WEBPACK_IMPORTED_MODULE_1__["checkArgs"])(fn_name, 'dist', dist, [_check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isNum]);
        }
        else {
            // ents_arr = splitIDs(fn_name, 'entities', entities, [IDcheckObj.isID, IDcheckObj.isIDList],
            //     [EEntType.WIRE, EEntType.FACE, EEntType.PLINE, EEntType.PGON, EEntType.COLL]) as TEntTypeIdx[];
            ents_arr = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsBreak"])(entities);
        }
        // --- Error Check ---
        _offset(__model__, ents_arr, dist);
    }
}
function _offset(__model__, ents_arr, dist) {
    // get all wires and offset
    const pgons_i = [];
    for (const ents of ents_arr) {
        const [ent_type, index] = ents;
        const wires_i = __model__.modeldata.geom.nav.navAnyToWire(ent_type, index);
        for (const wire_i of wires_i) {
            _offsetWire(__model__, wire_i, dist);
        }
        // save all pgons for re-tri
        const pgon_i = __model__.modeldata.geom.nav.navAnyToPgon(ent_type, index);
        if (pgon_i.length === 1) {
            if (pgons_i.indexOf(pgon_i[0]) === -1) {
                pgons_i.push(pgon_i[0]);
            }
        }
    }
    // re-tri all polygons
    if (pgons_i.length > 0) {
        __model__.modeldata.geom.modify_pgon.triPgons(pgons_i);
    }
}
function _offsetWire(__model__, wire_i, dist) {
    // get the normal of the wire
    const vec_norm = __model__.modeldata.geom.query.getWireNormal(wire_i);
    // if (vecLen(vec_norm) === 0) {
    //     vec_norm = [0, 0, 1];
    // }
    // loop through all edges and collect the required data
    const edges_i = __model__.modeldata.geom.nav.navAnyToEdge(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].WIRE, wire_i).slice(); // make a copy
    const is_closed = __model__.modeldata.geom.query.isWireClosed(wire_i);
    // the index to these arrays is the edge_i
    let perp_vec = null;
    let has_bad_edges = false;
    const perp_vecs = []; // index is edge_i
    const pairs_xyzs = []; // index is edge_i
    const pairs_posis_i = []; // index is edge_i
    for (const edge_i of edges_i) {
        const posis_i = __model__.modeldata.geom.nav.navAnyToPosi(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].EDGE, edge_i);
        const xyzs = posis_i.map(posi_i => __model__.modeldata.attribs.query.getPosiCoords(posi_i));
        const edge_vec = Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_4__["vecFromTo"])(xyzs[0], xyzs[1]);
        const edge_len = Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_4__["vecLen"])(edge_vec);
        pairs_xyzs[edge_i] = xyzs;
        pairs_posis_i[edge_i] = posis_i;
        if (edge_len > 0) {
            perp_vec = Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_4__["vecCross"])(Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_4__["vecNorm"])(edge_vec), vec_norm);
        }
        else {
            if (perp_vec === null) {
                has_bad_edges = true;
            }
        }
        perp_vecs[edge_i] = perp_vec;
    }
    // fix any bad edges, by setting the perp vec to its next neighbour
    if (has_bad_edges) {
        if (perp_vecs[perp_vecs.length - 1] === null) {
            throw new Error('Error: could not offset wire.');
        }
        for (let i = perp_vecs.length - 1; i >= 0; i--) {
            if (perp_vecs[i] === null) {
                perp_vecs[i] = perp_vec;
            }
            else {
                perp_vec = perp_vecs[i];
            }
        }
    }
    // add edge if this is a closed wire
    // make sure the edges_i is a copy, otherwise we are pushing into the model data structure
    if (is_closed) {
        edges_i.push(edges_i[0]); // add to the end
    }
    // loop through all the valid edges
    for (let i = 0; i < edges_i.length - 1; i++) {
        // get the two edges
        const this_edge_i = edges_i[i];
        const next_edge_i = edges_i[i + 1];
        // get the end posi_i and xyz of this edge
        const posi_i = pairs_posis_i[this_edge_i][1];
        const old_xyz = pairs_xyzs[this_edge_i][1];
        // get the two perpendicular vectors
        const this_perp_vec = perp_vecs[this_edge_i];
        const next_perp_vec = perp_vecs[next_edge_i];
        // calculate the offset vector
        let offset_vec = Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_4__["vecNorm"])(Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_4__["vecAdd"])(this_perp_vec, next_perp_vec));
        const dot = Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_4__["vecDot"])(this_perp_vec, offset_vec);
        const vec_len = dist / dot;
        offset_vec = Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_4__["vecSetLen"])(offset_vec, vec_len);
        // move the posi
        const new_xyz = Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_4__["vecAdd"])(old_xyz, offset_vec);
        __model__.modeldata.attribs.add.setPosiCoords(posi_i, new_xyz);
    }
    // if this is not a closed wire we have to move first and last posis
    if (!is_closed) {
        // first posi
        const first_edge_i = edges_i[0];
        const first_posi_i = pairs_posis_i[first_edge_i][0];
        const first_old_xyz = pairs_xyzs[first_edge_i][0];
        const first_perp_vec = Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_4__["vecSetLen"])(perp_vecs[first_edge_i], dist);
        const first_new_xyz = Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_4__["vecAdd"])(first_old_xyz, first_perp_vec);
        __model__.modeldata.attribs.add.setPosiCoords(first_posi_i, first_new_xyz);
        // last posi
        const last_edge_i = edges_i[edges_i.length - 1];
        const last_posi_i = pairs_posis_i[last_edge_i][1];
        const last_old_xyz = pairs_xyzs[last_edge_i][1];
        const last_perp_vec = Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_4__["vecSetLen"])(perp_vecs[last_edge_i], dist);
        const last_new_xyz = Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_4__["vecAdd"])(last_old_xyz, last_perp_vec);
        __model__.modeldata.attribs.add.setPosiCoords(last_posi_i, last_new_xyz);
    }
}
// ================================================================================================
/**
 * Reverses direction of entities.
 * @param __model__
 * @param entities Wire, face, polyline, polygon.
 * @returns void
 * @example modify.Reverse(face1)
 * @example_info Flips face1 and reverses its normal.
 * @example modify.Reverse(polyline1)
 * @example_info Reverses the order of vertices to reverse the direction of the polyline.
 */
function Reverse(__model__, entities) {
    entities = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_6__["arrMakeFlat"])(entities);
    if (!Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["isEmptyArr"])(entities)) {
        // --- Error Check ---
        let ents_arr;
        if (__model__.debug) {
            ents_arr = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])('modify.Reverse', 'entities', entities, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isId, _check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL], [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].WIRE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].FACE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON]);
        }
        else {
            // ents_arr = splitIDs('modify.Reverse', 'entities', entities,
            //     [IDcheckObj.isID, IDcheckObj.isIDList],
            //     [EEntType.WIRE, EEntType.PLINE, EEntType.FACE, EEntType.PGON])  as TEntTypeIdx[];
            ents_arr = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsBreak"])(entities);
        }
        // --- Error Check ---
        _reverse(__model__, ents_arr);
    }
}
function _reverse(__model__, ents_arr) {
    for (const [ent_type, ent_i] of ents_arr) {
        const wires_i = __model__.modeldata.geom.nav.navAnyToWire(ent_type, ent_i);
        wires_i.forEach(wire_i => __model__.modeldata.geom.modify.reverse(wire_i));
        __model__.modeldata.geom.time_stamp.updateObjsTs(ent_type, ent_i);
    }
}
// ================================================================================================
/**
 * Shifts the order of the edges in a closed wire.
 * ~
 * In a closed wire, any edge (or vertex) could be the first edge of the ring.
 * In some cases, it is useful to have an edge in a particular position in a ring.
 * This function allows the edges to be shifted either forwards or backwards around the ring.
 * The order of the edges in the ring will remain unchanged.
 *
 * @param __model__
 * @param entities Wire, face, polyline, polygon.
 * @returns void
 * @example modify.Shift(face1, 1)
 * @example_info Shifts the edges in the face wire, so that the every edge moves up by one position
 * in the ring. The last edge will become the first edge .
 * @example modify.Shift(polyline1, -1)
 * @example_info Shifts the edges in the closed polyline wire, so that every edge moves back by one position
 * in the ring. The first edge will become the last edge.
 */
function Shift(__model__, entities, offset) {
    entities = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_6__["arrMakeFlat"])(entities);
    if (!Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["isEmptyArr"])(entities)) {
        // --- Error Check ---
        let ents_arr;
        if (__model__.debug) {
            ents_arr = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])('modify.Reverse', 'entities', entities, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isId, _check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL], [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].WIRE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].FACE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON]);
        }
        else {
            // ents_arr = splitIDs('modify.Reverse', 'entities', entities,
            // [IDcheckObj.isID, IDcheckObj.isIDList],
            // [EEntType.WIRE, EEntType.PLINE, EEntType.FACE, EEntType.PGON])  as TEntTypeIdx[];
            ents_arr = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsBreak"])(entities);
        }
        // --- Error Check ---
        _shift(__model__, ents_arr, offset);
    }
}
function _shift(__model__, ents_arr, offset) {
    for (const [ent_type, ent_i] of ents_arr) {
        const wires_i = __model__.modeldata.geom.nav.navAnyToWire(ent_type, ent_i);
        wires_i.forEach(wire_i => __model__.modeldata.geom.modify.shift(wire_i, offset));
        __model__.modeldata.geom.time_stamp.updateObjsTs(ent_type, ent_i);
    }
}
// ================================================================================================
/**
 * Opens or closes a polyline.
 * ~
 * @param __model__
 * @param lines Polyline(s).
 * @returns void
 * @example modify.Close([polyline1,polyline2,...], method='close')
 * @example_info If open, polylines are changed to closed; if already closed, nothing happens.
 */
function Ring(__model__, entities, method) {
    entities = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_6__["arrMakeFlat"])(entities);
    if (!Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["isEmptyArr"])(entities)) {
        // --- Error Check ---
        const fn_name = 'modify.Ring';
        let ents_arr;
        if (__model__.debug) {
            ents_arr = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])(fn_name, 'entities', entities, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isId, _check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL], [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE]);
        }
        else {
            // ents_arr = splitIDs(fn_name, 'entities', entities,
            // [IDcheckObj.isID, IDcheckObj.isIDList], [EEntType.PLINE]) as TEntTypeIdx[];
            ents_arr = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsBreak"])(entities);
        }
        // --- Error Check ---
        _ring(__model__, ents_arr, method);
    }
}
var _ERingMethod;
(function (_ERingMethod) {
    _ERingMethod["OPEN"] = "open";
    _ERingMethod["CLOSE"] = "close";
})(_ERingMethod || (_ERingMethod = {}));
function _ring(__model__, ents_arr, method) {
    for (const [ent_type, ent_i] of ents_arr) {
        switch (method) {
            case _ERingMethod.CLOSE:
                __model__.modeldata.geom.modify_pline.closePline(ent_i);
                break;
            case _ERingMethod.OPEN:
                __model__.modeldata.geom.modify_pline.openPline(ent_i);
                break;
            default:
                break;
        }
        __model__.modeldata.geom.time_stamp.updateObjsTs(ent_type, ent_i);
    }
}
// ================================================================================================
var _EWeldMethod;
(function (_EWeldMethod) {
    _EWeldMethod["MAKE_WELD"] = "make_weld";
    _EWeldMethod["BREAK_WELD"] = "break_weld";
})(_EWeldMethod || (_EWeldMethod = {}));
/**
 * Make or break welds between vertices.
 * If two vertices are welded, then they share the same position.
 * ~
 * @param __model__
 * @param entities Entities, a list of vertices, or entities from which vertices can be extracted.
 * @param method Enum; the method to use for welding.
 * @returns void
 */
function Weld(__model__, entities, method) {
    entities = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_6__["arrMakeFlat"])(entities);
    // --- Error Check ---
    const fn_name = 'modify.Weld';
    let ents_arr;
    if (__model__.debug) {
        ents_arr = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])(fn_name, 'entities', entities, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isId, _check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL], [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].VERT, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].EDGE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].WIRE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].FACE,
            _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].POINT, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].COLL]);
    }
    else {
        // ents_arr = splitIDs(fn_name, 'entities', entities, [IDcheckObj.isID, IDcheckObj.isIDList],
        //     [EEntType.VERT, EEntType.EDGE, EEntType.WIRE, EEntType.FACE,
        //     EEntType.POINT, EEntType.PLINE, EEntType.PGON, EEntType.COLL]) as TEntTypeIdx[];
        ents_arr = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsBreak"])(entities);
    }
    // --- Error Check ---
    _weld(__model__, ents_arr, method);
}
function _weld(__model__, ents_arr, method) {
    // get unique ents
    const map = __model__.modeldata.geom.query.getEntSets(ents_arr, [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].VERT, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].POINT, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON]);
    // time stamp
    __model__.modeldata.geom.time_stamp.updateEntsTs(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].POINT, map.get(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].POINT));
    __model__.modeldata.geom.time_stamp.updateEntsTs(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE, map.get(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE));
    __model__.modeldata.geom.time_stamp.updateEntsTs(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON, map.get(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON));
    // get verts_i
    const all_verts_i = Array.from(map.get(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].VERT));
    switch (method) {
        case _EWeldMethod.BREAK_WELD:
            __model__.modeldata.geom.modify.cloneVertPositions(all_verts_i);
            break;
        case _EWeldMethod.MAKE_WELD:
            __model__.modeldata.geom.modify.mergeVertPositions(all_verts_i);
            break;
        default:
            break;
    }
}
// ================================================================================================
/**
 * Fuse positions that lie within a certain tolerance of one another.
 * New positions will be created.
 * If the positions that are fuse have vertices attached, then the vertices will become welded.
 * ~
 * In some cases, if edges are shorter than the tolerance, this can result in edges being deleted.
 * The deletion of edges may also result in polylines or polygpns being deleted.
 * ~
 * @param __model__
 * @param entities Entities, a list of positions, or entities from which positions can be extracted.
 * @param tolerance The distance tolerance for fusing positions.
 *  @returns void
 */
function Fuse(__model__, entities, tolerance) {
    entities = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_6__["arrMakeFlat"])(entities);
    // --- Error Check ---
    const fn_name = 'modify.Fuse';
    let ents_arr;
    if (__model__.debug) {
        ents_arr = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])(fn_name, 'entities', entities, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isId, _check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL], null);
    }
    else {
        // ents_arr = splitIDs(fn_name, 'entities', entities,
        // [IDcheckObj.isID, IDcheckObj.isIDList], null) as TEntTypeIdx[];
        ents_arr = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsBreak"])(entities);
    }
    // --- Error Check ---
    _fuse(__model__, ents_arr, tolerance);
}
function _fuseDistSq(xyz1, xyz2) {
    return Math.pow(xyz1[0] - xyz2[0], 2) + Math.pow(xyz1[1] - xyz2[1], 2) + Math.pow(xyz1[2] - xyz2[2], 2);
}
function _fuse(__model__, ents_arr, tolerance) {
    // get unique ents
    const map = __model__.modeldata.geom.query.getEntSets(ents_arr, [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].POSI, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].POINT, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON]);
    // time stamp
    __model__.modeldata.geom.time_stamp.updateEntsTs(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].POINT, map.get(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].POINT));
    __model__.modeldata.geom.time_stamp.updateEntsTs(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE, map.get(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE));
    __model__.modeldata.geom.time_stamp.updateEntsTs(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON, map.get(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON));
    // get posis
    const posis_i = Array.from(map.get(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].POSI));
    // find neighbour
    const map_posi_i_to_xyz = new Map();
    const typed_positions = new Float32Array(posis_i.length * 4);
    const typed_buff = new three__WEBPACK_IMPORTED_MODULE_8__["BufferGeometry"]();
    typed_buff.setAttribute('position', new three__WEBPACK_IMPORTED_MODULE_8__["BufferAttribute"](typed_positions, 4));
    for (let i = 0; i < posis_i.length; i++) {
        const posi_i = posis_i[i];
        const xyz = __model__.modeldata.attribs.query.getPosiCoords(posi_i);
        map_posi_i_to_xyz.set(posi_i, xyz);
        typed_positions[i * 4 + 0] = xyz[0];
        typed_positions[i * 4 + 1] = xyz[1];
        typed_positions[i * 4 + 2] = xyz[2];
        typed_positions[i * 4 + 3] = posi_i;
    }
    const kdtree = new _libs_TypedArrayUtils_js__WEBPACK_IMPORTED_MODULE_9__["TypedArrayUtils"].Kdtree(typed_positions, _fuseDistSq, 4);
    // create a neighbours list
    const nns = []; // [posi_i, num_neighbours, neighbour_poisi_i]
    for (let i = 0; i < posis_i.length; i++) {
        const posi_i = posis_i[i];
        const nn = kdtree.nearest(map_posi_i_to_xyz.get(posi_i), posis_i.length, tolerance * tolerance);
        const nn_posis_i = [];
        for (const a_nn of nn) {
            const obj = a_nn[0].obj;
            const nn_posi_i = obj[3];
            nn_posis_i.push(nn_posi_i);
        }
        nns.push([posis_i[i], nn_posis_i.length, nn_posis_i]);
    }
    // sort so that positions with most neighbours win
    nns.sort((a, b) => b[1] - a[1]);
    // create new positions, replace posis for existing vertices
    const nns_filt = []; // [posi_i, num_neighbours, neighbour_poisi_i]
    const exclude_posis_i = new Set(); // exclude any posis that have already been moved
    for (const nn of nns) {
        if (!exclude_posis_i.has(nn[0]) && nn[1] > 1) {
            nns_filt.push(nn);
            const new_xyz = [0, 0, 0];
            for (const n_posi_i of nn[2]) {
                exclude_posis_i.add(n_posi_i);
                const xyz = map_posi_i_to_xyz.get(n_posi_i);
                new_xyz[0] += xyz[0];
                new_xyz[1] += xyz[1];
                new_xyz[2] += xyz[2];
            }
            new_xyz[0] = new_xyz[0] / nn[1];
            new_xyz[1] = new_xyz[1] / nn[1];
            new_xyz[2] = new_xyz[2] / nn[1];
            const new_posi_i = __model__.modeldata.geom.add.addPosi();
            __model__.modeldata.attribs.add.setPosiCoords(new_posi_i, new_xyz);
            for (const n_posi_i of nn[2]) {
                const verts_i = __model__.modeldata.geom.nav.navPosiToVert(n_posi_i);
                for (const vert_i of verts_i) {
                    __model__.modeldata.geom.modify.replaceVertPosi(vert_i, new_posi_i);
                }
                // __model__.modeldata.geom.add.addPline([new_posi_i, n_posi_i], false); // temp
            }
        }
    }
    // delete the posis if they are unused
    __model__.modeldata.geom.del.delUnusedPosis(Array.from(exclude_posis_i));
}
// ================================================================================================
/**
 * Remesh a face or polygon.
 * ~
 * When a face or polygon is deformed, the triangles that make up that face will sometimes become incorrect.
 * Remeshing will regenerate the triangulated mesh for the face.
 * Remeshing is not performed automatically as it would degrade performance.
 * Instead, it is left up to the user to remesh only when it is actually required.
 * ~
 * @param __model__
 * @param entities Single or list of faces, polygons, collections.
 * @returns void
 * @example modify.Remesh(polygon1)
 * @example_info Remeshs the face of the polygon.
 */
function Remesh(__model__, entities) {
    entities = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_6__["arrMakeFlat"])(entities);
    if (!Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["isEmptyArr"])(entities)) {
        // --- Error Check ---
        let ents_arr;
        if (__model__.debug) {
            ents_arr = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])('modify.Remesh', 'entities', entities, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isId, _check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL], [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].FACE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].COLL]);
        }
        else {
            // ents_arr = splitIDs('modify.Remesh', 'entities', entities,
            // [IDcheckObj.isID, IDcheckObj.isIDList], [EEntType.FACE, EEntType.PGON, EEntType.COLL]) as TEntTypeIdx[];
            ents_arr = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsBreak"])(entities);
        }
        // --- Error Check ---
        _remesh(__model__, ents_arr);
    }
}
function _remesh(__model__, ents_arr) {
    for (const [ent_type, index] of ents_arr) {
        if (ent_type === _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON) {
            __model__.modeldata.geom.modify_pgon.triPgons(index);
        }
        else {
            const pgons_i = __model__.modeldata.geom.nav.navAnyToPgon(ent_type, index);
            __model__.modeldata.geom.modify_pgon.triPgons(pgons_i);
        }
    }
    // time stamp is updated by triPgons()
}
// ================================================================================================
var _EDeleteMethod;
(function (_EDeleteMethod) {
    _EDeleteMethod["DELETE_SELECTED"] = "delete_selected";
    _EDeleteMethod["KEEP_SELECTED"] = "keep_selected";
})(_EDeleteMethod || (_EDeleteMethod = {}));
/**
 * Deletes geometric entities: positions, points, polylines, polygons, and collections.
 * ~
 * When deleting positions, any topology that requires those positions will also be deleted.
 * (For example, any vertices linked to the deleted position will also be deleted,
 * which may in turn result in some edges being deleted, and so forth.)
 * ~
 * When deleting objects (point, polyline, and polygons), topology is also deleted.
 * ~
 * When deleting collections, the objects and other collections in the collection are also deleted.
 * ~
 * @param __model__
 * @param entities Positions, points, polylines, polygons, collections.
 * @param method Enum, delete or keep unused positions.
 * @returns void
 * @example modify.Delete(polygon1, 'delete_selected')
 * @example_info Deletes polygon1 from the model.
 */
function Delete(__model__, entities, method) {
    if (entities === null) {
        if (method === _EDeleteMethod.KEEP_SELECTED) {
            return;
        }
        if (method === _EDeleteMethod.DELETE_SELECTED) {
            __model__.delete(null, false);
            return;
        }
    }
    entities = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_6__["arrMakeFlat"])(entities);
    // --- Error Check ---
    const fn_name = 'modify.Delete';
    let ents_arr;
    if (__model__.debug) {
        ents_arr = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])(fn_name, 'entities', entities, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isId, _check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL], [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].POSI, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].POINT, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].COLL]);
    }
    else {
        // ents_arr = splitIDs(fn_name, 'entities', entities,
        // [IDcheckObj.isID, IDcheckObj.isIDList],
        // [EEntType.POSI, EEntType.POINT, EEntType.PLINE, EEntType.PGON, EEntType.COLL]) as TEntTypeIdx[];
        ents_arr = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsBreak"])(entities);
    }
    // --- Error Check ---
    const ent_sets = __model__.modeldata.geom.query.getDelEntSets(ents_arr);
    switch (method) {
        case _EDeleteMethod.DELETE_SELECTED:
            if (Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_6__["isEmptyArr2"])(entities)) {
                return;
            }
            __model__.delete(ent_sets, false); //  do not invert
            return;
        case _EDeleteMethod.KEEP_SELECTED:
            if (Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_6__["isEmptyArr2"])(entities)) {
                __model__.delete(null, false);
                return;
            }
            __model__.delete(ent_sets, true); // invert
            return;
        default:
            throw new Error(fn_name + ' : Method not recognised.');
    }
}
// ExtendPline
// ProjectPosition
// Move position along vector (normals)
// ================================================================================================
// // AttribPush modelling operation
// export enum _EPromoteMethod {
//     FIRST = 'first',
//     LAST = 'last',
//     AVERAGE = 'average',
//     MEDIAN = 'median',
//     SUM = 'sum',
//     MIN = 'min',
//     MAX = 'max'
// }
// // Promote modelling operation
// export enum _EPromoteTarget {
//     POSI = 'positions',
//     VERT = 'vertices',
//     EDGE = 'edges',
//     WIRE = 'wires',
//     FACE = 'faces',
//     POINT = 'points',
//     PLINE = 'plines',
//     PGON = 'pgons',
//     COLL = 'collections',
//     MOD = 'model'
// }
// function _convertPromoteMethod(selection: _EPromoteMethod): EAttribPromote {
//     switch (selection) {
//         case _EPromoteMethod.AVERAGE:
//             return EAttribPromote.AVERAGE;
//         case _EPromoteMethod.MEDIAN:
//             return EAttribPromote.MEDIAN;
//         case _EPromoteMethod.SUM:
//             return EAttribPromote.SUM;
//         case _EPromoteMethod.MIN:
//             return EAttribPromote.MIN;
//         case _EPromoteMethod.MAX:
//             return EAttribPromote.MAX;
//         case _EPromoteMethod.FIRST:
//             return EAttribPromote.FIRST;
//         case _EPromoteMethod.LAST:
//             return EAttribPromote.LAST;
//         default:
//             break;
//     }
// }
// function _convertPromoteTarget(selection: _EPromoteTarget): EEntType {
//     switch (selection) {
//         case _EPromoteTarget.POSI:
//             return EEntType.POSI;
//         case _EPromoteTarget.VERT:
//             return EEntType.VERT;
//         case _EPromoteTarget.EDGE:
//             return EEntType.EDGE;
//         case _EPromoteTarget.WIRE:
//             return EEntType.WIRE;
//         case _EPromoteTarget.FACE:
//             return EEntType.FACE;
//         case _EPromoteTarget.POINT:
//             return EEntType.POINT;
//         case _EPromoteTarget.PLINE:
//             return EEntType.PLINE;
//         case _EPromoteTarget.PGON:
//             return EEntType.PGON;
//         case _EPromoteTarget.COLL:
//             return EEntType.COLL;
//         case _EPromoteTarget.MOD:
//             return EEntType.MOD;
//         default:
//             break;
//     }
// }
// /**
//  * Pushes existing attribute values onto other entities.
//  * Attribute values can be promoted up the hierarchy, demoted down the hierarchy, or transferred across the hierarchy.
//  * ~
//  * In certain cases, when attributes are pushed, they may be aggregated. For example, if you are pushing attributes
//  * from vertices to polygons, then there will be multiple vertex attributes that can be combined in
//  * different ways.
//  * The 'method' specifies how the attributes should be aggregated. Note that if no aggregation is required
//  * then the aggregation method is ignored.
//  * ~
//  * The aggregation methods consist of numerical functions such as average, median, sum, max, and min. These will
//  * only work if the attribute values are numbers or lists of numbers. If the attribute values are string, then
//  * the numerical functions are ignored.
//  * ~
//  * If the attribute values are lists of numbers, then these aggregation methods work on the individual items in the list.
//  * For example, lets say you have an attribute consisting of normal vectors on vertices. If you push these attributes
//  * down to the positions, then aggregation may be required, since multiple vertices can share the same position.
//  * In this case, if you choose the `average` aggregation method, then resulting vectors on the positions will be the
//  * average of vertex vectors.
//  *
//  * @param __model__
//  * @param entities The entities that currently contain the attribute values.
//  * @param attrib_name The name of the attribute to be promoted, demoted, or transferred.
//  * @param to_level Enum; The level to which to promote, demote, or transfer the attribute values.
//  * @param method Enum; The method to use when attribute values need to be aggregated.
//  * @returns void
//  * @example promote1 = modify.PushAttribs([pgon1, pgon2], 'area', collections, sum)
//  * @example_info For the two polygons (pgon1 and pgon2), it gets the attribute values from the attribute called `area`,
//  * and pushes them up to the collection level. The `sum` method specifies that the two areas should be added up.
//  * Note that in order to create an attribute at the collection level, the two polygons should be part of a
//  * collection. If they are not part of the collection, then no attribute values will be push.
//  */
// export function PushAttribs(__model__: GIModel, entities: TId|TId[], attrib_name: string,
//         to_level: _EPromoteTarget, method: _EPromoteMethod): void {
//     // --- Error Check ---
//     let ents_arr: TEntTypeIdx|TEntTypeIdx[];
//     if (entities !== null) {
//         ents_arr = checkIDs('modify.Attribute', 'entities', entities,
//                             [IDcheckObj.isID, IDcheckObj.isIDList], null) as TEntTypeIdx|TEntTypeIdx[];
//     } else {
//         ents_arr = null;
//     }
//     // --- Error Check ---
//     let from_ent_type: EEntType;
//     const indices: number[] = [];
//     if (ents_arr !== null) {
//         const ents_arrs: TEntTypeIdx[] = ((getArrDepth(ents_arr) === 1) ? [ents_arr] : ents_arr) as TEntTypeIdx[];
//         from_ent_type = ents_arrs[0][0];
//         for (const [ent_type, index] of ents_arrs) {
//             if (ent_type !== from_ent_type) {
//                 throw new Error('All entities must be of the same type.');
//             }
//             indices.push(index);
//         }
//     } else {
//         from_ent_type = EEntType.MOD;
//     }
//     const to_ent_type: EEntType = _convertPromoteTarget(to_level);
//     const promote_method: EAttribPromote = _convertPromoteMethod(method);
//     if (from_ent_type === to_ent_type) {
//         __model__.modeldata.attribs.add.transferAttribValues(from_ent_type, attrib_name, indices, promote_method);
//     } else {
//         __model__.modeldata.attribs.add.promoteAttribValues(from_ent_type, attrib_name, indices, to_ent_type, promote_method);
//     }
// }


/***/ }),

/***/ "./src/assets/core/modules/basic/pattern.ts":
/*!**************************************************!*\
  !*** ./src/assets/core/modules/basic/pattern.ts ***!
  \**************************************************/
/*! exports provided: Line, Rectangle, _EGridMethod, Grid, _EBoxMethod, Box, Polyhedron, _EPolyhedronMethod, _polyhedron, Arc, Bezier, _EClose, Nurbs, _Interpolate, Interpolate, _ECurveCatRomType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Line", function() { return Line; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Rectangle", function() { return Rectangle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_EGridMethod", function() { return _EGridMethod; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Grid", function() { return Grid; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_EBoxMethod", function() { return _EBoxMethod; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Box", function() { return Box; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Polyhedron", function() { return Polyhedron; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_EPolyhedronMethod", function() { return _EPolyhedronMethod; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_polyhedron", function() { return _polyhedron; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Arc", function() { return Arc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Bezier", function() { return Bezier; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_EClose", function() { return _EClose; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Nurbs", function() { return Nurbs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_Interpolate", function() { return _Interpolate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Interpolate", function() { return Interpolate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_ECurveCatRomType", function() { return _ECurveCatRomType; });
/* harmony import */ var _check_args__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_check_args */ "./src/assets/core/modules/_check_args.ts");
/* harmony import */ var _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @libs/geo-info/common */ "./src/assets/libs/geo-info/common.ts");
/* harmony import */ var _libs_geo_info_id__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @libs/geo-info/id */ "./src/assets/libs/geo-info/id.ts");
/* harmony import */ var _libs_geom_vectors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @libs/geom/vectors */ "./src/assets/libs/geom/vectors.ts");
/* harmony import */ var _libs_geom_matrix__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @libs/geom/matrix */ "./src/assets/libs/geom/matrix.ts");
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/* harmony import */ var _assets_libs_verb_verb__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @assets/libs/verb/verb */ "./src/assets/libs/verb/verb.js");
/* harmony import */ var _assets_libs_verb_verb__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_assets_libs_verb_verb__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @assets/libs/util/arrs */ "./src/assets/libs/util/arrs.ts");
/**
 * The `pattern` module has functions for creating patters of positions in the model.
 * All these functions all return lists of position IDs.
 * The list may be nested, depending on which function is selected.
 */
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};
/**
 *
 */









// import * as VERB from 'verb';
// ================================================================================================
/**
 * Creates a row of positions in a line pattern. Returns a list of new positions.
 * @param __model__
 * @param origin XYZ coordinates as a list of three numbers.
 * @param size Size of the line.
 * @returns Entities, a list of four positions.
 */
function Line(__model__, origin, size, num_positions) {
    // --- Error Check ---
    if (__model__.debug) {
        const fn_name = 'pattern.Line';
        Object(_check_args__WEBPACK_IMPORTED_MODULE_0__["checkArgs"])(fn_name, 'origin', origin, [_check_args__WEBPACK_IMPORTED_MODULE_0__["ArgCh"].isXYZ, _check_args__WEBPACK_IMPORTED_MODULE_0__["ArgCh"].isPln]);
        Object(_check_args__WEBPACK_IMPORTED_MODULE_0__["checkArgs"])(fn_name, 'size', size, [_check_args__WEBPACK_IMPORTED_MODULE_0__["ArgCh"].isNum]);
        Object(_check_args__WEBPACK_IMPORTED_MODULE_0__["checkArgs"])(fn_name, 'num_positions', num_positions, [_check_args__WEBPACK_IMPORTED_MODULE_0__["ArgCh"].isInt]);
    }
    // --- Error Check ---
    // create the matrix one time
    let matrix;
    const origin_is_plane = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_2__["getArrDepth"])(origin) === 2;
    if (origin_is_plane) {
        matrix = Object(_libs_geom_matrix__WEBPACK_IMPORTED_MODULE_4__["xfromSourceTargetMatrix"])(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_1__["XYPLANE"], origin);
    }
    // create the positions
    const posis_i = [];
    const coords = [];
    const step = size / (num_positions - 1);
    for (let i = 0; i < num_positions; i++) {
        coords.push([-(size / 2) + i * step, 0, 0]);
    }
    for (const coord of coords) {
        let xyz = coord;
        if (origin_is_plane) {
            xyz = Object(_libs_geom_matrix__WEBPACK_IMPORTED_MODULE_4__["multMatrix"])(xyz, matrix);
        }
        else { // we have a plane
            xyz = Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_3__["vecAdd"])(xyz, origin);
        }
        const posi_i = __model__.modeldata.geom.add.addPosi();
        __model__.modeldata.attribs.add.setPosiCoords(posi_i, xyz);
        posis_i.push(posi_i);
    }
    // return
    return Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_2__["idsMakeFromIndicies"])(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_1__["EEntType"].POSI, posis_i);
}
// ================================================================================================
/**
 * Creates four positions in a rectangle pattern. Returns a list of new positions.
 * @param __model__
 * @param origin XYZ coordinates as a list of three numbers.
 * @param size Size of rectangle. If number, assume square of that length; if list of two numbers, x and y lengths respectively.
 * @returns Entities, a list of four positions.
 * @example coordinates1 = pattern.Rectangle([0,0,0], 10)
 * @example_info Creates a list of 4 coords, being the vertices of a 10 by 10 square.
 * @example coordinates1 = pattern.Rectangle([0,0,0], [10,20])
 * @example_info Creates a list of 4 coords, being the vertices of a 10 by 20 rectangle.
 */
function Rectangle(__model__, origin, size) {
    // --- Error Check ---
    if (__model__.debug) {
        const fn_name = 'pattern.Rectangle';
        Object(_check_args__WEBPACK_IMPORTED_MODULE_0__["checkArgs"])(fn_name, 'origin', origin, [_check_args__WEBPACK_IMPORTED_MODULE_0__["ArgCh"].isXYZ, _check_args__WEBPACK_IMPORTED_MODULE_0__["ArgCh"].isPln]);
        Object(_check_args__WEBPACK_IMPORTED_MODULE_0__["checkArgs"])(fn_name, 'size', size, [_check_args__WEBPACK_IMPORTED_MODULE_0__["ArgCh"].isNum, _check_args__WEBPACK_IMPORTED_MODULE_0__["ArgCh"].isXY]);
    }
    // --- Error Check ---
    // create the matrix one time
    let matrix;
    const origin_is_plane = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_2__["getArrDepth"])(origin) === 2;
    if (origin_is_plane) {
        matrix = Object(_libs_geom_matrix__WEBPACK_IMPORTED_MODULE_4__["xfromSourceTargetMatrix"])(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_1__["XYPLANE"], origin);
    }
    // create the positions
    const posis_i = [];
    const xy_size = (Array.isArray(size) ? size : [size, size]);
    const coords = [
        [-(xy_size[0] / 2), -(xy_size[1] / 2), 0],
        [(xy_size[0] / 2), -(xy_size[1] / 2), 0],
        [(xy_size[0] / 2), (xy_size[1] / 2), 0],
        [-(xy_size[0] / 2), (xy_size[1] / 2), 0]
    ];
    for (const coord of coords) {
        let xyz = coord;
        if (origin_is_plane) {
            xyz = Object(_libs_geom_matrix__WEBPACK_IMPORTED_MODULE_4__["multMatrix"])(xyz, matrix);
        }
        else { // we have a plane
            xyz = Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_3__["vecAdd"])(xyz, origin);
        }
        const posi_i = __model__.modeldata.geom.add.addPosi();
        __model__.modeldata.attribs.add.setPosiCoords(posi_i, xyz);
        posis_i.push(posi_i);
    }
    // return
    return Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_2__["idsMakeFromIndicies"])(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_1__["EEntType"].POSI, posis_i);
}
// ================================================================================================
var _EGridMethod;
(function (_EGridMethod) {
    _EGridMethod["FLAT"] = "flat";
    _EGridMethod["COLUMNS"] = "columns";
    _EGridMethod["ROWS"] = "rows";
    _EGridMethod["QUADS"] = "quads";
})(_EGridMethod || (_EGridMethod = {}));
/**
* Creates positions in a grid pattern. Returns a list (or list of lists) of new positions.
* @param __model__
* @param origin XYZ coordinates as a list of three numbers.
* @param size Size of grid. If number, assume equal lengths, i.e. a square grid.
* If list of two numbers, specifies x and y lengths respectively.
* @param num_positions Number of positions. If a number, assume equal number of positions.
* If a list of two numbers, specifies x and y number of positions respectivley.
* @param method Enum, define the way the coords will be return as lists.
* If integer, same number for x and y; if list of two numbers, number for x and y respectively.
* @returns Entities, a list of positions, or a list of lists of positions (depending on the 'method' setting).
* @example coordinates1 = pattern.Grid([0,0,0], 10, 3)
* @example_info Creates a list of 9 XYZ coordinates on a 3x3 square grid of length 10.
* @example coordinates1 = pattern.Grid([0,0,0], [10,20], [2,4])
* @example_info Creates a list of 8 XYZ coordinates on a 2x4 grid of length 10 by 20.
*/
function Grid(__model__, origin, size, num_positions, method) {
    // --- Error Check ---
    if (__model__.debug) {
        const fn_name = 'pattern.Grid';
        Object(_check_args__WEBPACK_IMPORTED_MODULE_0__["checkArgs"])(fn_name, 'origin', origin, [_check_args__WEBPACK_IMPORTED_MODULE_0__["ArgCh"].isXYZ, _check_args__WEBPACK_IMPORTED_MODULE_0__["ArgCh"].isPln]);
        Object(_check_args__WEBPACK_IMPORTED_MODULE_0__["checkArgs"])(fn_name, 'size', size, [_check_args__WEBPACK_IMPORTED_MODULE_0__["ArgCh"].isNum, _check_args__WEBPACK_IMPORTED_MODULE_0__["ArgCh"].isXY]);
        Object(_check_args__WEBPACK_IMPORTED_MODULE_0__["checkArgs"])(fn_name, 'num_positions', num_positions, [_check_args__WEBPACK_IMPORTED_MODULE_0__["ArgCh"].isInt, _check_args__WEBPACK_IMPORTED_MODULE_0__["ArgCh"].isXYInt]);
    }
    // --- Error Check ---
    // create the matrix one time
    let matrix;
    const origin_is_plane = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_2__["getArrDepth"])(origin) === 2;
    if (origin_is_plane) {
        matrix = Object(_libs_geom_matrix__WEBPACK_IMPORTED_MODULE_4__["xfromSourceTargetMatrix"])(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_1__["XYPLANE"], origin);
    }
    // create the positions
    const posis_i = [];
    const xy_size = (Array.isArray(size) ? size : [size, size]);
    const xy_num_positions = (Array.isArray(num_positions) ? num_positions : [num_positions, num_positions]);
    const x_offset = xy_size[0] / (xy_num_positions[0] - 1);
    const y_offset = xy_size[1] / (xy_num_positions[1] - 1);
    for (let i = 0; i < xy_num_positions[1]; i++) {
        const y = (i * y_offset) - (xy_size[1] / 2);
        for (let j = 0; j < xy_num_positions[0]; j++) {
            const x = (j * x_offset) - (xy_size[0] / 2);
            let xyz = [x, y, 0];
            if (origin_is_plane) {
                xyz = Object(_libs_geom_matrix__WEBPACK_IMPORTED_MODULE_4__["multMatrix"])(xyz, matrix);
            }
            else { // we have a plane
                xyz = Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_3__["vecAdd"])(xyz, origin);
            }
            const posi_i = __model__.modeldata.geom.add.addPosi();
            __model__.modeldata.attribs.add.setPosiCoords(posi_i, xyz);
            posis_i.push(posi_i);
        }
    }
    // structure the grid of posis, and return
    const posis_i2 = [];
    if (method === _EGridMethod.FLAT) {
        return Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_2__["idsMakeFromIndicies"])(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_1__["EEntType"].POSI, posis_i);
    }
    else if (method === _EGridMethod.ROWS) {
        for (let i = 0; i < xy_num_positions[1]; i++) {
            const row = [];
            for (let j = 0; j < xy_num_positions[0]; j++) {
                const index = (i * xy_num_positions[0]) + j;
                row.push(posis_i[index]);
            }
            posis_i2.push(row);
        }
    }
    else if (method === _EGridMethod.COLUMNS) {
        for (let i = 0; i < xy_num_positions[0]; i++) {
            const col = [];
            for (let j = 0; j < xy_num_positions[1]; j++) {
                const index = (j * xy_num_positions[0]) + i;
                col.push(posis_i[index]);
            }
            posis_i2.push(col);
        }
    }
    else if (method === _EGridMethod.QUADS) {
        for (let i = 0; i < xy_num_positions[1] - 1; i++) {
            for (let j = 0; j < xy_num_positions[0] - 1; j++) {
                const index = (i * xy_num_positions[0]) + j;
                const square = [
                    posis_i[index],
                    posis_i[index + 1],
                    posis_i[index + xy_num_positions[0] + 1],
                    posis_i[index + xy_num_positions[0]]
                ];
                posis_i2.push(square);
            }
        }
    }
    return Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_2__["idsMakeFromIndicies"])(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_1__["EEntType"].POSI, posis_i2);
}
// ================================================================================================
var _EBoxMethod;
(function (_EBoxMethod) {
    _EBoxMethod["FLAT"] = "flat";
    _EBoxMethod["ROWS"] = "rows";
    _EBoxMethod["COLUMNS"] = "columns";
    _EBoxMethod["LAYERS"] = "layers";
    // SIDES = 'sides',
    _EBoxMethod["QUADS"] = "quads";
})(_EBoxMethod || (_EBoxMethod = {}));
/**
 * Creates positions in a box pattern. Returns a list of new positions.
 * @param __model__
 * @param origin XYZ coordinates as a list of three numbers.
 * @param size Size of the box. If one number, assume equal lengths.
 * If list of two or three numbers, specifies x y z lengths respectively.
 * @param num_positions Number of positions. If number, assume equal number of positions.
 * If list of two or three numbers, specifies x y z numbers respectively.
 * @param method Enum
 * @returns Entities, a list of 6 positions.
 */
function Box(__model__, origin, size, num_positions, method) {
    // --- Error Check ---
    if (__model__.debug) {
        const fn_name = 'pattern.Box';
        Object(_check_args__WEBPACK_IMPORTED_MODULE_0__["checkArgs"])(fn_name, 'origin', origin, [_check_args__WEBPACK_IMPORTED_MODULE_0__["ArgCh"].isXYZ, _check_args__WEBPACK_IMPORTED_MODULE_0__["ArgCh"].isPln]);
        Object(_check_args__WEBPACK_IMPORTED_MODULE_0__["checkArgs"])(fn_name, 'size', size, [_check_args__WEBPACK_IMPORTED_MODULE_0__["ArgCh"].isNum, _check_args__WEBPACK_IMPORTED_MODULE_0__["ArgCh"].isXY, _check_args__WEBPACK_IMPORTED_MODULE_0__["ArgCh"].isXYZ]);
    }
    // --- Error Check ---
    // create the matrix one time
    let matrix;
    const origin_is_plane = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_2__["getArrDepth"])(origin) === 2;
    if (origin_is_plane) {
        matrix = Object(_libs_geom_matrix__WEBPACK_IMPORTED_MODULE_4__["xfromSourceTargetMatrix"])(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_1__["XYPLANE"], origin);
    }
    // create params
    const xyz_size = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_7__["arrFill"])(size, 3);
    const xyz_num_positions = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_7__["arrFill"])(num_positions, 3);
    // create the positions
    const layer_top_posis_i = [];
    const layer_bot_posis_i = [];
    const posis_i = [];
    const x_offset = xyz_size[0] / (xyz_num_positions[0] - 1);
    const y_offset = xyz_size[1] / (xyz_num_positions[1] - 1);
    const z_offset = xyz_size[2] / (xyz_num_positions[2] - 1);
    for (let k = 0; k < xyz_num_positions[2]; k++) {
        const layer_perim_x0_posis_i = [];
        const layer_perim_y0_posis_i = [];
        const layer_perim_x1_posis_i = [];
        const layer_perim_y1_posis_i = [];
        const z = (k * z_offset) - (xyz_size[2] / 2);
        for (let i = 0; i < xyz_num_positions[1]; i++) {
            const y = (i * y_offset) - (xyz_size[1] / 2);
            for (let j = 0; j < xyz_num_positions[0]; j++) {
                const x = (j * x_offset) - (xyz_size[0] / 2);
                let create_perim_layer = false;
                // perimeter layers
                if (i === 0 || i === xyz_num_positions[1] - 1) {
                    create_perim_layer = true;
                }
                if (j === 0 || j === xyz_num_positions[0] - 1) {
                    create_perim_layer = true;
                }
                // top layer
                let create_top_layer = false;
                if (k === xyz_num_positions[2] - 1) {
                    create_top_layer = true;
                }
                // bot layer
                let create_bot_layer = false;
                if (k === 0) {
                    create_bot_layer = true;
                }
                // create posis
                if (create_perim_layer || create_top_layer || create_bot_layer) {
                    let xyz = [x, y, z];
                    if (origin_is_plane) {
                        xyz = Object(_libs_geom_matrix__WEBPACK_IMPORTED_MODULE_4__["multMatrix"])(xyz, matrix);
                    }
                    else { // we have a plane
                        xyz = Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_3__["vecAdd"])(xyz, origin);
                    }
                    const posi_i = __model__.modeldata.geom.add.addPosi();
                    __model__.modeldata.attribs.add.setPosiCoords(posi_i, xyz);
                    if (create_perim_layer) {
                        if (i === 0) {
                            layer_perim_x0_posis_i.push(posi_i);
                        }
                        else if (i === xyz_num_positions[1] - 1) {
                            layer_perim_x1_posis_i.push(posi_i);
                        }
                        else if (j === xyz_num_positions[0] - 1) {
                            layer_perim_y0_posis_i.push(posi_i);
                        }
                        else if (j === 0) {
                            layer_perim_y1_posis_i.push(posi_i);
                        }
                    }
                    if (create_top_layer) {
                        layer_top_posis_i.push(posi_i);
                    }
                    if (create_bot_layer) {
                        layer_bot_posis_i.push(posi_i);
                    }
                }
            }
        }
        posis_i.push([layer_perim_x0_posis_i, layer_perim_y0_posis_i, layer_perim_x1_posis_i, layer_perim_y1_posis_i]);
    }
    // structure the grid of posis, and return
    if (method === _EBoxMethod.FLAT) {
        const layers_posis_i = [];
        for (let k = 1; k < posis_i.length - 2; k++) {
            layers_posis_i.push(Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_7__["arrMakeFlat"])([
                posis_i[k][0],
                posis_i[k][1],
                posis_i[k][2].reverse(),
                posis_i[k][3].reverse(),
            ]));
        }
        const all_posis = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_7__["arrMakeFlat"])([layer_bot_posis_i, layers_posis_i, layer_top_posis_i]);
        return Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_2__["idsMakeFromIndicies"])(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_1__["EEntType"].POSI, all_posis);
    }
    else if (method === _EBoxMethod.ROWS) {
        // rows that are parallel to x axis
        const posis_i2 = [];
        for (let i = 0; i < xyz_num_positions[1]; i++) {
            const row = [];
            // bottom
            for (let j = 0; j < xyz_num_positions[0]; j++) {
                const index = (i * xyz_num_positions[0]) + j;
                row.push(layer_bot_posis_i[index]);
            }
            // mid
            if (posis_i.length > 2) {
                for (let k = 1; k < posis_i.length - 1; k++) {
                    if (i === 0) {
                        row.push(...posis_i[k][0]);
                    }
                    else if (i === xyz_num_positions[1] - 1) {
                        row.push(...posis_i[k][2]);
                    }
                    else {
                        row.push(posis_i[k][3][i - 1]);
                        row.push(posis_i[k][1][i - 1]);
                    }
                }
            }
            // top
            for (let j = 0; j < xyz_num_positions[0]; j++) {
                const index = (i * xyz_num_positions[0]) + j;
                row.push(layer_top_posis_i[index]);
            }
            posis_i2.push(row);
        }
        return Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_2__["idsMakeFromIndicies"])(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_1__["EEntType"].POSI, posis_i2);
    }
    else if (method === _EBoxMethod.COLUMNS) {
        // columns that are parallel to the y axis
        // i is moving along x axis
        const posis_i2 = [];
        for (let i = 0; i < xyz_num_positions[0]; i++) {
            const col = [];
            // bot
            for (let j = 0; j < xyz_num_positions[1]; j++) {
                const index = (j * xyz_num_positions[0]) + i;
                col.push(layer_bot_posis_i[index]);
            }
            // mid
            if (posis_i.length > 2) {
                for (let k = 1; k < posis_i.length - 1; k++) {
                    if (i === 0) {
                        col.push(posis_i[k][0][0]);
                        col.push(...posis_i[k][3]);
                        col.push(posis_i[k][2][0]);
                    }
                    else if (i === xyz_num_positions[1] - 1) {
                        col.push(posis_i[k][0][xyz_num_positions[0] - 1]);
                        col.push(...posis_i[k][1]);
                        col.push(posis_i[k][0][xyz_num_positions[0] - 1]);
                    }
                    else {
                        col.push(posis_i[k][0][i]);
                        col.push(posis_i[k][2][i]);
                    }
                }
            }
            // top
            for (let j = 0; j < xyz_num_positions[1]; j++) {
                const index = (j * xyz_num_positions[0]) + i;
                col.push(layer_top_posis_i[index]);
            }
            posis_i2.push(col);
        }
        return Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_2__["idsMakeFromIndicies"])(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_1__["EEntType"].POSI, posis_i2);
    }
    else if (method === _EBoxMethod.LAYERS) {
        // layers that are parallel to the xy plane
        // i is moving along z axis
        // bottom
        const posis_i2 = [layer_bot_posis_i];
        // mid
        for (let i = 1; i < xyz_num_positions[2] - 1; i++) {
            if (posis_i.length > 2) {
                const layer = posis_i[i][0].slice();
                for (let j = 0; j < xyz_num_positions[1] - 2; j++) {
                    layer.push(posis_i[i][3][j]);
                    layer.push(posis_i[i][1][j]);
                }
                layer.push(...posis_i[i][2]);
                posis_i2.push(layer);
            }
        }
        // top
        posis_i2.push(layer_top_posis_i);
        return Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_2__["idsMakeFromIndicies"])(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_1__["EEntType"].POSI, posis_i2);
    }
    else if (method === _EBoxMethod.QUADS) {
        const posis_i2 = [];
        // bottom
        for (let i = 0; i < xyz_num_positions[1] - 1; i++) {
            for (let j = 0; j < xyz_num_positions[0] - 1; j++) {
                const index = (i * xyz_num_positions[0]) + j;
                const quad = [
                    layer_bot_posis_i[index],
                    layer_bot_posis_i[index + xyz_num_positions[0]],
                    layer_bot_posis_i[index + xyz_num_positions[0] + 1],
                    layer_bot_posis_i[index + 1]
                ];
                posis_i2.push(quad);
            }
        }
        // mid
        const layers_posis_i = [];
        for (let k = 0; k < posis_i.length; k++) {
            layers_posis_i.push(Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_7__["arrMakeFlat"])([
                posis_i[k][0],
                posis_i[k][1],
                posis_i[k][2].reverse(),
                posis_i[k][3].reverse(),
            ]));
        }
        for (let k = 0; k < layers_posis_i.length - 1; k++) {
            const layer_posis_i = layers_posis_i[k];
            const next_layer_posis_i = layers_posis_i[k + 1];
            for (let i = 0; i < layer_posis_i.length; i++) {
                const index = i;
                const next_index = i === layer_posis_i.length - 1 ? 0 : i + 1;
                const quad = [
                    layer_posis_i[index],
                    layer_posis_i[next_index],
                    next_layer_posis_i[next_index],
                    next_layer_posis_i[index]
                ];
                posis_i2.push(quad);
            }
        }
        // top
        for (let i = 0; i < xyz_num_positions[1] - 1; i++) {
            for (let j = 0; j < xyz_num_positions[0] - 1; j++) {
                const index = (i * xyz_num_positions[0]) + j;
                const quad = [
                    layer_top_posis_i[index],
                    layer_top_posis_i[index + 1],
                    layer_top_posis_i[index + xyz_num_positions[0] + 1],
                    layer_top_posis_i[index + xyz_num_positions[0]]
                ];
                posis_i2.push(quad);
            }
        }
        return Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_2__["idsMakeFromIndicies"])(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_1__["EEntType"].POSI, posis_i2);
    }
    return [];
}
// ================================================================================================
/**
 * Creates positions in a polyhedron pattern. Returns a list of new positions.
 * ~
 * @param __model__
 * @param origin XYZ coordinates as a list of three numbers.
 * @param radius xxx
 * @param detail xxx
 * @param method Enum
 * @returns Entities, a list of positions.
 */
function Polyhedron(__model__, origin, radius, detail, method) {
    // --- Error Check ---
    if (__model__.debug) {
        const fn_name = 'pattern.Polyhedron';
        Object(_check_args__WEBPACK_IMPORTED_MODULE_0__["checkArgs"])(fn_name, 'origin', origin, [_check_args__WEBPACK_IMPORTED_MODULE_0__["ArgCh"].isXYZ, _check_args__WEBPACK_IMPORTED_MODULE_0__["ArgCh"].isPln]);
        Object(_check_args__WEBPACK_IMPORTED_MODULE_0__["checkArgs"])(fn_name, 'radius', radius, [_check_args__WEBPACK_IMPORTED_MODULE_0__["ArgCh"].isNum]);
        Object(_check_args__WEBPACK_IMPORTED_MODULE_0__["checkArgs"])(fn_name, 'detail', detail, [_check_args__WEBPACK_IMPORTED_MODULE_0__["ArgCh"].isInt]);
        if (detail > 6) {
            throw new Error('pattern.Polyhedron: The "detail" argument is too high, the maximum is 6.');
        }
    }
    // --- Error Check ---
    // create the matrix one time
    let matrix = null;
    const origin_is_plane = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_2__["getArrDepth"])(origin) === 2;
    if (origin_is_plane) {
        matrix = Object(_libs_geom_matrix__WEBPACK_IMPORTED_MODULE_4__["xfromSourceTargetMatrix"])(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_1__["XYPLANE"], origin);
    }
    else {
        matrix = new three__WEBPACK_IMPORTED_MODULE_5__["Matrix4"]();
        matrix.makeTranslation(...origin);
    }
    // make polyhedron posis
    const posis_i = _polyhedron(__model__, matrix, radius, detail, method);
    return Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_2__["idsMakeFromIndicies"])(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_1__["EEntType"].POSI, posis_i);
}
var _EPolyhedronMethod;
(function (_EPolyhedronMethod) {
    _EPolyhedronMethod["FLAT_TETRA"] = "flat_tetra";
    _EPolyhedronMethod["FLAT_OCTA"] = "flat_octa";
    _EPolyhedronMethod["FLAT_ICOSA"] = "flat_icosa";
    _EPolyhedronMethod["FLAT_DODECA"] = "flat_dodeca";
    _EPolyhedronMethod["FACE_TETRA"] = "face_tetra";
    _EPolyhedronMethod["FACE_OCTA"] = "face_octa";
    _EPolyhedronMethod["FACE_ICOSA"] = "face_icosa";
    _EPolyhedronMethod["FACE_DODECA"] = "face_dodeca";
})(_EPolyhedronMethod || (_EPolyhedronMethod = {}));
function _polyhedron(__model__, matrix, radius, detail, method) {
    // create the posis
    let hedron_tjs = null;
    switch (method) {
        case _EPolyhedronMethod.FLAT_TETRA:
        case _EPolyhedronMethod.FACE_TETRA:
            hedron_tjs = new three__WEBPACK_IMPORTED_MODULE_5__["TetrahedronGeometry"](radius, detail);
            break;
        case _EPolyhedronMethod.FLAT_OCTA:
        case _EPolyhedronMethod.FACE_OCTA:
            hedron_tjs = new three__WEBPACK_IMPORTED_MODULE_5__["OctahedronGeometry"](radius, detail);
            break;
        case _EPolyhedronMethod.FLAT_ICOSA:
        case _EPolyhedronMethod.FACE_ICOSA:
            hedron_tjs = new three__WEBPACK_IMPORTED_MODULE_5__["IcosahedronGeometry"](radius, detail);
            break;
        case _EPolyhedronMethod.FLAT_DODECA:
        case _EPolyhedronMethod.FACE_DODECA:
            hedron_tjs = new three__WEBPACK_IMPORTED_MODULE_5__["DodecahedronGeometry"](radius, detail);
            break;
        default:
            throw new Error('pattern.Polyhedron: method not recognised.');
    }
    // create the posis
    const posis_i = [];
    for (const vert_tjs of hedron_tjs.vertices) {
        const xyz = Object(_libs_geom_matrix__WEBPACK_IMPORTED_MODULE_4__["multMatrix"])(vert_tjs.toArray(), matrix);
        const posi_i = __model__.modeldata.geom.add.addPosi();
        __model__.modeldata.attribs.add.setPosiCoords(posi_i, xyz);
        posis_i.push(posi_i);
    }
    // if the method is flat, then we are done, return the posis
    switch (method) {
        case _EPolyhedronMethod.FLAT_TETRA:
        case _EPolyhedronMethod.FLAT_OCTA:
        case _EPolyhedronMethod.FLAT_ICOSA:
        case _EPolyhedronMethod.FLAT_DODECA:
            return posis_i;
    }
    // get the posis into the arrays
    const posis_arrs_i = [];
    for (const face_tjs of hedron_tjs.faces) {
        posis_arrs_i.push([
            posis_i[face_tjs.a],
            posis_i[face_tjs.b],
            posis_i[face_tjs.c]
        ]);
    }
    // dispose the tjs polyhedron
    hedron_tjs.dispose();
    // return the result
    return posis_arrs_i;
}
// ================================================================================================
/**
 * Creates positions in an arc pattern. Returns a list of new positions.
 * If the angle of the arc is set to null, then circular patterns will be created.
 * For circular patterns, duplicates at start and end are automatically removed.
 *
 * @param __model__
 * @param origin XYZ coordinates as a list of three numbers.
 * @param radius Radius of circle as a number.
 * @param num_positions Number of positions to be distributed equally along the arc.
 * @param arc_angle Angle of arc (in radians).
 * @returns Entities, a list of positions.
 * @example coordinates1 = pattern.Arc([0,0,0], 10, 12, PI)
 * @example_info Creates a list of 12 positions distributed equally along a semicircle of radius 10.
 */
function Arc(__model__, origin, radius, num_positions, arc_angle) {
    // --- Error Check ---
    if (__model__.debug) {
        const fn_name = 'pattern.Arc';
        Object(_check_args__WEBPACK_IMPORTED_MODULE_0__["checkArgs"])(fn_name, 'origin', origin, [_check_args__WEBPACK_IMPORTED_MODULE_0__["ArgCh"].isXYZ, _check_args__WEBPACK_IMPORTED_MODULE_0__["ArgCh"].isPln]);
        Object(_check_args__WEBPACK_IMPORTED_MODULE_0__["checkArgs"])(fn_name, 'radius', radius, [_check_args__WEBPACK_IMPORTED_MODULE_0__["ArgCh"].isNum]);
        Object(_check_args__WEBPACK_IMPORTED_MODULE_0__["checkArgs"])(fn_name, 'num_positions', num_positions, [_check_args__WEBPACK_IMPORTED_MODULE_0__["ArgCh"].isInt]);
        Object(_check_args__WEBPACK_IMPORTED_MODULE_0__["checkArgs"])(fn_name, 'arc_angle', arc_angle, [_check_args__WEBPACK_IMPORTED_MODULE_0__["ArgCh"].isNum, _check_args__WEBPACK_IMPORTED_MODULE_0__["ArgCh"].isNull]);
    }
    // --- Error Check ---
    // create the matrix one time
    let matrix;
    const origin_is_plane = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_2__["getArrDepth"])(origin) === 2;
    if (origin_is_plane) {
        matrix = Object(_libs_geom_matrix__WEBPACK_IMPORTED_MODULE_4__["xfromSourceTargetMatrix"])(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_1__["XYPLANE"], origin);
    }
    // calc the rot angle per position
    const rot = (arc_angle === null) ? (2 * Math.PI) / num_positions : arc_angle / (num_positions - 1);
    // create positions
    const posis_i = [];
    for (let i = 0; i < num_positions; i++) {
        const angle = rot * i; // CCW
        const x = (Math.cos(angle) * radius);
        const y = (Math.sin(angle) * radius);
        let xyz = [x, y, 0];
        if (origin_is_plane) {
            xyz = Object(_libs_geom_matrix__WEBPACK_IMPORTED_MODULE_4__["multMatrix"])(xyz, matrix);
        }
        else { // we have a plane
            xyz = Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_3__["vecAdd"])(xyz, origin);
        }
        const posi_i = __model__.modeldata.geom.add.addPosi();
        __model__.modeldata.attribs.add.setPosiCoords(posi_i, xyz);
        posis_i.push(posi_i);
    }
    // return the list of posis
    return Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_2__["idsMakeFromIndicies"])(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_1__["EEntType"].POSI, posis_i);
}
// ================================================================================================
/**
 * Creates positions in an Bezier curve pattern. Returns a list of new positions.
 * The Bezier is created as either a qadratic or cubic Bezier. It is always an open curve.
 * ~
 * The input is a list of XYZ coordinates (three coords for quadratics, four coords for cubics).
 * The first and last coordinates in the list are the start and end positions of the Bezier curve.
 * The middle coordinates act as the control points for controlling the shape of the Bezier curve.
 * ~
 * For the quadratic Bezier, three XYZ coordinates are required.
 * For the cubic Bezier, four XYZ coordinates are required.
 * ~
 * For more information, see the wikipedia article: <a href="https://en.wikipedia.org/wiki/B%C3%A9zier_curve">B%C3%A9zier_curve</a>.
 * ~
 * @param __model__
 * @param coords A list of XYZ coordinates (three coords for quadratics, four coords for cubics).
 * @param num_positions Number of positions to be distributed along the Bezier.
 * @returns Entities, a list of positions.
 * @example coordinates1 = pattern.Bezier([[0,0,0], [10,0,50], [20,0,10]], 20)
 * @example_info Creates a list of 20 positions distributed along a Bezier curve pattern.
 */
function Bezier(__model__, coords, num_positions) {
    // --- Error Check ---
    const fn_name = 'pattern.Bezier';
    if (__model__.debug) {
        Object(_check_args__WEBPACK_IMPORTED_MODULE_0__["checkArgs"])(fn_name, 'coords', coords, [_check_args__WEBPACK_IMPORTED_MODULE_0__["ArgCh"].isXYZL]);
        Object(_check_args__WEBPACK_IMPORTED_MODULE_0__["checkArgs"])(fn_name, 'num_positions', num_positions, [_check_args__WEBPACK_IMPORTED_MODULE_0__["ArgCh"].isInt]);
    }
    // --- Error Check ---
    // create the curve
    const coords_tjs = coords.map(coord => new three__WEBPACK_IMPORTED_MODULE_5__["Vector3"](coord[0], coord[1], coord[2]));
    let points_tjs = [];
    let curve_tjs = null;
    if (coords.length === 4) {
        curve_tjs = new three__WEBPACK_IMPORTED_MODULE_5__["CubicBezierCurve3"](coords_tjs[0], coords_tjs[1], coords_tjs[2], coords_tjs[3]);
        points_tjs = curve_tjs.getPoints(num_positions - 1);
    }
    else if (coords.length === 3) {
        curve_tjs = new three__WEBPACK_IMPORTED_MODULE_5__["QuadraticBezierCurve3"](coords_tjs[0], coords_tjs[1], coords_tjs[2]);
        points_tjs = curve_tjs.getPoints(num_positions - 1);
    }
    else {
        throw new Error(fn_name + ': "coords" should be a list of either three or four XYZ coords.');
    }
    // create positions
    const posis_i = [];
    for (let i = 0; i < num_positions; i++) {
        const posi_i = __model__.modeldata.geom.add.addPosi();
        __model__.modeldata.attribs.add.setPosiCoords(posi_i, points_tjs[i].toArray());
        posis_i.push(posi_i);
    }
    // return the list of posis
    return Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_2__["idsMakeFromIndicies"])(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_1__["EEntType"].POSI, posis_i);
}
// ================================================================================================
var _EClose;
(function (_EClose) {
    _EClose["OPEN"] = "open";
    _EClose["CLOSE"] = "close";
})(_EClose || (_EClose = {}));
/**
 * Creates positions in an NURBS curve pattern, by using the XYZ positions as control points.
 * Returns a list of new positions.
 * ~
 * The positions are created along the curve at equal parameter values.
 * This means that the euclidean distance between the positions will not necessarily be equal.
 * ~
 * The input is a list of XYZ coordinates that will act as control points for the curve.
 * If the curve is open, then the first and last coordinates in the list are the start and end positions of the curve.
 * ~
 * The number of positions should be at least one greater than the degree of the curve.
 * ~
 * The degree (between 2 and 5) of the urve defines how smooth the curve is.
 * Quadratic: degree = 2
 * Cubic: degree = 3
 * Quartic: degree = 4.
 * ~
 * @param __model__
 * @param coords A list of XYZ coordinates (must be at least three XYZ coords).
 * @param degree The degree of the curve, and integer between 2 and 5.
 * @param close Enum, 'close' or 'open'
 * @param num_positions Number of positions to be distributed along the Bezier.
 * @returns Entities, a list of positions.
 * @example coordinates1 = pattern.Nurbs([[0,0,0], [10,0,50], [20,0,10]], 20)
 * @example_info Creates a list of 20 positions distributed along a Bezier curve pattern.
 */
function Nurbs(__model__, coords, degree, close, num_positions) {
    // --- Error Check ---
    if (__model__.debug) {
        const fn_name = 'pattern.Nurbs';
        Object(_check_args__WEBPACK_IMPORTED_MODULE_0__["checkArgs"])(fn_name, 'coords', coords, [_check_args__WEBPACK_IMPORTED_MODULE_0__["ArgCh"].isXYZL]);
        Object(_check_args__WEBPACK_IMPORTED_MODULE_0__["checkArgs"])(fn_name, 'num_positions', num_positions, [_check_args__WEBPACK_IMPORTED_MODULE_0__["ArgCh"].isInt]);
        if (coords.length < 3) {
            throw new Error(fn_name + ': "coords" should be a list of at least three XYZ coords.');
        }
        if (degree < 2 || degree > 5) {
            throw new Error(fn_name + ': "degree" should be between 2 and 5.');
        }
        if (degree > (coords.length - 1)) {
            throw new Error(fn_name + ': a curve of degree ' + degree + ' requires at least ' + (degree + 1) + ' coords.');
        }
    }
    // --- Error Check ---
    const closed = close === _EClose.CLOSE;
    // create the curve using the VERBS library
    const offset = degree + 1;
    const coords2 = coords.slice();
    if (closed) {
        const start = coords2.slice(0, offset);
        const end = coords2.slice(coords2.length - offset, coords2.length);
        coords2.splice(0, 0, ...end);
        coords2.splice(coords2.length, 0, ...start);
    }
    const weights = coords2.forEach(_ => 1);
    const num_knots = coords2.length + degree + 1;
    const knots = [];
    const uniform_knots = num_knots - (2 * degree);
    for (let i = 0; i < degree; i++) {
        knots.push(0);
    }
    for (let i = 0; i < uniform_knots; i++) {
        knots.push(i / (uniform_knots - 1));
    }
    for (let i = 0; i < degree; i++) {
        knots.push(1);
    }
    const curve_verb = new _assets_libs_verb_verb__WEBPACK_IMPORTED_MODULE_6__["geom"].NurbsCurve.byKnotsControlPointsWeights(degree, knots, coords2, weights);
    // Testing VERB closed curve
    // const k: number[] = [0, 1, 2, 3, 4, 5, 6, 7, 8];
    // const c: number[][] = [[0, 0, 0], [10, 0, 0], [10, 10, 0], [0, 10, 0], [0, 0, 0], [10, 0, 0]];
    // const w: number[] = [1, 1, 1, 1, 1, 1];
    // const curve_verb2 = new VERB.geom.NurbsCurve.byKnotsControlPointsWeights(2, k, c, w);
    // This gives an error: Error:
    // Invalid knot vector format! Should begin with degree + 1 repeats and end with degree + 1 repeats!
    const posis_i = nurbsToPosis(__model__, curve_verb, degree, closed, num_positions, coords[0]);
    // return the list of posis
    return Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_2__["idsMakeFromIndicies"])(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_1__["EEntType"].POSI, posis_i);
}
// ================================================================================================
/**
 * Creates positions in an NURBS curve pattern, by iterpolating between the XYZ positions.
 * Returns a list of new positions.
 * ~
 * THe positions are created along the curve at equal parameter values.
 * This means that the euclidean distance between the positions will not necessarily be equal.
 * ~
 * The input is a list of XYZ coordinates that will act as control points for the curve.
 * If the curve is open, then the first and last coordinates in the list are the start and end positions of the curve.
 * ~
 * The number of positions should be at least one greater than the degree of the curve.
 * ~
 * The degree (between 2 and 5) of the urve defines how smooth the curve is.
 * Quadratic: degree = 2
 * Cubic: degree = 3
 * Quartic: degree = 4.
 * ~
 * @param __model__
 * @param coords A list of XYZ coordinates (must be at least three XYZ coords).
 * @param degree The degree of the curve, and integer between 2 and 5.
 * @param close Enum, 'close' or 'open'
 * @param num_positions Number of positions to be distributed along the Bezier.
 * @returns Entities, a list of positions.
 * @example coordinates1 = pattern.Nurbs([[0,0,0], [10,0,50], [20,0,10]], 20)
 * @example_info Creates a list of 20 positions distributed along a Bezier curve pattern.
 */
function _Interpolate(__model__, coords, degree, close, num_positions) {
    // --- Error Check ---
    if (__model__.debug) {
        const fn_name = 'pattern._Interpolate';
        Object(_check_args__WEBPACK_IMPORTED_MODULE_0__["checkArgs"])(fn_name, 'coords', coords, [_check_args__WEBPACK_IMPORTED_MODULE_0__["ArgCh"].isXYZL]);
        Object(_check_args__WEBPACK_IMPORTED_MODULE_0__["checkArgs"])(fn_name, 'num_positions', num_positions, [_check_args__WEBPACK_IMPORTED_MODULE_0__["ArgCh"].isInt]);
        // --- Error Check ---
        if (coords.length < 3) {
            throw new Error(fn_name + ': "coords" should be a list of at least three XYZ coords.');
        }
        if (degree < 2 || degree > 5) {
            throw new Error(fn_name + ': "degree" should be between 2 and 5.');
        }
        if (degree > (coords.length - 1)) {
            throw new Error(fn_name + ': a curve of degree ' + degree + ' requires at least ' + (degree + 1) + ' coords.');
        }
    }
    const closed = close === _EClose.CLOSE;
    // create the curve using the VERBS library
    const offset = degree + 1;
    const coords2 = coords.slice();
    if (closed) {
        const start = coords2.slice(0, offset);
        const end = coords2.slice(coords2.length - offset, coords2.length);
        coords2.splice(0, 0, ...end);
        coords2.splice(coords2.length, 0, ...start);
    }
    const curve_verb = new _assets_libs_verb_verb__WEBPACK_IMPORTED_MODULE_6__["geom"].NurbsCurve.byPoints(coords2, degree);
    // return the list of posis
    const posis_i = nurbsToPosis(__model__, curve_verb, degree, closed, num_positions, coords[0]);
    return Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_2__["idsMakeFromIndicies"])(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_1__["EEntType"].POSI, posis_i);
}
function nurbsToPosis(__model__, curve_verb, degree, closed, num_positions, start) {
    // create positions
    const posis_i = [];
    const [offset_start, offset_end] = { 2: [5, 3], 3: [6, 5], 4: [8, 6], 5: [9, 8] }[degree];
    const knots = curve_verb.knots();
    const u_start = knots[offset_start];
    const u_end = knots[knots.length - offset_end - 1];
    const u_range = u_end - u_start;
    // trying split
    // const [c1, c2] = curve_verb.split(u_start);
    // const [c3, c4] = c2.split(u_end);
    // const curve_length_samples_verb: any[] = c3.divideByEqualArcLength(num_positions - 1);
    // const u_values_verb: number[] = curve_length_samples_verb.map( cls => cls.u as number );
    let min_dist_to_start = Infinity;
    let closest_to_start = -1;
    for (let i = 0; i < num_positions; i++) {
        let u;
        if (closed) {
            u = u_start + ((i / num_positions) * u_range);
        }
        else {
            u = i / (num_positions - 1);
        }
        const xyz = curve_verb.point(u);
        // xyz[2] = i / 10;
        const posi_i = __model__.modeldata.geom.add.addPosi();
        __model__.modeldata.attribs.add.setPosiCoords(posi_i, xyz);
        posis_i.push(posi_i);
        const dist = Math.abs(start[0] - xyz[0]) +
            Math.abs(start[1] - xyz[1]) +
            Math.abs(start[2] - xyz[2]);
        if (dist < min_dist_to_start) {
            min_dist_to_start = dist;
            closest_to_start = i;
        }
    }
    const posis_i_start = posis_i.slice(closest_to_start, posis_i.length);
    const posis_i_end = posis_i.slice(0, closest_to_start);
    const posis_i_sorted = posis_i_start.concat(posis_i_end);
    // return the list of posis
    return posis_i_sorted;
}
// ================================================================================================
/**
 * Creates positions in an spline pattern. Returns a list of new positions.
 * The spline is created using the Catmull-Rom algorithm.
 * It is a type of interpolating spline (a curve that goes through its control points).
 * ~
 * The input is a list of XYZ coordinates. These act as the control points for creating the Spline curve.
 * The positions that get generated will be divided equally between the control points.
 * For example, if you define 4 control points for a cosed spline, and set 'num_positions' to be 40,
 * then you will get 8 positions between each pair of control points,
 * irrespective of the distance between the control points.
 * ~
 * The spline curve can be created in three ways: 'centripetal', 'chordal', or 'catmullrom'.
 * ~
 * For more information, see the wikipedia article:
 * <a href="https://en.wikipedia.org/wiki/Centripetal_Catmull%E2%80%93Rom_spline">Catmull–Rom spline</a>.
 * ~
 * <img src="https://upload.wikimedia.org/wikipedia/commons/2/2f/Catmull-Rom_examples_with_parameters..png"
 * alt="Curve types" width="100">
 * ~
 * @param __model__
 * @param coords A list of XYZ coordinates.
 * @param type Enum, the type of interpolation algorithm.
 * @param tension Curve tension, between 0 and 1. This only has an effect when the 'type' is set to 'catmullrom'.
 * @param close Enum, 'open' or 'close'.
 * @param num_positions Number of positions to be distributed distributed along the spline.
 * @returns Entities, a list of positions.
 * @example coordinates1 = pattern.Spline([[0,0,0], [10,0,50], [20,0,0], [30,0,20], [40,0,10]], 'chordal','close', 0.2, 50)
 * @example_info Creates a list of 50 positions distributed along a spline curve pattern.
 */
function Interpolate(__model__, coords, type, tension, close, num_positions) {
    // --- Error Check ---
    if (__model__.debug) {
        const fn_name = 'pattern.Interpolate';
        Object(_check_args__WEBPACK_IMPORTED_MODULE_0__["checkArgs"])(fn_name, 'coords', coords, [_check_args__WEBPACK_IMPORTED_MODULE_0__["ArgCh"].isXYZL]);
        Object(_check_args__WEBPACK_IMPORTED_MODULE_0__["checkArgs"])(fn_name, 'tension', tension, [_check_args__WEBPACK_IMPORTED_MODULE_0__["ArgCh"].isNum01]);
        Object(_check_args__WEBPACK_IMPORTED_MODULE_0__["checkArgs"])(fn_name, 'num_positions', num_positions, [_check_args__WEBPACK_IMPORTED_MODULE_0__["ArgCh"].isInt]);
        if (coords.length < 3) {
            throw new Error(fn_name + ': "coords" should be a list of at least three XYZ coords.');
        }
    }
    // --- Error Check ---
    const closed_tjs = close === _EClose.CLOSE;
    const num_positions_tjs = closed_tjs ? num_positions : num_positions - 1;
    if (tension === 0) {
        tension = 1e-16;
    } // There seems to be a bug in threejs, so this is a fix
    // Check we have enough coords
    // create the curve
    const coords_tjs = coords.map(coord => new three__WEBPACK_IMPORTED_MODULE_5__["Vector3"](coord[0], coord[1], coord[2]));
    const curve_tjs = new three__WEBPACK_IMPORTED_MODULE_5__["CatmullRomCurve3"](coords_tjs, closed_tjs, type, tension);
    const points_tjs = curve_tjs.getPoints(num_positions_tjs);
    // create positions
    const posis_i = [];
    for (let i = 0; i < num_positions; i++) {
        const posi_i = __model__.modeldata.geom.add.addPosi();
        __model__.modeldata.attribs.add.setPosiCoords(posi_i, points_tjs[i].toArray());
        posis_i.push(posi_i);
    }
    // return the list of posis
    return Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_2__["idsMakeFromIndicies"])(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_1__["EEntType"].POSI, posis_i);
}
// Enums for CurveCatRom()
var _ECurveCatRomType;
(function (_ECurveCatRomType) {
    _ECurveCatRomType["CENTRIPETAL"] = "centripetal";
    _ECurveCatRomType["CHORDAL"] = "chordal";
    _ECurveCatRomType["CATMULLROM"] = "catmullrom";
})(_ECurveCatRomType || (_ECurveCatRomType = {}));
// ================================================================================================


/***/ }),

/***/ "./src/assets/core/modules/basic/poly2d.ts":
/*!*************************************************!*\
  !*** ./src/assets/core/modules/basic/poly2d.ts ***!
  \*************************************************/
/*! exports provided: _EClipJointType, _EClipEndType, _EOffset, _EOffsetRound, _EBooleanMethod, Voronoi, Delaunay, ConvexHull, _EBBoxMethod, BBoxPolygon, Union, Boolean, OffsetMitre, OffsetChamfer, OffsetRound, Stitch, Clean */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_EClipJointType", function() { return _EClipJointType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_EClipEndType", function() { return _EClipEndType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_EOffset", function() { return _EOffset; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_EOffsetRound", function() { return _EOffsetRound; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_EBooleanMethod", function() { return _EBooleanMethod; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Voronoi", function() { return Voronoi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Delaunay", function() { return Delaunay; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ConvexHull", function() { return ConvexHull; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_EBBoxMethod", function() { return _EBBoxMethod; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BBoxPolygon", function() { return BBoxPolygon; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Union", function() { return Union; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Boolean", function() { return Boolean; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OffsetMitre", function() { return OffsetMitre; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OffsetChamfer", function() { return OffsetChamfer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OffsetRound", function() { return OffsetRound; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Stitch", function() { return Stitch; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Clean", function() { return Clean; });
/* harmony import */ var _check_ids__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_check_ids */ "./src/assets/core/modules/_check_ids.ts");
/* harmony import */ var _check_args__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_check_args */ "./src/assets/core/modules/_check_args.ts");
/* harmony import */ var _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @libs/geo-info/common */ "./src/assets/libs/geo-info/common.ts");
/* harmony import */ var _assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @assets/libs/util/arrs */ "./src/assets/libs/util/arrs.ts");
/* harmony import */ var _doodle3d_clipper_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @doodle3d/clipper-js */ "./node_modules/@doodle3d/clipper-js/module/index.js");
/* harmony import */ var _doodle3d_clipper_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_doodle3d_clipper_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _assets_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @assets/libs/geo-info/id */ "./src/assets/libs/geo-info/id.ts");
/* harmony import */ var d3_delaunay__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-delaunay */ "./node_modules/d3-delaunay/src/index.js");
/* harmony import */ var d3_polygon__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-polygon */ "./node_modules/d3-polygon/src/index.js");
/* harmony import */ var d3_voronoi__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-voronoi */ "./node_modules/d3-voronoi/src/index.js");
/* harmony import */ var _assets_libs_geom_distance__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @assets/libs/geom/distance */ "./src/assets/libs/geom/distance.ts");
/* harmony import */ var _assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @assets/libs/geom/vectors */ "./src/assets/libs/geom/vectors.ts");
/* harmony import */ var _assets_libs_geom_matrix__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @assets/libs/geom/matrix */ "./src/assets/libs/geom/matrix.ts");
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./_common */ "./src/assets/core/modules/basic/_common.ts");
/**
 * The `poly2D` module has a set of functions for working with 2D polygons, on the XY plane.
 */
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};
/**
 *
 */














const SCALE = 1e9;
// Clipper types
var _EClipJointType;
(function (_EClipJointType) {
    _EClipJointType["SQUARE"] = "jtSquare";
    _EClipJointType["ROUND"] = "jtRound";
    _EClipJointType["MITER"] = "jtMiter";
})(_EClipJointType || (_EClipJointType = {}));
var _EClipEndType;
(function (_EClipEndType) {
    _EClipEndType["OPEN_SQUARE"] = "etOpenSquare";
    _EClipEndType["OPEN_ROUND"] = "etOpenRound";
    _EClipEndType["OPEN_BUTT"] = "etOpenButt";
    _EClipEndType["CLOSED_PLINE"] = "etClosedLine";
    _EClipEndType["CLOSED_PGON"] = "etClosedPolygon";
})(_EClipEndType || (_EClipEndType = {}));
const MClipOffsetEndType = new Map([
    ['square_end', _EClipEndType.OPEN_SQUARE],
    ['round_end', _EClipEndType.OPEN_ROUND],
    ['butt_end', _EClipEndType.OPEN_BUTT]
]);
// Function enums
var _EOffset;
(function (_EOffset) {
    _EOffset["SQUARE_END"] = "square_end";
    _EOffset["BUTT_END"] = "butt_end";
})(_EOffset || (_EOffset = {}));
var _EOffsetRound;
(function (_EOffsetRound) {
    _EOffsetRound["SQUARE_END"] = "square_end";
    _EOffsetRound["BUTT_END"] = "butt_end";
    _EOffsetRound["ROUND_END"] = "round_end";
})(_EOffsetRound || (_EOffsetRound = {}));
var _EBooleanMethod;
(function (_EBooleanMethod) {
    _EBooleanMethod["INTERSECT"] = "intersect";
    _EBooleanMethod["DIFFERENCE"] = "difference";
    _EBooleanMethod["SYMMETRIC"] = "symmetric";
})(_EBooleanMethod || (_EBooleanMethod = {}));
// ================================================================================================
// get polygons from the model
function _getPgons(__model__, ents_arr) {
    const set_pgons_i = new Set();
    for (const [ent_type, ent_i] of ents_arr) {
        switch (ent_type) {
            case _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE:
            case _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].POINT:
                break;
            case _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON:
                set_pgons_i.add(ent_i);
                break;
            case _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].COLL:
                const coll_pgons_i = __model__.modeldata.geom.nav.navCollToPgon(ent_i);
                for (const coll_pgon_i of coll_pgons_i) {
                    set_pgons_i.add(coll_pgon_i);
                }
                break;
            default:
                const ent_pgons_i = __model__.modeldata.geom.nav.navAnyToPgon(ent_type, ent_i);
                for (const ent_pgon_i of ent_pgons_i) {
                    set_pgons_i.add(ent_pgon_i);
                }
                break;
        }
    }
    return Array.from(set_pgons_i);
}
// get polygons and polylines from the model
function _getPgonsPlines(__model__, ents_arr) {
    const set_pgons_i = new Set();
    const set_plines_i = new Set();
    for (const [ent_type, ent_i] of ents_arr) {
        switch (ent_type) {
            case _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE:
                set_plines_i.add(ent_i);
                break;
            case _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].POINT:
                break;
            case _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON:
                set_pgons_i.add(ent_i);
                break;
            case _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].COLL:
                const coll_pgons_i = __model__.modeldata.geom.nav.navCollToPgon(ent_i);
                for (const coll_pgon_i of coll_pgons_i) {
                    set_pgons_i.add(coll_pgon_i);
                }
                const coll_plines_i = __model__.modeldata.geom.nav.navCollToPline(ent_i);
                for (const coll_pline_i of coll_plines_i) {
                    set_plines_i.add(coll_pline_i);
                }
                break;
            default:
                const ent_pgons_i = __model__.modeldata.geom.nav.navAnyToPgon(ent_type, ent_i);
                for (const ent_pgon_i of ent_pgons_i) {
                    set_pgons_i.add(ent_pgon_i);
                }
                const ent_plines_i = __model__.modeldata.geom.nav.navAnyToPline(ent_type, ent_i);
                for (const ent_pline_i of ent_plines_i) {
                    set_plines_i.add(ent_pline_i);
                }
                break;
        }
    }
    return [Array.from(set_pgons_i), Array.from(set_plines_i)];
}
// get posis from the model
function _getPosis(__model__, ents_arr) {
    const set_posis_i = new Set();
    for (const [ent_type, ent_i] of ents_arr) {
        switch (ent_type) {
            case _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].POSI:
                set_posis_i.add(ent_i);
                break;
            default:
                const ent_posis_i = __model__.modeldata.geom.nav.navAnyToPosi(ent_type, ent_i);
                for (const ent_posi_i of ent_posis_i) {
                    set_posis_i.add(ent_posi_i);
                }
                break;
        }
    }
    return Array.from(set_posis_i);
}
// ================================================================================================
// clipperjs -> Mobius Posi
function _getPosiFromMap(__model__, x, y, posis_map) {
    // TODO consider using a hash function insetad of a double map
    // try to find this coord in the map
    // if not found, create a new posi and add it to the map
    let posi_i;
    let map1 = posis_map.get(x);
    if (map1 !== undefined) {
        posi_i = map1.get(y);
    }
    else {
        map1 = new Map();
        posis_map.set(x, map1);
    }
    if (posi_i === undefined) {
        posi_i = __model__.modeldata.geom.add.addPosi();
        __model__.modeldata.attribs.add.setPosiCoords(posi_i, [x, y, 0]);
        map1.set(y, posi_i);
    }
    return posi_i;
}
function _putPosiInMap(x, y, posi_i, posis_map) {
    let map1 = posis_map.get(x);
    if (map1 === undefined) {
        map1 = new Map();
    }
    map1.set(y, posi_i);
}
// mobius -> clipperjs
function _convertPgonToShape(__model__, pgon_i, posis_map) {
    const wires_i = __model__.modeldata.geom.nav.navAnyToWire(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON, pgon_i);
    const shape_coords = [];
    for (const wire_i of wires_i) {
        const len = shape_coords.push([]);
        const posis_i = __model__.modeldata.geom.nav.navAnyToPosi(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].WIRE, wire_i);
        for (const posi_i of posis_i) {
            const xyz = __model__.modeldata.attribs.query.getPosiCoords(posi_i);
            const coord = { X: xyz[0], Y: xyz[1] };
            shape_coords[len - 1].push(coord);
            _putPosiInMap(xyz[0], xyz[1], posi_i, posis_map);
        }
    }
    const shape = new _doodle3d_clipper_js__WEBPACK_IMPORTED_MODULE_4___default.a(shape_coords, true);
    shape.scaleUp(SCALE);
    return shape;
}
// clipperjs
function _convertPgonsToShapeUnion(__model__, pgons_i, posis_map) {
    let result_shape = null;
    for (const pgon_i of pgons_i) {
        const shape = _convertPgonToShape(__model__, pgon_i, posis_map);
        if (result_shape == null) {
            result_shape = shape;
        }
        else {
            result_shape = result_shape.union(shape);
        }
    }
    return result_shape;
}
// clipperjs
function _convertPgonsToShapeJoin(__model__, pgons_i, posis_map) {
    let result_shape = null;
    for (const pgon_i of pgons_i) {
        const shape = _convertPgonToShape(__model__, pgon_i, posis_map);
        if (result_shape == null) {
            result_shape = shape;
        }
        else {
            result_shape = result_shape.join(shape);
        }
    }
    return result_shape;
}
// mobius -> clipperjs
function _convertWireToShape(__model__, wire_i, is_closed, posis_map) {
    const shape_coords = [];
    shape_coords.push([]);
    const posis_i = __model__.modeldata.geom.nav.navAnyToPosi(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].WIRE, wire_i);
    for (const posi_i of posis_i) {
        const xyz = __model__.modeldata.attribs.query.getPosiCoords(posi_i);
        const coord = { X: xyz[0], Y: xyz[1] };
        shape_coords[0].push(coord);
        _putPosiInMap(xyz[0], xyz[1], posi_i, posis_map);
    }
    const shape = new _doodle3d_clipper_js__WEBPACK_IMPORTED_MODULE_4___default.a(shape_coords, is_closed);
    shape.scaleUp(SCALE);
    return shape;
}
// clipperjs -> mobius
function _convertShapesToPgons(__model__, shapes, posis_map) {
    shapes = Array.isArray(shapes) ? shapes : [shapes];
    const pgons_i = [];
    for (const shape of shapes) {
        shape.scaleDown(SCALE);
        const sep_shapes = shape.separateShapes();
        for (const sep_shape of sep_shapes) {
            const posis_i = [];
            const paths = sep_shape.paths;
            for (const path of paths) {
                if (path.length === 0) {
                    continue;
                }
                const len = posis_i.push([]);
                for (const coord of path) {
                    const posi_i = _getPosiFromMap(__model__, coord.X, coord.Y, posis_map);
                    posis_i[len - 1].push(posi_i);
                }
            }
            if (posis_i.length === 0) {
                continue;
            }
            const outer_posis_i = posis_i[0];
            const holes_posis_i = posis_i.slice(1);
            const pgon_i = __model__.modeldata.geom.add.addPgon(outer_posis_i, holes_posis_i);
            pgons_i.push(pgon_i);
        }
    }
    return pgons_i;
}
// clipperjs
function _convertShapeToPlines(__model__, shape, is_closed, posis_map) {
    shape.scaleDown(SCALE);
    const sep_shapes = shape.separateShapes();
    const plines_i = [];
    for (const sep_shape of sep_shapes) {
        const paths = sep_shape.paths;
        for (const path of paths) {
            if (path.length === 0) {
                continue;
            }
            const list_posis_i = [];
            for (const coord of path) {
                const posi_i = _getPosiFromMap(__model__, coord.X, coord.Y, posis_map);
                list_posis_i.push(posi_i);
            }
            if (list_posis_i.length < 2) {
                continue;
            }
            const pgon_i = __model__.modeldata.geom.add.addPline(list_posis_i, is_closed);
            plines_i.push(pgon_i);
        }
    }
    return plines_i;
}
// clipperjs
function _printPaths(paths, mesage) {
    console.log(mesage);
    for (const path of paths) {
        console.log('    PATH');
        for (const coord of path) {
            console.log('        ', JSON.stringify(coord));
        }
    }
}
// ================================================================================================
// d3
// ================================================================================================
/**
 * Create a voronoi subdivision of one or more polygons.
 * ~
 * @param __model__
 * @param pgons A list of polygons, or entities from which polygons can be extracted.
 * @param entities A list of positions, or entities from which positions can be extracted.
 * @returns A list of new polygons.
 */
function Voronoi(__model__, pgons, entities) {
    pgons = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_3__["arrMakeFlat"])(pgons);
    entities = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_3__["arrMakeFlat"])(entities);
    if (Object(_assets_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_5__["isEmptyArr"])(pgons)) {
        return [];
    }
    if (Object(_assets_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_5__["isEmptyArr"])(entities)) {
        return [];
    }
    // --- Error Check ---
    const fn_name = 'poly2d.Voronoi';
    let pgons_ents_arr;
    let posis_ents_arr;
    if (__model__.debug) {
        pgons_ents_arr = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])(fn_name, 'pgons', pgons, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL], null);
        posis_ents_arr = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])(fn_name, 'entities', entities, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL], null);
    }
    else {
        // pgons_ents_arr = splitIDs(fn_name, 'pgons', pgons,
        //     [IDcheckObj.isIDList], null) as TEntTypeIdx[];
        // posis_ents_arr = splitIDs(fn_name, 'entities', entities,
        //     [IDcheckObj.isIDList], null) as TEntTypeIdx[];
        pgons_ents_arr = Object(_assets_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_5__["idsBreak"])(pgons);
        posis_ents_arr = Object(_assets_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_5__["idsBreak"])(entities);
    }
    // --- Error Check ---
    const posis_map = new Map();
    // pgons
    const pgons_i = _getPgons(__model__, pgons_ents_arr);
    if (pgons_i.length === 0) {
        return [];
    }
    // posis
    const posis_i = _getPosis(__model__, posis_ents_arr);
    if (posis_i.length === 0) {
        return [];
    }
    // posis
    const d3_cell_points = [];
    for (const posi_i of posis_i) {
        const xyz = __model__.modeldata.attribs.query.getPosiCoords(posi_i);
        d3_cell_points.push([xyz[0], xyz[1]]);
    }
    // loop and create cells
    const all_cells_i = [];
    for (const pgon_i of pgons_i) {
        // pgon and bounds
        const bounds = [Infinity, Infinity, -Infinity, -Infinity]; // xmin, ymin, xmax, ymax
        // const pgon_shape_coords: IClipCoord[] = [];
        for (const posi_i of __model__.modeldata.geom.nav.navAnyToPosi(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON, pgon_i)) {
            const xyz = __model__.modeldata.attribs.query.getPosiCoords(posi_i);
            // pgon_shape_coords.push( { X: xyz[0], Y: xyz[1]} );
            if (xyz[0] < bounds[0]) {
                bounds[0] = xyz[0];
            }
            if (xyz[1] < bounds[1]) {
                bounds[1] = xyz[1];
            }
            if (xyz[0] > bounds[2]) {
                bounds[2] = xyz[0];
            }
            if (xyz[1] > bounds[3]) {
                bounds[3] = xyz[1];
            }
        }
        // const pgon_shape: Shape = new Shape([pgon_shape_coords], true); // TODO holes
        const pgon_shape = _convertPgonToShape(__model__, pgon_i, posis_map);
        // pgon_shape.scaleUp(SCALE);
        // create voronoi
        const cells_i = _voronoiOld(__model__, pgon_shape, d3_cell_points, bounds, posis_map);
        for (const cell_i of cells_i) {
            all_cells_i.push(cell_i);
        }
    }
    // return cell pgons
    return Object(_assets_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_5__["idsMake"])(all_cells_i.map(cell_i => [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON, cell_i]));
}
// There is a bug in d3 new voronoi, it produces wrong results...
// function _voronoi(__model__: GIModel, pgon_shape: Shape, d3_cell_points: [number, number][],
//         bounds: number[], posis_map: TPosisMap): number[] {
//     const d3_delaunay = Delaunay.from(d3_cell_points);
//     const d3_voronoi = d3_delaunay.voronoi(bounds);
//     const shapes: Shape[] = [];
//     for (const d3_cell_coords of Array.from(d3_voronoi.cellPolygons())) {
//         const clipped_shape: Shape = _voronoiClip(__model__, pgon_shape, d3_cell_coords as [number, number][]);
//         shapes.push(clipped_shape);
//     }
//     return _convertShapesToPgons(__model__, shapes, posis_map);
// }
// function _voronoiClip(__model__: GIModel, pgon_shape: Shape, d3_cell_coords: [number, number][]): Shape {
//     const cell_shape_coords: IClipCoord[] = [];
//     // for (const d3_cell_coord of d3_cell_coords) {
//     for (let i = 0; i < d3_cell_coords.length - 1; i++) {
//         cell_shape_coords.push( {X: d3_cell_coords[i][0], Y: d3_cell_coords[i][1]} );
//     }
//     const cell_shape: Shape = new Shape([cell_shape_coords], true);
//     cell_shape.scaleUp(SCALE);
//     const clipped_shape: Shape = pgon_shape.intersect(cell_shape);
//     return clipped_shape;
// }
function _voronoiOld(__model__, pgon_shape, d3_cell_points, bounds, posis_map) {
    const d3_voronoi = d3_voronoi__WEBPACK_IMPORTED_MODULE_8__["voronoi"]().extent([[bounds[0], bounds[1]], [bounds[2], bounds[3]]]);
    const d3_voronoi_diag = d3_voronoi(d3_cell_points);
    const shapes = [];
    for (const d3_cell_coords of d3_voronoi_diag.polygons()) {
        if (d3_cell_coords !== undefined) {
            const clipped_shape = _voronoiClipOld(__model__, pgon_shape, d3_cell_coords);
            shapes.push(clipped_shape);
        }
    }
    return _convertShapesToPgons(__model__, shapes, posis_map);
}
function _voronoiClipOld(__model__, pgon_shape, d3_cell_coords) {
    const cell_shape_coords = [];
    // for (const d3_cell_coord of d3_cell_coords) {
    for (let i = 0; i < d3_cell_coords.length; i++) {
        cell_shape_coords.push({ X: d3_cell_coords[i][0], Y: d3_cell_coords[i][1] });
    }
    const cell_shape = new _doodle3d_clipper_js__WEBPACK_IMPORTED_MODULE_4___default.a([cell_shape_coords], true);
    cell_shape.scaleUp(SCALE);
    const clipped_shape = pgon_shape.intersect(cell_shape);
    return clipped_shape;
}
// ================================================================================================
/**
 * Create a delaunay triangulation of set of positions.
 * ~
 * @param __model__
 * @param entities A list of positions, or entities from which positions can be extracted.
 * @returns A list of new polygons.
 */
function Delaunay(__model__, entities) {
    entities = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_3__["arrMakeFlat"])(entities);
    if (Object(_assets_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_5__["isEmptyArr"])(entities)) {
        return [];
    }
    // --- Error Check ---
    const fn_name = 'poly2d.Delaunay';
    let posis_ents_arr;
    if (__model__.debug) {
        posis_ents_arr = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])(fn_name, 'entities1', entities, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL], null);
    }
    else {
        // posis_ents_arr = splitIDs(fn_name, 'entities1', entities,
        // [IDcheckObj.isIDList], null) as TEntTypeIdx[];
        posis_ents_arr = Object(_assets_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_5__["idsBreak"])(entities);
    }
    // --- Error Check ---
    const posis_map = new Map();
    // posis
    const posis_i = _getPosis(__model__, posis_ents_arr);
    if (posis_i.length === 0) {
        return [];
    }
    // posis
    const d3_tri_coords = [];
    for (const posi_i of posis_i) {
        const xyz = __model__.modeldata.attribs.query.getPosiCoords(posi_i);
        d3_tri_coords.push([xyz[0], xyz[1]]);
        _putPosiInMap(xyz[0], xyz[1], posi_i, posis_map);
    }
    // create delaunay triangulation
    const cells_i = _delaunay(__model__, d3_tri_coords, posis_map);
    // return cell pgons
    return Object(_assets_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_5__["idsMake"])(cells_i.map(cell_i => [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON, cell_i]));
}
function _delaunay(__model__, d3_tri_coords, posis_map) {
    const new_pgons_i = [];
    const delaunay = d3_delaunay__WEBPACK_IMPORTED_MODULE_6__["Delaunay"].from(d3_tri_coords);
    const delaunay_posis_i = [];
    for (const d3_tri_coord of d3_tri_coords) {
        // TODO use the posis_map!!
        // const deauny_posi_i: number = __model__.modeldata.geom.add.addPosi();
        // __model__.modeldata.attribs.add.setPosiCoords(deauny_posi_i, [point[0], point[1], 0]);
        const delaunay_posi_i = _getPosiFromMap(__model__, d3_tri_coord[0], d3_tri_coord[1], posis_map);
        delaunay_posis_i.push(delaunay_posi_i);
    }
    for (let i = 0; i < delaunay.triangles.length; i += 3) {
        const a = delaunay_posis_i[delaunay.triangles[i]];
        const b = delaunay_posis_i[delaunay.triangles[i + 1]];
        const c = delaunay_posis_i[delaunay.triangles[i + 2]];
        new_pgons_i.push(__model__.modeldata.geom.add.addPgon([c, b, a]));
    }
    return new_pgons_i;
}
// ================================================================================================
/**
 * Create a voronoi subdivision of a polygon.
 *
 * @param __model__
 * @param entities A list of positions, or entities from which positions can bet extracted.
 * @returns A new polygons, the convex hull of the positions.
 */
function ConvexHull(__model__, entities) {
    entities = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_3__["arrMakeFlat"])(entities);
    if (Object(_assets_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_5__["isEmptyArr"])(entities)) {
        return null;
    }
    // --- Error Check ---
    const fn_name = 'poly2d.ConvexHull';
    let ents_arr;
    if (__model__.debug) {
        ents_arr = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])(fn_name, 'entities', entities, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL], null);
    }
    else {
        // ents_arr = splitIDs(fn_name, 'entities', entities,
        // [IDcheckObj.isIDList], null) as TEntTypeIdx[];
        ents_arr = Object(_assets_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_5__["idsBreak"])(entities);
    }
    // --- Error Check ---
    // posis
    const posis_i = _getPosis(__model__, ents_arr);
    if (posis_i.length === 0) {
        return null;
    }
    const hull_posis_i = _convexHull(__model__, posis_i);
    // return cell pgons
    const hull_pgon_i = __model__.modeldata.geom.add.addPgon(hull_posis_i);
    return Object(_assets_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_5__["idsMake"])([_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON, hull_pgon_i]);
}
function _convexHull(__model__, posis_i) {
    const points = [];
    const posis_map = new Map();
    for (const posi_i of posis_i) {
        const xyz = __model__.modeldata.attribs.query.getPosiCoords(posi_i);
        points.push([xyz[0], xyz[1]]);
        _putPosiInMap(xyz[0], xyz[1], posi_i, posis_map);
    }
    if (points.length < 3) {
        return null;
    }
    // loop and create hull
    const hull_points = d3_polygon__WEBPACK_IMPORTED_MODULE_7__["polygonHull"](points);
    const hull_posis_i = [];
    for (const hull_point of hull_points) {
        const hull_posi_i = _getPosiFromMap(__model__, hull_point[0], hull_point[1], posis_map);
        hull_posis_i.push(hull_posi_i);
    }
    hull_posis_i.reverse();
    return hull_posis_i;
}
// ================================================================================================
var _EBBoxMethod;
(function (_EBBoxMethod) {
    _EBBoxMethod["AABB"] = "aabb";
    _EBBoxMethod["OBB"] = "obb";
})(_EBBoxMethod || (_EBBoxMethod = {}));
/**
 * Create a polygon that is a 2D bounding box of the entities.
 * ~
 * For the method, 'aabb' generates an Axis Aligned Bounding Box, and 'obb' generates an Oriented Bounding Box.
 * ~
 *
 * @param __model__
 * @param entities A list of positions, or entities from which positions can bet extracted.
 * @param method Enum, the method for generating the bounding box.
 * @returns A new polygon, the bounding box of the positions.
 */
function BBoxPolygon(__model__, entities, method) {
    entities = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_3__["arrMakeFlat"])(entities);
    if (Object(_assets_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_5__["isEmptyArr"])(entities)) {
        return null;
    }
    // --- Error Check ---
    const fn_name = 'poly2d.BBoxPolygon';
    let ents_arr;
    if (__model__.debug) {
        ents_arr = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])(fn_name, 'entities', entities, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL], null);
    }
    else {
        // ents_arr = splitIDs(fn_name, 'entities', entities,
        // [IDcheckObj.isIDList], null) as TEntTypeIdx[];
        ents_arr = Object(_assets_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_5__["idsBreak"])(entities);
    }
    // --- Error Check ---
    // posis
    const posis_i = _getPosis(__model__, ents_arr);
    if (posis_i.length === 0) {
        return null;
    }
    let pgon_i;
    switch (method) {
        case _EBBoxMethod.AABB:
            pgon_i = _bboxAABB(__model__, posis_i);
            break;
        case _EBBoxMethod.OBB:
            pgon_i = _bboxOBB(__model__, posis_i);
            break;
        default:
            break;
    }
    return Object(_assets_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_5__["idsMake"])([_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON, pgon_i]);
}
function _bboxAABB(__model__, posis_i) {
    const bbox = [Infinity, Infinity, -Infinity, -Infinity];
    for (const posi_i of posis_i) {
        const xyz = __model__.modeldata.attribs.query.getPosiCoords(posi_i);
        if (xyz[0] < bbox[0]) {
            bbox[0] = xyz[0];
        }
        if (xyz[1] < bbox[1]) {
            bbox[1] = xyz[1];
        }
        if (xyz[0] > bbox[2]) {
            bbox[2] = xyz[0];
        }
        if (xyz[1] > bbox[3]) {
            bbox[3] = xyz[1];
        }
    }
    const a = [bbox[0], bbox[1], 0];
    const b = [bbox[2], bbox[1], 0];
    const c = [bbox[2], bbox[3], 0];
    const d = [bbox[0], bbox[3], 0];
    const box_posis_i = [];
    for (const xyz of [a, b, c, d]) {
        const box_posi_i = __model__.modeldata.geom.add.addPosi();
        __model__.modeldata.attribs.add.setPosiCoords(box_posi_i, xyz);
        box_posis_i.push(box_posi_i);
    }
    const box_pgon_i = __model__.modeldata.geom.add.addPgon(box_posis_i);
    return box_pgon_i;
}
function _bboxOBB(__model__, posis_i) {
    // posis
    const hull_posis_i = _convexHull(__model__, posis_i);
    hull_posis_i.push(hull_posis_i[0]);
    const first = __model__.modeldata.attribs.query.getPosiCoords(hull_posis_i[0]);
    const hull_xyzs = [[first[0], first[1], 0]];
    let longest_len = 0;
    let origin_index = -1;
    for (let i = 1; i < hull_posis_i.length; i++) {
        // add xy to list
        const next = __model__.modeldata.attribs.query.getPosiCoords(hull_posis_i[i]);
        hull_xyzs.push([next[0], next[1], 0]);
        // get dist
        const curr_len = Object(_assets_libs_geom_distance__WEBPACK_IMPORTED_MODULE_9__["distance"])(hull_xyzs[i - 1], hull_xyzs[i]);
        if (curr_len > longest_len) {
            longest_len = curr_len;
            origin_index = i - 1;
        }
    }
    // get the plane
    const origin = hull_xyzs[origin_index];
    const x_vec = Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_10__["vecNorm"])(Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_10__["vecFromTo"])(origin, hull_xyzs[origin_index + 1]));
    const y_vec = [-x_vec[1], x_vec[0], 0]; // vecCross([0, 0, 1], x_vec);
    const source_pln = [origin, x_vec, y_vec];
    // xform posis and get min max
    const bbox = [Infinity, Infinity, -Infinity, -Infinity];
    const target_pln = [[0, 0, 0], [1, 0, 0], [0, 1, 0]];
    const matrix = Object(_assets_libs_geom_matrix__WEBPACK_IMPORTED_MODULE_11__["xfromSourceTargetMatrix"])(source_pln, target_pln);
    for (const xyz of hull_xyzs) {
        const new_xyz = Object(_assets_libs_geom_matrix__WEBPACK_IMPORTED_MODULE_11__["multMatrix"])(xyz, matrix);
        if (new_xyz[0] < bbox[0]) {
            bbox[0] = new_xyz[0];
        }
        if (new_xyz[1] < bbox[1]) {
            bbox[1] = new_xyz[1];
        }
        if (new_xyz[0] > bbox[2]) {
            bbox[2] = new_xyz[0];
        }
        if (new_xyz[1] > bbox[3]) {
            bbox[3] = new_xyz[1];
        }
    }
    // calc the bbx
    const a = Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_10__["vecAdd"])(origin, Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_10__["vecMult"])(x_vec, bbox[0]));
    const b = Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_10__["vecAdd"])(origin, Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_10__["vecMult"])(x_vec, bbox[2]));
    const height_vec = Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_10__["vecMult"])(y_vec, bbox[3] - bbox[1]);
    const c = Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_10__["vecAdd"])(b, height_vec);
    const d = Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_10__["vecAdd"])(a, height_vec);
    const box_posis_i = [];
    for (const xyz of [a, b, c, d]) {
        const box_posi_i = __model__.modeldata.geom.add.addPosi();
        __model__.modeldata.attribs.add.setPosiCoords(box_posi_i, xyz);
        box_posis_i.push(box_posi_i);
    }
    const box_pgon_i = __model__.modeldata.geom.add.addPgon(box_posis_i);
    return box_pgon_i;
}
function _distance2d(xy1, xy2) {
    const x = xy1[0] - xy2[0];
    const y = xy1[1] - xy2[1];
    return Math.sqrt(x * x + y * y);
}
// ================================================================================================
/**
 * Create the union of a set of polygons.
 *
 * @param __model__
 * @param entities A list of polygons, or entities from which polygons can bet extracted.
 * @returns A list of new polygons.
 */
function Union(__model__, entities) {
    entities = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_3__["arrMakeFlat"])(entities);
    if (Object(_assets_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_5__["isEmptyArr"])(entities)) {
        return [];
    }
    // --- Error Check ---
    const fn_name = 'poly2d.Union';
    let ents_arr;
    if (__model__.debug) {
        ents_arr = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])(fn_name, 'entities', entities, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isId, _check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL], null);
    }
    else {
        // ents_arr = splitIDs(fn_name, 'entities', entities,
        // [IDcheckObj.isID, IDcheckObj.isIDList], null) as TEntTypeIdx[];
        ents_arr = Object(_assets_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_5__["idsBreak"])(entities);
    }
    // --- Error Check ---
    const posis_map = new Map();
    const pgons_i = _getPgons(__model__, ents_arr);
    if (pgons_i.length === 0) {
        return [];
    }
    const result_shape = _convertPgonsToShapeUnion(__model__, pgons_i, posis_map);
    if (result_shape === null) {
        return [];
    }
    const all_new_pgons = _convertShapesToPgons(__model__, result_shape, posis_map);
    return Object(_assets_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_5__["idsMake"])(all_new_pgons.map(pgon_i => [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON, pgon_i]));
}
// ================================================================================================
/**
 * Perform a boolean operation on polylines or polygons.
 * ~
 * The entities in A can be either polyline or polygons.
 * The entities in B must be polygons.
 * The polygons in B are first unioned before the operation is performed.
 * The boolean operation is then performed between each polyline or polygon in A, and the unioned B polygons.
 * ~
 * If A is an empty list, then an empty list is returned.
 * If B is an empty list, then the A list is returned.
 * ~
 * @param __model__
 * @param a_entities A list of polyline or polygons, or entities from which polyline or polygons can be extracted.
 * @param b_entities A list of polygons, or entities from which polygons can be extracted.
 * @param method Enum, the boolean operator to apply.
 * @returns A list of new polylines and polygons.
 */
function Boolean(__model__, a_entities, b_entities, method) {
    a_entities = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_3__["arrMakeFlat"])(a_entities);
    if (Object(_assets_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_5__["isEmptyArr"])(a_entities)) {
        return [];
    }
    b_entities = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_3__["arrMakeFlat"])(b_entities);
    if (Object(_assets_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_5__["isEmptyArr"])(b_entities)) {
        return a_entities;
    }
    // --- Error Check ---
    const fn_name = 'poly2d.Boolean';
    let a_ents_arr;
    let b_ents_arr;
    if (__model__.debug) {
        a_ents_arr = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])(fn_name, 'a_entities', a_entities, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isId, _check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL], null);
        b_ents_arr = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])(fn_name, 'b_entities', b_entities, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isId, _check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL], null);
    }
    else {
        // a_ents_arr = splitIDs(fn_name, 'a_entities', a_entities,
        // [IDcheckObj.isID, IDcheckObj.isIDList], null) as TEntTypeIdx[];
        // b_ents_arr = splitIDs(fn_name, 'b_entities', b_entities,
        // [IDcheckObj.isID, IDcheckObj.isIDList], null) as TEntTypeIdx[];
        a_ents_arr = Object(_assets_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_5__["idsBreak"])(a_entities);
        b_ents_arr = Object(_assets_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_5__["idsBreak"])(b_entities);
    }
    // --- Error Check ---
    const posis_map = new Map();
    const [a_pgons_i, a_plines_i] = _getPgonsPlines(__model__, a_ents_arr);
    const b_pgons_i = _getPgons(__model__, b_ents_arr);
    if (a_pgons_i.length === 0 && a_plines_i.length === 0) {
        return [];
    }
    if (b_pgons_i.length === 0) {
        return [];
    }
    // const a_shape: Shape = _convertPgonsToShapeUnion(__model__, a_pgons_i, posis_map);
    const b_shape = _convertPgonsToShapeUnion(__model__, b_pgons_i, posis_map);
    // call the boolean function
    const new_pgons_i = _booleanPgons(__model__, a_pgons_i, b_shape, method, posis_map);
    const new_plines_i = _booleanPlines(__model__, a_plines_i, b_shape, method, posis_map);
    // make the list of polylines and polygons
    const result_ents = [];
    const new_pgons = Object(_assets_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_5__["idsMake"])(new_pgons_i.map(pgon_i => [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON, pgon_i]));
    for (const new_pgon of new_pgons) {
        result_ents.push(new_pgon);
    }
    const new_plines = Object(_assets_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_5__["idsMake"])(new_plines_i.map(pline_i => [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE, pline_i]));
    for (const new_pline of new_plines) {
        result_ents.push(new_pline);
    }
    // always return a list
    return result_ents;
}
function _booleanPgons(__model__, pgons_i, b_shape, method, posis_map) {
    if (!Array.isArray(pgons_i)) {
        pgons_i = pgons_i;
        const a_shape = _convertPgonToShape(__model__, pgons_i, posis_map);
        let result_shape;
        switch (method) {
            case _EBooleanMethod.INTERSECT:
                result_shape = a_shape.intersect(b_shape);
                break;
            case _EBooleanMethod.DIFFERENCE:
                result_shape = a_shape.difference(b_shape);
                break;
            case _EBooleanMethod.SYMMETRIC:
                result_shape = a_shape.xor(b_shape);
                break;
            default:
                break;
        }
        return _convertShapesToPgons(__model__, result_shape, posis_map);
    }
    else {
        pgons_i = pgons_i;
        const all_new_pgons = [];
        for (const pgon_i of pgons_i) {
            const result_pgons_i = _booleanPgons(__model__, pgon_i, b_shape, method, posis_map);
            for (const result_pgon_i of result_pgons_i) {
                all_new_pgons.push(result_pgon_i);
            }
        }
        return all_new_pgons;
    }
}
function _booleanPlines(__model__, plines_i, b_shape, method, posis_map) {
    if (!Array.isArray(plines_i)) {
        plines_i = plines_i;
        const wire_i = __model__.modeldata.geom.nav.navPlineToWire(plines_i);
        const is_closed = __model__.modeldata.geom.query.isWireClosed(wire_i);
        const a_shape = _convertWireToShape(__model__, wire_i, is_closed, posis_map);
        let result_shape;
        switch (method) {
            case _EBooleanMethod.INTERSECT:
                result_shape = a_shape.intersect(b_shape);
                break;
            case _EBooleanMethod.DIFFERENCE:
                result_shape = a_shape.difference(b_shape);
                break;
            case _EBooleanMethod.SYMMETRIC:
                // the perimeter of the B polygon is included in the output
                // but the perimeter is not closed, which seems strange
                result_shape = a_shape.xor(b_shape);
                break;
            default:
                break;
        }
        return _convertShapeToPlines(__model__, result_shape, is_closed, posis_map);
    }
    else {
        plines_i = plines_i;
        const all_new_plines = [];
        for (const pline_i of plines_i) {
            const result_plines_i = _booleanPlines(__model__, pline_i, b_shape, method, posis_map);
            for (const result_pline_i of result_plines_i) {
                all_new_plines.push(result_pline_i);
            }
        }
        return all_new_plines;
    }
}
// ================================================================================================
/**
 * Offset a polyline or polygon, with mitered joints.
 *
 * @param __model__
 * @param entities A list of pollines or polygons, or entities from which polylines or polygons can be extracted.
 * @param dist Offset distance
 * @param limit Mitre limit
 * @param end_type Enum, the type of end shape for open polylines'.
 * @returns A list of new polygons.
 */
function OffsetMitre(__model__, entities, dist, limit, end_type) {
    entities = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_3__["arrMakeFlat"])(entities);
    if (Object(_assets_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_5__["isEmptyArr"])(entities)) {
        return [];
    }
    // --- Error Check ---
    const fn_name = 'poly2d.OffsetMitre';
    let ents_arr;
    if (__model__.debug) {
        ents_arr = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])(fn_name, 'entities', entities, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isId, _check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL], [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON]);
        Object(_check_args__WEBPACK_IMPORTED_MODULE_1__["checkArgs"])(fn_name, 'miter_limit', limit, [_check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isNum]);
    }
    else {
        // ents_arr = splitIDs(fn_name, 'entities', entities,
        //     [IDcheckObj.isID, IDcheckObj.isIDList], [EEntType.PLINE, EEntType.PGON]) as TEntTypeIdx[];
        ents_arr = Object(_assets_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_5__["idsBreak"])(entities);
    }
    // --- Error Check ---
    const posis_map = new Map();
    const all_new_pgons = [];
    const options = {
        jointType: _EClipJointType.MITER,
        endType: MClipOffsetEndType.get(end_type),
        miterLimit: limit / dist
    };
    const [pgons_i, plines_i] = _getPgonsPlines(__model__, ents_arr);
    for (const pgon_i of pgons_i) {
        const new_pgons_i = _offsetPgon(__model__, pgon_i, dist, options, posis_map);
        for (const new_pgon_i of new_pgons_i) {
            all_new_pgons.push([_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON, new_pgon_i]);
        }
    }
    for (const pline_i of plines_i) {
        const new_pgons_i = _offsetPline(__model__, pline_i, dist, options, posis_map);
        for (const new_pgon_i of new_pgons_i) {
            all_new_pgons.push([_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON, new_pgon_i]);
        }
    }
    // for (const [ent_type, ent_i] of ents_arr) {
    //     const new_pgons_i: number[] = _offset(__model__, ent_type, ent_i, dist, options);
    //     if (new_pgons_i !== null) {
    //         for (const new_pgon_i of new_pgons_i) {
    //             all_new_pgons.push([EEntType.PGON, new_pgon_i]);
    //         }
    //     }
    // }
    return Object(_assets_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_5__["idsMake"])(all_new_pgons);
}
/**
 * Offset a polyline or polygon, with chamfered joints.
 *
 * @param __model__
 * @param entities A list of pollines or polygons, or entities from which polylines or polygons can be extracted.
 * @param dist Offset distance
 * @param end_type Enum, the type of end shape for open polylines'.
 * @returns A list of new polygons.
 */
function OffsetChamfer(__model__, entities, dist, end_type) {
    entities = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_3__["arrMakeFlat"])(entities);
    if (Object(_assets_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_5__["isEmptyArr"])(entities)) {
        return [];
    }
    // --- Error Check ---
    const fn_name = 'poly2d.OffsetChamfer';
    let ents_arr;
    if (__model__.debug) {
        ents_arr = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])(fn_name, 'entities', entities, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isId, _check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL], [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON]);
    }
    else {
        // ents_arr = splitIDs(fn_name, 'entities', entities,
        // [IDcheckObj.isID, IDcheckObj.isIDList], [EEntType.PLINE, EEntType.PGON]) as TEntTypeIdx[];
        ents_arr = Object(_assets_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_5__["idsBreak"])(entities);
    }
    // --- Error Check ---
    const posis_map = new Map();
    const all_new_pgons = [];
    const options = {
        jointType: _EClipJointType.SQUARE,
        endType: MClipOffsetEndType.get(end_type)
    };
    const [pgons_i, plines_i] = _getPgonsPlines(__model__, ents_arr);
    for (const pgon_i of pgons_i) {
        const new_pgons_i = _offsetPgon(__model__, pgon_i, dist, options, posis_map);
        for (const new_pgon_i of new_pgons_i) {
            all_new_pgons.push([_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON, new_pgon_i]);
        }
    }
    for (const pline_i of plines_i) {
        const new_pgons_i = _offsetPline(__model__, pline_i, dist, options, posis_map);
        for (const new_pgon_i of new_pgons_i) {
            all_new_pgons.push([_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON, new_pgon_i]);
        }
    }
    // for (const [ent_type, ent_i] of ents_arr) {
    //     const new_pgons_i: number[] = _offset(__model__, ent_type, ent_i, dist, options);
    //     if (new_pgons_i !== null) {
    //         for (const new_pgon_i of new_pgons_i) {
    //             all_new_pgons.push([EEntType.PGON, new_pgon_i]);
    //         }
    //     }
    // }
    return Object(_assets_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_5__["idsMake"])(all_new_pgons);
}
/**
 * Offset a polyline or polygon, with round joints.
 *
 * @param __model__
 * @param entities A list of pollines or polygons, or entities from which polylines or polygons can be extracted.
 * @param dist Offset distance
 * @param tolerance The tolerance for the rounded corners.
 * @param end_type Enum, the type of end shape for open polylines'.
 * @returns A list of new polygons.
 */
function OffsetRound(__model__, entities, dist, tolerance, end_type) {
    entities = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_3__["arrMakeFlat"])(entities);
    if (Object(_assets_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_5__["isEmptyArr"])(entities)) {
        return [];
    }
    // --- Error Check ---
    const fn_name = 'poly2d.OffsetRound';
    let ents_arr;
    if (__model__.debug) {
        ents_arr = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])(fn_name, 'entities', entities, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isId, _check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL], [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON]);
        Object(_check_args__WEBPACK_IMPORTED_MODULE_1__["checkArgs"])(fn_name, 'tolerance', tolerance, [_check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isNum]);
    }
    else {
        // ents_arr = splitIDs(fn_name, 'entities', entities,
        // [IDcheckObj.isID, IDcheckObj.isIDList], [EEntType.PLINE, EEntType.PGON]) as TEntTypeIdx[];
        ents_arr = Object(_assets_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_5__["idsBreak"])(entities);
    }
    // --- Error Check ---
    const posis_map = new Map();
    const all_new_pgons = [];
    const options = {
        jointType: _EClipJointType.ROUND,
        endType: MClipOffsetEndType.get(end_type),
        roundPrecision: tolerance * SCALE
    };
    const [pgons_i, plines_i] = _getPgonsPlines(__model__, ents_arr);
    for (const pgon_i of pgons_i) {
        const new_pgons_i = _offsetPgon(__model__, pgon_i, dist, options, posis_map);
        for (const new_pgon_i of new_pgons_i) {
            all_new_pgons.push([_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON, new_pgon_i]);
        }
    }
    for (const pline_i of plines_i) {
        const new_pgons_i = _offsetPline(__model__, pline_i, dist, options, posis_map);
        for (const new_pgon_i of new_pgons_i) {
            all_new_pgons.push([_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON, new_pgon_i]);
        }
    }
    return Object(_assets_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_5__["idsMake"])(all_new_pgons);
}
function _offsetPgon(__model__, pgon_i, dist, options, posis_map) {
    options.endType = _EClipEndType.CLOSED_PGON;
    const shape = _convertPgonToShape(__model__, pgon_i, posis_map);
    const result = shape.offset(dist * SCALE, options);
    const result_shape = new _doodle3d_clipper_js__WEBPACK_IMPORTED_MODULE_4___default.a(result.paths, result.closed);
    return _convertShapesToPgons(__model__, result_shape, posis_map);
}
function _offsetPline(__model__, pline_i, dist, options, posis_map) {
    const wire_i = __model__.modeldata.geom.nav.navPlineToWire(pline_i);
    const is_closed = __model__.modeldata.geom.query.isWireClosed(wire_i);
    if (is_closed) {
        options.endType = _EClipEndType.CLOSED_PLINE;
    }
    const shape = _convertWireToShape(__model__, wire_i, is_closed, posis_map);
    const result = shape.offset(dist * SCALE, options);
    const result_shape = new _doodle3d_clipper_js__WEBPACK_IMPORTED_MODULE_4___default.a(result.paths, result.closed);
    return _convertShapesToPgons(__model__, result_shape, posis_map);
}
// ================================================================================================
/**
 * Adds vertices to polyline and polygons at all locations where egdes intersect one another.
 * The vertices are welded.
 * This can be useful for creating networks that can be used for shortest path calculations.
 * ~
 * The input polyline and polygons are copied.
 * ~
 * @param __model__
 * @param entities A list polylines or polygons, or entities from which polylines or polygons can be extracted.
 * @returns Copies of the input polyline and polygons, stiched.
 */
function Stitch(__model__, entities) {
    entities = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_3__["arrMakeFlat"])(entities);
    if (Object(_assets_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_5__["isEmptyArr"])(entities)) {
        return [];
    }
    // --- Error Check ---
    const fn_name = 'poly2d.Stitch';
    let ents_arr;
    if (__model__.debug) {
        ents_arr = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])(fn_name, 'entities', entities, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL], [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON]);
    }
    else {
        // ents_arr = splitIDs(fn_name, 'entities', entities,
        // [IDcheckObj.isIDList], [EEntType.PLINE, EEntType.PGON]) as TEntTypeIdx[];
        ents_arr = Object(_assets_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_5__["idsBreak"])(entities);
    }
    // --- Error Check ---
    // copy the list of entities
    const new_ents_arr = Object(_common__WEBPACK_IMPORTED_MODULE_12__["_copyGeom"])(__model__, ents_arr, true);
    Object(_common__WEBPACK_IMPORTED_MODULE_12__["_copyGeomPosis"])(__model__, new_ents_arr, true, [0, 0, 0]);
    // create maps for data
    const map_edge_i_to_posi_i = new Map();
    const map_edge_i_to_bbox = new Map();
    const map_posi_i_to_xyz = new Map();
    // get the edges
    // const ents_arr2: TEntTypeIdx[] = [];
    // const edges_i: number[] = [];
    // for (const pline_i of __model__.modeldata.geom.add.copyPlines(Array.from(set_plines_i), true) as number[]) {
    //     ents_arr2.push([EEntType.PLINE, pline_i]);
    //     const ent_edges_i: number[] = __model__.modeldata.geom.nav.navAnyToEdge(EEntType.PLINE, pline_i);
    //     for (const edge_i of ent_edges_i) {
    //         edges_i.push(edge_i);
    //         _knifeGetEdgeData(__model__, edge_i, map_edge_i_to_posi_i, map_edge_i_to_bbox, map_posi_i_to_xyz);
    //     }
    // }
    const edges_i = [];
    for (const [ent_type, ent_i] of new_ents_arr) {
        const ent_edges_i = __model__.modeldata.geom.nav.navAnyToEdge(ent_type, ent_i);
        for (const ent_edge_i of ent_edges_i) {
            edges_i.push(ent_edge_i);
            _knifeGetEdgeData(__model__, ent_edge_i, map_edge_i_to_posi_i, map_edge_i_to_bbox, map_posi_i_to_xyz);
        }
    }
    // get the edges and the data for each edge
    const map_edge_i_to_isects = new Map();
    const map_edge_i_to_edge_i = new Map();
    for (const a_edge_i of edges_i) {
        const a_posis_i = map_edge_i_to_posi_i.get(a_edge_i);
        const a_xyz0 = map_posi_i_to_xyz.get(a_posis_i[0]);
        const a_xyz1 = map_posi_i_to_xyz.get(a_posis_i[1]);
        const a_xys = [[a_xyz0[0], a_xyz0[1]], [a_xyz1[0], a_xyz1[1]]];
        const a_bbox = map_edge_i_to_bbox.get(a_edge_i);
        for (const b_edge_i of edges_i) {
            // if this is same edge, continue
            if (a_edge_i === b_edge_i) {
                continue;
            }
            // if we have already done this pair of edges, continue
            if (map_edge_i_to_edge_i.has(a_edge_i)) {
                if (map_edge_i_to_edge_i.get(a_edge_i).has(b_edge_i)) {
                    continue;
                }
            }
            const b_posis_i = map_edge_i_to_posi_i.get(b_edge_i);
            const b_xyz0 = map_posi_i_to_xyz.get(b_posis_i[0]);
            const b_xyz1 = map_posi_i_to_xyz.get(b_posis_i[1]);
            const b_xys = [[b_xyz0[0], b_xyz0[1]], [b_xyz1[0], b_xyz1[1]]];
            const b_bbox = map_edge_i_to_bbox.get(b_edge_i);
            if (_knifeOverlap(a_bbox, b_bbox)) {
                const isect = _knifeIntersect(a_xys, b_xys);
                if (isect !== null) {
                    let a_isect = true;
                    let b_isect = true;
                    const s = isect[0];
                    const t = isect[1];
                    const new_xy = isect[2];
                    // get or create the new posi
                    let new_posi_i = null;
                    // check if we are at the start or end of 'a' edge
                    if (s === 0) {
                        a_isect = false;
                        new_posi_i = a_posis_i[0];
                    }
                    else if (s === 1) {
                        a_isect = false;
                        new_posi_i = a_posis_i[1];
                    }
                    // check if we are at the start or end of 'b' edge
                    if (t === 0) {
                        b_isect = false;
                        new_posi_i = b_posis_i[0];
                    }
                    else if (t === 1) {
                        b_isect = false;
                        new_posi_i = b_posis_i[1];
                    }
                    // make a new position if we have an isect,
                    if (new_posi_i === null && (a_isect || b_isect)) {
                        new_posi_i = __model__.modeldata.geom.add.addPosi();
                        __model__.modeldata.attribs.add.setPosiCoords(new_posi_i, [new_xy[0], new_xy[1], 0]);
                    }
                    // store the isects if there are any
                    if (a_isect) {
                        if (!map_edge_i_to_isects.has(a_edge_i)) {
                            map_edge_i_to_isects.set(a_edge_i, []);
                        }
                        map_edge_i_to_isects.get(a_edge_i).push([s, new_posi_i]);
                    }
                    if (b_isect) {
                        if (!map_edge_i_to_isects.has(b_edge_i)) {
                            map_edge_i_to_isects.set(b_edge_i, []);
                        }
                        map_edge_i_to_isects.get(b_edge_i).push([t, new_posi_i]);
                    }
                    // now remember that we did this pair already, so we don't do it again
                    if (!map_edge_i_to_edge_i.has(b_edge_i)) {
                        map_edge_i_to_edge_i.set(b_edge_i, new Set());
                    }
                    map_edge_i_to_edge_i.get(b_edge_i).add(a_edge_i);
                }
            }
        }
    }
    // const all_new_edges_i: number[] = [];
    const all_new_edges_i = [];
    for (const edge_i of map_edge_i_to_isects.keys()) {
        // isect [t, posi_i]
        const isects = map_edge_i_to_isects.get(edge_i);
        isects.sort((a, b) => a[0] - b[0]);
        const posis_i = isects.map(isect => isect[1]);
        const new_edges_i = __model__.modeldata.geom.modify.insertVertsIntoWire(edge_i, posis_i);
        for (const new_edge_i of new_edges_i) {
            all_new_edges_i.push(new_edge_i);
        }
    }
    // check if any new edges are zero length
    const del_posis_i = [];
    for (const edge_i of all_new_edges_i) {
        const posis_i = __model__.modeldata.geom.nav.navAnyToPosi(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].EDGE, edge_i);
        const xyzs = posis_i.map(posi_i => __model__.modeldata.attribs.query.getPosiCoords(posi_i));
        const dist = Object(_assets_libs_geom_distance__WEBPACK_IMPORTED_MODULE_9__["distanceManhattan"])(xyzs[0], xyzs[1]);
        if (dist === 0) {
            // we are going to del this posi
            const del_posi_i = posis_i[0];
            // get the vert of this edge
            const verts_i = __model__.modeldata.geom.nav.navEdgeToVert(edge_i);
            const del_vert_i = verts_i[0];
            // we need to make sure we dont disconnect any edges in the process
            // so we get all the verts connected to this edge
            // for each other edge, we will replace the posi for the vert that would have been deleted
            // the posi will be posis_i[1]
            const replc_verts_i = __model__.modeldata.geom.nav.navPosiToVert(del_posi_i);
            for (const replc_vert_i of replc_verts_i) {
                if (replc_vert_i === del_vert_i) {
                    continue;
                }
                __model__.modeldata.geom.modify.replaceVertPosi(replc_vert_i, posis_i[1], false); // false = do nothing if edge becomes invalid
            }
            del_posis_i.push(posis_i[0]);
        }
    }
    __model__.modeldata.geom.del.delPosis(del_posis_i);
    // return
    return Object(_assets_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_5__["idsMake"])(new_ents_arr);
}
function _knifeGetEdgeData(__model__, edge_i, map_edge_i_to_posi_i, map_edge_i_to_bbox, map_posi_i_to_xyz) {
    // get the two posis
    const posis_i = __model__.modeldata.geom.nav.navAnyToPosi(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].EDGE, edge_i);
    // save the two posis_i
    map_edge_i_to_posi_i.set(edge_i, [posis_i[0], posis_i[1]]);
    // save the xy value of the two posis
    if (!map_posi_i_to_xyz.has(posis_i[0])) {
        const xyz = __model__.modeldata.attribs.query.getPosiCoords(posis_i[0]);
        __model__.modeldata.attribs.add.setPosiCoords(posis_i[0], [xyz[0], xyz[1], 0]);
        // Why is this not working? It also moves the original geom...
        // if (xyz[2] !== 0) { xyz[2] = 0; } // TODO <<<<<<<<<<<<<<<<<<<<<<
        map_posi_i_to_xyz.set(posis_i[0], xyz);
    }
    if (!map_posi_i_to_xyz.has(posis_i[1])) {
        const xyz = __model__.modeldata.attribs.query.getPosiCoords(posis_i[1]);
        __model__.modeldata.attribs.add.setPosiCoords(posis_i[1], [xyz[0], xyz[1], 0]);
        // Why is this not working? It also moves the original geom...
        // if (xyz[2] !== 0) { xyz[2] = 0; } // TODO <<<<<<<<<<<<<<<<<<<<<<
        map_posi_i_to_xyz.set(posis_i[1], xyz);
    }
    // save the bbox
    const xyz0 = map_posi_i_to_xyz.get(posis_i[0]);
    const xyz1 = map_posi_i_to_xyz.get(posis_i[1]);
    const xys = [[xyz0[0], xyz0[1]], [xyz1[0], xyz1[1]]];
    const x_min = xys[0][0] < xys[1][0] ? xys[0][0] : xys[1][0];
    const x_max = xys[0][0] > xys[1][0] ? xys[0][0] : xys[1][0];
    const y_min = xys[0][1] < xys[1][1] ? xys[0][1] : xys[1][1];
    const y_max = xys[0][1] > xys[1][1] ? xys[0][1] : xys[1][1];
    map_edge_i_to_bbox.set(edge_i, [[x_min, y_min], [x_max, y_max]]);
}
function _knifeOverlap(bbox1, bbox2) {
    if (bbox2[1][0] < bbox1[0][0]) {
        return false;
    }
    if (bbox2[0][0] > bbox1[1][0]) {
        return false;
    }
    if (bbox2[1][1] < bbox1[0][1]) {
        return false;
    }
    if (bbox2[0][1] > bbox1[1][1]) {
        return false;
    }
    return true;
}
function _knifeIntersect(l1, l2) {
    // https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection
    const x1 = l1[0][0];
    const y1 = l1[0][1];
    const x2 = l1[1][0];
    const y2 = l1[1][1];
    const x3 = l2[0][0];
    const y3 = l2[0][1];
    const x4 = l2[1][0];
    const y4 = l2[1][1];
    const denominator = ((x1 - x2) * (y3 - y4)) - ((y1 - y2) * (x3 - x4));
    if (denominator === 0) {
        return null;
    }
    const t = (((x1 - x3) * (y3 - y4)) - ((y1 - y3) * (x3 - x4))) / denominator;
    const u = -(((x1 - x2) * (y1 - y3)) - ((y1 - y2) * (x1 - x3))) / denominator;
    if ((t >= 0 && t <= 1) && (u >= 0 && u <= 1)) {
        const new_xy = [x1 + (t * x2) - (t * x1), y1 + (t * y2) - (t * y1)];
        return [t, u, new_xy];
    }
    return null;
}
// ================================================================================================
/**
 * Clean a polyline or polygon.
 * ~
 * Vertices that are closer together than the specified tolerance will be merged.
 * Vertices that are colinear within the tolerance distance will be deleted.
 * ~
 * @param __model__
 * @param entities A list of polylines or polygons, or entities from which polylines or polygons can be extracted.
 * @param tolerance The tolerance for deleting vertices from the polyline.
 * @returns A list of new polygons.
 */
function Clean(__model__, entities, tolerance) {
    entities = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_3__["arrMakeFlat"])(entities);
    if (Object(_assets_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_5__["isEmptyArr"])(entities)) {
        return [];
    }
    // --- Error Check ---
    const fn_name = 'poly2d.Clean';
    let ents_arr;
    if (__model__.debug) {
        ents_arr = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])(fn_name, 'entities', entities, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isId, _check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL], [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON]);
        Object(_check_args__WEBPACK_IMPORTED_MODULE_1__["checkArgs"])(fn_name, 'tolerance', tolerance, [_check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isNum]);
    }
    else {
        // ents_arr = splitIDs(fn_name, 'entities', entities,
        //     [IDcheckObj.isID, IDcheckObj.isIDList], [EEntType.PLINE, EEntType.PGON]) as TEntTypeIdx[];
        ents_arr = Object(_assets_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_5__["idsBreak"])(entities);
    }
    // --- Error Check ---
    const posis_map = new Map();
    const all_new_pgons = [];
    const [pgons_i, plines_i] = _getPgonsPlines(__model__, ents_arr);
    for (const pgon_i of pgons_i) {
        const new_pgons_i = _cleanPgon(__model__, pgon_i, tolerance, posis_map);
        for (const new_pgon_i of new_pgons_i) {
            all_new_pgons.push([_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON, new_pgon_i]);
        }
    }
    for (const pline_i of plines_i) {
        const new_plines_i = _cleanPline(__model__, pline_i, tolerance, posis_map);
        for (const new_pline_i of new_plines_i) {
            all_new_pgons.push([_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE, new_pline_i]);
        }
    }
    return Object(_assets_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_5__["idsMake"])(all_new_pgons);
}
function _cleanPgon(__model__, pgon_i, tolerance, posis_map) {
    const shape = _convertPgonToShape(__model__, pgon_i, posis_map);
    const result = shape.clean(tolerance * SCALE);
    const result_shape = new _doodle3d_clipper_js__WEBPACK_IMPORTED_MODULE_4___default.a(result.paths, result.closed);
    return _convertShapesToPgons(__model__, result_shape, posis_map);
}
function _cleanPline(__model__, pline_i, tolerance, posis_map) {
    const wire_i = __model__.modeldata.geom.nav.navPlineToWire(pline_i);
    const verts_i = __model__.modeldata.geom.nav.navAnyToVert(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].WIRE, wire_i);
    if (verts_i.length === 2) {
        return [pline_i];
    }
    const is_closed = __model__.modeldata.geom.query.isWireClosed(wire_i);
    const shape = _convertWireToShape(__model__, wire_i, is_closed, posis_map);
    const result = shape.clean(tolerance * SCALE);
    const result_shape = new _doodle3d_clipper_js__WEBPACK_IMPORTED_MODULE_4___default.a(result.paths, result.closed);
    const shape_num_verts = result_shape.paths[0].length;
    if (shape_num_verts === 0 || shape_num_verts === verts_i.length) {
        return [pline_i];
    }
    return _convertShapeToPlines(__model__, result_shape, result.closed, posis_map);
}


/***/ }),

/***/ "./src/assets/core/modules/basic/query.ts":
/*!************************************************!*\
  !*** ./src/assets/core/modules/basic/query.ts ***!
  \************************************************/
/*! exports provided: _EEntType, _EEntTypeAndMod, _EDataType, Get, Filter, _EFilterOperator, Invert, _ESortMethod, Sort, Perimeter, _perimeter, Neighbor, _neighbors, Type, _ETypeQueryEnum */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_EEntType", function() { return _EEntType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_EEntTypeAndMod", function() { return _EEntTypeAndMod; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_EDataType", function() { return _EDataType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Get", function() { return Get; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Filter", function() { return Filter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_EFilterOperator", function() { return _EFilterOperator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Invert", function() { return Invert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_ESortMethod", function() { return _ESortMethod; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Sort", function() { return Sort; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Perimeter", function() { return Perimeter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_perimeter", function() { return _perimeter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Neighbor", function() { return Neighbor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_neighbors", function() { return _neighbors; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Type", function() { return Type; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_ETypeQueryEnum", function() { return _ETypeQueryEnum; });
/* harmony import */ var _check_ids__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_check_ids */ "./src/assets/core/modules/_check_ids.ts");
/* harmony import */ var _check_attribs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_check_attribs */ "./src/assets/core/modules/_check_attribs.ts");
/* harmony import */ var _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @libs/geo-info/common */ "./src/assets/libs/geo-info/common.ts");
/* harmony import */ var _libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @libs/geo-info/id */ "./src/assets/libs/geo-info/id.ts");
/* harmony import */ var _assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @assets/libs/util/arrs */ "./src/assets/libs/util/arrs.ts");
/**
 * The `query` module has functions for querying entities in the the model.
 * Most of these functions all return a list of IDs of entities in the model.
 * ~
 * ~
 */
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};
/**
 *
 */





// ================================================================================================
var _EEntType;
(function (_EEntType) {
    _EEntType["POSI"] = "ps";
    _EEntType["VERT"] = "_v";
    _EEntType["EDGE"] = "_e";
    _EEntType["WIRE"] = "_w";
    _EEntType["FACE"] = "_f";
    _EEntType["POINT"] = "pt";
    _EEntType["PLINE"] = "pl";
    _EEntType["PGON"] = "pg";
    _EEntType["COLL"] = "co";
})(_EEntType || (_EEntType = {}));
var _EEntTypeAndMod;
(function (_EEntTypeAndMod) {
    _EEntTypeAndMod["POSI"] = "ps";
    _EEntTypeAndMod["VERT"] = "_v";
    _EEntTypeAndMod["EDGE"] = "_e";
    _EEntTypeAndMod["WIRE"] = "_w";
    _EEntTypeAndMod["FACE"] = "_f";
    _EEntTypeAndMod["POINT"] = "pt";
    _EEntTypeAndMod["PLINE"] = "pl";
    _EEntTypeAndMod["PGON"] = "pg";
    _EEntTypeAndMod["COLL"] = "co";
    _EEntTypeAndMod["MOD"] = "mo";
})(_EEntTypeAndMod || (_EEntTypeAndMod = {}));
function _getEntTypeFromStr(ent_type_str) {
    switch (ent_type_str) {
        case _EEntTypeAndMod.POSI:
            return _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].POSI;
        case _EEntTypeAndMod.VERT:
            return _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].VERT;
        case _EEntTypeAndMod.EDGE:
            return _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].EDGE;
        case _EEntTypeAndMod.WIRE:
            return _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].WIRE;
        case _EEntTypeAndMod.FACE:
            return _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].FACE;
        case _EEntTypeAndMod.POINT:
            return _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].POINT;
        case _EEntTypeAndMod.PLINE:
            return _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE;
        case _EEntTypeAndMod.PGON:
            return _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON;
        case _EEntTypeAndMod.COLL:
            return _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].COLL;
        case _EEntTypeAndMod.MOD:
            return _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].MOD;
        default:
            break;
    }
}
// ================================================================================================
var _EDataType;
(function (_EDataType) {
    _EDataType["NUMBER"] = "number";
    _EDataType["STRING"] = "string";
    _EDataType["BOOLEAN"] = "boolean";
    _EDataType["LIST"] = "list";
    _EDataType["DICT"] = "dict";
})(_EDataType || (_EDataType = {}));
// ================================================================================================
/**
 * Get entities from a list of entities.
 * For example, you can get the position entities from a list of polygon entities.
 * ~
 * The result will always be a list of entities, even if there is only one entity.
 * In a case where you want only one entity, remember to get the first item in the list.
 * ~
 * The resulting list of entities will not contain duplicate entities.
 * ~
 * @param __model__
 * @param ent_type_enum Enum, the type of entity to get.
 * @param entities Optional, list of entities to get entities from, or null to get all entities in the model.
 * @returns Entities, a list of entities.
 * @example positions = query.Get('positions', [polyline1, polyline2])
 * @example_info Returns a list of positions that are part of polyline1 and polyline2.
 */
function Get(__model__, ent_type_enum, entities) {
    if (Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["isEmptyArr"])(entities)) {
        return [];
    }
    // --- Error Check ---
    const fn_name = 'query.Get';
    let ents_arr = null;
    if (__model__.debug) {
        if (entities !== null && entities !== undefined) {
            ents_arr = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])(fn_name, 'entities', entities, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isId, _check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL, _check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdLL], null);
        }
    }
    else {
        if (entities !== null && entities !== undefined) {
            // ents_arr = splitIDs(fn_name, 'entities', entities,
            //     [IDcheckObj.isID, IDcheckObj.isIDList, IDcheckObj.isIDListOfLists], null) as TEntTypeIdx|TEntTypeIdx[];
            ents_arr = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsBreak"])(entities);
        }
    }
    // --- Error Check ---
    // get the entity type // TODO deal with multiple ent types
    const ent_type = _getEntTypeFromStr(ent_type_enum);
    // if ents_arr is null, then get all entities in the model of type ent_type
    if (ents_arr === null) {
        // return the result
        return Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsMake"])(_getAll(__model__, ent_type));
    }
    if (Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["isEmptyArr"])(ents_arr)) {
        return [];
    }
    // make sure that the ents_arr is at least depth 2
    const depth = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["getArrDepth"])(ents_arr);
    if (depth === 1) {
        ents_arr = [ents_arr];
    }
    ents_arr = ents_arr;
    // get the entities
    const found_ents_arr = _getFrom(__model__, ent_type, ents_arr);
    // return the result
    return Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsMake"])(found_ents_arr);
}
function _getAll(__model__, ent_type) {
    const ents_i = __model__.modeldata.geom.query.getEnts(ent_type);
    return ents_i.map(ent_i => [ent_type, ent_i]);
}
function _getFrom(__model__, ent_type, ents_arr) {
    if (ents_arr.length === 0) {
        return [];
    }
    // do the query
    const depth = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["getArrDepth"])(ents_arr);
    if (depth === 2) {
        ents_arr = ents_arr;
        // get the list of entities that are found
        const found_ents_i_set = new Set();
        for (const ent_arr of ents_arr) {
            if (__model__.modeldata.geom.query.entExists(ent_arr[0], ent_arr[1])) {
                const ents_i = __model__.modeldata.geom.nav.navAnyToAny(ent_arr[0], ent_type, ent_arr[1]);
                if (ents_i) {
                    for (const ent_i of ents_i) {
                        if (ent_i !== undefined) {
                            found_ents_i_set.add(ent_i);
                        }
                    }
                }
            }
        }
        // return the found ents
        const found_ents_i = Array.from(found_ents_i_set);
        return found_ents_i.map(entity_i => [ent_type, entity_i]);
    }
    else { // depth === 3
        // TODO Why do we want this option?
        // TODO I cannot see any reason to return anything buy a flat list
        ents_arr = ents_arr;
        return ents_arr.map(ents_arr_item => _getFrom(__model__, ent_type, ents_arr_item));
    }
}
// ================================================================================================
/**
 * Filter a list of entities based on an attribute value.
 * ~
 * The result will always be a list of entities, even if there is only one entity.
 * In a case where you want only one entity, remember to get the first item in the list.
 * ~
 * @param __model__
 * @param entities List of entities to filter. The entities must all be of the same type
 * @param attrib The attribute to use for filtering. Can be `name`, `[name, index]`, or `[name, key]`.
 * @param operator_enum Enum, the operator to use for filtering
 * @param value The attribute value to use for filtering.
 * @returns Entities, a list of entities that match the conditions specified in 'expr'.
 */
function Filter(__model__, entities, attrib, operator_enum, value) {
    if (entities === null) {
        return [];
    }
    if (Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["isEmptyArr"])(entities)) {
        return [];
    }
    // --- Error Check ---
    const fn_name = 'query.Filter';
    let ents_arr = null;
    let attrib_name, attrib_idx_key;
    if (__model__.debug) {
        if (entities !== null && entities !== undefined) {
            ents_arr = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])(fn_name, 'entities', entities, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isId, _check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL, _check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdLL], null);
        }
        [attrib_name, attrib_idx_key] = Object(_check_attribs__WEBPACK_IMPORTED_MODULE_1__["checkAttribNameIdxKey"])(fn_name, attrib);
        Object(_check_attribs__WEBPACK_IMPORTED_MODULE_1__["checkAttribValue"])(fn_name, value);
    }
    else {
        if (entities !== null && entities !== undefined) {
            // ents_arr = splitIDs(fn_name, 'entities', entities,
            //     [IDcheckObj.isID, IDcheckObj.isIDList, IDcheckObj.isIDListOfLists], null) as TEntTypeIdx|TEntTypeIdx[];
            ents_arr = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsBreak"])(entities);
        }
        [attrib_name, attrib_idx_key] = Object(_check_attribs__WEBPACK_IMPORTED_MODULE_1__["splitAttribNameIdxKey"])(fn_name, attrib);
    }
    // --- Error Check ---
    // make sure that the ents_arr is at least depth 2
    const depth = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["getArrDepth"])(ents_arr);
    if (depth === 1) {
        ents_arr = [ents_arr];
    }
    ents_arr = ents_arr;
    // get the oeprator
    const op_type = _filterOperator(operator_enum);
    // do the query
    const found_ents_arr = _filter(__model__, ents_arr, attrib_name, attrib_idx_key, op_type, value);
    // return the result
    return Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsMake"])(found_ents_arr);
}
var _EFilterOperator;
(function (_EFilterOperator) {
    _EFilterOperator["IS_EQUAL"] = "==";
    _EFilterOperator["IS_NOT_EQUAL"] = "!=";
    _EFilterOperator["IS_GREATER_OR_EQUAL"] = ">=";
    _EFilterOperator["IS_LESS_OR_EQUAL"] = "<=";
    _EFilterOperator["IS_GREATER"] = ">";
    _EFilterOperator["IS_LESS"] = "<";
    _EFilterOperator["EQUAL"] = "=";
})(_EFilterOperator || (_EFilterOperator = {}));
function _filterOperator(select) {
    switch (select) {
        case _EFilterOperator.IS_EQUAL:
            return _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EFilterOperatorTypes"].IS_EQUAL;
        case _EFilterOperator.IS_NOT_EQUAL:
            return _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EFilterOperatorTypes"].IS_NOT_EQUAL;
        case _EFilterOperator.IS_GREATER_OR_EQUAL:
            return _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EFilterOperatorTypes"].IS_GREATER_OR_EQUAL;
        case _EFilterOperator.IS_LESS_OR_EQUAL:
            return _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EFilterOperatorTypes"].IS_LESS_OR_EQUAL;
        case _EFilterOperator.IS_GREATER:
            return _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EFilterOperatorTypes"].IS_GREATER;
        case _EFilterOperator.IS_LESS:
            return _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EFilterOperatorTypes"].IS_LESS;
        default:
            throw new Error('Query operator type not recognised.');
    }
}
function _filter(__model__, ents_arr, name, idx_or_key, op_type, value) {
    if (ents_arr.length === 0) {
        return [];
    }
    // do the filter
    const depth = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["getArrDepth"])(ents_arr);
    if (depth === 2) {
        ents_arr = ents_arr;
        const ent_type = ents_arr[0][0];
        // get the list of entities
        // const found_ents_i: number[] = [];
        // for (const ent_arr of ents_arr) {
        //     found_ents_i.push(...__model__.modeldata.geom.nav.navAnyToAny(ent_arr[0], ent_type, ent_arr[1]));
        // }
        const ents_i = [];
        for (const ent_arr of ents_arr) {
            if (ent_arr[0] !== ent_type) {
                throw new Error('Error filtering list of entities: The entities must all be of the same type.');
            }
            ents_i.push(ent_arr[1]);
        }
        // filter the entities
        const query_result = __model__.modeldata.attribs.query.filterByAttribs(ent_type, ents_i, name, idx_or_key, op_type, value);
        if (query_result.length === 0) {
            return [];
        }
        return query_result.map(entity_i => [ent_type, entity_i]);
    }
    else { // depth === 3
        // TODO Why do we want this option?
        // TODO I cannot see any reason to return anything buy a flat list
        ents_arr = ents_arr;
        return ents_arr.map(ents_arr_item => _filter(__model__, ents_arr_item, name, idx_or_key, op_type, value));
    }
}
// ================================================================================================
/**
 * Returns a list of entities that are not part of the specified entities.
 * For example, you can get the position entities that are not part of a list of polygon entities.
 * ~
 * This function does the opposite of query.Get().
 * While query.Get() gets entities that are part of of the list of entities,
 * this function gets the entities that are not part of the list of entities.
 * ~
 * @param __model__
 * @param ent_type_enum Enum, specifies what type of entities will be returned.
 * @param entities List of entities to be excluded.
 * @returns Entities, a list of entities that match the type specified in 'ent_type_enum', and that are not in entities.
 * @example positions = query.Invert('positions', [polyline1, polyline2])
 * @example_info Returns a list of positions that are not part of polyline1 and polyline2.
 */
function Invert(__model__, ent_type_enum, entities) {
    if (Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["isEmptyArr"])(entities)) {
        return [];
    }
    entities = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_4__["arrMakeFlat"])(entities);
    // --- Error Check ---
    let ents_arr = null;
    if (__model__.debug) {
        if (entities !== null && entities !== undefined) {
            ents_arr = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])('query.Invert', 'entities', entities, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL], null);
        }
    }
    else {
        if (entities !== null && entities !== undefined) {
            // ents_arr = splitIDs('query.Invert', 'entities', entities, [IDcheckObj.isIDList], null) as TEntTypeIdx[];
            ents_arr = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsBreak"])(entities);
        }
    }
    // --- Error Check ---
    const select_ent_types = _getEntTypeFromStr(ent_type_enum);
    const found_ents_arr = _invert(__model__, select_ent_types, ents_arr);
    return Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsMake"])(found_ents_arr);
}
function _invert(__model__, select_ent_type, ents_arr) {
    // get the ents to exclude
    const excl_ents_i = ents_arr
        .filter(ent_arr => ent_arr[0] === select_ent_type).map(ent_arr => ent_arr[1]);
    // get the list of entities
    const found_entities_i = [];
    const ents_i = __model__.modeldata.geom.query.getEnts(select_ent_type);
    for (const ent_i of ents_i) {
        if (excl_ents_i.indexOf(ent_i) === -1) {
            found_entities_i.push(ent_i);
        }
    }
    return found_entities_i.map(entity_i => [select_ent_type, entity_i]);
}
// ================================================================================================
var _ESortMethod;
(function (_ESortMethod) {
    _ESortMethod["DESCENDING"] = "descending";
    _ESortMethod["ASCENDING"] = "ascending";
})(_ESortMethod || (_ESortMethod = {}));
/**
 * Sorts entities based on an attribute.
 * ~
 * If the attribute is a list, and index can also be specified as follows: #@name1[index].
 * ~
 * @param __model__
 * @param entities List of two or more entities to be sorted, all of the same entity type.
 * @param attrib Attribute name to use for sorting. Can be `name`, `[name, index]`, or `[name, key]`.
 * @param method_enum Enum, sort descending or ascending.
 * @returns Entities, a list of sorted entities.
 * @example sorted_list = query.Sort( [pos1, pos2, pos3], #@xyz[2], descending)
 * @example_info Returns a list of three positions, sorted according to the descending z value.
 */
function Sort(__model__, entities, attrib, method_enum) {
    if (Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["isEmptyArr"])(entities)) {
        return [];
    }
    entities = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_4__["arrMakeFlat"])(entities);
    // --- Error Check ---
    const fn_name = 'query.Sort';
    let ents_arr;
    let attrib_name, attrib_idx_key;
    if (__model__.debug) {
        ents_arr = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])(fn_name, 'entities', entities, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL], null);
        [attrib_name, attrib_idx_key] = Object(_check_attribs__WEBPACK_IMPORTED_MODULE_1__["checkAttribNameIdxKey"])(fn_name, attrib);
    }
    else {
        // ents_arr = splitIDs(fn_name, 'entities', entities, [IDcheckObj.isIDList], null) as TEntTypeIdx[];
        ents_arr = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsBreak"])(entities);
        [attrib_name, attrib_idx_key] = Object(_check_attribs__WEBPACK_IMPORTED_MODULE_1__["splitAttribNameIdxKey"])(fn_name, attrib);
    }
    // --- Error Check ---
    const sort_method = (method_enum === _ESortMethod.DESCENDING) ? _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["ESort"].DESCENDING : _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["ESort"].ASCENDING;
    const sorted_ents_arr = _sort(__model__, ents_arr, attrib_name, attrib_idx_key, sort_method);
    return Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsMake"])(sorted_ents_arr);
}
function _sort(__model__, ents_arr, attrib_name, idx_or_key, method) {
    // get the list of ents_i
    const ent_type = ents_arr[0][0];
    const ents_i = ents_arr.filter(ent_arr => ent_arr[0] === ent_type).map(ent_arr => ent_arr[1]);
    // check if we are sorting by '_id'
    if (attrib_name === '_id') {
        const ents_arr_copy = ents_arr.slice();
        ents_arr_copy.sort(_compareID);
        if (method === _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["ESort"].DESCENDING) {
            ents_arr_copy.reverse();
        }
        return ents_arr_copy;
    }
    // do the sort on the list of entities
    const sort_result = __model__.modeldata.attribs.query.sortByAttribs(ent_type, ents_i, attrib_name, idx_or_key, method);
    return sort_result.map(entity_i => [ent_type, entity_i]);
}
function _compareID(id1, id2) {
    const [ent_type1, index1] = id1;
    const [ent_type2, index2] = id2;
    if (ent_type1 !== ent_type2) {
        return ent_type1 - ent_type2;
    }
    if (index1 !== index2) {
        return index1 - index2;
    }
    return 0;
}
// ================================================================================================
/**
* Returns a list of perimeter entities. In order to qualify as a perimeter entity,
* entities must be part of the set of input entities and must have naked edges.
* ~
* @param __model__
* @param ent_type Enum, select the type of perimeter entities to return
* @param entities List of entities.
* @returns Entities, a list of perimeter entities.
* @example query.Perimeter('edges', [polygon1,polygon2,polygon])
* @example_info Returns list of edges that are at the perimeter of polygon1, polygon2, or polygon3.
*/
function Perimeter(__model__, ent_type, entities) {
    if (Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_4__["isEmptyArr2"])(entities)) {
        return [];
    }
    entities = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_4__["arrMakeFlat"])(entities);
    // --- Error Check ---
    let ents_arr = null;
    if (__model__.debug) {
        if (entities !== null && entities !== undefined) {
            ents_arr = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])('query.Perimeter', 'entities', entities, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL], null);
        }
    }
    else {
        if (entities !== null && entities !== undefined) {
            // ents_arr = splitIDs('query.Perimeter', 'entities', entities, [IDcheckObj.isIDList], null) as TEntTypeIdx[];
            ents_arr = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsBreak"])(entities);
        }
    }
    // --- Error Check ---
    const select_ent_type = _getEntTypeFromStr(ent_type);
    const found_ents_arr = _perimeter(__model__, select_ent_type, ents_arr);
    return Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsMake"])(found_ents_arr);
}
function _perimeter(__model__, select_ent_type, ents_arr) {
    // get an array of all edges
    const edges_i = [];
    for (const ent_arr of ents_arr) {
        const [ent_type, index] = ent_arr;
        const edges_ent_i = __model__.modeldata.geom.nav.navAnyToEdge(ent_type, index);
        for (const edge_ent_i of edges_ent_i) {
            edges_i.push(edge_ent_i);
        }
    }
    // get the perimeter entities
    const all_perim_ents_i = __model__.modeldata.geom.query.perimeter(select_ent_type, edges_i);
    return all_perim_ents_i.map(perim_ent_i => [select_ent_type, perim_ent_i]);
}
// ================================================================================================
/**
* Returns a list of neighboring entities. In order to qualify as a neighbor,
* entities must not be part of the set of input entities, but must be welded to one or more entities in the input.
* ~
* @param __model__
* @param ent_type_enum Enum, select the types of neighbors to return
* @param entities List of entities.
* @returns Entities, a list of welded neighbors
* @example query.neighbor('edges', [polyline1,polyline2,polyline3])
* @example_info Returns list of edges that are welded to polyline1, polyline2, or polyline3.
*/
function Neighbor(__model__, ent_type_enum, entities) {
    if (Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["isEmptyArr"])(entities)) {
        return [];
    }
    entities = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_4__["arrMakeFlat"])(entities);
    // --- Error Check ---
    let ents_arr = null;
    if (__model__.debug) {
        if (entities !== null && entities !== undefined) {
            ents_arr = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])('query.Neighbor', 'entities', entities, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL], null);
        }
    }
    else {
        if (entities !== null && entities !== undefined) {
            // ents_arr = splitIDs('query.neighbor', 'entities', entities, [IDcheckObj.isIDList], null) as TEntTypeIdx[];
            ents_arr = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsBreak"])(entities);
        }
    }
    // --- Error Check ---
    const select_ent_type = _getEntTypeFromStr(ent_type_enum);
    const found_ents_arr = _neighbors(__model__, select_ent_type, ents_arr);
    return Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsMake"])(found_ents_arr);
}
function _neighbors(__model__, select_ent_type, ents_arr) {
    // get an array of all vertices
    const verts_i = [];
    for (const ent_arr of ents_arr) {
        const [ent_type, index] = ent_arr;
        const verts_ent_i = __model__.modeldata.geom.nav.navAnyToVert(ent_type, index);
        for (const vert_ent_i of verts_ent_i) {
            verts_i.push(vert_ent_i);
        }
    }
    // get the neighbor entities
    const all_nbor_ents_i = __model__.modeldata.geom.query.neighbor(select_ent_type, verts_i);
    return all_nbor_ents_i.map(nbor_ent_i => [select_ent_type, nbor_ent_i]);
}
// ================================================================================================
/**
 * Checks the type of an entity.
 * ~
 * For is_used_posi, returns true if the entity is a posi, and it is used by at least one vertex.
 * For is_unused_posi, it returns the opposite of is_used_posi.
 * For is_object, returns true if the entity is a point, a polyline, or a polygon.
 * For is_topology, returns true if the entity is a vertex, an edge, a wire, or a face.
 * For is_point_topology, is_polyline_topology, and is_polygon_topology, returns true
 * if the entity is a topological entity, and it is part of an object of the specified type.
 * ~
 * For is_open, returns true if the entity is a wire or polyline and is open. For is_closed, it returns the opposite of is_open.
 * For is_hole, returns ture if the entity is a wire, and it defines a hole in a face.
 * For has_holes, returns true if the entity is a face or polygon, and it has holes.
 * For has_no_holes, it returns the opposite of has_holes.
 *
 * @param __model__
 * @param entities An entity, or a list of entities.
 * @param type_query_enum Enum, select the conditions to test agains.
 * @returns Boolean or list of boolean in input sequence.
 * @example query.Type([polyline1, polyline2, polygon1], is_polyline )
 * @example_info Returns a list [true, true, false] if polyline1 and polyline2 are polylines but polygon1 is not a polyline.
 */
function Type(__model__, entities, type_query_enum) {
    if (Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["isEmptyArr"])(entities)) {
        return [];
    }
    // --- Error Check ---
    const fn_name = 'query.Type';
    let ents_arr = null;
    if (__model__.debug) {
        ents_arr = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])(fn_name, 'entities', entities, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isId, _check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL], null);
    }
    else {
        // ents_arr = splitIDs(fn_name, 'entities', entities, [IDcheckObj.isID, IDcheckObj.isIDList], null) as TEntTypeIdx|TEntTypeIdx[];
        ents_arr = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsBreak"])(entities);
    }
    // --- Error Check ---
    return _type(__model__, ents_arr, type_query_enum);
}
function _isClosed(__model__, ents_arr) {
    if (!Array.isArray(ents_arr[0])) {
        const [ent_type, index] = ents_arr;
        if (ent_type === _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON) {
            return true;
        }
        else if (ent_type !== _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].WIRE && ent_type !== _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE) {
            return false;
        }
        let wire_i = index;
        if (ent_type === _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE) {
            wire_i = __model__.modeldata.geom.nav.navPlineToWire(index);
        }
        return __model__.modeldata.geom.query.isWireClosed(wire_i);
    }
    else {
        return ents_arr.map(ents => _isClosed(__model__, ents));
    }
}
var _ETypeQueryEnum;
(function (_ETypeQueryEnum) {
    _ETypeQueryEnum["EXISTS"] = "exists";
    _ETypeQueryEnum["IS_POSI"] = "is_position";
    _ETypeQueryEnum["IS_USED_POSI"] = "is_used_posi";
    _ETypeQueryEnum["IS_UNUSED_POSI"] = "is_unused_posi";
    _ETypeQueryEnum["IS_VERT"] = "is_vertex";
    _ETypeQueryEnum["IS_EDGE"] = "is_edge";
    _ETypeQueryEnum["IS_WIRE"] = "is_wire";
    _ETypeQueryEnum["IS_FACE"] = "is_face";
    _ETypeQueryEnum["IS_POINT"] = "is_point";
    _ETypeQueryEnum["IS_PLINE"] = "is_polyline";
    _ETypeQueryEnum["IS_PGON"] = "is_polygon";
    _ETypeQueryEnum["IS_COLL"] = "is_collection";
    _ETypeQueryEnum["IS_OBJ"] = "is_object";
    _ETypeQueryEnum["IS_TOPO"] = "is_topology";
    _ETypeQueryEnum["IS_POINT_TOPO"] = "is_point_topology";
    _ETypeQueryEnum["IS_PLINE_TOPO"] = "is_polyline_topology";
    _ETypeQueryEnum["IS_PGON_TOPO"] = "is_polygon_topology";
    _ETypeQueryEnum["IS_OPEN"] = "is_open";
    _ETypeQueryEnum["IS_CLOSED"] = "is_closed";
    _ETypeQueryEnum["IS_HOLE"] = "is_hole";
    _ETypeQueryEnum["HAS_HOLES"] = "has_holes";
    _ETypeQueryEnum["HAS_NO_HOLES"] = "has_no_holes";
})(_ETypeQueryEnum || (_ETypeQueryEnum = {}));
function _exists(__model__, ent_arr) {
    const [ent_type, index] = ent_arr;
    return __model__.modeldata.geom.query.entExists(ent_type, index);
}
function _isUsedPosi(__model__, ent_arr) {
    const [ent_type, index] = ent_arr;
    if (ent_type !== _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].POSI) {
        return false;
    }
    const verts_i = __model__.modeldata.geom.nav.navPosiToVert(index);
    if (verts_i === undefined || verts_i === null) {
        return false;
    }
    return verts_i.length > 0;
}
function _isObj(__model__, ent_arr) {
    const [ent_type, index] = ent_arr;
    if (ent_type === _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].POINT || ent_type === _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE || ent_type === _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON) {
        return true;
    }
    return false;
}
function _isTopo(__model__, ent_arr) {
    const [ent_type, index] = ent_arr;
    if (ent_type === _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].VERT || ent_type === _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].EDGE || ent_type === _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].WIRE || ent_type === _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].FACE) {
        return true;
    }
    return false;
}
function _isPointTopo(__model__, ent_arr) {
    const [ent_type, index] = ent_arr;
    if (ent_type === _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].VERT || ent_type === _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].EDGE || ent_type === _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].WIRE || ent_type === _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].FACE) {
        const points_i = __model__.modeldata.geom.nav.navAnyToPoint(ent_type, index);
        if (points_i !== undefined && points_i !== null && points_i.length) {
            return true;
        }
    }
    return false;
}
function _isPlineTopo(__model__, ent_arr) {
    const [ent_type, index] = ent_arr;
    if (ent_type === _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].VERT || ent_type === _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].EDGE || ent_type === _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].WIRE || ent_type === _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].FACE) {
        const plines_i = __model__.modeldata.geom.nav.navAnyToPline(ent_type, index);
        if (plines_i !== undefined && plines_i !== null && plines_i.length) {
            return true;
        }
    }
    return false;
}
function _isPgonTopo(__model__, ent_arr) {
    const [ent_type, index] = ent_arr;
    if (ent_type === _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].VERT || ent_type === _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].EDGE || ent_type === _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].WIRE || ent_type === _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].FACE) {
        const pgons_i = __model__.modeldata.geom.nav.navAnyToPgon(ent_type, index);
        if (pgons_i !== undefined && pgons_i !== null && pgons_i.length) {
            return true;
        }
    }
    return false;
}
function _isClosed2(__model__, ent_arr) {
    const [ent_type, index] = ent_arr;
    if (ent_type === _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON) {
        return true;
    }
    else if (ent_type !== _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].WIRE && ent_type !== _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE) {
        return false;
    }
    let wire_i = index;
    if (ent_type === _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE) {
        wire_i = __model__.modeldata.geom.nav.navPlineToWire(index);
    }
    return __model__.modeldata.geom.query.isWireClosed(wire_i);
}
function _isHole(__model__, ent_arr) {
    const [ent_type, index] = ent_arr;
    if (ent_type !== _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].WIRE) {
        return false;
    }
    const face_i = __model__.modeldata.geom.nav.navWireToFace(index);
    if (face_i === undefined || face_i === null) {
        return false;
    }
    const wires_i = __model__.modeldata.geom.nav.navFaceToWire(face_i);
    return wires_i.indexOf(index) > 0;
}
function _hasNoHoles(__model__, ent_arr) {
    const [ent_type, index] = ent_arr;
    if (ent_type !== _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].FACE && ent_type !== _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON) {
        return false;
    }
    let face_i = index;
    if (ent_type === _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON) {
        face_i = __model__.modeldata.geom.nav.navPgonToFace(index);
    }
    const wires_i = __model__.modeldata.geom.nav.navFaceToWire(face_i);
    return wires_i.length === 1;
}
function _type(__model__, ents_arr, query_ent_type) {
    if (Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["getArrDepth"])(ents_arr) === 1) {
        const ent_arr = ents_arr;
        const [ent_type, _] = ent_arr;
        switch (query_ent_type) {
            case _ETypeQueryEnum.EXISTS:
                return _exists(__model__, ent_arr);
            case _ETypeQueryEnum.IS_POSI:
                return ent_type === _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].POSI;
            case _ETypeQueryEnum.IS_USED_POSI:
                return _isUsedPosi(__model__, ent_arr);
            case _ETypeQueryEnum.IS_UNUSED_POSI:
                return !_isUsedPosi(__model__, ent_arr);
            case _ETypeQueryEnum.IS_VERT:
                return ent_type === _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].VERT;
            case _ETypeQueryEnum.IS_EDGE:
                return ent_type === _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].EDGE;
            case _ETypeQueryEnum.IS_WIRE:
                return ent_type === _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].WIRE;
            case _ETypeQueryEnum.IS_FACE:
                return ent_type === _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].FACE;
            case _ETypeQueryEnum.IS_POINT:
                return ent_type === _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].POINT;
            case _ETypeQueryEnum.IS_PLINE:
                return ent_type === _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE;
            case _ETypeQueryEnum.IS_PGON:
                return ent_type === _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON;
            case _ETypeQueryEnum.IS_COLL:
                return ent_type === _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].COLL;
            case _ETypeQueryEnum.IS_OBJ:
                return _isObj(__model__, ent_arr);
            case _ETypeQueryEnum.IS_TOPO:
                return _isTopo(__model__, ent_arr);
            case _ETypeQueryEnum.IS_POINT_TOPO:
                return _isPointTopo(__model__, ent_arr);
            case _ETypeQueryEnum.IS_PLINE_TOPO:
                return _isPlineTopo(__model__, ent_arr);
            case _ETypeQueryEnum.IS_PGON_TOPO:
                return _isPgonTopo(__model__, ent_arr);
            case _ETypeQueryEnum.IS_OPEN:
                return !_isClosed2(__model__, ent_arr);
            case _ETypeQueryEnum.IS_CLOSED:
                return _isClosed2(__model__, ent_arr);
            case _ETypeQueryEnum.IS_HOLE:
                return _isHole(__model__, ent_arr);
            case _ETypeQueryEnum.HAS_HOLES:
                return !_hasNoHoles(__model__, ent_arr);
            case _ETypeQueryEnum.HAS_NO_HOLES:
                return _hasNoHoles(__model__, ent_arr);
            default:
                break;
        }
    }
    else {
        return ents_arr.map(ent_arr => _type(__model__, ent_arr, query_ent_type));
    }
}
// TODO IS_PLANAR
// TODO IS_QUAD
// ================================================================================================


/***/ }),

/***/ "./src/assets/core/modules/basic/util.ts":
/*!***********************************************!*\
  !*** ./src/assets/core/modules/basic/util.ts ***!
  \***********************************************/
/*! exports provided: _ECOmpareMethod, ModelPurge, ModelInfo, ParamInfo, EntityInfo, _EIOExportParams, _EIOExportContents, ExportIO, ModelCompare, ModelCheck, SendData */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_ECOmpareMethod", function() { return _ECOmpareMethod; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ModelPurge", function() { return ModelPurge; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ModelInfo", function() { return ModelInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ParamInfo", function() { return ParamInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EntityInfo", function() { return EntityInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_EIOExportParams", function() { return _EIOExportParams; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_EIOExportContents", function() { return _EIOExportContents; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ExportIO", function() { return ExportIO; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ModelCompare", function() { return ModelCompare; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ModelCheck", function() { return ModelCheck; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SendData", function() { return SendData; });
/* harmony import */ var _check_ids__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_check_ids */ "./src/assets/core/modules/_check_ids.ts");
/* harmony import */ var _libs_geo_info_GIModel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @libs/geo-info/GIModel */ "./src/assets/libs/geo-info/GIModel.ts");
/* harmony import */ var _libs_filesys_download__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @libs/filesys/download */ "./src/assets/libs/filesys/download.ts");
/* harmony import */ var _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @libs/geo-info/common */ "./src/assets/libs/geo-info/common.ts");
/* harmony import */ var _assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @assets/libs/util/arrs */ "./src/assets/libs/util/arrs.ts");
/* harmony import */ var _assets_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @assets/libs/geo-info/id */ "./src/assets/libs/geo-info/id.ts");
/* harmony import */ var _io__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./io */ "./src/assets/core/modules/basic/io.ts");
/**
 * The `util` module has some utility functions used for debugging.
 */
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};
/**
 *
 */







var _ECOmpareMethod;
(function (_ECOmpareMethod) {
    _ECOmpareMethod["THIS_IS_SUBSET"] = "subset";
    _ECOmpareMethod["THIS_IS_SUPERSET"] = "superset";
    _ECOmpareMethod["THIS_IS_EQUAL"] = "equal";
})(_ECOmpareMethod || (_ECOmpareMethod = {}));
// ================================================================================================
/**
 * Removes all deleted entities from the model.
 * The IDs of other entities may change as a result.
 * ~
 * For example, if 'pg0' was deleted and 'pg1' still exists, then after purge
 * 'pg1' will get renumbered, and will get the ID 'pg0'.
 *
 * @param __model__
 * @returns void
 */
function ModelPurge(__model__) {
    __model__.purge();
}
// ================================================================================================
/**
 * Returns an html string representation of the contents of this model
 *
 * @param __model__
 * @returns Text that summarises what is in the model, click print to see this text.
 */
function ModelInfo(__model__) {
    let info = '<h4>Model Information:</h4>';
    info += '<ul>';
    // model attribs
    const model_attribs = __model__.modeldata.attribs.query.getAttribNames(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].MOD);
    if (model_attribs.length !== 0) {
        info += '<li>Model attribs: ' + model_attribs.join(', ') + '</li>';
    }
    // collections
    const num_colls = __model__.modeldata.geom.query.numEnts(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].COLL);
    // const num_del_colls: number = __model__.modeldata.geom.query.numEnts(EEntType.COLL, true) - num_colls;
    const coll_attribs = __model__.modeldata.attribs.query.getAttribNames(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].COLL);
    info += '<li>';
    info += '<b>Collections</b>: ' + num_colls; // + ' (Deleted: ' + num_del_colls + ') ';
    if (coll_attribs.length !== 0) {
        info += 'Attribs: ' + coll_attribs.join(', ');
    }
    info += '</li>';
    // pgons
    const num_pgons = __model__.modeldata.geom.query.numEnts(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].PGON);
    // const num_del_pgons: number = __model__.modeldata.geom.query.numEnts(EEntType.PGON, true) - num_pgons;
    const pgon_attribs = __model__.modeldata.attribs.query.getAttribNames(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].PGON);
    info += '<li>';
    info += '<b>Polygons</b>: ' + num_pgons; // + ' (Deleted: ' + num_del_pgons + ') ';
    if (pgon_attribs.length !== 0) {
        info += 'Attribs: ' + pgon_attribs.join(', ');
    }
    info += '</li>';
    // plines
    const num_plines = __model__.modeldata.geom.query.numEnts(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].PLINE);
    // const num_del_plines: number = __model__.modeldata.geom.query.numEnts(EEntType.PLINE, true) - num_plines;
    const pline_attribs = __model__.modeldata.attribs.query.getAttribNames(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].PLINE);
    info += '<li>';
    info += '<b>Polylines</b>: ' + num_plines; // + ' (Deleted: ' + num_del_plines + ') ';
    if (pline_attribs.length !== 0) {
        info += 'Attribs: ' + pline_attribs.join(', ');
    }
    info += '</li>';
    // points
    const num_points = __model__.modeldata.geom.query.numEnts(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].POINT);
    // const num_del_points: number = __model__.modeldata.geom.query.numEnts(EEntType.POINT, true) - num_points;
    const point_attribs = __model__.modeldata.attribs.query.getAttribNames(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].POINT);
    info += '<li>';
    info += '<b>Points</b>: ' + num_points; // + ' (Deleted: ' + num_del_points + ') ';
    if (point_attribs.length !== 0) {
        info += 'Attribs: ' + point_attribs.join(', ');
    }
    info += '</li>';
    // faces
    const num_faces = __model__.modeldata.geom.query.numEnts(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].FACE);
    // const num_del_faces: number = __model__.modeldata.geom.query.numEnts(EEntType.FACE, true) - num_faces;
    const face_attribs = __model__.modeldata.attribs.query.getAttribNames(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].FACE);
    info += '<li>';
    info += '<b>Faces</b>: ' + num_faces; // + ' (Deleted: ' + num_del_faces + ') ';
    if (face_attribs.length !== 0) {
        info += 'Attribs: ' + face_attribs.join(', ');
    }
    info += '</li>';
    // wires
    const num_wires = __model__.modeldata.geom.query.numEnts(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].WIRE);
    // const num_del_wires: number = __model__.modeldata.geom.query.numEnts(EEntType.WIRE, true) - num_wires;
    const wire_attribs = __model__.modeldata.attribs.query.getAttribNames(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].WIRE);
    info += '<li>';
    info += '<b>Wires</b>: ' + num_wires; // + ' (Deleted: ' + num_del_wires + ') ';
    if (wire_attribs.length !== 0) {
        info += 'Attribs: ' + wire_attribs.join(', ');
    }
    info += '</li>';
    // edges
    const num_edges = __model__.modeldata.geom.query.numEnts(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].EDGE);
    // const num_del_edges: number = __model__.modeldata.geom.query.numEnts(EEntType.EDGE, true) - num_edges;
    const edge_attribs = __model__.modeldata.attribs.query.getAttribNames(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].EDGE);
    info += '<li>';
    info += '<b>Edges</b>: ' + num_edges; // + ' (Deleted: ' + num_del_edges + ') ';
    if (edge_attribs.length !== 0) {
        info += 'Attribs: ' + edge_attribs.join(', ');
    }
    info += '</li>';
    // verts
    const num_verts = __model__.modeldata.geom.query.numEnts(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].VERT);
    // const num_del_verts: number = __model__.modeldata.geom.query.numEnts(EEntType.VERT, true) - num_verts;
    const vert_attribs = __model__.modeldata.attribs.query.getAttribNames(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].VERT);
    info += '<li>';
    info += '<b>Vertices</b>: ' + num_verts; // + ' (Deleted: ' + num_del_verts + ') ';
    if (vert_attribs.length !== 0) {
        info += 'Attribs: ' + vert_attribs.join(', ');
    }
    info += '</li>';
    // posis
    const num_posis = __model__.modeldata.geom.query.numEnts(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].POSI);
    // const num_del_posis: number = __model__.modeldata.geom.query.numEnts(EEntType.POSI, true) - num_posis;
    const posi_attribs = __model__.modeldata.attribs.query.getAttribNames(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].POSI);
    info += '<li>';
    info += '<b>Positions</b>: ' + num_posis; // + ' (Deleted: ' + num_del_posis + ') ';
    if (posi_attribs.length !== 0) {
        info += 'Attribs: ' + posi_attribs.join(', ');
    }
    info += '</li>';
    // end
    info += '</ul>';
    // return the string
    return info;
}
// ================================================================================================
/**
 * Returns am html string representation of the parameters in this model
 *
 * @param __model__
 * @param __constList__
 * @returns Text that summarises what is in the model.
 */
function ParamInfo(__model__, __constList__) {
    return JSON.stringify(__constList__);
}
// ================================================================================================
/**
 * Returns an html string representation of one or more entities in the model.
 * ~
 * @param __model__
 * @param entities One or more objects ot collections.
 * @returns void
 */
function EntityInfo(__model__, entities) {
    entities = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_4__["arrMakeFlat"])(entities);
    // --- Error Check ---
    const fn_name = 'collection.Info';
    let ents_arr;
    if (__model__.debug) {
        ents_arr = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])(fn_name, 'coll', entities, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isId, _check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL], [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].COLL, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].PGON, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].PLINE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].POINT]);
    }
    else {
        // ents_arr = splitIDs(fn_name, 'coll', entities,
        //     [IDcheckObj.isID, IDcheckObj.isIDList],
        //     [EEntType.COLL, EEntType.PGON, EEntType.PLINE, EEntType.POINT]) as TEntTypeIdx[];
        ents_arr = Object(_assets_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_5__["idsBreak"])(entities);
    }
    // --- Error Check ---
    let result = '<h4>Entity Information:</h4>';
    for (const ent_arr of ents_arr) {
        const [ent_type, ent_i] = ent_arr;
        switch (ent_type) {
            case _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].COLL:
                result += _collInfo(__model__, ent_i);
                break;
            case _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].PGON:
                result += _pgonInfo(__model__, ent_i);
                break;
            case _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].PLINE:
                result += _plineInfo(__model__, ent_i);
                break;
            case _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].POINT:
                result += _pointInfo(__model__, ent_i);
                break;
            default:
                break;
        }
    }
    return result;
}
function _getAttribs(__model__, ent_type, ent_i) {
    const names = __model__.modeldata.attribs.query.getAttribNames(ent_type);
    const attribs_with_vals = [];
    for (const name of names) {
        const val = __model__.modeldata.attribs.query.getAttribVal(ent_type, name, ent_i);
        if (val !== undefined) {
            attribs_with_vals.push(name);
        }
    }
    return attribs_with_vals;
}
function _getColls(__model__, ent_type, ent_i) {
    let colls_i = [];
    if (ent_type === _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].COLL) {
        const parent = __model__.modeldata.geom.query.getCollParent(ent_i);
        if (parent !== -1) {
            colls_i = [parent];
        }
    }
    else {
        colls_i = __model__.modeldata.geom.nav.navAnyToColl(ent_type, ent_i);
    }
    const colls_names = [];
    for (const coll_i of colls_i) {
        let coll_name = 'No name';
        if (__model__.modeldata.attribs.query.hasAttrib(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].COLL, 'name')) {
            coll_name = __model__.modeldata.attribs.query.getAttribVal(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].COLL, 'name', coll_i);
        }
        colls_names.push(coll_name);
    }
    return colls_names;
}
function _pointInfo(__model__, point_i) {
    let info = '';
    // get the data
    const attribs = _getAttribs(__model__, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].POINT, point_i);
    const colls_names = _getColls(__model__, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].POINT, point_i);
    // make str
    info += '<ul>';
    info += '<li>Type: <b>Point</b></li>';
    info += '<ul>';
    if (attribs.length !== 0) {
        info += '<li>Attribs: ' + attribs.join(', ') + '</li>';
    }
    if (colls_names.length === 1) {
        info += '<li>In collection: ' + colls_names[0] + '</li>';
    }
    else if (colls_names.length > 1) {
        info += '<li>In ' + colls_names.length + ' collections: ' + colls_names.join(', ') + '</li>';
    }
    info += '</ul>';
    info += '</ul>';
    return info;
}
function _plineInfo(__model__, pline_i) {
    let info = '';
    // get the data
    const attribs = _getAttribs(__model__, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].PLINE, pline_i);
    const num_verts = __model__.modeldata.geom.nav.navAnyToVert(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].PLINE, pline_i).length;
    const num_edges = __model__.modeldata.geom.nav.navAnyToEdge(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].PLINE, pline_i).length;
    const colls_names = _getColls(__model__, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].PLINE, pline_i);
    // make str
    info += '<ul>';
    info += '<li>Type: <b>Polyline</b></li>';
    info += '<ul>';
    if (attribs.length !== 0) {
        info += '<li>Attribs: ' + attribs.join(', ') + '</li>';
    }
    if (num_verts) {
        info += '<li>Num verts: ' + num_verts + '</li>';
    }
    if (num_edges) {
        info += '<li>Num edges: ' + num_edges + '</li>';
    }
    if (colls_names.length === 1) {
        info += '<li>In collection: ' + colls_names[0] + '</li>';
    }
    else if (colls_names.length > 1) {
        info += '<li>In ' + colls_names.length + ' collections: ' + colls_names.join(', ') + '</li>';
    }
    info += '</ul>';
    info += '</ul>';
    return info;
}
function _pgonInfo(__model__, pgon_i) {
    let info = '';
    // get the data
    const attribs = _getAttribs(__model__, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].PGON, pgon_i);
    const num_verts = __model__.modeldata.geom.nav.navAnyToVert(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].PGON, pgon_i).length;
    const num_edges = __model__.modeldata.geom.nav.navAnyToEdge(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].PGON, pgon_i).length;
    const num_wires = __model__.modeldata.geom.nav.navAnyToWire(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].PGON, pgon_i).length;
    const colls_i = __model__.modeldata.geom.nav.navPgonToColl(pgon_i);
    const colls_names = _getColls(__model__, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].PGON, pgon_i);
    // make str
    info += '<ul>';
    info += '<li>Type: <b>Polygon</b></li>';
    info += '<ul>';
    if (attribs.length !== 0) {
        info += '<li>Attribs: ' + attribs.join(', ') + '</li>';
    }
    if (num_verts) {
        info += '<li>Num verts: ' + num_verts + '</li>';
    }
    if (num_edges) {
        info += '<li>Num edges: ' + num_edges + '</li>';
    }
    if (num_wires) {
        info += '<li>Num wires: ' + num_wires + '</li>';
    }
    if (colls_i.length === 1) {
        info += '<li>In collection: ' + colls_names[0] + '</li>';
    }
    else if (colls_i.length > 1) {
        info += '<li>In ' + colls_i.length + ' collections: ' + colls_names.join(', ') + '</li>';
    }
    info += '</ul>';
    info += '</ul>';
    return info;
}
function _collInfo(__model__, coll_i) {
    let info = '';
    // get the data
    let coll_name = 'None';
    if (__model__.modeldata.attribs.query.hasAttrib(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].COLL, 'name')) {
        coll_name = __model__.modeldata.attribs.query.getAttribVal(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].COLL, 'name', coll_i);
    }
    const attribs = _getAttribs(__model__, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].COLL, coll_i);
    const num_pgons = __model__.modeldata.geom.nav.navCollToPgon(coll_i).length;
    const num_plines = __model__.modeldata.geom.nav.navCollToPline(coll_i).length;
    const num_points = __model__.modeldata.geom.nav.navCollToPoint(coll_i).length;
    const colls_names = _getColls(__model__, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].COLL, coll_i);
    // make str
    info += '<ul>';
    info += '<li>Type: <b>Collection</b></li>';
    info += '<ul>';
    info += '<li>Name: <b>' + coll_name + '</b></li>';
    if (attribs.length !== 0) {
        info += '<li>Attribs: ' + attribs.join(', ') + '</li>';
    }
    if (num_pgons) {
        info += '<li>Num pgons: ' + num_pgons + '</li>';
    }
    if (num_plines) {
        info += '<li>Num plines: ' + num_plines + '</li>';
    }
    if (num_points) {
        info += '<li>Num points: ' + num_points + '</li>';
    }
    if (colls_names.length === 1) {
        info += '<li>In collection: ' + colls_names[0] + '</li>';
    }
    else if (colls_names.length > 1) {
        info += '<li>In ' + colls_names.length + ' collections: ' + colls_names.join(', ') + '</li>';
    }
    const children = __model__.modeldata.geom.query.getCollChildren(coll_i);
    if (children.length > 0) {
        info += '<li>Child collections: </li>';
        for (const child of children) {
            info += _collInfo(__model__, child);
        }
    }
    info += '</ul>';
    info += '</ul>';
    return info;
}
// ================================================================================================
var _EIOExportParams;
(function (_EIOExportParams) {
    _EIOExportParams["YES"] = "Add Params";
    _EIOExportParams["NO"] = "No Params";
})(_EIOExportParams || (_EIOExportParams = {}));
var _EIOExportContents;
(function (_EIOExportContents) {
    _EIOExportContents["BOTH"] = "Both";
    _EIOExportContents["CONSOLE"] = "Console Only";
    _EIOExportContents["MODEL"] = "Model Only";
})(_EIOExportContents || (_EIOExportContents = {}));
/**
 * Export data from the model as a file.
 * This will result in a popup in your browser, asking you to save the filel.
 * @param __model__
 * @param __console__
 * @param __constList__
 * @param __fileName__
 * @param file_name Name of the file as a string.
 * @param exportParams Enum.
 * @param exportContent Enum.
 * @returns Boolean.
 * @example util.ExportIO('my_model.json')
 * @example_info Exports all the data in the model as an OBJ.
 */
function ExportIO(__model__, __console__, __constList__, __fileName__, file_name, exportParams, exportContent) {
    // let gi_data: string = JSON.stringify(__model__.getData());
    // gi_data = gi_data.replace(/\\\"/g, '\\\\\\"'); // TODO temporary fix
    const consolidatedConsole = [];
    for (const logStr of __console__) {
        if (!logStr.match('<p style="padding: 2px 0px 2px 10px;"><b><i>')) {
            continue;
        }
        const replacedStr = logStr.replace('<p style="padding: 2px 0px 2px 10px;"><b><i>', '')
            .replace('</i></b> ', '').replace('</p>', '').replace('<br>', '\n');
        consolidatedConsole.push(replacedStr);
    }
    const newConstList = {};
    for (const obj in __constList__) {
        if (__constList__.hasOwnProperty(obj)) {
            newConstList[obj] = convertString(__constList__[obj]);
        }
    }
    const edxAnswer = {
        'fileName': __fileName__,
        'params': newConstList,
        'console': consolidatedConsole.join('\n'),
        'model': __model__.getModelData()
    };
    if (exportParams === _EIOExportParams.NO) {
        edxAnswer['params'] = undefined;
    }
    if (exportContent === _EIOExportContents.CONSOLE) {
        edxAnswer['model'] = undefined;
    }
    else if (exportContent === _EIOExportContents.MODEL) {
        edxAnswer['console'] = undefined;
    }
    return Object(_libs_filesys_download__WEBPACK_IMPORTED_MODULE_2__["download"])(JSON.stringify(edxAnswer), file_name);
}
function convertString(value) {
    let val;
    if (!value) {
        val = value;
    }
    else if (typeof value === 'number' || value === undefined) {
        val = value;
    }
    else if (typeof value === 'string') {
        val = '"' + value + '"';
    }
    else if (value.constructor === [].constructor) {
        val = JSON.stringify(value);
    }
    else if (value.constructor === {}.constructor) {
        val = JSON.stringify(value);
    }
    else {
        val = value;
    }
    return val;
}
// ================================================================================================
/**
 * Compare the GI data in this model to the GI data in another model.
 * ~
 * If method = subset, then this model is the answer, and the other model is the submitted model.
 * It will check that all entites in this model also exist in the other model.
 * ~
 * If method = superset, then this model is the submitted model, and the other model is the answer model.
 * It will check that all entites in the other model also exist in this model.
 * ~
 * For specifying the location of the GI Model, you can either specify a URL,
 * or the name of a file in LocalStorage.
 * In the latter case, you do not specify a path, you just specify the file name, e.g. 'my_model.gi'
 *
 * @param __model__
 * @param input_data The location of the GI Model to compare this model to.
 * @param method Enum, method used to compare this model to the other model specified in the gi_model parameter.
 * @returns Text that summarises the comparison between the two models.
 */
function ModelCompare(__model__, input_data, method) {
    return __awaiter(this, void 0, void 0, function* () {
        const gi_model = yield Object(_io__WEBPACK_IMPORTED_MODULE_6__["_getFile"])(input_data);
        const gi_obj = JSON.parse(gi_model);
        const other_model = new _libs_geo_info_GIModel__WEBPACK_IMPORTED_MODULE_1__["GIModel"]();
        other_model.setModelData(gi_obj);
        let result = null;
        // compare function has three boolean args
        // normalize: boolean
        // check_geom_equality: boolean
        // check_attrib_equality: boolean
        switch (method) {
            case _ECOmpareMethod.THIS_IS_SUBSET:
                result = __model__.compare(other_model, true, false, false);
                break;
            case _ECOmpareMethod.THIS_IS_SUPERSET:
                result = other_model.compare(__model__, true, false, false);
                break;
            case _ECOmpareMethod.THIS_IS_EQUAL:
                result = __model__.compare(other_model, true, true, false);
                break;
            default:
                throw new Error('Compare method not recognised');
        }
        return result.comment;
    });
}
// ================================================================================================
/**
 * Check the internal consistency of the model.
 *
 * @param __model__
 * @returns Text that summarises what is in the model, click print to see this text.
 */
function ModelCheck(__model__) {
    console.log('==== ==== ==== ====');
    console.log('MODEL GEOM\n', __model__.modeldata.geom.toStr());
    console.log('MODEL ATTRIBS\n', __model__.modeldata.attribs.toStr());
    console.log('META\n', __model__.metadata.toDebugStr());
    console.log('==== ==== ==== ====');
    console.log(__model__);
    const check = __model__.check();
    if (check.length > 0) {
        return String(check);
    }
    return 'No internal inconsistencies have been found.';
}
// ================================================================================================
/**
 * Post a message to the parent window.
 *
 * @param __model__
 * @param data The data to send, a list or a dictionary.
 * @returns Text that summarises what is in the model, click print to see this text.
 */
function SendData(__model__, data) {
    window.parent.postMessage(data, '*');
}
// ================================================================================================


/***/ }),

/***/ "./src/assets/core/modules/basic/visualize.ts":
/*!****************************************************!*\
  !*** ./src/assets/core/modules/basic/visualize.ts ***!
  \****************************************************/
/*! exports provided: _ESide, _Ecolors, Color, Gradient, _EColorRampMethod, _EEdgeMethod, Edge, _EMeshMethod, Mesh, Ray, Plane, BBox */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_ESide", function() { return _ESide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_Ecolors", function() { return _Ecolors; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Color", function() { return Color; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Gradient", function() { return Gradient; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_EColorRampMethod", function() { return _EColorRampMethod; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_EEdgeMethod", function() { return _EEdgeMethod; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Edge", function() { return Edge; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_EMeshMethod", function() { return _EMeshMethod; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Mesh", function() { return Mesh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Ray", function() { return Ray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Plane", function() { return Plane; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BBox", function() { return BBox; });
/* harmony import */ var _check_ids__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_check_ids */ "./src/assets/core/modules/_check_ids.ts");
/* harmony import */ var _check_args__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_check_args */ "./src/assets/core/modules/_check_args.ts");
/* harmony import */ var _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @libs/geo-info/common */ "./src/assets/libs/geo-info/common.ts");
/* harmony import */ var _libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @libs/geo-info/id */ "./src/assets/libs/geo-info/id.ts");
/* harmony import */ var _assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @assets/libs/util/arrs */ "./src/assets/libs/util/arrs.ts");
/* harmony import */ var _assets_core_inline_math__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @assets/core/inline/_math */ "./src/assets/core/inline/_math.ts");
/* harmony import */ var _assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @assets/libs/geom/vectors */ "./src/assets/libs/geom/vectors.ts");
/* harmony import */ var chroma_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! chroma-js */ "./node_modules/chroma-js/chroma.js");
/* harmony import */ var chroma_js__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(chroma_js__WEBPACK_IMPORTED_MODULE_7__);
/**
 * The `visualize` module has functions for defining various settings for the 3D viewer.
 * Color is saved as vertex attributes.
 */
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};
/**
 *
 */









// ================================================================================================
var _ESide;
(function (_ESide) {
    _ESide["FRONT"] = "front";
    _ESide["BACK"] = "back";
    _ESide["BOTH"] = "both";
})(_ESide || (_ESide = {}));
var _Ecolors;
(function (_Ecolors) {
    _Ecolors["NO_VERT_COLORS"] = "none";
    _Ecolors["VERT_COLORS"] = "apply_rgb";
})(_Ecolors || (_Ecolors = {}));
// ================================================================================================
/**
 * Sets color by creating a vertex attribute called 'rgb' and setting the value.
 * ~
 * @param entities The entities for which to set the color.
 * @param color The color, [0,0,0] is black, [1,1,1] is white.
 * @returns void
 */
function Color(__model__, entities, color) {
    entities = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_4__["arrMakeFlat"])(entities);
    if (Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["isEmptyArr"])(entities)) {
        return;
    }
    // --- Error Check ---
    const fn_name = 'visualize.Color';
    let ents_arr = null;
    if (__model__.debug) {
        if (entities !== null) {
            ents_arr = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])(fn_name, 'entities', entities, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isId, _check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL, _check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdLL], null);
        }
        Object(_check_args__WEBPACK_IMPORTED_MODULE_1__["checkArgs"])(fn_name, 'color', color, [_check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isColor]);
    }
    else {
        // if (entities !== null) {
        //     ents_arr = splitIDs(fn_name, 'entities', entities,
        //         [IDcheckObj.isID, IDcheckObj.isIDList, IDcheckObj.isIDListOfLists], null) as TEntTypeIdx[];
        // }
        ents_arr = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsBreak"])(entities);
    }
    // --- Error Check ---
    _color(__model__, ents_arr, color);
}
function _color(__model__, ents_arr, color) {
    if (!__model__.modeldata.attribs.query.hasAttrib(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].VERT, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EAttribNames"].COLOR)) {
        __model__.modeldata.attribs.add.addAttrib(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].VERT, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EAttribNames"].COLOR, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EAttribDataTypeStrs"].LIST);
    }
    // make a list of all the verts
    let all_verts_i = [];
    if (ents_arr === null) {
        all_verts_i = __model__.modeldata.geom.query.getEnts(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].VERT);
    }
    else {
        for (const ent_arr of ents_arr) {
            const [ent_type, ent_i] = ent_arr;
            if (ent_type === _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].VERT) {
                all_verts_i.push(ent_i);
            }
            else {
                const verts_i = __model__.modeldata.geom.nav.navAnyToVert(ent_type, ent_i);
                for (const vert_i of verts_i) {
                    all_verts_i.push(vert_i);
                }
            }
        }
    }
    // set all verts to have same color
    __model__.modeldata.attribs.add.setEntAttribVal(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].VERT, all_verts_i, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EAttribNames"].COLOR, color);
}
// ================================================================================================
/**
 * Generates a colour range based on a numeric attribute.
 * Sets the color by creating a vertex attribute called 'rgb' and setting the value.
 * ~
 * @param entities The entities for which to set the color.
 * @param attrib The numeric attribute to be used to create the gradient.
 * You can spacify an attribute with an index. For example, ['xyz', 2] will create a gradient based on height.
 * @param range The range of the attribute, [minimum, maximum].
 * If only one number, it defaults to [0, maximum]. If null, then the range will be auto-calculated.
 * @param method Enum, the colour gradient to use.
 * @returns void
 */
function Gradient(__model__, entities, attrib, range, method) {
    entities = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_4__["arrMakeFlat"])(entities);
    if (!Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["isEmptyArr"])(entities)) {
        // --- Error Check ---
        const fn_name = 'visualize.Gradient';
        let ents_arr = null;
        let attrib_name;
        let attrib_idx_or_key;
        if (__model__.debug) {
            ents_arr = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])(fn_name, 'entities', entities, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isId, _check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL, _check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdLL], null);
            Object(_check_args__WEBPACK_IMPORTED_MODULE_1__["checkArgs"])(fn_name, 'attrib', attrib, [_check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isStr, _check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isStrStr, _check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isStrNum]);
            Object(_check_args__WEBPACK_IMPORTED_MODULE_1__["checkArgs"])(fn_name, 'range', range, [_check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isNull, _check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isNum, _check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isNumL]);
            attrib_name = Array.isArray(attrib) ? attrib[0] : attrib;
            attrib_idx_or_key = Array.isArray(attrib) ? attrib[1] : null;
            if (!__model__.modeldata.attribs.query.hasAttrib(ents_arr[0][0], attrib_name)) {
                throw new Error(fn_name + ': The attribute with name "' + attrib + '" does not exist on these entities.');
            }
            else {
                let data_type = null;
                if (attrib_idx_or_key === null) {
                    data_type = __model__.modeldata.attribs.query.getAttribDataType(ents_arr[0][0], attrib_name);
                }
                else {
                    const first_val = __model__.modeldata.attribs.query.getAttribValAny(ents_arr[0][0], attrib_name, ents_arr[0][1], attrib_idx_or_key);
                }
                if (data_type !== _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EAttribDataTypeStrs"].NUMBER) {
                    throw new Error(fn_name + ': The attribute with name "' + attrib_name + '" is not a number data type.' +
                        'For generating a gradient, the attribute must be a number.');
                }
            }
        }
        else {
            // ents_arr = splitIDs(fn_name, 'entities', entities,
            //     [IDcheckObj.isID, IDcheckObj.isIDList, IDcheckObj.isIDListOfLists], null) as TEntTypeIdx[];
            ents_arr = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsBreak"])(entities);
            attrib_name = Array.isArray(attrib) ? attrib[0] : attrib;
            attrib_idx_or_key = Array.isArray(attrib) ? attrib[1] : null;
        }
        // --- Error Check ---
        if (range === null) {
            range = [null, null];
        }
        range = Array.isArray(range) ? range : [0, range];
        _gradient(__model__, ents_arr, attrib_name, attrib_idx_or_key, range, method);
    }
}
// https://codesandbox.io/s/5w573r54w4
var _EColorRampMethod;
(function (_EColorRampMethod) {
    _EColorRampMethod["FALSE_COLOR"] = "false_color";
    _EColorRampMethod["BLACK_BODY"] = "black_body";
    _EColorRampMethod["WHITE_RED"] = "white_red";
    _EColorRampMethod["WHITE_GREEN"] = "white_green";
    _EColorRampMethod["WHITE_BLUE"] = "white_blue";
    _EColorRampMethod["BLUE_RED"] = "blue_red";
    _EColorRampMethod["GREEN_RED"] = "green_red";
    _EColorRampMethod["BLUE_GREEN"] = "blue_green";
    _EColorRampMethod["GREY_SCALE"] = "grey_scale";
    _EColorRampMethod["ORRD"] = "OrRd";
    _EColorRampMethod["PUBU"] = "PuBu";
    _EColorRampMethod["BUPU"] = "BuPu";
    _EColorRampMethod["ORANGES"] = "Oranges";
    _EColorRampMethod["BUGN"] = "BuGn";
    _EColorRampMethod["YLORBR"] = "YlOrBr";
    _EColorRampMethod["YLGN"] = "YlGn";
    _EColorRampMethod["REDS"] = "Reds";
    _EColorRampMethod["RDPU"] = "RdPu";
    _EColorRampMethod["GREENS"] = "Greens";
    _EColorRampMethod["YLGNBU"] = "YlGnBu";
    _EColorRampMethod["PURPLES"] = "Purples";
    _EColorRampMethod["GNBU"] = "GnBu";
    _EColorRampMethod["GREYS"] = "Greys";
    _EColorRampMethod["YLORRD"] = "YlOrRd";
    _EColorRampMethod["PURD"] = "PuRd";
    _EColorRampMethod["BLUES"] = "Blues";
    _EColorRampMethod["PUBUGN"] = "PuBuGn";
    _EColorRampMethod["VIRIDIS"] = "Viridis";
    _EColorRampMethod["SPECTRAL"] = "Spectral";
    _EColorRampMethod["RDYLGN"] = "RdYlGn";
    _EColorRampMethod["RDBU"] = "RdBu";
    _EColorRampMethod["PIYG"] = "PiYG";
    _EColorRampMethod["PRGN"] = "PRGn";
    _EColorRampMethod["RDYLBU"] = "RdYlBu";
    _EColorRampMethod["BRBG"] = "BrBG";
    _EColorRampMethod["RDGY"] = "RdGy";
    _EColorRampMethod["PUOR"] = "PuOr";
    _EColorRampMethod["SET2"] = "Set2";
    _EColorRampMethod["ACCENT"] = "Accent";
    _EColorRampMethod["SET1"] = "Set1";
    _EColorRampMethod["SET3"] = "Set3";
    _EColorRampMethod["DARK2"] = "Dark2";
    _EColorRampMethod["PAIRED"] = "Paired";
    _EColorRampMethod["PASTEL2"] = "Pastel2";
    _EColorRampMethod["PASTEL1"] = "Pastel1";
})(_EColorRampMethod || (_EColorRampMethod = {}));
function _gradient(__model__, ents_arr, attrib_name, idx_or_key, range, method) {
    if (!__model__.modeldata.attribs.query.hasAttrib(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].VERT, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EAttribNames"].COLOR)) {
        __model__.modeldata.attribs.add.addAttrib(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].VERT, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EAttribNames"].COLOR, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EAttribDataTypeStrs"].LIST);
    }
    // get the ents
    const first_ent_type = ents_arr[0][0];
    const ents_i = ents_arr.map(ent_arr => ent_arr[1]);
    // push the attrib down from the ent to its verts
    if (first_ent_type !== _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].VERT) {
        __model__.modeldata.attribs.add.pushAttribVals(first_ent_type, attrib_name, idx_or_key, ents_i, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].VERT, attrib_name, null, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EAttribPush"].AVERAGE);
    }
    // make a list of all the verts
    const all_verts_i = [];
    for (const ent_arr of ents_arr) {
        const [ent_type, ent_i] = ent_arr;
        if (ent_type === _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].VERT) {
            all_verts_i.push(ent_i);
        }
        else {
            const verts_i = __model__.modeldata.geom.nav.navAnyToVert(ent_type, ent_i);
            for (const vert_i of verts_i) {
                all_verts_i.push(vert_i);
            }
        }
    }
    // get the attribute values
    const vert_values = __model__.modeldata.attribs.query.getAttribVal(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].VERT, attrib_name, all_verts_i);
    // if range[0] is null, get min value
    if (range[0] === null) {
        range[0] = Object(_assets_core_inline_math__WEBPACK_IMPORTED_MODULE_5__["min"])(vert_values);
    }
    // if range[1] is null. get max value
    if (range[1] === null) {
        range[1] = Object(_assets_core_inline_math__WEBPACK_IMPORTED_MODULE_5__["max"])(vert_values);
    }
    // create color scale
    const scales = {
        'false_color': ['blue', 'cyan', 'green', 'yellow', 'red'],
        'black_body': ['black', 'red', 'yellow', 'white'],
        'white_red': ['white', 'red'],
        'white_blue': ['white', 'blue'],
        'white_green': ['white', 'green'],
        'blue_red': ['blue', 'red'],
        'green_red': ['green', 'red'],
        'blue_green': ['blue', 'green'],
        'grey_scale': ['white', 'black']
    };
    let scale = null;
    if (method in scales) {
        scale = scales[method];
    }
    else {
        scale = method;
    }
    const col_scale = chroma_js__WEBPACK_IMPORTED_MODULE_7__["scale"](scale);
    const col_domain = col_scale.domain(range);
    // make a values map, grouping together all the verts that have the same value
    const values_map = new Map();
    for (let i = 0; i < all_verts_i.length; i++) {
        if (!values_map.has(vert_values[i])) {
            // const col: TColor = colFalse(vert_values[i], range[0], range[1]);
            const ch_col = col_domain(vert_values[i]).gl();
            const col = [ch_col[0], ch_col[1], ch_col[2]];
            values_map.set(vert_values[i], [col, [all_verts_i[i]]]);
        }
        else {
            values_map.get(vert_values[i])[1].push(all_verts_i[i]);
        }
    }
    // set color of each group of verts
    values_map.forEach((col_and_verts_i) => {
        const col = col_and_verts_i[0];
        const verts_i = col_and_verts_i[1];
        __model__.modeldata.attribs.add.setEntAttribVal(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].VERT, verts_i, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EAttribNames"].COLOR, col);
    });
}
// ================================================================================================
var _EEdgeMethod;
(function (_EEdgeMethod) {
    _EEdgeMethod["VISIBLE"] = "visible";
    _EEdgeMethod["HIDDEN"] = "hidden";
})(_EEdgeMethod || (_EEdgeMethod = {}));
/**
 * Controls how edges are visualized by setting the visibility of the edge.
 * ~
 * The method can either be 'visible' or 'hidden'.
 * 'visible' means that an edge line will be visible.
 * 'hidden' means that no edge lines will be visible.
 * ~
 * @param entities A list of edges, or other entities from which edges can be extracted.
 * @param method Enum, visible or hidden.
 * @returns void
 */
function Edge(__model__, entities, method) {
    entities = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_4__["arrMakeFlat"])(entities);
    if (Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["isEmptyArr"])(entities)) {
        return;
    }
    // --- Error Check ---
    const fn_name = 'visualize.Edge';
    let ents_arr = null;
    if (__model__.debug) {
        if (entities !== null) {
            ents_arr = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])(fn_name, 'entities', entities, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL], null);
        }
    }
    else {
        // if (entities !== null) {
        //     ents_arr = splitIDs(fn_name, 'entities', entities,
        //         [IDcheckObj.isIDList], null) as TEntTypeIdx[];
        // }
        ents_arr = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsBreak"])(entities);
    }
    // --- Error Check ---
    if (!__model__.modeldata.attribs.query.hasAttrib(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].EDGE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EAttribNames"].VISIBILITY)) {
        if (method === _EEdgeMethod.VISIBLE) {
            return;
        }
        else {
            __model__.modeldata.attribs.add.addAttrib(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].EDGE, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EAttribNames"].VISIBILITY, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EAttribDataTypeStrs"].STRING);
        }
    }
    // Get the unique edges
    let edges_i = [];
    if (ents_arr !== null) {
        const set_edges_i = new Set();
        for (const [ent_type, ent_i] of ents_arr) {
            if (ent_type === _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].EDGE) {
                set_edges_i.add(ent_i);
            }
            else {
                const ent_edges_i = __model__.modeldata.geom.nav.navAnyToEdge(ent_type, ent_i);
                for (const ent_edge_i of ent_edges_i) {
                    set_edges_i.add(ent_edge_i);
                }
            }
        }
        edges_i = Array.from(set_edges_i);
    }
    else {
        edges_i = __model__.modeldata.geom.query.getEnts(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].EDGE);
    }
    // Set edge visibility
    const setting = method === _EEdgeMethod.VISIBLE ? null : 'hidden';
    __model__.modeldata.attribs.add.setEntAttribVal(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].EDGE, edges_i, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EAttribNames"].VISIBILITY, setting);
}
// ================================================================================================
var _EMeshMethod;
(function (_EMeshMethod) {
    _EMeshMethod["FACETED"] = "faceted";
    _EMeshMethod["SMOOTH"] = "smooth";
})(_EMeshMethod || (_EMeshMethod = {}));
/**
 * Controls how polygon meshes are visualized by creating normals on vertices.
 * ~
 * The method can either be 'faceted' or 'smooth'.
 * 'faceted' means that the normal direction for each vertex will be perpendicular to the polygon to which it belongs.
 * 'smooth' means that the normal direction for each vertex will be the average of all polygons welded to this vertex.
 * ~
 * @param entities Vertices belonging to polygons, or entities from which polygon vertices can be extracted.
 * @param method Enum, the types of normals to create, faceted or smooth.
 * @returns void
 */
function Mesh(__model__, entities, method) {
    entities = Object(_assets_libs_util_arrs__WEBPACK_IMPORTED_MODULE_4__["arrMakeFlat"])(entities);
    if (Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["isEmptyArr"])(entities)) {
        return;
    }
    // --- Error Check ---
    const fn_name = 'visualize.Mesh';
    let ents_arr = null;
    if (__model__.debug) {
        if (entities !== null) {
            ents_arr = Object(_check_ids__WEBPACK_IMPORTED_MODULE_0__["checkIDs"])(fn_name, 'entities', entities, [_check_ids__WEBPACK_IMPORTED_MODULE_0__["IdCh"].isIdL], null);
        }
    }
    else {
        // if (entities !== null) {
        //     ents_arr = splitIDs(fn_name, 'entities', entities,
        //         [IDcheckObj.isIDList], null) as TEntTypeIdx[];
        // }
        ents_arr = Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsBreak"])(entities);
    }
    // --- Error Check ---
    // Get the unique verts that belong to pgons
    let verts_i = [];
    if (ents_arr !== null) {
        const set_verts_i = new Set();
        for (const [ent_type, ent_i] of ents_arr) {
            if (ent_type === _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].VERT) {
                if (__model__.modeldata.geom.query.getTopoObjType(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].VERT, ent_i) === _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON) {
                    set_verts_i.add(ent_i);
                }
            }
            else if (ent_type === _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].POINT) {
                // skip
            }
            else if (ent_type === _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE) {
                // skip
            }
            else if (ent_type === _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON) {
                const ent_verts_i = __model__.modeldata.geom.nav.navAnyToVert(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON, ent_i);
                for (const ent_vert_i of ent_verts_i) {
                    set_verts_i.add(ent_vert_i);
                }
            }
            else if (ent_type === _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].COLL) {
                const coll_pgons_i = __model__.modeldata.geom.nav.navCollToPgon(ent_i);
                for (const coll_pgon_i of coll_pgons_i) {
                    const ent_verts_i = __model__.modeldata.geom.nav.navAnyToVert(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON, coll_pgon_i);
                    for (const ent_vert_i of ent_verts_i) {
                        set_verts_i.add(ent_vert_i);
                    }
                }
            }
            else {
                const ent_verts_i = __model__.modeldata.geom.nav.navAnyToVert(ent_type, ent_i);
                for (const ent_vert_i of ent_verts_i) {
                    if (__model__.modeldata.geom.query.getTopoObjType(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].VERT, ent_vert_i) === _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PGON) {
                        set_verts_i.add(ent_vert_i);
                    }
                }
            }
        }
        verts_i = Array.from(set_verts_i);
    }
    else {
        verts_i = __model__.modeldata.geom.query.getEnts(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].VERT);
    }
    // calc vertex normals and set edge visibility
    switch (method) {
        case _EMeshMethod.FACETED:
            _meshFaceted(__model__, verts_i);
            break;
        case _EMeshMethod.SMOOTH:
            _meshSmooth(__model__, verts_i);
            break;
        default:
            break;
    }
}
function _meshFaceted(__model__, verts_i) {
    if (!__model__.modeldata.attribs.query.hasAttrib(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].VERT, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EAttribNames"].NORMAL)) {
        __model__.modeldata.attribs.add.addAttrib(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].VERT, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EAttribNames"].NORMAL, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EAttribDataTypeStrs"].LIST);
    }
    // get the polygons
    const map_vert_pgons = new Map();
    const set_pgons_i = new Set();
    for (const vert_i of verts_i) {
        const pgons_i = __model__.modeldata.geom.nav.navAnyToPgon(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].VERT, vert_i); // TODO optimize
        if (pgons_i.length === 1) { // one polygon
            map_vert_pgons.set(vert_i, pgons_i[0]);
            set_pgons_i.add(pgons_i[0]);
        }
    }
    // calc the normals one time
    const normals = [];
    for (const pgon_i of Array.from(set_pgons_i)) {
        const normal = __model__.modeldata.geom.query.getFaceNormal(__model__.modeldata.geom.nav.navPgonToFace(pgon_i));
        normals[pgon_i] = normal;
    }
    // set the normal
    map_vert_pgons.forEach((pgon_i, vert_i) => {
        const normal = normals[pgon_i];
        __model__.modeldata.attribs.add.setEntAttribVal(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].VERT, vert_i, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EAttribNames"].NORMAL, normal);
    });
}
function _meshSmooth(__model__, verts_i) {
    if (!__model__.modeldata.attribs.query.hasAttrib(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].VERT, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EAttribNames"].NORMAL)) {
        __model__.modeldata.attribs.add.addAttrib(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].VERT, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EAttribNames"].NORMAL, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EAttribDataTypeStrs"].LIST);
    }
    // get the polygons
    const map_posi_pgons = new Map();
    const set_pgons_i = new Set();
    const vert_to_posi = [];
    for (const vert_i of verts_i) {
        const posi_i = __model__.modeldata.geom.nav.navVertToPosi(vert_i);
        vert_to_posi[vert_i] = posi_i;
        if (!map_posi_pgons.has(posi_i)) {
            const posi_pgons_i = __model__.modeldata.geom.nav.navAnyToPgon(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].VERT, vert_i);
            map_posi_pgons.set(posi_i, posi_pgons_i);
            for (const posi_pgon_i of posi_pgons_i) {
                set_pgons_i.add(posi_pgon_i);
            }
        }
    }
    // calc all normals one time
    const normals = [];
    for (const pgon_i of Array.from(set_pgons_i)) {
        const normal = __model__.modeldata.geom.query.getFaceNormal(__model__.modeldata.geom.nav.navPgonToFace(pgon_i));
        normals[pgon_i] = normal;
    }
    // set normals on all verts
    for (const vert_i of verts_i) {
        const posi_i = vert_to_posi[vert_i];
        let normal = [0, 0, 0];
        const posi_pgons_i = map_posi_pgons.get(posi_i);
        for (const posi_pgon_i of posi_pgons_i) {
            normal = [
                normal[0] + normals[posi_pgon_i][0],
                normal[1] + normals[posi_pgon_i][1],
                normal[2] + normals[posi_pgon_i][2]
            ];
        }
        const div = posi_pgons_i.length;
        normal = [normal[0] / div, normal[1] / div, normal[2] / div];
        normal = Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_6__["vecNorm"])(normal);
        __model__.modeldata.attribs.add.setEntAttribVal(_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].VERT, vert_i, _libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EAttribNames"].NORMAL, normal);
    }
}
// ================================================================================================
/**
 * Visualises a ray or a list of rays by creating a polyline with an arrow head.
 *
 * @param __model__
 * @param rays Polylines representing the ray or rays.
 * @param scale Scales the arrow head of the vector.
 * @returns entities, a line with an arrow head representing the ray.
 * @example ray1 = visualize.Ray([[1,2,3],[0,0,1]])
 */
function Ray(__model__, rays, scale) {
    // --- Error Check ---
    const fn_name = 'visualize.Ray';
    if (__model__.debug) {
        Object(_check_args__WEBPACK_IMPORTED_MODULE_1__["checkArgs"])(fn_name, 'ray', rays, [_check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isRay, _check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isRayL]);
        Object(_check_args__WEBPACK_IMPORTED_MODULE_1__["checkArgs"])(fn_name, 'scale', scale, [_check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isNum]);
    }
    // --- Error Check ---
    return Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsMake"])(_visRay(__model__, rays, scale));
}
function _visRay(__model__, rays, scale) {
    if (Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["getArrDepth"])(rays) === 2) {
        const ray = rays;
        const origin = ray[0];
        const vec = ray[1]; // vecMult(ray[1], scale);
        const end = Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_6__["vecAdd"])(origin, vec);
        // create orign point
        const origin_posi_i = __model__.modeldata.geom.add.addPosi();
        __model__.modeldata.attribs.add.setPosiCoords(origin_posi_i, origin);
        // create pline
        const end_posi_i = __model__.modeldata.geom.add.addPosi();
        __model__.modeldata.attribs.add.setPosiCoords(end_posi_i, end);
        const pline_i = __model__.modeldata.geom.add.addPline([origin_posi_i, end_posi_i]);
        // create the arrow heads
        const vec_unit = Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_6__["vecNorm"])(ray[1]);
        const head_scale = scale;
        let vec_norm = null;
        if (Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_6__["vecDot"])([0, 0, 1], vec)) {
            vec_norm = Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_6__["vecSetLen"])(Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_6__["vecCross"])(vec_unit, [0, 1, 0]), head_scale);
        }
        else {
            vec_norm = Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_6__["vecSetLen"])(Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_6__["vecCross"])(vec_unit, [0, 0, 1]), head_scale);
        }
        const vec_rev = Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_6__["vecSetLen"])(Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_6__["vecMult"])(vec, -1), head_scale);
        const arrow_a = Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_6__["vecAdd"])(Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_6__["vecAdd"])(end, vec_rev), vec_norm);
        const arrow_a_posi_i = __model__.modeldata.geom.add.addPosi();
        __model__.modeldata.attribs.add.setPosiCoords(arrow_a_posi_i, arrow_a);
        const arrow_a_pline_i = __model__.modeldata.geom.add.addPline([end_posi_i, arrow_a_posi_i]);
        const arrow_b = Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_6__["vecSub"])(Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_6__["vecAdd"])(end, vec_rev), vec_norm);
        const arrow_b_posi_i = __model__.modeldata.geom.add.addPosi();
        __model__.modeldata.attribs.add.setPosiCoords(arrow_b_posi_i, arrow_b);
        const arrow_b_pline_i = __model__.modeldata.geom.add.addPline([end_posi_i, arrow_b_posi_i]);
        // return the geometry IDs
        return [
            [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE, pline_i],
            [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE, arrow_a_pline_i],
            [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE, arrow_b_pline_i]
        ];
    }
    else {
        const ents_arr = [];
        for (const ray of rays) {
            const ray_ents = _visRay(__model__, ray, scale);
            for (const ray_ent of ray_ents) {
                ents_arr.push(ray_ent);
            }
        }
        return ents_arr;
    }
}
// ================================================================================================
/**
 * Visualises a plane or a list of planes by creating polylines.
 *
 * @param __model__
 * @param plane A plane or a list of planes.
 * @returns Entities, a square plane polyline and three axis polyline.
 * @example plane1 = visualize.Plane(position1, vector1, [0,1,0])
 * @example_info Creates a plane with position1 on it and normal = cross product of vector1 with y-axis.
 */
function Plane(__model__, planes, scale) {
    // --- Error Check ---
    const fn_name = 'visualize.Plane';
    if (__model__.debug) {
        Object(_check_args__WEBPACK_IMPORTED_MODULE_1__["checkArgs"])(fn_name, 'planes', planes, [_check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isPln, _check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isPlnL]);
        Object(_check_args__WEBPACK_IMPORTED_MODULE_1__["checkArgs"])(fn_name, 'scale', scale, [_check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isNum]);
    }
    // --- Error Check ---
    return Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsMake"])(_visPlane(__model__, planes, scale));
}
function _visPlane(__model__, planes, scale) {
    if (Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["getArrDepth"])(planes) === 2) {
        const plane = planes;
        const origin = plane[0];
        const x_vec = Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_6__["vecMult"])(plane[1], scale);
        const y_vec = Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_6__["vecMult"])(plane[2], scale);
        let x_end = Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_6__["vecAdd"])(origin, x_vec);
        let y_end = Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_6__["vecAdd"])(origin, y_vec);
        const z_end = Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_6__["vecAdd"])(origin, Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_6__["vecSetLen"])(Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_6__["vecCross"])(x_vec, y_vec), scale));
        const plane_corners = [
            Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_6__["vecAdd"])(x_end, y_vec),
            Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_6__["vecSub"])(y_end, x_vec),
            Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_6__["vecSub"])(Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_6__["vecSub"])(origin, x_vec), y_vec),
            Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_6__["vecSub"])(x_end, y_vec),
        ];
        x_end = Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_6__["vecAdd"])(x_end, Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_6__["vecMult"])(x_vec, 0.1));
        y_end = Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_6__["vecSub"])(y_end, Object(_assets_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_6__["vecMult"])(y_vec, 0.1));
        // create the point
        const origin_posi_i = __model__.modeldata.geom.add.addPosi();
        __model__.modeldata.attribs.add.setPosiCoords(origin_posi_i, origin);
        // create the x axis
        const x_end_posi_i = __model__.modeldata.geom.add.addPosi();
        __model__.modeldata.attribs.add.setPosiCoords(x_end_posi_i, x_end);
        const x_pline_i = __model__.modeldata.geom.add.addPline([origin_posi_i, x_end_posi_i]);
        // create the y axis
        const y_end_posi_i = __model__.modeldata.geom.add.addPosi();
        __model__.modeldata.attribs.add.setPosiCoords(y_end_posi_i, y_end);
        const y_pline_i = __model__.modeldata.geom.add.addPline([origin_posi_i, y_end_posi_i]);
        // create the z axis
        const z_end_posi_i = __model__.modeldata.geom.add.addPosi();
        __model__.modeldata.attribs.add.setPosiCoords(z_end_posi_i, z_end);
        const z_pline_i = __model__.modeldata.geom.add.addPline([origin_posi_i, z_end_posi_i]);
        // create pline for plane
        const corner_posis_i = [];
        for (const corner of plane_corners) {
            const posi_i = __model__.modeldata.geom.add.addPosi();
            __model__.modeldata.attribs.add.setPosiCoords(posi_i, corner);
            corner_posis_i.push(posi_i);
        }
        const plane_i = __model__.modeldata.geom.add.addPline(corner_posis_i, true);
        // return the geometry IDs
        return [
            [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE, x_pline_i],
            [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE, y_pline_i],
            [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE, z_pline_i],
            [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE, plane_i]
        ];
    }
    else {
        const ents_arr = [];
        for (const plane of planes) {
            const plane_ents = _visPlane(__model__, plane, scale);
            for (const plane_ent of plane_ents) {
                ents_arr.push(plane_ent);
            }
        }
        return ents_arr;
    }
}
// ================================================================================================
/**
 * Visualises a bounding box by adding geometry to the model.
 *
 * @param __model__
 * @param bboxes A list of lists.
 * @returns Entities, twelve polylines representing the box.
 * @example bbox1 = virtual.viBBox(position1, vector1, [0,1,0])
 * @example_info Creates a plane with position1 on it and normal = cross product of vector1 with y-axis.
 */
function BBox(__model__, bboxes) {
    // --- Error Check ---
    const fn_name = 'visualize.BBox';
    if (__model__.debug) {
        Object(_check_args__WEBPACK_IMPORTED_MODULE_1__["checkArgs"])(fn_name, 'bbox', bboxes, [_check_args__WEBPACK_IMPORTED_MODULE_1__["ArgCh"].isBBox]); // TODO bboxs can be a list // add isBBoxList to enable check
    }
    // --- Error Check ---
    return Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["idsMake"])(_visBBox(__model__, bboxes));
}
function _visBBox(__model__, bboxs) {
    if (Object(_libs_geo_info_id__WEBPACK_IMPORTED_MODULE_3__["getArrDepth"])(bboxs) === 2) {
        const bbox = bboxs;
        const _min = bbox[1];
        const _max = bbox[2];
        // bottom
        const ps0 = __model__.modeldata.geom.add.addPosi();
        __model__.modeldata.attribs.add.setPosiCoords(ps0, _min);
        const ps1 = __model__.modeldata.geom.add.addPosi();
        __model__.modeldata.attribs.add.setPosiCoords(ps1, [_max[0], _min[1], _min[2]]);
        const ps2 = __model__.modeldata.geom.add.addPosi();
        __model__.modeldata.attribs.add.setPosiCoords(ps2, [_max[0], _max[1], _min[2]]);
        const ps3 = __model__.modeldata.geom.add.addPosi();
        __model__.modeldata.attribs.add.setPosiCoords(ps3, [_min[0], _max[1], _min[2]]);
        // top
        const ps4 = __model__.modeldata.geom.add.addPosi();
        __model__.modeldata.attribs.add.setPosiCoords(ps4, [_min[0], _min[1], _max[2]]);
        const ps5 = __model__.modeldata.geom.add.addPosi();
        __model__.modeldata.attribs.add.setPosiCoords(ps5, [_max[0], _min[1], _max[2]]);
        const ps6 = __model__.modeldata.geom.add.addPosi();
        __model__.modeldata.attribs.add.setPosiCoords(ps6, _max);
        const ps7 = __model__.modeldata.geom.add.addPosi();
        __model__.modeldata.attribs.add.setPosiCoords(ps7, [_min[0], _max[1], _max[2]]);
        // plines bottom
        const pl0 = __model__.modeldata.geom.add.addPline([ps0, ps1]);
        const pl1 = __model__.modeldata.geom.add.addPline([ps1, ps2]);
        const pl2 = __model__.modeldata.geom.add.addPline([ps2, ps3]);
        const pl3 = __model__.modeldata.geom.add.addPline([ps3, ps0]);
        // plines top
        const pl4 = __model__.modeldata.geom.add.addPline([ps4, ps5]);
        const pl5 = __model__.modeldata.geom.add.addPline([ps5, ps6]);
        const pl6 = __model__.modeldata.geom.add.addPline([ps6, ps7]);
        const pl7 = __model__.modeldata.geom.add.addPline([ps7, ps4]);
        // plines vertical
        const pl8 = __model__.modeldata.geom.add.addPline([ps0, ps4]);
        const pl9 = __model__.modeldata.geom.add.addPline([ps1, ps5]);
        const pl10 = __model__.modeldata.geom.add.addPline([ps2, ps6]);
        const pl11 = __model__.modeldata.geom.add.addPline([ps3, ps7]);
        // return
        return [pl0, pl1, pl2, pl3, pl4, pl5, pl6, pl7, pl8, pl9, pl10, pl11].map(pl => [_libs_geo_info_common__WEBPACK_IMPORTED_MODULE_2__["EEntType"].PLINE, pl]);
    }
    else {
        const ents_arr = [];
        for (const bbox of bboxs) {
            const bbox_ents = _visBBox(__model__, bbox);
            for (const bbox_ent of bbox_ents) {
                ents_arr.push(bbox_ent);
            }
        }
        return ents_arr;
    }
}


/***/ }),

/***/ "./src/assets/core/modules/index.ts":
/*!******************************************!*\
  !*** ./src/assets/core/modules/index.ts ***!
  \******************************************/
/*! exports provided: _model, query, pattern, make, modify, attrib, calc, intersect, collection, list, dict, analyze, visualize, material, io, util, poly2d, _math, _mathjs, _types, _strs, _rand, _vec, _ray, _plane, _geometry, _list, _set, _colors, _conversion, _constants, _util, _arithmetic, _Output, _parameterTypes, _varString */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_model */ "./src/assets/core/modules/_model.ts");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "_model", function() { return _model__WEBPACK_IMPORTED_MODULE_0__; });
/* harmony import */ var _basic_query__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./basic/query */ "./src/assets/core/modules/basic/query.ts");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "query", function() { return _basic_query__WEBPACK_IMPORTED_MODULE_1__; });
/* harmony import */ var _basic_pattern__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./basic/pattern */ "./src/assets/core/modules/basic/pattern.ts");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "pattern", function() { return _basic_pattern__WEBPACK_IMPORTED_MODULE_2__; });
/* harmony import */ var _basic_make__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./basic/make */ "./src/assets/core/modules/basic/make.ts");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "make", function() { return _basic_make__WEBPACK_IMPORTED_MODULE_3__; });
/* harmony import */ var _basic_modify__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./basic/modify */ "./src/assets/core/modules/basic/modify.ts");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "modify", function() { return _basic_modify__WEBPACK_IMPORTED_MODULE_4__; });
/* harmony import */ var _basic_attrib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./basic/attrib */ "./src/assets/core/modules/basic/attrib.ts");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "attrib", function() { return _basic_attrib__WEBPACK_IMPORTED_MODULE_5__; });
/* harmony import */ var _basic_calc__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./basic/calc */ "./src/assets/core/modules/basic/calc.ts");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "calc", function() { return _basic_calc__WEBPACK_IMPORTED_MODULE_6__; });
/* harmony import */ var _basic_intersect__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./basic/intersect */ "./src/assets/core/modules/basic/intersect.ts");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "intersect", function() { return _basic_intersect__WEBPACK_IMPORTED_MODULE_7__; });
/* harmony import */ var _basic_collection__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./basic/collection */ "./src/assets/core/modules/basic/collection.ts");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "collection", function() { return _basic_collection__WEBPACK_IMPORTED_MODULE_8__; });
/* harmony import */ var _basic_list__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./basic/list */ "./src/assets/core/modules/basic/list.ts");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "list", function() { return _basic_list__WEBPACK_IMPORTED_MODULE_9__; });
/* harmony import */ var _basic_dict__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./basic/dict */ "./src/assets/core/modules/basic/dict.ts");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "dict", function() { return _basic_dict__WEBPACK_IMPORTED_MODULE_10__; });
/* harmony import */ var _basic_analyze__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./basic/analyze */ "./src/assets/core/modules/basic/analyze.ts");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "analyze", function() { return _basic_analyze__WEBPACK_IMPORTED_MODULE_11__; });
/* harmony import */ var _basic_visualize__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./basic/visualize */ "./src/assets/core/modules/basic/visualize.ts");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "visualize", function() { return _basic_visualize__WEBPACK_IMPORTED_MODULE_12__; });
/* harmony import */ var _basic_material__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./basic/material */ "./src/assets/core/modules/basic/material.ts");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "material", function() { return _basic_material__WEBPACK_IMPORTED_MODULE_13__; });
/* harmony import */ var _basic_io__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./basic/io */ "./src/assets/core/modules/basic/io.ts");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "io", function() { return _basic_io__WEBPACK_IMPORTED_MODULE_14__; });
/* harmony import */ var _basic_util__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./basic/util */ "./src/assets/core/modules/basic/util.ts");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "util", function() { return _basic_util__WEBPACK_IMPORTED_MODULE_15__; });
/* harmony import */ var _basic_poly2d__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./basic/poly2d */ "./src/assets/core/modules/basic/poly2d.ts");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "poly2d", function() { return _basic_poly2d__WEBPACK_IMPORTED_MODULE_16__; });
/* harmony import */ var _inline_math__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../inline/_math */ "./src/assets/core/inline/_math.ts");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "_math", function() { return _inline_math__WEBPACK_IMPORTED_MODULE_17__; });
/* harmony import */ var _inline_mathjs__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../inline/_mathjs */ "./src/assets/core/inline/_mathjs.ts");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "_mathjs", function() { return _inline_mathjs__WEBPACK_IMPORTED_MODULE_18__; });
/* harmony import */ var _inline_types__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../inline/_types */ "./src/assets/core/inline/_types.ts");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "_types", function() { return _inline_types__WEBPACK_IMPORTED_MODULE_19__; });
/* harmony import */ var _inline_strs__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../inline/_strs */ "./src/assets/core/inline/_strs.ts");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "_strs", function() { return _inline_strs__WEBPACK_IMPORTED_MODULE_20__; });
/* harmony import */ var _inline_rand__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ../inline/_rand */ "./src/assets/core/inline/_rand.ts");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "_rand", function() { return _inline_rand__WEBPACK_IMPORTED_MODULE_21__; });
/* harmony import */ var _inline_vec__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ../inline/_vec */ "./src/assets/core/inline/_vec.ts");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "_vec", function() { return _inline_vec__WEBPACK_IMPORTED_MODULE_22__; });
/* harmony import */ var _inline_ray__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ../inline/_ray */ "./src/assets/core/inline/_ray.ts");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "_ray", function() { return _inline_ray__WEBPACK_IMPORTED_MODULE_23__; });
/* harmony import */ var _inline_plane__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ../inline/_plane */ "./src/assets/core/inline/_plane.ts");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "_plane", function() { return _inline_plane__WEBPACK_IMPORTED_MODULE_24__; });
/* harmony import */ var _inline_geometry__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ../inline/_geometry */ "./src/assets/core/inline/_geometry.ts");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "_geometry", function() { return _inline_geometry__WEBPACK_IMPORTED_MODULE_25__; });
/* harmony import */ var _inline_list__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ../inline/_list */ "./src/assets/core/inline/_list.ts");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "_list", function() { return _inline_list__WEBPACK_IMPORTED_MODULE_26__; });
/* harmony import */ var _inline_set__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ../inline/_set */ "./src/assets/core/inline/_set.ts");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "_set", function() { return _inline_set__WEBPACK_IMPORTED_MODULE_27__; });
/* harmony import */ var _inline_colors__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ../inline/_colors */ "./src/assets/core/inline/_colors.ts");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "_colors", function() { return _inline_colors__WEBPACK_IMPORTED_MODULE_28__; });
/* harmony import */ var _inline_conversion__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ../inline/_conversion */ "./src/assets/core/inline/_conversion.ts");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "_conversion", function() { return _inline_conversion__WEBPACK_IMPORTED_MODULE_29__; });
/* harmony import */ var _inline_constants__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ../inline/_constants */ "./src/assets/core/inline/_constants.ts");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "_constants", function() { return _inline_constants__WEBPACK_IMPORTED_MODULE_30__; });
/* harmony import */ var _inline_util__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ../inline/_util */ "./src/assets/core/inline/_util.ts");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "_util", function() { return _inline_util__WEBPACK_IMPORTED_MODULE_31__; });
/* harmony import */ var _inline_arithmetic__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ../inline/_arithmetic */ "./src/assets/core/inline/_arithmetic.ts");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "_arithmetic", function() { return _inline_arithmetic__WEBPACK_IMPORTED_MODULE_32__; });
/* harmony import */ var _output__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./_output */ "./src/assets/core/modules/_output.ts");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "_Output", function() { return _output__WEBPACK_IMPORTED_MODULE_33__; });
/* harmony import */ var _parameterTypes__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ../_parameterTypes */ "./src/assets/core/_parameterTypes.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_parameterTypes", function() { return _parameterTypes__WEBPACK_IMPORTED_MODULE_34__["_parameterTypes"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_varString", function() { return _parameterTypes__WEBPACK_IMPORTED_MODULE_34__["_varString"]; });

// functions used by mobius
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};
// import * as Model from './Model';
// export {Model};


// import * as _model from './Model';
// export {_model};
// functions for end users
































// helpers
































// input, output ports





/***/ }),

/***/ "./src/assets/libs/TypedArrayUtils.js":
/*!********************************************!*\
  !*** ./src/assets/libs/TypedArrayUtils.js ***!
  \********************************************/
/*! exports provided: TypedArrayUtils */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TypedArrayUtils", function() { return TypedArrayUtils; });

var TypedArrayUtils = {};

/**
 * In-place quicksort for typed arrays (e.g. for Float32Array)
 * provides fast sorting
 * useful e.g. for a custom shader and/or BufferGeometry
 *
 * @author Roman Bolzern <roman.bolzern@fhnw.ch>, 2013
 * @author I4DS http://www.fhnw.ch/i4ds, 2013
 * @license MIT License <http://www.opensource.org/licenses/mit-license.php>
 *
 * Complexity: http://bigocheatsheet.com/ see Quicksort
 *
 * Example:
 * points: [x, y, z, x, y, z, x, y, z, ...]
 * eleSize: 3 //because of (x, y, z)
 * orderElement: 0 //order according to x
 */

TypedArrayUtils.quicksortIP = function ( arr, eleSize, orderElement ) {

	var stack = [];
	var sp = - 1;
	var left = 0;
	var right = arr.length / eleSize - 1;
	var tmp = 0.0, x = 0, y = 0;

	var swapF = function ( a, b ) {

		a *= eleSize; b *= eleSize;

		for ( y = 0; y < eleSize; y ++ ) {

			tmp = arr[ a + y ];
			arr[ a + y ] = arr[ b + y ];
			arr[ b + y ] = tmp;

		}

	};

	var i, j, swap = new Float32Array( eleSize ), temp = new Float32Array( eleSize );

	while ( true ) {

		if ( right - left <= 25 ) {

			for ( j = left + 1; j <= right; j ++ ) {

				for ( x = 0; x < eleSize; x ++ ) {

					swap[ x ] = arr[ j * eleSize + x ];

				}

				i = j - 1;

				while ( i >= left && arr[ i * eleSize + orderElement ] > swap[ orderElement ] ) {

					for ( x = 0; x < eleSize; x ++ ) {

						arr[ ( i + 1 ) * eleSize + x ] = arr[ i * eleSize + x ];

					}

					i --;

				}

				for ( x = 0; x < eleSize; x ++ ) {

					arr[ ( i + 1 ) * eleSize + x ] = swap[ x ];

				}

			}

			if ( sp == - 1 ) break;

			right = stack[ sp -- ]; //?
			left = stack[ sp -- ];

		} else {

			var median = ( left + right ) >> 1;

			i = left + 1;
			j = right;

			swapF( median, i );

			if ( arr[ left * eleSize + orderElement ] > arr[ right * eleSize + orderElement ] ) {

				swapF( left, right );

			}

			if ( arr[ i * eleSize + orderElement ] > arr[ right * eleSize + orderElement ] ) {

				swapF( i, right );

			}

			if ( arr[ left * eleSize + orderElement ] > arr[ i * eleSize + orderElement ] ) {

				swapF( left, i );

			}

			for ( x = 0; x < eleSize; x ++ ) {

				temp[ x ] = arr[ i * eleSize + x ];

			}

			while ( true ) {

				do i ++; while ( arr[ i * eleSize + orderElement ] < temp[ orderElement ] );
				do j --; while ( arr[ j * eleSize + orderElement ] > temp[ orderElement ] );

				if ( j < i ) break;

				swapF( i, j );

			}

			for ( x = 0; x < eleSize; x ++ ) {

				arr[ ( left + 1 ) * eleSize + x ] = arr[ j * eleSize + x ];
				arr[ j * eleSize + x ] = temp[ x ];

			}

			if ( right - i + 1 >= j - left ) {

				stack[ ++ sp ] = i;
				stack[ ++ sp ] = right;
				right = j - 1;

			} else {

				stack[ ++ sp ] = left;
				stack[ ++ sp ] = j - 1;
				left = i;

			}

		}

	}

	return arr;

};



/**
 * k-d Tree for typed arrays (e.g. for Float32Array), in-place
 * provides fast nearest neighbour search
 * useful e.g. for a custom shader and/or BufferGeometry, saves tons of memory
 * has no insert and remove, only buildup and neares neighbour search
 *
 * Based on https://github.com/ubilabs/kd-tree-javascript by Ubilabs
 *
 * @author Roman Bolzern <roman.bolzern@fhnw.ch>, 2013
 * @author I4DS http://www.fhnw.ch/i4ds, 2013
 * @license MIT License <http://www.opensource.org/licenses/mit-license.php>
 *
 * Requires typed array quicksort
 *
 * Example:
 * points: [x, y, z, x, y, z, x, y, z, ...]
 * metric: function(a, b){	return Math.pow(a[0] - b[0], 2) +  Math.pow(a[1] - b[1], 2) +  Math.pow(a[2] - b[2], 2); }  //Manhatten distance
 * eleSize: 3 //because of (x, y, z)
 *
 * Further information (including mathematical properties)
 * http://en.wikipedia.org/wiki/Binary_tree
 * http://en.wikipedia.org/wiki/K-d_tree
 *
 * If you want to further minimize memory usage, remove Node.depth and replace in search algorithm with a traversal to root node (see comments at TypedArrayUtils.Kdtree.prototype.Node)
 */

TypedArrayUtils.Kdtree = function ( points, metric, eleSize ) {

	var self = this;

	var maxDepth = 0;

	var getPointSet = function ( points, pos ) {

		return points.subarray( pos * eleSize, pos * eleSize + eleSize );

	};

	function buildTree( points, depth, parent, pos ) {

		var dim = depth % eleSize,
			median,
			node,
			plength = points.length / eleSize;

		if ( depth > maxDepth ) maxDepth = depth;

		if ( plength === 0 ) return null;
		if ( plength === 1 ) {

			return new self.Node( getPointSet( points, 0 ), depth, parent, pos );

		}

		TypedArrayUtils.quicksortIP( points, eleSize, dim );

		median = Math.floor( plength / 2 );

		node = new self.Node( getPointSet( points, median ), depth, parent, median + pos );
		node.left = buildTree( points.subarray( 0, median * eleSize ), depth + 1, node, pos );
		node.right = buildTree( points.subarray( ( median + 1 ) * eleSize, points.length ), depth + 1, node, pos + median + 1 );

		return node;

	}

	this.root = buildTree( points, 0, null, 0 );

	this.getMaxDepth = function () {

		return maxDepth;

	};

	this.nearest = function ( point, maxNodes, maxDistance ) {

		 /* point: array of size eleSize
			maxNodes: max amount of nodes to return
			maxDistance: maximum distance to point result nodes should have
			condition (not implemented): function to test node before it's added to the result list, e.g. test for view frustum
		*/

		var i,
			result,
			bestNodes;

		bestNodes = new TypedArrayUtils.Kdtree.BinaryHeap(

			function ( e ) {

				return - e[ 1 ];

			}

		);

		function nearestSearch( node ) {

			var bestChild,
				dimension = node.depth % eleSize,
				ownDistance = metric( point, node.obj ),
				linearDistance = 0,
				otherChild,
				i,
				linearPoint = [];

			function saveNode( node, distance ) {

				bestNodes.push( [ node, distance ] );

				if ( bestNodes.size() > maxNodes ) {

					bestNodes.pop();

				}

			}

			for ( i = 0; i < eleSize; i += 1 ) {

				if ( i === node.depth % eleSize ) {

					linearPoint[ i ] = point[ i ];

				} else {

					linearPoint[ i ] = node.obj[ i ];

				}

			}

			linearDistance = metric( linearPoint, node.obj );

			// if it's a leaf

			if ( node.right === null && node.left === null ) {

				if ( bestNodes.size() < maxNodes || ownDistance < bestNodes.peek()[ 1 ] ) {

					saveNode( node, ownDistance );

				}

				return;

			}

			if ( node.right === null ) {

				bestChild = node.left;

			} else if ( node.left === null ) {

				bestChild = node.right;

			} else {

				if ( point[ dimension ] < node.obj[ dimension ] ) {

					bestChild = node.left;

				} else {

					bestChild = node.right;

				}

			}

			// recursive search

			nearestSearch( bestChild );

			if ( bestNodes.size() < maxNodes || ownDistance < bestNodes.peek()[ 1 ] ) {

				saveNode( node, ownDistance );

			}

			// if there's still room or the current distance is nearer than the best distance

			if ( bestNodes.size() < maxNodes || Math.abs( linearDistance ) < bestNodes.peek()[ 1 ] ) {

				if ( bestChild === node.left ) {

					otherChild = node.right;

				} else {

					otherChild = node.left;

				}

				if ( otherChild !== null ) {

					nearestSearch( otherChild );

				}

			}

		}

		if ( maxDistance ) {

			for ( i = 0; i < maxNodes; i += 1 ) {

				bestNodes.push( [ null, maxDistance ] );

			}

		}

		nearestSearch( self.root );

		result = [];

		for ( i = 0; i < maxNodes; i += 1 ) {

			if ( bestNodes.content[ i ][ 0 ] ) {

				result.push( [ bestNodes.content[ i ][ 0 ], bestNodes.content[ i ][ 1 ] ] );

			}

		}

		return result;

	};

};

/**
 * If you need to free up additional memory and agree with an additional O( log n ) traversal time you can get rid of "depth" and "pos" in Node:
 * Depth can be easily done by adding 1 for every parent (care: root node has depth 0, not 1)
 * Pos is a bit tricky: Assuming the tree is balanced (which is the case when after we built it up), perform the following steps:
 *   By traversing to the root store the path e.g. in a bit pattern (01001011, 0 is left, 1 is right)
 *   From buildTree we know that "median = Math.floor( plength / 2 );", therefore for each bit...
 *     0: amountOfNodesRelevantForUs = Math.floor( (pamountOfNodesRelevantForUs - 1) / 2 );
 *     1: amountOfNodesRelevantForUs = Math.ceil( (pamountOfNodesRelevantForUs - 1) / 2 );
 *        pos += Math.floor( (pamountOfNodesRelevantForUs - 1) / 2 );
 *     when recursion done, we still need to add all left children of target node:
 *        pos += Math.floor( (pamountOfNodesRelevantForUs - 1) / 2 );
 *        and I think you need to +1 for the current position, not sure.. depends, try it out ^^
 *
 * I experienced that for 200'000 nodes you can get rid of 4 MB memory each, leading to 8 MB memory saved.
 */
TypedArrayUtils.Kdtree.prototype.Node = function ( obj, depth, parent, pos ) {

	this.obj = obj;
	this.left = null;
	this.right = null;
	this.parent = parent;
	this.depth = depth;
	this.pos = pos;

};

/**
 * Binary heap implementation
 * @author http://eloquentjavascript.net/appendix2.htm
 */

TypedArrayUtils.Kdtree.BinaryHeap = function ( scoreFunction ) {

	this.content = [];
	this.scoreFunction = scoreFunction;

};

TypedArrayUtils.Kdtree.BinaryHeap.prototype = {

	push: function ( element ) {

		// Add the new element to the end of the array.
		this.content.push( element );

		// Allow it to bubble up.
		this.bubbleUp( this.content.length - 1 );

	},

	pop: function () {

		// Store the first element so we can return it later.
		var result = this.content[ 0 ];

		// Get the element at the end of the array.
		var end = this.content.pop();

		// If there are any elements left, put the end element at the
		// start, and let it sink down.
		if ( this.content.length > 0 ) {

			this.content[ 0 ] = end;
			this.sinkDown( 0 );

		}

		return result;

	},

	peek: function () {

		return this.content[ 0 ];

	},

	remove: function ( node ) {

		var len = this.content.length;

		// To remove a value, we must search through the array to find it.
		for ( var i = 0; i < len; i ++ ) {

			if ( this.content[ i ] == node ) {

				// When it is found, the process seen in 'pop' is repeated
				// to fill up the hole.
				var end = this.content.pop();

				if ( i != len - 1 ) {

					this.content[ i ] = end;

					if ( this.scoreFunction( end ) < this.scoreFunction( node ) ) {

						this.bubbleUp( i );

					} else {

						this.sinkDown( i );

					}

				}

				return;

			}

		}

		throw new Error( "Node not found." );

	},

	size: function () {

		return this.content.length;

	},

	bubbleUp: function ( n ) {

		// Fetch the element that has to be moved.
		var element = this.content[ n ];

		// When at 0, an element can not go up any further.
		while ( n > 0 ) {

			// Compute the parent element's index, and fetch it.
			var parentN = Math.floor( ( n + 1 ) / 2 ) - 1,
				parent = this.content[ parentN ];

			// Swap the elements if the parent is greater.
			if ( this.scoreFunction( element ) < this.scoreFunction( parent ) ) {

				this.content[ parentN ] = element;
				this.content[ n ] = parent;

				// Update 'n' to continue at the new position.
				n = parentN;

			} else {

				// Found a parent that is less, no need to move it further.
				break;

			}

		}

	},

	sinkDown: function ( n ) {

		// Look up the target element and its score.
		var length = this.content.length,
			element = this.content[ n ],
			elemScore = this.scoreFunction( element );

		while ( true ) {

			// Compute the indices of the child elements.
			var child2N = ( n + 1 ) * 2, child1N = child2N - 1;

			// This is used to store the new position of the element, if any.
			var swap = null;

			// If the first child exists (is inside the array)...
			if ( child1N < length ) {

				// Look it up and compute its score.
				var child1 = this.content[ child1N ],
					child1Score = this.scoreFunction( child1 );

				// If the score is less than our element's, we need to swap.
				if ( child1Score < elemScore ) swap = child1N;

			}

			// Do the same checks for the other child.
			if ( child2N < length ) {

				var child2 = this.content[ child2N ],
					child2Score = this.scoreFunction( child2 );

				if ( child2Score < ( swap === null ? elemScore : child1Score ) ) swap = child2N;

			}

			// If the element needs to be moved, swap it, and continue.
			if ( swap !== null ) {

				this.content[ n ] = this.content[ swap ];
				this.content[ swap ] = element;
				n = swap;

			} else {

				// Otherwise, we are done.
				break;

			}

		}

	}

};




/***/ }),

/***/ "./src/assets/libs/filesys/download.ts":
/*!*********************************************!*\
  !*** ./src/assets/libs/filesys/download.ts ***!
  \*********************************************/
/*! exports provided: download */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "download", function() { return download; });
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};
/**
 * Download a file.
 * @param data
 * @param filename
 */
function download(data, filename) {
    // console.log('Downloading');
    const file = new File([data], filename, { type: 'plain/text;charset=utf-8' });
    // console.log(file.name);
    const link = document.createElement('a');
    link.href = window.URL.createObjectURL(file);
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    return true;
}


/***/ }),

/***/ "./src/assets/libs/geo-info/GIAttribMap.ts":
/*!*************************************************!*\
  !*** ./src/assets/libs/geo-info/GIAttribMap.ts ***!
  \*************************************************/
/*! exports provided: GIAttribMap */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GIAttribMap", function() { return GIAttribMap; });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common */ "./src/assets/libs/geo-info/common.ts");
/* harmony import */ var _util_arrs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/arrs */ "./src/assets/libs/util/arrs.ts");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _common_func__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./common_func */ "./src/assets/libs/geo-info/common_func.ts");
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};




/**
 * Geo-info attribute class for one attribute.
 * The attributs stores key-value pairs.
 * Multiple keys point to the same value.
 * So for example, [[1,3], "a"],[[0,4], "b"] can be converted into sequential arrays.
 * The values would be ["a", "b"]
 * The keys would be [1,0,,0,1] (Note the undefined value in the middle.)
 *
 */
class GIAttribMap {
    /**
     * Creates an attribute.
     * @param attrib_data
     */
    constructor(modeldata, name, ent_type, data_type) {
        this._modeldata = modeldata;
        this._name = name;
        this._ent_type = ent_type;
        this._data_type = data_type;
        if (data_type === _common__WEBPACK_IMPORTED_MODULE_0__["EAttribDataTypeStrs"].LIST || data_type === _common__WEBPACK_IMPORTED_MODULE_0__["EAttribDataTypeStrs"].DICT) {
            this._data_length = 0;
        }
        else {
            this._data_length = 1;
        }
        // the maps
        this._map_val_i_to_ents_i = new Map();
        this._map_ent_i_to_val_i = new Map();
    }
    /**
     * Returns the JSON data for this attribute.
     */
    getJSONData() {
        return {
            name: this._name,
            data_type: this._data_type,
            data_length: this._data_length,
            data: Array.from(this._map_val_i_to_ents_i)
        };
    }
    /**
     * Sets the JSON data for this attribute.
     * Any existing data is deleted.
     */
    setJSONData(attrib_data) {
        this._name = attrib_data.name;
        this._data_type = attrib_data.data_type;
        this._data_length = attrib_data.data_length;
        this._map_val_i_to_ents_i = new Map(attrib_data.data);
        this._map_ent_i_to_val_i = new Map();
        this._map_val_i_to_ents_i.forEach((ents_i, val_i) => {
            ents_i.forEach(ent_i => {
                this._map_ent_i_to_val_i.set(ent_i, val_i);
            });
        });
    }
    /**
     * Gets the name of this attribute.
     */
    getName() {
        return this._name;
    }
    /**
     * Sets the name of this attribute.
     */
    setName(name) {
        this._name = name;
    }
    /**
     * Returns the data type of this attribute.
     */
    getDataType() {
        return this._data_type;
    }
    /**
     * Returns the length of the data.
     * ~
     * If _data_type is NUMBER, STRING, BOOLEAN, then length = 1
     * ~
     * If _data_type is LIST, length is the list of the longest length, can be 0
     * ~
     * If _data_type is OBJECT, length is the obect with the longest Object.keys, can be 0
     */
    getDataLength() {
        return this._data_length;
    }
    // /**
    //  * Returns true if the data has non null/undefined value.
    //  */
    // public hasNonNullVal(): boolean {
    //     return this._num_vals > 0;
    // }
    // /**
    //  * Returns true if this value exists in the attributes.
    //  */
    // public hasVal(val: TAttribDataTypes): boolean {
    //     return this._map_val_k_to_val_i.has(this._valToValkey(val));
    // }
    /**
     * Returns true if there is an entity that has a value (i.e. the value is not undefined).
     */
    hasEnt(ent_i) {
        return this._map_ent_i_to_val_i.has(ent_i);
    }
    /**
     * Returns the number of entities that have a value (i.e. is not undefined).
     */
    numEnts() {
        return this._map_ent_i_to_val_i.size;
    }
    /**
     * Returns the number of values.
     */
    numVals() {
        return this._map_val_i_to_ents_i.size;
    }
    /**
     * Returns the IDs of all ents that have a value.
     */
    getEnts() {
        return Array.from(this._map_ent_i_to_val_i.keys());
    }
    /**
     * Delete the entities from this attribute map.
     */
    delEnt(ents_i) {
        ents_i = (Array.isArray(ents_i)) ? ents_i : [ents_i];
        ents_i.forEach(ent_i => {
            // _map_ent_i_to_val_i: Map<number, number>
            const val_i = this._map_ent_i_to_val_i.get(ent_i);
            if (val_i !== undefined) {
                // del the entity from _map_ent_i_to_val_i
                this._map_ent_i_to_val_i.delete(ent_i);
                // del the entity from _map_val_i_to_ents_i
                const other_ents_i = this._map_val_i_to_ents_i.get(val_i);
                other_ents_i.splice(other_ents_i.indexOf(ent_i), 1);
                // clean up just in case that was the last entity with this value
                this._cleanUp(val_i);
                // update time stamp
                this._modeldata.geom.time_stamp.updateEntTs(this._ent_type, ent_i);
            }
        });
        // TODO
        // this._data_length may need to be reduced
    }
    /**
     * Returns a nested array of entities and values, like this:
     * [ [[2,4,6,8], 'hello'], [[9,10], 'world']]
     * This is the same format as used in gi-json
     * This matches the method setEntsVals()
     */
    getEntsVals() {
        const ents_i_values = [];
        this._map_val_i_to_ents_i.forEach((ents_i, val_i) => {
            // const value: TAttribDataTypes = this._map_val_i_to_val.get(val_i);
            const value = this._modeldata.model.metadata.getAttribValFromIdx(val_i, this._data_type);
            ents_i_values.push([ents_i, value]);
        });
        return ents_i_values;
    }
    /**
     * Sets the value for a given entity or entities.
     *
     * If the value is undefined, no action is taken.
     *
     * The value can be null, in which case it is equivalent to deleting the entities from this attrib map.
     *
     * @param ent_i
     * @param val
     */
    setEntVal(ents_i, val, check_type = true) {
        // console.log("xxxx", val)
        // if indefined, do nothing
        if (val === undefined) {
            return;
        }
        // if null, delete
        if (val === null) {
            this.delEnt(ents_i);
            return;
        }
        // check the type
        if (check_type) {
            if (this._data_type === _common__WEBPACK_IMPORTED_MODULE_0__["EAttribDataTypeStrs"].NUMBER && typeof val !== 'number') {
                throw new Error('Error setting attribute value. Attribute is of type "number" but the value is not a number.');
            }
            else if (this._data_type === _common__WEBPACK_IMPORTED_MODULE_0__["EAttribDataTypeStrs"].STRING && typeof val !== 'string') {
                throw new Error('Error setting attribute value. Attribute is of type "string" but the value is not a string.');
            }
            else if (this._data_type === _common__WEBPACK_IMPORTED_MODULE_0__["EAttribDataTypeStrs"].BOOLEAN && typeof val !== 'boolean') {
                throw new Error('Error setting attribute value. Attribute is of type "boolean" but the value is not a boolean.');
            }
            else if (this._data_type === _common__WEBPACK_IMPORTED_MODULE_0__["EAttribDataTypeStrs"].LIST && !Array.isArray(val)) {
                throw new Error('Error setting attribute value. Attribute is of type "list" but the value is not a list.');
            }
            else if (this._data_type === _common__WEBPACK_IMPORTED_MODULE_0__["EAttribDataTypeStrs"].DICT && typeof val !== 'object') {
                throw new Error('Error setting attribute value. Attribute is of type "list" but the value is not a list.');
            }
        }
        const val_k = this._valToValkey(val);
        // get the index to the value
        let val_i;
        if (this._modeldata.model.metadata.hasAttribKey(val_k, this._data_type)) {
            val_i = this._modeldata.model.metadata.getAttribIdxFromKey(val_k, this._data_type);
            if (!this._map_val_i_to_ents_i.has(val_i)) {
                this._map_val_i_to_ents_i.set(val_i, []);
            }
        }
        else {
            val_i = this._modeldata.model.metadata.addAttribByKeyVal(val_k, val, this._data_type);
            this._map_val_i_to_ents_i.set(val_i, []);
        }
        // an array of ents
        ents_i = (Array.isArray(ents_i)) ? ents_i : [ents_i];
        // loop through all the unique ents, and set _map_ent_i_to_val_i
        let unique_ents_i = ents_i;
        if (ents_i.length > 1) {
            unique_ents_i = Array.from(new Set(ents_i));
        }
        unique_ents_i.forEach(ent_i => {
            // keep the old value for later
            const old_val_i = this._map_ent_i_to_val_i.get(ent_i);
            // for each ent_i, set the new val_i
            this._map_ent_i_to_val_i.set(ent_i, val_i);
            // clean up the old val_i
            if (old_val_i !== undefined && old_val_i !== val_i) {
                Object(_util_arrs__WEBPACK_IMPORTED_MODULE_1__["arrRem"])(this._map_val_i_to_ents_i.get(old_val_i), ent_i);
                // clean up just in case that was the last entity with this value
                this._cleanUp(old_val_i);
            }
            // update the time stamp for this entity
            this._modeldata.geom.time_stamp.updateEntTs(this._ent_type, ent_i);
        });
        // for the val_i, set it to point to all the ents that have this value
        const exist_ents_i = this._map_val_i_to_ents_i.get(val_i);
        const exist_new_ents_i = exist_ents_i === undefined ?
            ents_i :
            Array.from(new Set(exist_ents_i.concat(ents_i)));
        this._map_val_i_to_ents_i.set(val_i, exist_new_ents_i);
        // update the _data_length for lists and objects
        if (this._data_type === _common__WEBPACK_IMPORTED_MODULE_0__["EAttribDataTypeStrs"].LIST) {
            const arr_len = val.length;
            if (arr_len > this._data_length) {
                this._data_length = arr_len;
            }
        }
        else if (this._data_type === _common__WEBPACK_IMPORTED_MODULE_0__["EAttribDataTypeStrs"].DICT) {
            const arr_len = Object.keys(val).length;
            if (arr_len > this._data_length) {
                this._data_length = arr_len;
            }
        }
    }
    /**
     * Renumber the entity IDs.
     * This gets called when this data is being meregd into another model.
     * In such a case, entity IDs need to be renumbered to avoid conflicts.
     * The new entity IDs are defined in the renum_map argument.
     * @param renum_map
     */
    renumEnts(renum_map) {
        // private _map_val_i_to_ents_i: Map<number, number[]>;
        this._map_val_i_to_ents_i.forEach((ents_i, val_i) => {
            for (let i = 0; i < ents_i.length; i++) {
                const new_ent_i = renum_map.get(ents_i[i]); // shift
                ents_i[i] = new_ent_i;
                this._map_ent_i_to_val_i.set(new_ent_i, val_i);
            }
        });
    }
    /**
     * Merges another attrib map into this attrib map
     * @param attrib_map The attrib map to merge into this map
     */
    merge(attrib_map) {
        attrib_map._map_val_i_to_ents_i.forEach((other_ents_i, val_i) => {
            // get the ents
            const exist_ents_i = this._map_val_i_to_ents_i.get(val_i);
            const exist_other_ents_i = exist_ents_i === undefined ?
                Array.from(other_ents_i) :
                Array.from(new Set(exist_ents_i.concat(other_ents_i)));
            // update the ent maps
            this._map_val_i_to_ents_i.set(val_i, exist_other_ents_i);
            other_ents_i.forEach(ent_i => this._map_ent_i_to_val_i.set(ent_i, val_i));
        });
        // update the data length
        if (this._data_type === _common__WEBPACK_IMPORTED_MODULE_0__["EAttribDataTypeStrs"].LIST || this._data_type === _common__WEBPACK_IMPORTED_MODULE_0__["EAttribDataTypeStrs"].DICT) {
            if (attrib_map._data_length > this._data_length) {
                this._data_length = attrib_map._data_length;
            }
        }
    }
    /**
     * Dumps another attrib map into this attrib map
     * Assumes tha this map is empty
     * @param attrib_map The attrib map to merge into this map
     */
    dump(attrib_map) {
        this._map_val_i_to_ents_i = Object(_common_func__WEBPACK_IMPORTED_MODULE_3__["cloneDeepMapArr"])(attrib_map._map_val_i_to_ents_i);
        this._map_ent_i_to_val_i = new Map(attrib_map._map_ent_i_to_val_i);
    }
    /**
     * Dumps another attrib map into this attrib map
     * Assumes tha this map is empty
     * @param attrib_map The attrib map to merge into this map
     */
    dumpSelect(attrib_map, selected) {
        selected.forEach(selected_ent_i => {
            if (attrib_map._map_ent_i_to_val_i.has(selected_ent_i)) {
                const val_i = attrib_map._map_ent_i_to_val_i.get(selected_ent_i);
                const ents_i = attrib_map._map_val_i_to_ents_i.get(val_i);
                const ents2_i = ents_i.filter(ent_i => selected.has(ent_i));
                this._map_val_i_to_ents_i.set(val_i, ents2_i);
                ents2_i.forEach(ent_i => this._map_ent_i_to_val_i.set(ent_i, val_i));
                // update the data length
                if (this._data_type === _common__WEBPACK_IMPORTED_MODULE_0__["EAttribDataTypeStrs"].LIST || this._data_type === _common__WEBPACK_IMPORTED_MODULE_0__["EAttribDataTypeStrs"].DICT) {
                    const val = this._modeldata.model.metadata.getAttribValFromIdx(val_i, this._data_type);
                    if (this._data_type === _common__WEBPACK_IMPORTED_MODULE_0__["EAttribDataTypeStrs"].LIST) {
                        const arr_len = val.length;
                        if (arr_len > this._data_length) {
                            this._data_length = arr_len;
                        }
                    }
                    else if (this._data_type === _common__WEBPACK_IMPORTED_MODULE_0__["EAttribDataTypeStrs"].DICT) {
                        const arr_len = Object.keys(val).length;
                        if (arr_len > this._data_length) {
                            this._data_length = arr_len;
                        }
                    }
                }
            }
        });
    }
    /**
     * Sets the indexed value for a given entity or entities.
     * This assumes that this attribute is a list.
     * @param ent_i
     * @param idx
     * @param val
     */
    setEntListIdxVal(ents_i, idx, val) {
        // check this is a list
        if (this._data_type !== _common__WEBPACK_IMPORTED_MODULE_0__["EAttribDataTypeStrs"].LIST) {
            throw new Error('Setting indexed attribute, but the attribute is not a list: "' + this._name + '".');
        }
        // make sure we have an array of ents_i
        ents_i = (Array.isArray(ents_i)) ? ents_i : [ents_i];
        // loop through all the unique ents, and setEntVal
        let unique_ents_i = ents_i;
        if (ents_i.length > 1) {
            unique_ents_i = Array.from(new Set(ents_i));
        }
        unique_ents_i.forEach(ent_i => {
            const exist_list = this.getEntVal(ent_i);
            let new_list = [];
            if (exist_list !== undefined) {
                new_list = lodash__WEBPACK_IMPORTED_MODULE_2__["cloneDeep"](exist_list); // IMPORTANT clone the array
            }
            if (idx < 0) {
                idx += new_list.length;
            }
            new_list[idx] = val;
            this.setEntVal(ent_i, new_list);
        });
    }
    /**
     * Sets the keyed value for a given entity or entities.
     * This assumes that this attribute is a dict.
     * @param ents_i
     * @param key
     * @param val
     */
    setEntDictKeyVal(ents_i, key, val) {
        // check this is a dict
        if (this._data_type !== _common__WEBPACK_IMPORTED_MODULE_0__["EAttribDataTypeStrs"].DICT) {
            throw new Error('Setting keyed attribute, but the attribute is not a dict: "' + this._name + '".');
        }
        // make sure we have an array of ents_i
        ents_i = (Array.isArray(ents_i)) ? ents_i : [ents_i];
        // loop through all the unique ents, and setEntVal
        let unique_ents_i = ents_i;
        if (ents_i.length > 1) {
            unique_ents_i = Array.from(new Set(ents_i));
        }
        unique_ents_i.forEach(ent_i => {
            const exist_dict = this.getEntVal(ent_i);
            let new_dict = {};
            if (exist_dict !== undefined) {
                new_dict = lodash__WEBPACK_IMPORTED_MODULE_2__["cloneDeep"](exist_dict); // IMPORTANT clone the dict
            }
            new_dict[key] = val;
            this.setEntVal(ent_i, new_dict);
        });
    }
    /**
     * Gets the value for a given entity, or an array of values given an array of entities.
     * ~
     * Returns undefined if the entity does not exist in this map.
     * ~
     * @param ent_i
     */
    getEntVal(ents_i) {
        if (!Array.isArray(ents_i)) {
            const ent_i = ents_i;
            const val_i = this._map_ent_i_to_val_i.get(ent_i);
            if (val_i === undefined) {
                return undefined;
            }
            // return this._map_val_i_to_val.get(val_i) as TAttribDataTypes;
            return this._modeldata.model.metadata.getAttribValFromIdx(val_i, this._data_type);
        }
        else {
            return ents_i.map(ent_i => this.getEntVal(ent_i));
        }
    }
    /**
     * Gets the indexed value in a list  for a given entity.
     * Returns undefined if the entity does not exist
     * This assumes that this attribute is a list.
     * @param ent_i
     */
    getEntListIdxVal(ents_i, idx) {
        if (this._data_type !== _common__WEBPACK_IMPORTED_MODULE_0__["EAttribDataTypeStrs"].LIST) {
            throw new Error('Trying to get indexed value, but the attribute data type is not a list.');
        }
        if (!Array.isArray(ents_i)) {
            const ent_i = ents_i;
            const exist_value_arr = this.getEntVal(ent_i);
            return exist_value_arr[idx];
        }
        else {
            return ents_i.map(ent_i => this.getEntVal(ent_i)[idx]);
        }
    }
    /**
     * Gets the value in an dict for a given entity.
     * Returns undefined if the entity does not exist
     * This assumes that this attribute is a dict.
     * @param ent_i
     */
    getEntDictKeyVal(ents_i, key) {
        if (this._data_type !== _common__WEBPACK_IMPORTED_MODULE_0__["EAttribDataTypeStrs"].DICT) {
            throw new Error('Trying to get key value, but the attribute data type is not a dict.');
        }
        if (!Array.isArray(ents_i)) {
            const ent_i = ents_i;
            const exist_value_arr = this.getEntVal(ent_i);
            return exist_value_arr[key];
        }
        else {
            return ents_i.map(ent_i => this.getEntVal(ent_i)[key]);
        }
    }
    /**
     * Gets all the keys that have a given value
     * If the value does not exist an empty array is returned
     * The value can be a list or object
     * @param val
     */
    getEntsFromVal(val) {
        // const val_i: number = this._map_val_k_to_val_i.get(this._valToValkey(val));
        const val_i = this._modeldata.model.metadata.getAttribIdxFromKey(this._valToValkey(val), this._data_type);
        if (val_i === undefined) {
            return [];
        }
        return this._map_val_i_to_ents_i.get(val_i);
    }
    /**
     * Returns an array of entity indices which do not have a value (undefined)
     */
    getEntsWithoutVal(ents_i) {
        return ents_i.filter(ent_i => !this._map_ent_i_to_val_i.has(ent_i));
    }
    /**
     * Returns an array of entity indices which have a value (not undefined)
     */
    getEntsWithVal(ents_i) {
        return ents_i.filter(ent_i => this._map_ent_i_to_val_i.has(ent_i));
    }
    /**
     * Executes a query.
     * ~
     * The value can be NUMBER, STRING, BOOLEAN, LIST or DICT
     * ~
     * @param ents_i
     * @param operator The relational operator, ==, !=, <=, >=, etc
     * @param search_val The value to search, string or number, or any[].
     */
    queryVal(ents_i, operator, search_val) {
        // check the null search case
        if (search_val === null) {
            if (operator !== _common__WEBPACK_IMPORTED_MODULE_0__["EFilterOperatorTypes"].IS_EQUAL && operator !== _common__WEBPACK_IMPORTED_MODULE_0__["EFilterOperatorTypes"].IS_NOT_EQUAL) {
                {
                    throw new Error('Query operator "' + operator + '" and query "null" value are incompatible.');
                }
            }
        }
        // search
        if (this._data_type === _common__WEBPACK_IMPORTED_MODULE_0__["EAttribDataTypeStrs"].NUMBER) {
            if (search_val !== null && typeof search_val !== 'number') {
                throw new Error('Query search value "' + search_val + '" is not a number.');
            }
            return this._searchNumVal(ents_i, operator, search_val);
        }
        else if (this._data_type === _common__WEBPACK_IMPORTED_MODULE_0__["EAttribDataTypeStrs"].STRING) {
            if (operator !== _common__WEBPACK_IMPORTED_MODULE_0__["EFilterOperatorTypes"].IS_EQUAL && operator !== _common__WEBPACK_IMPORTED_MODULE_0__["EFilterOperatorTypes"].IS_NOT_EQUAL) {
                throw new Error('Query operator "' + operator + '" and query "' + search_val + '" value are incompatible.');
            }
            if (search_val !== null && typeof search_val !== 'string') {
                throw new Error('Query search value "' + search_val + '" is not a string.');
            }
            return this._searchStrVal(ents_i, operator, search_val);
        }
        else if (this._data_type === _common__WEBPACK_IMPORTED_MODULE_0__["EAttribDataTypeStrs"].BOOLEAN) {
            if (search_val !== null && typeof search_val !== 'boolean') {
                throw new Error('Query search value "' + search_val + '" is not a boolean.');
            }
            return this._searchBoolVal(ents_i, operator, search_val);
        }
        else if (this._data_type === _common__WEBPACK_IMPORTED_MODULE_0__["EAttribDataTypeStrs"].LIST) {
            if (search_val !== null && !Array.isArray(search_val)) {
                throw new Error('Query search value "' + search_val + '" is not a list.');
            }
            return this._searchListVal(ents_i, operator, search_val);
        }
        else if (this._data_type === _common__WEBPACK_IMPORTED_MODULE_0__["EAttribDataTypeStrs"].DICT) {
            if (search_val !== null && typeof search_val !== 'object') {
                throw new Error('Query search value "' + search_val + '" is not an dictionary.');
            }
            return this._searchObjVal(ents_i, operator, search_val);
        }
        else {
            throw new Error('Bad query.');
        }
    }
    /**
     * Executes a query for an indexed valued in a list
     * @param ents_i
     * @param val_arr_idx The index of the value in the array
     * @param operator The relational operator, ==, !=, <=, >=, etc
     * @param search_val The value to search, string or number, or any[].
     */
    queryListIdxVal(ents_i, val_arr_idx, operator, search_val) {
        // check the null search case
        if (search_val === null) {
            if (operator !== _common__WEBPACK_IMPORTED_MODULE_0__["EFilterOperatorTypes"].IS_EQUAL && operator !== _common__WEBPACK_IMPORTED_MODULE_0__["EFilterOperatorTypes"].IS_NOT_EQUAL) {
                {
                    throw new Error('Query operator "' + operator + '" and query "null" value are incompatible.');
                }
            }
        }
        // check
        if (!Number.isInteger(val_arr_idx)) {
            throw new Error('Query index "' + val_arr_idx + '" must be of type "number", and must be an integer.');
        }
        if (this._data_type !== _common__WEBPACK_IMPORTED_MODULE_0__["EAttribDataTypeStrs"].LIST) {
            throw new Error('Query attribute "' + this._name + '" is not a list.');
        }
        // search
        return this._searchListIdxVal(ents_i, val_arr_idx, operator, search_val);
    }
    /**
     * Executes a query for an valued in an object, identified by a key
     * @param ents_i
     * @param val_obj_key The key of the value in the object
     * @param operator The relational operator, ==, !=, <=, >=, etc
     * @param search_val The value to search, string or number, or any[].
     */
    queryDictKeyVal(ents_i, val_obj_key, operator, search_val) {
        // check the null search case
        if (search_val === null) {
            if (operator !== _common__WEBPACK_IMPORTED_MODULE_0__["EFilterOperatorTypes"].IS_EQUAL && operator !== _common__WEBPACK_IMPORTED_MODULE_0__["EFilterOperatorTypes"].IS_NOT_EQUAL) {
                {
                    throw new Error('Query operator "' + operator + '" and query "null" value are incompatible.');
                }
            }
        }
        // check
        if (typeof val_obj_key !== 'string') {
            throw new Error('Query index "' + val_obj_key + '" must be of type "string".');
        }
        if (this._data_type !== _common__WEBPACK_IMPORTED_MODULE_0__["EAttribDataTypeStrs"].DICT) {
            throw new Error('Query attribute "' + this._name + '" is not a dictionary.');
        }
        // search
        return this._searchDictKeyVal(ents_i, val_obj_key, operator, search_val);
    }
    //  ===============================================================================================================
    //  Private methods
    //  ===============================================================================================================
    /**
     * Convert a value into a map key
     *
     * The key can be either a string or a number.
     * string -> string
     * number -> number
     * boolean -> number (1 or 0)
     * list -> string
     */
    _valToValkey(val) {
        if (this._data_type === _common__WEBPACK_IMPORTED_MODULE_0__["EAttribDataTypeStrs"].STRING) {
            if (typeof val !== 'string') {
                throw new Error('Value must be of type "string".');
            }
            return val;
        }
        else if (this._data_type === _common__WEBPACK_IMPORTED_MODULE_0__["EAttribDataTypeStrs"].NUMBER) {
            if (typeof val !== 'number') {
                throw new Error('Value must be of type "number".');
            }
            return val;
        }
        else if (this._data_type === _common__WEBPACK_IMPORTED_MODULE_0__["EAttribDataTypeStrs"].BOOLEAN) {
            if (typeof val !== 'boolean') {
                throw new Error('Value must be of type "boolean".');
            }
            else {
                if (val) {
                    return 1;
                }
                else {
                    return 0;
                }
            }
        }
        else if (this._data_type === _common__WEBPACK_IMPORTED_MODULE_0__["EAttribDataTypeStrs"].LIST) {
            if (!Array.isArray(val)) {
                throw new Error('Value must be of type "list".');
            }
            return JSON.stringify(val);
        }
        else if (this._data_type === _common__WEBPACK_IMPORTED_MODULE_0__["EAttribDataTypeStrs"].DICT) {
            if (typeof val !== 'object') {
                throw new Error('Value must be of type "object".');
            }
            return JSON.stringify(val);
        }
        // datatype is none of the above
        throw new Error('Datatype not recognised.');
    }
    /**
     * Checks if anything still points to this value
     * If not, cleans up the arrays
     * _map_val_i_to_ents_i
     * _map_val_i_to_val
     * _map_val_k_to_val_i
     */
    _cleanUp(val_i) {
        if (val_i !== undefined) {
            // _map_val_i_to_ents_i: Map<number, number[]>
            const ents_i = this._map_val_i_to_ents_i.get(val_i);
            if (ents_i.length === 0) {
                this._map_val_i_to_ents_i.delete(val_i);
            }
        }
    }
    /**
     * Compare two values with a comparison operator, ==, !=, >, >=, <, <=
     * ~
     * If the values are of different types, then false is returned.
     * ~
     * For arrays, true is returned only if a pairwise comparison between the items in the two arrays all return true.
     * The two arrays must also be of equal length.
     * ~
     * Values may be null.
     * Values that are undefined will be treated as null.
     * ~
     * @param operator
     * @param val1
     * @param val2
     */
    _compare(operator, val1, val2) {
        if (Array.isArray(val1)) {
            if (!Array.isArray(val2)) {
                return false;
            }
            if (val1.length !== val2.length) {
                return false;
            }
            for (let i = 0; i < val1.length; i++) {
                if (!this._compare(operator, val1[i], val2[i])) {
                    return false;
                }
            }
            return true;
        }
        if (val1 === undefined) {
            val1 = null;
        }
        if (val2 === undefined) {
            val2 = null;
        }
        if (typeof val1 !== typeof val2) {
            return false;
        }
        switch (operator) {
            // ==
            case _common__WEBPACK_IMPORTED_MODULE_0__["EFilterOperatorTypes"].IS_EQUAL:
                return val1 === val2;
            // !=
            case _common__WEBPACK_IMPORTED_MODULE_0__["EFilterOperatorTypes"].IS_NOT_EQUAL:
                return val1 !== val2;
            // >
            case _common__WEBPACK_IMPORTED_MODULE_0__["EFilterOperatorTypes"].IS_GREATER:
                return val1 > val2;
            // >=
            case _common__WEBPACK_IMPORTED_MODULE_0__["EFilterOperatorTypes"].IS_GREATER_OR_EQUAL:
                return val1 >= val2;
            // <
            case _common__WEBPACK_IMPORTED_MODULE_0__["EFilterOperatorTypes"].IS_LESS:
                return val1 < val2;
            // <=
            case _common__WEBPACK_IMPORTED_MODULE_0__["EFilterOperatorTypes"].IS_LESS_OR_EQUAL:
                return val1 <= val2;
            default:
                throw new Error('Query operator not found: ' + operator);
        }
    }
    // ======================================================
    /**
     * Searches for the number value using the operator
     */
    _searchNumVal(ents_i, operator, search_val) {
        // first deal with null cases
        if (search_val === null && operator === _common__WEBPACK_IMPORTED_MODULE_0__["EFilterOperatorTypes"].IS_EQUAL) {
            return this.getEntsWithoutVal(ents_i);
        }
        else if (search_val === null && operator === _common__WEBPACK_IMPORTED_MODULE_0__["EFilterOperatorTypes"].IS_NOT_EQUAL) {
            return this.getEntsWithVal(ents_i);
        }
        // search
        let found_keys;
        switch (operator) {
            case _common__WEBPACK_IMPORTED_MODULE_0__["EFilterOperatorTypes"].IS_EQUAL:
                found_keys = this.getEntsFromVal(search_val);
                if (found_keys === undefined) {
                    return [];
                }
                return ents_i.filter(ent_i => found_keys.indexOf(ent_i) !== -1);
            case _common__WEBPACK_IMPORTED_MODULE_0__["EFilterOperatorTypes"].IS_NOT_EQUAL:
                found_keys = this.getEntsFromVal(search_val);
                if (found_keys === undefined) {
                    return [];
                }
                return ents_i.filter(ent_i => found_keys.indexOf(ent_i) === -1);
            case _common__WEBPACK_IMPORTED_MODULE_0__["EFilterOperatorTypes"].IS_GREATER:
            case _common__WEBPACK_IMPORTED_MODULE_0__["EFilterOperatorTypes"].IS_GREATER_OR_EQUAL:
            case _common__WEBPACK_IMPORTED_MODULE_0__["EFilterOperatorTypes"].IS_LESS:
            case _common__WEBPACK_IMPORTED_MODULE_0__["EFilterOperatorTypes"].IS_LESS_OR_EQUAL:
                found_keys = [];
                for (const ent_i of ents_i) {
                    const val = this.getEntVal(ent_i);
                    if ((val !== null && val !== undefined) && this._compare(operator, val, search_val)) {
                        found_keys.push(ent_i);
                    }
                }
                return found_keys;
            default:
                throw new Error('Query error: Operator not found.');
        }
    }
    /**
     * Searches for the string value using the operator
     */
    _searchStrVal(ents_i, operator, search_val) {
        // first deal with null cases
        if (search_val === null && operator === _common__WEBPACK_IMPORTED_MODULE_0__["EFilterOperatorTypes"].IS_EQUAL) {
            return this.getEntsWithoutVal(ents_i);
        }
        else if (search_val === null && operator === _common__WEBPACK_IMPORTED_MODULE_0__["EFilterOperatorTypes"].IS_NOT_EQUAL) {
            return this.getEntsWithVal(ents_i);
        }
        // search
        let found_keys;
        switch (operator) {
            case _common__WEBPACK_IMPORTED_MODULE_0__["EFilterOperatorTypes"].IS_EQUAL:
                found_keys = this.getEntsFromVal(search_val);
                if (found_keys === undefined) {
                    return [];
                }
                return ents_i.filter(ent_i => found_keys.indexOf(ent_i) !== -1);
            case _common__WEBPACK_IMPORTED_MODULE_0__["EFilterOperatorTypes"].IS_NOT_EQUAL:
                found_keys = this.getEntsFromVal(search_val);
                if (found_keys === undefined) {
                    return [];
                }
                return ents_i.filter(ent_i => found_keys.indexOf(ent_i) === -1);
            case _common__WEBPACK_IMPORTED_MODULE_0__["EFilterOperatorTypes"].IS_GREATER:
            case _common__WEBPACK_IMPORTED_MODULE_0__["EFilterOperatorTypes"].IS_GREATER_OR_EQUAL:
            case _common__WEBPACK_IMPORTED_MODULE_0__["EFilterOperatorTypes"].IS_LESS:
            case _common__WEBPACK_IMPORTED_MODULE_0__["EFilterOperatorTypes"].IS_LESS_OR_EQUAL:
                throw new Error('Query error: Operator not allowed with string values.');
            default:
                throw new Error('Query error: Operator not found.');
        }
    }
    /**
     * Searches for the boolean value using the operator
     */
    _searchBoolVal(ents_i, operator, search_val) {
        // first deal with null cases
        if (search_val === null && operator === _common__WEBPACK_IMPORTED_MODULE_0__["EFilterOperatorTypes"].IS_EQUAL) {
            return this.getEntsWithoutVal(ents_i);
        }
        else if (search_val === null && operator === _common__WEBPACK_IMPORTED_MODULE_0__["EFilterOperatorTypes"].IS_NOT_EQUAL) {
            return this.getEntsWithVal(ents_i);
        }
        // search
        let found_keys;
        switch (operator) {
            case _common__WEBPACK_IMPORTED_MODULE_0__["EFilterOperatorTypes"].IS_EQUAL:
                found_keys = this.getEntsFromVal(search_val);
                if (found_keys === undefined) {
                    return [];
                }
                return ents_i.filter(ent_i => found_keys.indexOf(ent_i) !== -1);
            case _common__WEBPACK_IMPORTED_MODULE_0__["EFilterOperatorTypes"].IS_NOT_EQUAL:
                found_keys = this.getEntsFromVal(search_val);
                if (found_keys === undefined) {
                    return [];
                }
                return ents_i.filter(ent_i => found_keys.indexOf(ent_i) === -1);
            case _common__WEBPACK_IMPORTED_MODULE_0__["EFilterOperatorTypes"].IS_GREATER:
            case _common__WEBPACK_IMPORTED_MODULE_0__["EFilterOperatorTypes"].IS_GREATER_OR_EQUAL:
            case _common__WEBPACK_IMPORTED_MODULE_0__["EFilterOperatorTypes"].IS_LESS:
            case _common__WEBPACK_IMPORTED_MODULE_0__["EFilterOperatorTypes"].IS_LESS_OR_EQUAL:
                throw new Error('Query error: Operator not allowed with boolean values.');
            default:
                throw new Error('Query error: Operator not found.');
        }
    }
    /**
     * Searches for the list value using the operator
     */
    _searchListVal(ents_i, operator, search_val) {
        // first deal with null cases
        if (search_val === null && operator === _common__WEBPACK_IMPORTED_MODULE_0__["EFilterOperatorTypes"].IS_EQUAL) {
            return this.getEntsWithoutVal(ents_i);
        }
        else if (search_val === null && operator === _common__WEBPACK_IMPORTED_MODULE_0__["EFilterOperatorTypes"].IS_NOT_EQUAL) {
            return this.getEntsWithVal(ents_i);
        }
        // search
        let found_keys;
        switch (operator) {
            case _common__WEBPACK_IMPORTED_MODULE_0__["EFilterOperatorTypes"].IS_EQUAL:
                found_keys = this.getEntsFromVal(search_val);
                if (found_keys === undefined) {
                    return [];
                }
                return ents_i.filter(ent_i => found_keys.indexOf(ent_i) !== -1);
            case _common__WEBPACK_IMPORTED_MODULE_0__["EFilterOperatorTypes"].IS_NOT_EQUAL:
                found_keys = this.getEntsFromVal(search_val);
                if (found_keys === undefined) {
                    return [];
                }
                return ents_i.filter(ent_i => found_keys.indexOf(ent_i) === -1);
            case _common__WEBPACK_IMPORTED_MODULE_0__["EFilterOperatorTypes"].IS_GREATER:
            case _common__WEBPACK_IMPORTED_MODULE_0__["EFilterOperatorTypes"].IS_GREATER_OR_EQUAL:
            case _common__WEBPACK_IMPORTED_MODULE_0__["EFilterOperatorTypes"].IS_LESS:
            case _common__WEBPACK_IMPORTED_MODULE_0__["EFilterOperatorTypes"].IS_LESS_OR_EQUAL:
                found_keys = [];
                for (const ent_i of ents_i) {
                    const val = this.getEntVal(ent_i);
                    if ((val !== null && val !== undefined) && this._compare(operator, val, search_val)) {
                        found_keys.push(ent_i);
                    }
                }
                return found_keys;
            default:
                throw new Error('Query error: Operator not found.');
        }
    }
    /**
     * Searches for the object value using the operator
     */
    _searchObjVal(ents_i, operator, search_val) {
        // first deal with null cases
        if (search_val === null && operator === _common__WEBPACK_IMPORTED_MODULE_0__["EFilterOperatorTypes"].IS_EQUAL) {
            return this.getEntsWithoutVal(ents_i);
        }
        else if (search_val === null && operator === _common__WEBPACK_IMPORTED_MODULE_0__["EFilterOperatorTypes"].IS_NOT_EQUAL) {
            return this.getEntsWithVal(ents_i);
        }
        // search
        let found_keys;
        switch (operator) {
            case _common__WEBPACK_IMPORTED_MODULE_0__["EFilterOperatorTypes"].IS_EQUAL:
                found_keys = this.getEntsFromVal(search_val);
                if (found_keys === undefined) {
                    return [];
                }
                return ents_i.filter(ent_i => found_keys.indexOf(ent_i) !== -1);
            case _common__WEBPACK_IMPORTED_MODULE_0__["EFilterOperatorTypes"].IS_NOT_EQUAL:
                found_keys = this.getEntsFromVal(search_val);
                if (found_keys === undefined) {
                    return [];
                }
                return ents_i.filter(ent_i => found_keys.indexOf(ent_i) === -1);
            case _common__WEBPACK_IMPORTED_MODULE_0__["EFilterOperatorTypes"].IS_GREATER:
            case _common__WEBPACK_IMPORTED_MODULE_0__["EFilterOperatorTypes"].IS_GREATER_OR_EQUAL:
            case _common__WEBPACK_IMPORTED_MODULE_0__["EFilterOperatorTypes"].IS_LESS:
            case _common__WEBPACK_IMPORTED_MODULE_0__["EFilterOperatorTypes"].IS_LESS_OR_EQUAL:
                throw new Error('Query error: Operator not allowed with values of type "dict".');
            default:
                throw new Error('Query error: Operator not found.');
        }
    }
    /**
     * Searches for the value using the operator
     */
    _searchListIdxVal(ents_i, arr_idx, operator, search_val) {
        // do the search
        const found_ents_i = [];
        for (const ent_i of ents_i) {
            const search_value_arr = this.getEntVal(ent_i);
            if (search_value_arr !== undefined) {
                const comp = this._compare(operator, search_value_arr[arr_idx], search_val);
                if (comp) {
                    found_ents_i.push(ent_i);
                }
            }
        }
        return found_ents_i;
    }
    /**
         * Searches for the value using the operator
         */
    _searchDictKeyVal(ents_i, obj_key, operator, search_val) {
        // do the search
        const found_ents_i = [];
        for (const ent_i of ents_i) {
            const search_value_arr = this.getEntVal(ent_i);
            if (search_value_arr !== undefined) {
                const comp = this._compare(operator, search_value_arr[obj_key], search_val);
                if (comp) {
                    found_ents_i.push(ent_i);
                }
            }
        }
        return found_ents_i;
    }
}


/***/ }),

/***/ "./src/assets/libs/geo-info/GIAttribMapBool.ts":
/*!*****************************************************!*\
  !*** ./src/assets/libs/geo-info/GIAttribMapBool.ts ***!
  \*****************************************************/
/*! exports provided: GIAttribMapBool */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GIAttribMapBool", function() { return GIAttribMapBool; });
/* harmony import */ var _util_arrs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/arrs */ "./src/assets/libs/util/arrs.ts");
/* harmony import */ var _GIAttribMap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GIAttribMap */ "./src/assets/libs/geo-info/GIAttribMap.ts");
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};


/**
 * Geo-info attribute class for one attribute.
 * The attributs stores key-value pairs.
 * Multiple keys point to the same value.
 * So for example, [[1,3], "a"],[[0,4], "b"] can be converted into sequential arrays.
 * The values would be ["a", "b"]
 * The keys would be [1,0,,0,1] (Note the undefined value in the middle.)
 *
 */
class GIAttribMapBool extends _GIAttribMap__WEBPACK_IMPORTED_MODULE_1__["GIAttribMap"] {
    /**
     * Creates an attribute.
     * @param attrib_data
     */
    constructor(modeldata, name, ent_type, data_type) {
        super(modeldata, name, ent_type, data_type);
    }
    /**
     * Returns a nested array of entities and values, like this:
     * [ [[2,4,6,8], 'hello'], [[9,10], 'world']]
     * This is the same format as used in gi-json
     * This matches the method setEntsVals()
     */
    getEntsVals() {
        const ents_i_values = [];
        this._map_val_i_to_ents_i.forEach((ents_i, val_i) => {
            // val_i is either 0 or 1 (false or true)
            const val = [false, true][val_i];
            ents_i_values.push([ents_i, val]);
        });
        return ents_i_values;
    }
    /**
     * Sets the value for a given entity or entities.
     *
     * If the value is undefined, no action is taken.
     *
     * The value can be null, in which case it is equivalent to deleting the entities from this attrib map.
     *
     * @param ent_i
     * @param val
     */
    setEntVal(ents_i, val, check_type = true) {
        // if indefined, do nothing
        if (val === undefined) {
            return;
        }
        // if null, delete
        if (val === null) {
            this.delEnt(ents_i);
            return;
        }
        // check the type
        if (check_type) {
            if (typeof val !== 'boolean') {
                throw new Error('Error setting attribute value. Attribute is of type "boolean" but the value is not a boolean.');
            }
        }
        // val_i is either 0 or 1 (false or true)
        const val_i = val ? 1 : 0;
        // an array of ents
        ents_i = (Array.isArray(ents_i)) ? ents_i : [ents_i];
        // loop through all the unique ents, and set _map_ent_i_to_val_i
        let unique_ents_i = ents_i;
        if (ents_i.length > 1) {
            unique_ents_i = Array.from(new Set(ents_i));
        }
        unique_ents_i.forEach(ent_i => {
            // keep the old value for later
            const old_val_i = this._map_ent_i_to_val_i.get(ent_i);
            // for each ent_i, set the new val_i
            this._map_ent_i_to_val_i.set(ent_i, val_i);
            // clean up the old val_i
            if (old_val_i !== undefined && old_val_i !== val_i) {
                Object(_util_arrs__WEBPACK_IMPORTED_MODULE_0__["arrRem"])(this._map_val_i_to_ents_i.get(old_val_i), ent_i);
                // clean up just in case that was the last entity with this value
                this._cleanUp(old_val_i);
            }
            // update the time stamp for this entity
            this._modeldata.geom.time_stamp.updateEntTs(this._ent_type, ent_i);
        });
        // for the val_i, set it to point to all the ents that have this value
        const exist_ents_i = this._map_val_i_to_ents_i.get(val_i);
        const exist_new_ents_i = exist_ents_i === undefined ?
            ents_i :
            Array.from(new Set(exist_ents_i.concat(ents_i)));
        this._map_val_i_to_ents_i.set(val_i, exist_new_ents_i);
    }
    /**
     * Dumps another attrib map into this attrib map
     * Assumes tha this map is empty
     * @param attrib_map The attrib map to merge into this map
     */
    dumpSelect(attrib_map, selected) {
        selected.forEach(selected_ent_i => {
            if (attrib_map._map_ent_i_to_val_i.has(selected_ent_i)) {
                const val_i = attrib_map._map_ent_i_to_val_i.get(selected_ent_i);
                const ents_i = attrib_map._map_val_i_to_ents_i.get(val_i);
                const ents2_i = ents_i.filter(ent_i => selected.has(ent_i));
                this._map_val_i_to_ents_i.set(val_i, ents2_i);
                ents2_i.forEach(ent_i => this._map_ent_i_to_val_i.set(ent_i, val_i));
            }
        });
    }
    /**
     * Gets the value for a given entity, or an array of values given an array of entities.
     * ~
     * Returns undefined if the entity does not exist in this map.
     * ~
     * @param ent_i
     */
    getEntVal(ents_i) {
        if (!Array.isArray(ents_i)) {
            const ent_i = ents_i;
            const val_i = this._map_ent_i_to_val_i.get(ent_i);
            if (val_i === undefined) {
                return undefined;
            }
            return [false, true][val_i];
        }
        else {
            return ents_i.map(ent_i => this.getEntVal(ent_i));
        }
    }
    /**
     * Gets all the keys that have a given value
     * If the value does not exist an empty array is returned
     * The value can be a list or object
     * @param val
     */
    getEntsFromVal(val) {
        const val_i = val ? 1 : 0;
        const ents_i = this._map_val_i_to_ents_i.get(val_i);
        if (ents_i === undefined) {
            return [];
        }
        return ents_i;
    }
}


/***/ }),

/***/ "./src/assets/libs/geo-info/GIAttribModify.ts":
/*!****************************************************!*\
  !*** ./src/assets/libs/geo-info/GIAttribModify.ts ***!
  \****************************************************/
/*! exports provided: GIAttribsModify */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GIAttribsModify", function() { return GIAttribsModify; });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common */ "./src/assets/libs/geo-info/common.ts");
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};

/**
 * Class for attributes.
 */
class GIAttribsModify {
    /**
      * Creates an object to store the attribute data.
      * @param modeldata The JSON data
      */
    constructor(modeldata, attribs_maps) {
        this._modeldata = modeldata;
        this._attribs_maps = attribs_maps;
    }
    /**
     * Deletes an existing attribute.
     * Time stamps are not updated.
     *
     * @param ent_type The level at which to create the attribute.
     * @param name The name of the attribute.
     * @return True if the attribute was created, false otherwise.
     */
    delAttrib(ent_type, name) {
        const attribs_maps_key = _common__WEBPACK_IMPORTED_MODULE_0__["EEntTypeStr"][ent_type];
        const attribs = this._attribs_maps[attribs_maps_key];
        // delete
        return attribs.delete(name);
    }
    /**
     * Rename an existing attribute.
     * Time stamps are not updated.
     *
     * @param ent_type The level at which to create the attribute.
     * @param old_name The name of the old attribute.
     * @param new_name The name of the new attribute.
     * @return True if the attribute was renamed, false otherwise.
     */
    renameAttrib(ent_type, old_name, new_name) {
        const attribs_maps_key = _common__WEBPACK_IMPORTED_MODULE_0__["EEntTypeStr"][ent_type];
        const attribs = this._attribs_maps[attribs_maps_key];
        if (!attribs.has(old_name)) {
            return false;
        }
        if (attribs.has(new_name)) {
            return false;
        }
        if (old_name === new_name) {
            return false;
        }
        // rename
        const attrib = attribs.get(old_name);
        attrib.setName(new_name);
        const result = attribs.set(new_name, attrib);
        return attribs.delete(old_name);
    }
}


/***/ }),

/***/ "./src/assets/libs/geo-info/GIAttribs.ts":
/*!***********************************************!*\
  !*** ./src/assets/libs/geo-info/GIAttribs.ts ***!
  \***********************************************/
/*! exports provided: GIAttribs */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GIAttribs", function() { return GIAttribs; });
/* harmony import */ var _GIAttribsAdd__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GIAttribsAdd */ "./src/assets/libs/geo-info/GIAttribsAdd.ts");
/* harmony import */ var _GIAttribsThreejs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GIAttribsThreejs */ "./src/assets/libs/geo-info/GIAttribsThreejs.ts");
/* harmony import */ var _GIAttribsQuery__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./GIAttribsQuery */ "./src/assets/libs/geo-info/GIAttribsQuery.ts");
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./common */ "./src/assets/libs/geo-info/common.ts");
/* harmony import */ var _GIAttribsIO__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./GIAttribsIO */ "./src/assets/libs/geo-info/GIAttribsIO.ts");
/* harmony import */ var _GIAttribModify__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./GIAttribModify */ "./src/assets/libs/geo-info/GIAttribModify.ts");
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};






function hashCode(s) {
    let h;
    for (let i = 0; i < s.length; i++) {
        // tslint:disable-next-line:no-bitwise
        h = Math.imul(31, h) + s.charCodeAt(i) | 0;
    }
    return h;
}
const eny_type_array = [
    _common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].POSI,
    _common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].VERT,
    _common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].EDGE,
    _common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].WIRE,
    _common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].FACE,
    _common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].POINT,
    _common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].PLINE,
    _common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].PGON,
    _common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].COLL,
    _common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].MOD
];
const ent_type_strs = new Map([
    [_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].POSI, 'positions'],
    [_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].VERT, 'vertices'],
    [_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].EDGE, 'edges'],
    [_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].WIRE, 'wires'],
    [_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].FACE, 'faces'],
    [_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].POINT, 'points'],
    [_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].PLINE, 'polylines'],
    [_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].PGON, 'polygons'],
    [_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].COLL, 'collections'],
    [_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].MOD, 'model']
]);
/**
 * Class for attributes.
 */
class GIAttribs {
    /**
      * Creates an object to store the attribute data.
      * @param modeldata The JSON data
      */
    constructor(modeldata) {
        // maps, the key is the name, the value is the attrib map clas
        this._attribs_maps = {
            ps: new Map(),
            _v: new Map(),
            _e: new Map(),
            _w: new Map(),
            _f: new Map(),
            pt: new Map(),
            pl: new Map(),
            pg: new Map(),
            co: new Map(),
            mo: new Map()
        };
        this._modeldata = modeldata;
        this.io = new _GIAttribsIO__WEBPACK_IMPORTED_MODULE_4__["GIAttribsIO"](modeldata, this._attribs_maps);
        this.add = new _GIAttribsAdd__WEBPACK_IMPORTED_MODULE_0__["GIAttribsAdd"](modeldata, this._attribs_maps);
        this.modify = new _GIAttribModify__WEBPACK_IMPORTED_MODULE_5__["GIAttribsModify"](modeldata, this._attribs_maps);
        this.query = new _GIAttribsQuery__WEBPACK_IMPORTED_MODULE_2__["GIAttribsQuery"](modeldata, this._attribs_maps);
        this.threejs = new _GIAttribsThreejs__WEBPACK_IMPORTED_MODULE_1__["GIAttribsThreejs"](modeldata, this._attribs_maps);
        // create xyz on posis
        this.add.addAttrib(_common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].POSI, _common__WEBPACK_IMPORTED_MODULE_3__["EAttribNames"].COORDS, _common__WEBPACK_IMPORTED_MODULE_3__["EAttribDataTypeStrs"].LIST);
    }
    /**
     * Compares this model and another model.
     * ~
     * If check_equality=false, the max total score will be equal to the number of attributes in this model.
     * It checks that each attribute in this model exists in the other model. If it exists, 1 mark is assigned.
     * ~
     * If check_equality=true, the max score will be increased by 10, equal to the number of entity levels.
     * For each entity level, if the other model contains no additional attributes, then one mark is assigned.
     * ~
     * @param other_model The model to compare with.
     */
    compare(other_model, result) {
        result.comment.push('Comparing attribute names and types.');
        // compare all attributes except model attributes
        // check that this model is a subset of other model
        // all the attributes in this model must also be in other model
        const attrib_comments = [];
        let matches = true;
        const attrib_names = new Map();
        for (const ent_type of eny_type_array) {
            // get the attrib names
            const ent_type_str = ent_type_strs.get(ent_type);
            const this_attrib_names = this._modeldata.attribs.query.getAttribNames(ent_type);
            const other_attrib_names = other_model.modeldata.attribs.query.getAttribNames(ent_type);
            attrib_names.set(ent_type, this_attrib_names);
            // check that each attribute in this model exists in the other model
            for (const this_attrib_name of this_attrib_names) {
                // check is this is built in
                let is_built_in = false;
                if (this_attrib_name === 'xyz' || this_attrib_name === 'rgb' || this_attrib_name.startsWith('_')) {
                    is_built_in = true;
                }
                // update the total
                if (!is_built_in) {
                    result.total += 1;
                }
                // compare names
                if (other_attrib_names.indexOf(this_attrib_name) === -1) {
                    matches = false;
                    attrib_comments.push('The "' + this_attrib_name + '" ' + ent_type_str + ' attribute is missing.');
                }
                else {
                    // get the data types
                    const data_type_1 = this._modeldata.attribs.query.getAttribDataType(ent_type, this_attrib_name);
                    const data_type_2 = other_model.modeldata.attribs.query.getAttribDataType(ent_type, this_attrib_name);
                    // compare data types
                    if (data_type_1 !== data_type_2) {
                        matches = false;
                        attrib_comments.push('The "' + this_attrib_name + '" ' + ent_type_str + ' attribute datatype is wrong. '
                            + 'It is "' + data_type_1 + '" but it should be "' + data_type_1 + '".');
                    }
                    else {
                        // update the score
                        if (!is_built_in) {
                            result.score += 1;
                        }
                    }
                }
            }
            // check if we have exact equality in attributes
            // total marks is not updated, we deduct marks
            // check that the other model does not have additional attribs
            if (other_attrib_names.length > this_attrib_names.length) {
                const additional_attribs = [];
                for (const other_attrib_name of other_attrib_names) {
                    if (this_attrib_names.indexOf(other_attrib_name) === -1) {
                        additional_attribs.push(other_attrib_name);
                    }
                }
                attrib_comments.push('There are additional ' + ent_type_str + ' attributes. ' +
                    'The following attributes are not required: [' + additional_attribs.join(',') + ']. ');
                // update the score, deduct 1 mark
                result.score -= 1;
            }
            else if (other_attrib_names.length < this_attrib_names.length) {
                attrib_comments.push('Mismatch: Model has too few entities of type: ' + ent_type_strs.get(ent_type) + '.');
            }
            else {
                // correct
            }
        }
        if (attrib_comments.length === 0) {
            attrib_comments.push('Attributes all match, both name and data type.');
        }
        // add to result
        result.comment.push(attrib_comments);
    }
    /**
     * Generate a string for debugging
     */
    toStr() {
        let result = '';
        for (const ent_type of eny_type_array) {
            const ent_type_str = ent_type_strs.get(ent_type);
            result += ent_type_str + ': ';
            if (ent_type === _common__WEBPACK_IMPORTED_MODULE_3__["EEntType"].MOD) {
                // TODO
            }
            else {
                const attrib_names = this.query.getAttribNames(ent_type);
                for (const attrib_name of attrib_names) {
                    result += JSON.stringify(this.query.getAttrib(ent_type, attrib_name).getJSONData());
                    result += '\n';
                }
            }
        }
        return result;
    }
}


/***/ }),

/***/ "./src/assets/libs/geo-info/GIAttribsAdd.ts":
/*!**************************************************!*\
  !*** ./src/assets/libs/geo-info/GIAttribsAdd.ts ***!
  \**************************************************/
/*! exports provided: GIAttribsAdd */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GIAttribsAdd", function() { return GIAttribsAdd; });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common */ "./src/assets/libs/geo-info/common.ts");
/* harmony import */ var _libs_geom_vectors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @libs/geom/vectors */ "./src/assets/libs/geom/vectors.ts");
/* harmony import */ var mathjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! mathjs */ "./node_modules/mathjs/index.js");
/* harmony import */ var mathjs__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(mathjs__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _GIAttribMapBool__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./GIAttribMapBool */ "./src/assets/libs/geo-info/GIAttribMapBool.ts");
/* harmony import */ var _GIAttribMap__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./GIAttribMap */ "./src/assets/libs/geo-info/GIAttribMap.ts");
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};





/**
 * Class for attributes.
 */
class GIAttribsAdd {
    /**
      * Creates an object to store the attribute data.
      * @param modeldata The JSON data
      */
    constructor(modeldata, attribs_maps) {
        this._modeldata = modeldata;
        this._attribs_maps = attribs_maps;
    }
    /**
     * Creates a new attribte, at either the model level or the entity level.
     * This function is call by var@att_name and by @att_name
     *
     * For entity attributes, if an attribute with the same name but different data_type already exists,
     * then an error is thrown.
     *
     * @param ent_type The level at which to create the attribute.
     * @param name The name of the attribute.
     * @param data_type The data type of the attribute.
     */
    addAttrib(ent_type, name, data_type) {
        const attribs_maps_key = _common__WEBPACK_IMPORTED_MODULE_0__["EEntTypeStr"][ent_type];
        const attribs = this._attribs_maps[attribs_maps_key];
        if (ent_type === _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].MOD) {
            this.addModelAttrib(name);
        }
        else {
            this.addEntAttrib(ent_type, name, data_type);
        }
    }
    /**
     * Creates a new attribte at the model level
     *
     * @param name The name of the attribute.
     */
    addModelAttrib(name) {
        const attribs = this._attribs_maps[_common__WEBPACK_IMPORTED_MODULE_0__["EEntTypeStr"].mo];
        if (!attribs.has(name)) {
            attribs.set(name, null);
        }
    }
    /**
     * Creates a new attribte at an  entity level.
     *
     * For entity attributes, if an attribute with the same name but different data_type already exists,
     * then an error is thrown.
     *
     * @param ent_type The level at which to create the attribute.
     * @param name The name of the attribute.
     * @param data_type The data type of the attribute.
     */
    addEntAttrib(ent_type, name, data_type) {
        const attribs_maps_key = _common__WEBPACK_IMPORTED_MODULE_0__["EEntTypeStr"][ent_type];
        const attribs = this._attribs_maps[attribs_maps_key];
        let attrib;
        if (!attribs.has(name)) {
            if (data_type === _common__WEBPACK_IMPORTED_MODULE_0__["EAttribDataTypeStrs"].BOOLEAN) {
                attrib = new _GIAttribMapBool__WEBPACK_IMPORTED_MODULE_3__["GIAttribMapBool"](this._modeldata, name, ent_type, data_type);
            }
            else {
                attrib = new _GIAttribMap__WEBPACK_IMPORTED_MODULE_4__["GIAttribMap"](this._modeldata, name, ent_type, data_type);
            }
            attribs.set(name, attrib);
        }
        else {
            attrib = attribs.get(name);
            if (attrib.getDataType() !== data_type) {
                throw new Error('Attribute could not be created due to conflict with existing attribute with same name.');
            }
        }
        return attrib;
    }
    /**
     * Set a model attrib value
     * @param id
     * @param name
     * @param value
     */
    setModelAttribVal(name, value) {
        const attribs_maps_key = _common__WEBPACK_IMPORTED_MODULE_0__["EEntTypeStr"][_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].MOD];
        const attrib = this._attribs_maps[attribs_maps_key];
        attrib.set(name, value);
    }
    /**
     * Set a model attrib indexed value.
     * If the attribute does not exist, it throws an error.
     * @param id
     * @param name
     * @param value
     */
    setModelAttribListIdxVal(name, idx, value) {
        const attribs_maps_key = _common__WEBPACK_IMPORTED_MODULE_0__["EEntTypeStr"][_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].MOD];
        const attrib = this._attribs_maps[attribs_maps_key];
        const list_value = attrib.get(name);
        if (list_value === undefined) {
            throw new Error('Attribute with this name does not exist.');
        }
        if (!Array.isArray(list_value)) {
            throw new Error('Attribute is not a list, so indexed values are not allowed.');
        }
        list_value[idx] = value;
    }
    /**
     * Set a model attrib indexed value.
     * If the attribute does not exist, it throws an error.
     * @param id
     * @param name
     * @param value
     */
    setModelAttribDictKeyVal(name, key, value) {
        const attribs_maps_key = _common__WEBPACK_IMPORTED_MODULE_0__["EEntTypeStr"][_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].MOD];
        const attrib = this._attribs_maps[attribs_maps_key];
        const dict_value = attrib.get(name);
        if (dict_value === undefined) {
            throw new Error('Attribute with this name does not exist.');
        }
        if (Array.isArray(dict_value) || typeof dict_value !== 'object') {
            throw new Error('Attribute is not a dictionary, so keyed values are not allowed.');
        }
        dict_value[key] = value;
    }
    /**
     * Set an entity attrib value
     * If the attribute does not exist, then it is created.
     * @param id
     * @param name
     * @param value
     */
    setEntAttribVal(ent_type, ents_i, name, value) {
        const attribs_maps_key = _common__WEBPACK_IMPORTED_MODULE_0__["EEntTypeStr"][ent_type];
        const attribs = this._attribs_maps[attribs_maps_key];
        if (attribs.get(name) === undefined) {
            const new_data_type = this._checkDataType(value);
            this.addAttrib(ent_type, name, new_data_type);
        }
        attribs.get(name).setEntVal(ents_i, value);
    }
    /**
     * Set an entity attrib indexed value.
     * If the attribute does not exist, it throws an error.
     * @param id
     * @param name
     * @param value
     */
    setEntAttribListIdxVal(ent_type, ents_i, name, idx, value) {
        const attribs_maps_key = _common__WEBPACK_IMPORTED_MODULE_0__["EEntTypeStr"][ent_type];
        const attribs = this._attribs_maps[attribs_maps_key];
        const attrib = attribs.get(name);
        if (attrib === undefined) {
            throw new Error('Attribute does not exist.');
        }
        if (attrib.getDataType() !== _common__WEBPACK_IMPORTED_MODULE_0__["EAttribDataTypeStrs"].LIST) {
            throw new Error('Attribute is not a list, so indexed values are not allowed.');
        }
        attrib.setEntListIdxVal(ents_i, idx, value);
    }
    /**
     * Set an entity attrib indexed value.
     * If the attribute does not exist, it throws an error.
     * @param id
     * @param name
     * @param value
     */
    setEntAttribDictKeyVal(ent_type, ents_i, name, key, value) {
        const attribs_maps_key = _common__WEBPACK_IMPORTED_MODULE_0__["EEntTypeStr"][ent_type];
        const attribs = this._attribs_maps[attribs_maps_key];
        const attrib = attribs.get(name);
        if (attrib === undefined) {
            throw new Error('Attribute does not exist.');
        }
        if (attrib.getDataType() !== _common__WEBPACK_IMPORTED_MODULE_0__["EAttribDataTypeStrs"].DICT) {
            throw new Error('Attribute is not a dictionary, so keyed values are not allowed.');
        }
        attrib.setEntDictKeyVal(ents_i, key, value);
    }
    /**
     * Delete the entity from an attribute
     * If there is no value for the entity, then this does nothing
     * If there is a value, then both the entity index and the value are deleted
     * @param ent_type
     * @param name
     */
    delEntFromAttribs(ent_type, ents_i) {
        // get the attrib names
        const attribs_maps_key = _common__WEBPACK_IMPORTED_MODULE_0__["EEntTypeStr"][ent_type];
        const attribs = this._attribs_maps[attribs_maps_key];
        attribs.forEach(attrib => attrib.delEnt(ents_i));
    }
    /**
     * Set the xyz position by index
     * @param index
     * @param value
     */
    setPosiCoords(index, xyz) {
        this._attribs_maps.ps.get(_common__WEBPACK_IMPORTED_MODULE_0__["EAttribNames"].COORDS).setEntVal(index, xyz);
    }
    /**
     * Move the xyz position by index
     * @param index
     * @param value
     */
    movePosiCoords(index, xyz) {
        const old_xyz = this._attribs_maps.ps.get(_common__WEBPACK_IMPORTED_MODULE_0__["EAttribNames"].COORDS).getEntVal(index);
        const new_xyz = Object(_libs_geom_vectors__WEBPACK_IMPORTED_MODULE_1__["vecAdd"])(old_xyz, xyz);
        this._attribs_maps.ps.get(_common__WEBPACK_IMPORTED_MODULE_0__["EAttribNames"].COORDS).setEntVal(index, new_xyz);
    }
    /**
     * Copy all attribs from one entity to another entity
     * @param ent_type
     * @param name
     */
    copyAttribs(ent_type, from_ent_i, to_ent_i) {
        // get the attrib names
        const attribs_maps_key = _common__WEBPACK_IMPORTED_MODULE_0__["EEntTypeStr"][ent_type];
        const attribs = this._attribs_maps[attribs_maps_key];
        const attrib_names = Array.from(attribs.keys());
        // copy each attrib
        for (const attrib_name of attrib_names) {
            const attrib = attribs.get(attrib_name);
            const attrib_value = attrib.getEntVal(from_ent_i);
            attrib.setEntVal(to_ent_i, attrib_value);
        }
    }
    /**
     * Promotes attrib values up and down the hierarchy.
     */
    pushAttribVals(source_ent_type, source_attrib_name, source_attrib_idx_key, source_indices, target, target_attrib_name, target_attrib_idx_key, method) {
        // if source and target are same, then return
        if (source_ent_type === target) {
            return;
        }
        // check that the attribute exists
        if (!this._modeldata.attribs.query.hasAttrib(source_ent_type, source_attrib_name)) {
            throw new Error('Error pushing attributes: The attribute does not exist.');
        }
        let target_ent_type = null;
        let target_coll = null;
        // check if this is coll -> coll
        if (target === 'coll_parent' || target === 'coll_children') {
            if (source_ent_type !== _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].COLL) {
                throw new Error('Error pushing attributes between collections: The source and target must both be collections.');
            }
            target_coll = target;
            target_ent_type = _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].COLL;
        }
        else {
            target_ent_type = target;
        }
        // get the data type and data size of the existing attribute
        const source_data_type = this._modeldata.attribs.query.getAttribDataType(source_ent_type, source_attrib_name);
        const source_data_size = this._modeldata.attribs.query.getAttribDataLength(source_ent_type, source_attrib_name);
        // get the target data type and size
        let target_data_type = source_data_type;
        let target_data_size = source_data_size;
        if (target_attrib_idx_key !== null) {
            // so the target data type must be a list or a dict
            if (typeof target_attrib_idx_key === 'number') {
                target_data_type = _common__WEBPACK_IMPORTED_MODULE_0__["EAttribDataTypeStrs"].LIST;
            }
            else if (typeof target_attrib_idx_key === 'string') {
                target_data_type = _common__WEBPACK_IMPORTED_MODULE_0__["EAttribDataTypeStrs"].DICT;
            }
            else {
                throw new Error('The target attribute index or key is not valid: "' + target_attrib_idx_key + '".');
            }
        }
        else if (source_attrib_idx_key !== null) {
            // get the first data item as a template to check data type and data size
            const first_val = this._modeldata.attribs.query.getAttribValAny(source_ent_type, source_attrib_name, source_indices[0], source_attrib_idx_key);
            target_data_type = this._checkDataType(first_val);
            if (target_data_type === _common__WEBPACK_IMPORTED_MODULE_0__["EAttribDataTypeStrs"].LIST) {
                const first_val_arr = first_val;
                target_data_size = first_val_arr.length;
                for (const val of first_val_arr) {
                    if (typeof val !== 'number') {
                        throw new Error('The attribute value being pushed is a list but the values in the list are not numbers.');
                    }
                }
            }
            else if (target_data_type === _common__WEBPACK_IMPORTED_MODULE_0__["EAttribDataTypeStrs"].NUMBER) {
                target_data_size = 0;
            }
            else {
                throw new Error('The attribute value being pushed is neither a number nor a list of numbers.');
            }
        }
        // move attributes from entities up to the model, or form model down to entities
        if (target_ent_type === _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].MOD) {
            this.addAttrib(target_ent_type, target_attrib_name, target_data_type);
            const attrib_values = [];
            for (const index of source_indices) {
                const value = this._modeldata.attribs.query.getAttribValAny(source_ent_type, source_attrib_name, index, source_attrib_idx_key);
                attrib_values.push(value);
            }
            const agg_value = this._aggregateVals(attrib_values, target_data_size, method);
            if (typeof target_attrib_idx_key === 'number') {
                this.setModelAttribListIdxVal(target_attrib_name, target_attrib_idx_key, agg_value);
            }
            else if (typeof target_attrib_idx_key === 'string') {
                this.setModelAttribDictKeyVal(target_attrib_name, target_attrib_idx_key, agg_value);
            }
            else {
                this.setModelAttribVal(target_attrib_name, agg_value);
            }
            return;
        }
        else if (source_ent_type === _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].MOD) {
            const value = this._modeldata.attribs.query.getModelAttribValAny(source_attrib_name, source_attrib_idx_key);
            this.addAttrib(target_ent_type, target_attrib_name, target_data_type);
            const target_ents_i = this._modeldata.geom.query.getEnts(target_ent_type);
            for (const target_ent_i of target_ents_i) {
                if (typeof target_attrib_idx_key === 'number') {
                    this.setEntAttribListIdxVal(target_ent_type, target_ent_i, target_attrib_name, target_attrib_idx_key, value);
                }
                else if (typeof target_attrib_idx_key === 'string') {
                    this.setEntAttribDictKeyVal(target_ent_type, target_ent_i, target_attrib_name, target_attrib_idx_key, value);
                }
                else {
                    this.setEntAttribVal(target_ent_type, target_ent_i, target_attrib_name, value);
                }
            }
            return;
        }
        // get all the values for each target
        const attrib_values_map = new Map();
        for (const index of source_indices) {
            const attrib_value = this._modeldata.attribs.query.getAttribValAny(source_ent_type, source_attrib_name, index, source_attrib_idx_key);
            let target_ents_i = null;
            if (target_coll === 'coll_parent') {
                const parent = this._modeldata.geom.nav.navCollToCollParent(index);
                target_ents_i = (parent === -1) ? [] : [parent];
            }
            else if (target_coll === 'coll_children') {
                target_ents_i = this._modeldata.geom.nav.navCollToCollChildren(index);
            }
            else {
                target_ent_type = target_ent_type;
                target_ents_i = this._modeldata.geom.nav.navAnyToAny(source_ent_type, target_ent_type, index);
            }
            for (const target_ent_i of target_ents_i) {
                if (!attrib_values_map.has(target_ent_i)) {
                    attrib_values_map.set(target_ent_i, []);
                }
                attrib_values_map.get(target_ent_i).push(attrib_value);
            }
        }
        // create the new target attribute if it does not already exist
        if (target_coll !== null) {
            target_ent_type = target_ent_type;
            this.addAttrib(target_ent_type, target_attrib_name, target_data_type);
        }
        // calculate the new value and set the attribute
        attrib_values_map.forEach((attrib_values, target_ent_i) => {
            let value = attrib_values[0];
            if (attrib_values.length > 1) {
                value = this._aggregateVals(attrib_values, target_data_size, method);
            }
            if (typeof target_attrib_idx_key === 'number') {
                this.setEntAttribListIdxVal(target_ent_type, target_ent_i, target_attrib_name, target_attrib_idx_key, value);
            }
            else if (typeof target_attrib_idx_key === 'string') {
                this.setEntAttribDictKeyVal(target_ent_type, target_ent_i, target_attrib_name, target_attrib_idx_key, value);
            }
            else {
                this.setEntAttribVal(target_ent_type, target_ent_i, target_attrib_name, value);
            }
        });
    }
    // ============================================================================
    // Private methods
    // ============================================================================
    // TODO for mathjs operations, check the values are numbers...
    _aggregateVals(values, data_size, method) {
        switch (method) {
            case _common__WEBPACK_IMPORTED_MODULE_0__["EAttribPush"].AVERAGE:
                if (data_size > 1) {
                    const result = [];
                    for (let i = 0; i < data_size; i++) {
                        result[i] = mathjs__WEBPACK_IMPORTED_MODULE_2__["mean"](values.map(vec => vec[i]));
                    }
                    return result;
                }
                else {
                    return mathjs__WEBPACK_IMPORTED_MODULE_2__["mean"](values);
                }
            case _common__WEBPACK_IMPORTED_MODULE_0__["EAttribPush"].MEDIAN:
                if (data_size > 1) {
                    const result = [];
                    for (let i = 0; i < data_size; i++) {
                        result[i] = mathjs__WEBPACK_IMPORTED_MODULE_2__["median"](values.map(vec => vec[i]));
                    }
                    return result;
                }
                else {
                    return mathjs__WEBPACK_IMPORTED_MODULE_2__["median"](values);
                }
            case _common__WEBPACK_IMPORTED_MODULE_0__["EAttribPush"].SUM:
                if (data_size > 1) {
                    const result = [];
                    for (let i = 0; i < data_size; i++) {
                        result[i] = mathjs__WEBPACK_IMPORTED_MODULE_2__["sum"](values.map(vec => vec[i]));
                    }
                    return result;
                }
                else {
                    return mathjs__WEBPACK_IMPORTED_MODULE_2__["sum"](values);
                }
            case _common__WEBPACK_IMPORTED_MODULE_0__["EAttribPush"].MIN:
                if (data_size > 1) {
                    const result = [];
                    for (let i = 0; i < data_size; i++) {
                        result[i] = mathjs__WEBPACK_IMPORTED_MODULE_2__["min"](values.map(vec => vec[i]));
                    }
                    return result;
                }
                else {
                    return mathjs__WEBPACK_IMPORTED_MODULE_2__["min"](values);
                }
            case _common__WEBPACK_IMPORTED_MODULE_0__["EAttribPush"].MAX:
                if (data_size > 1) {
                    const result = [];
                    for (let i = 0; i < data_size; i++) {
                        result[i] = mathjs__WEBPACK_IMPORTED_MODULE_2__["max"](values.map(vec => vec[i]));
                    }
                    return result;
                }
                else {
                    return mathjs__WEBPACK_IMPORTED_MODULE_2__["max"](values);
                }
            case _common__WEBPACK_IMPORTED_MODULE_0__["EAttribPush"].LAST:
                return values[values.length - 1];
            default:
                return values[0]; // EAttribPush.FIRST
        }
    }
    /**
     * Utility method to check the data type of an attribute.
     * @param value
     */
    _checkDataType(value) {
        if (typeof value === 'string') {
            return _common__WEBPACK_IMPORTED_MODULE_0__["EAttribDataTypeStrs"].STRING;
        }
        else if (typeof value === 'number') {
            return _common__WEBPACK_IMPORTED_MODULE_0__["EAttribDataTypeStrs"].NUMBER;
        }
        else if (typeof value === 'boolean') {
            return _common__WEBPACK_IMPORTED_MODULE_0__["EAttribDataTypeStrs"].BOOLEAN;
        }
        else if (Array.isArray(value)) {
            return _common__WEBPACK_IMPORTED_MODULE_0__["EAttribDataTypeStrs"].LIST;
        }
        else if (typeof value === 'object') {
            return _common__WEBPACK_IMPORTED_MODULE_0__["EAttribDataTypeStrs"].LIST;
        }
        throw new Error('Data type for new attribute not recognised.');
    }
}


/***/ }),

/***/ "./src/assets/libs/geo-info/GIAttribsIO.ts":
/*!*************************************************!*\
  !*** ./src/assets/libs/geo-info/GIAttribsIO.ts ***!
  \*************************************************/
/*! exports provided: GIAttribsIO */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GIAttribsIO", function() { return GIAttribsIO; });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common */ "./src/assets/libs/geo-info/common.ts");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_1__);
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};


/**
 * Class for attributes.
 */
class GIAttribsIO {
    /**
      * Creates an object to store the attribute data.
      * @param modeldata The JSON data
      */
    constructor(modeldata, attribs_maps) {
        this._modeldata = modeldata;
        this._attribs_maps = attribs_maps;
    }
    /**
     * Adds data to this model from another model.
     * The existing data in the model is not deleted - checks for conflicts.
     * @param model_data Attribute data from the other model.
     */
    merge(attribs_maps) {
        if (attribs_maps.ps !== undefined) {
            this._mergeAttribs(attribs_maps, _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POSI);
        }
        if (attribs_maps._v !== undefined) {
            this._mergeAttribs(attribs_maps, _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].VERT);
        }
        if (attribs_maps._e !== undefined) {
            this._mergeAttribs(attribs_maps, _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].EDGE);
        }
        if (attribs_maps._w !== undefined) {
            this._mergeAttribs(attribs_maps, _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].WIRE);
        }
        if (attribs_maps._f !== undefined) {
            this._mergeAttribs(attribs_maps, _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].FACE);
        }
        if (attribs_maps.pt !== undefined) {
            this._mergeAttribs(attribs_maps, _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POINT);
        }
        if (attribs_maps.pl !== undefined) {
            this._mergeAttribs(attribs_maps, _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PLINE);
        }
        if (attribs_maps.pg !== undefined) {
            this._mergeAttribs(attribs_maps, _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PGON);
        }
        if (attribs_maps.co !== undefined) {
            this._mergeAttribs(attribs_maps, _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].COLL);
        }
        if (attribs_maps.mo !== undefined) {
            this._mergeModelAttribs(attribs_maps);
        }
    }
    /**
     * Adds data to this model from another model.
     * Assumes this model is empty - no conflict detection.
     * @param model_data Attribute data from the other model.
     */
    dump(attribs_maps) {
        if (attribs_maps.ps !== undefined) {
            this._dumpAttribs(attribs_maps, _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POSI);
        }
        if (attribs_maps._v !== undefined) {
            this._dumpAttribs(attribs_maps, _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].VERT);
        }
        if (attribs_maps._e !== undefined) {
            this._dumpAttribs(attribs_maps, _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].EDGE);
        }
        if (attribs_maps._w !== undefined) {
            this._dumpAttribs(attribs_maps, _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].WIRE);
        }
        if (attribs_maps._f !== undefined) {
            this._dumpAttribs(attribs_maps, _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].FACE);
        }
        if (attribs_maps.pt !== undefined) {
            this._dumpAttribs(attribs_maps, _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POINT);
        }
        if (attribs_maps.pl !== undefined) {
            this._dumpAttribs(attribs_maps, _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PLINE);
        }
        if (attribs_maps.pg !== undefined) {
            this._dumpAttribs(attribs_maps, _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PGON);
        }
        if (attribs_maps.co !== undefined) {
            this._dumpAttribs(attribs_maps, _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].COLL);
        }
        if (attribs_maps.mo !== undefined) {
            this._dumpModelAttribs(attribs_maps);
        }
    }
    /**
     * Adds selected data to this model from another model.
     * Assumes this model is empty - no conflict detection.
     * If ent_sets is null, then only copy model attribs.
     * @param model_data Attribute data from the other model.
     */
    dumpSelect(attribs_maps, ent_sets) {
        if (ent_sets === null) {
            if (attribs_maps.mo !== undefined) {
                this._dumpModelAttribs(attribs_maps);
            }
            return;
        }
        if (attribs_maps.ps !== undefined) {
            this._dumpAttribsSelect(attribs_maps, _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POSI, ent_sets.posis_i);
        }
        if (attribs_maps._v !== undefined) {
            this._dumpAttribsSelect(attribs_maps, _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].VERT, ent_sets.verts_i);
        }
        if (attribs_maps._e !== undefined) {
            this._dumpAttribsSelect(attribs_maps, _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].EDGE, ent_sets.edges_i);
        }
        if (attribs_maps._w !== undefined) {
            this._dumpAttribsSelect(attribs_maps, _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].WIRE, ent_sets.wires_i);
        }
        if (attribs_maps._f !== undefined) {
            this._dumpAttribsSelect(attribs_maps, _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].FACE, ent_sets.faces_i);
        }
        if (attribs_maps.pt !== undefined) {
            this._dumpAttribsSelect(attribs_maps, _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POINT, ent_sets.points_i);
        }
        if (attribs_maps.pl !== undefined) {
            this._dumpAttribsSelect(attribs_maps, _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PLINE, ent_sets.plines_i);
        }
        if (attribs_maps.pg !== undefined) {
            this._dumpAttribsSelect(attribs_maps, _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PGON, ent_sets.pgons_i);
        }
        if (attribs_maps.co !== undefined) {
            this._dumpAttribsSelect(attribs_maps, _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].COLL, ent_sets.colls_i);
        }
        if (attribs_maps.mo !== undefined) {
            this._dumpModelAttribs(attribs_maps);
        }
    }
    /**
     * Adds data to this model from another model.
     * The existing data in the model is not deleted.
     * @param model_data Attribute data from the other model.
     */
    mergeAndPurge(attribs_maps, renum_maps) {
        // add the attribute data
        if (attribs_maps.ps !== undefined) {
            this._mergeAndPurgeAttribs(attribs_maps, _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POSI, renum_maps.get('posis'));
        }
        if (attribs_maps._v !== undefined) {
            this._mergeAndPurgeAttribs(attribs_maps, _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].VERT, renum_maps.get('verts'));
        }
        if (attribs_maps._e !== undefined) {
            this._mergeAndPurgeAttribs(attribs_maps, _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].EDGE, renum_maps.get('edges'));
        }
        if (attribs_maps._w !== undefined) {
            this._mergeAndPurgeAttribs(attribs_maps, _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].WIRE, renum_maps.get('wires'));
        }
        if (attribs_maps._f !== undefined) {
            this._mergeAndPurgeAttribs(attribs_maps, _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].FACE, renum_maps.get('faces'));
        }
        if (attribs_maps.pt !== undefined) {
            this._mergeAndPurgeAttribs(attribs_maps, _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POINT, renum_maps.get('points'));
        }
        if (attribs_maps.pl !== undefined) {
            this._mergeAndPurgeAttribs(attribs_maps, _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PLINE, renum_maps.get('plines'));
        }
        if (attribs_maps.pg !== undefined) {
            this._mergeAndPurgeAttribs(attribs_maps, _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PGON, renum_maps.get('pgons'));
        }
        if (attribs_maps.co !== undefined) {
            this._mergeAndPurgeAttribs(attribs_maps, _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].COLL, renum_maps.get('colls'));
        }
        if (attribs_maps.mo !== undefined) {
            this._mergeModelAttribs(attribs_maps);
        }
    }
    /**
     * Adds data to this model from JSON data.
     * The existing data in the model is deleted.
     * @param model_data The JSON data for the model.
     */
    setJSONData(attribs_data) {
        // add the attribute data
        if (attribs_data.posis !== undefined) {
            this._setAttribsJSONData(attribs_data.posis, _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POSI);
        }
        if (attribs_data.verts !== undefined) {
            this._setAttribsJSONData(attribs_data.verts, _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].VERT);
        }
        if (attribs_data.edges !== undefined) {
            this._setAttribsJSONData(attribs_data.edges, _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].EDGE);
        }
        if (attribs_data.wires !== undefined) {
            this._setAttribsJSONData(attribs_data.wires, _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].WIRE);
        }
        if (attribs_data.faces !== undefined) {
            this._setAttribsJSONData(attribs_data.faces, _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].FACE);
        }
        if (attribs_data.points !== undefined) {
            this._setAttribsJSONData(attribs_data.points, _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POINT);
        }
        if (attribs_data.plines !== undefined) {
            this._setAttribsJSONData(attribs_data.plines, _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PLINE);
        }
        if (attribs_data.pgons !== undefined) {
            this._setAttribsJSONData(attribs_data.pgons, _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PGON);
        }
        if (attribs_data.colls !== undefined) {
            this._setAttribsJSONData(attribs_data.colls, _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].COLL);
        }
        if (attribs_data.model !== undefined) {
            this._setModelAttribs(attribs_data.model);
        }
    }
    /**
     * Returns the JSON data for this model.
     */
    getJSONData() {
        const data = {
            posis: Array.from(this._attribs_maps.ps.values()).map(attrib => attrib.getJSONData()),
            verts: Array.from(this._attribs_maps._v.values()).map(attrib => attrib.getJSONData()),
            edges: Array.from(this._attribs_maps._e.values()).map(attrib => attrib.getJSONData()),
            wires: Array.from(this._attribs_maps._w.values()).map(attrib => attrib.getJSONData()),
            faces: Array.from(this._attribs_maps._f.values()).map(attrib => attrib.getJSONData()),
            points: Array.from(this._attribs_maps.pt.values()).map(attrib => attrib.getJSONData()),
            plines: Array.from(this._attribs_maps.pl.values()).map(attrib => attrib.getJSONData()),
            pgons: Array.from(this._attribs_maps.pg.values()).map(attrib => attrib.getJSONData()),
            colls: Array.from(this._attribs_maps.co.values()).map(attrib => attrib.getJSONData()),
            model: Array.from(this._attribs_maps.mo)
        };
        return data;
    }
    // ============================================================================
    // Private methods
    // ============================================================================
    /**
     * From another model
     * The existing attributes are not deleted
     * Deep copy of attrib values
     * @param attribs_maps
     */
    _mergeModelAttribs(attribs_maps) {
        const other_attribs = attribs_maps[_common__WEBPACK_IMPORTED_MODULE_0__["EEntTypeStr"][_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].MOD]];
        const this_attribs = this._attribs_maps[_common__WEBPACK_IMPORTED_MODULE_0__["EEntTypeStr"][_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].MOD]];
        // TODO this is a hack to fix an error
        if (!(other_attribs instanceof Map)) {
            return;
        }
        other_attribs.forEach((val, key) => {
            this_attribs.set(key, lodash__WEBPACK_IMPORTED_MODULE_1__["cloneDeep"](val));
        });
    }
    /**
     * From another model
     * The existing attributes are not deleted
     * Deep copy of attrib values
     * @param attribs_maps
     */
    _dumpModelAttribs(attribs_maps) {
        this._attribs_maps[_common__WEBPACK_IMPORTED_MODULE_0__["EEntTypeStr"][_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].MOD]] = lodash__WEBPACK_IMPORTED_MODULE_1__["cloneDeep"](attribs_maps[_common__WEBPACK_IMPORTED_MODULE_0__["EEntTypeStr"][_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].MOD]]);
    }
    /**
     * From JSON data
     * Existing attributes are deleted
     * @param new_attribs_data
     */
    _setModelAttribs(new_attribs_data) {
        this._attribs_maps[_common__WEBPACK_IMPORTED_MODULE_0__["EEntTypeStr"][_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].MOD]] = new Map(new_attribs_data);
    }
    /**
     * merge attributes from another model into this model.
     * The existing attributes are not deleted
     * @param attribs_maps
     */
    _mergeAttribs(attribs_maps, ent_type) {
        const other_attribs = attribs_maps[_common__WEBPACK_IMPORTED_MODULE_0__["EEntTypeStr"][ent_type]];
        const this_attribs = this._attribs_maps[_common__WEBPACK_IMPORTED_MODULE_0__["EEntTypeStr"][ent_type]];
        other_attribs.forEach(other_attrib => {
            if (other_attrib.numEnts() > 0) {
                // get the name
                const name = other_attrib.getName();
                // get or create the attrib
                let this_attrib;
                if (!this_attribs.has(name)) {
                    this_attrib = this._modeldata.attribs.add.addEntAttrib(ent_type, name, other_attrib.getDataType());
                }
                else {
                    this_attrib = this_attribs.get(name);
                    if (this_attrib.getDataType() !== other_attrib.getDataType()) {
                        throw new Error('Merge Error: Cannot merge attributes with different data types.');
                    }
                }
                // merge
                this_attrib.merge(other_attrib);
            }
        });
    }
    /**
     * merge attributes from another model into this model.
     * It is assumed that a purge has been performed, so the entity IDs will have changed.
     * The new entity IDs are defined in the renum_map argument.
     * The existing attributes are not deleted.
     * @param attribs_maps
     */
    _mergeAndPurgeAttribs(attribs_maps, ent_type, renum_map) {
        const other_attribs = attribs_maps[_common__WEBPACK_IMPORTED_MODULE_0__["EEntTypeStr"][ent_type]];
        const this_attribs = this._attribs_maps[_common__WEBPACK_IMPORTED_MODULE_0__["EEntTypeStr"][ent_type]];
        other_attribs.forEach(other_attrib => {
            if (other_attrib.numEnts() > 0) {
                // get the name
                const name = other_attrib.getName();
                // get or create the attrib
                let this_attrib;
                if (!this_attribs.has(name)) {
                    this_attrib = this._modeldata.attribs.add.addEntAttrib(ent_type, name, other_attrib.getDataType());
                }
                else {
                    this_attrib = this_attribs.get(name);
                    if (this_attrib.getDataType() !== other_attrib.getDataType()) {
                        throw new Error('Merge Error: Cannot merge attributes with different data types.');
                    }
                }
                // shift
                other_attrib.renumEnts(renum_map);
                // merge
                this_attrib.merge(other_attrib);
            }
        });
    }
    /**
     * merge attributes from another model into this model.
     * Assumes that the existing model is empty
     * @param attribs_maps
     */
    _dumpAttribs(attribs_maps, ent_type) {
        const other_attribs = attribs_maps[_common__WEBPACK_IMPORTED_MODULE_0__["EEntTypeStr"][ent_type]];
        other_attribs.forEach(other_attrib => {
            if (other_attrib.numEnts() > 0) {
                const this_attrib = this._modeldata.attribs.add.addEntAttrib(ent_type, other_attrib.getName(), other_attrib.getDataType());
                this_attrib.dump(other_attrib);
            }
        });
    }
    /**
     * Dumps selected attributes from another model into this model.
     * Assumes that the existing model is empty
     * @param attribs_maps
     */
    _dumpAttribsSelect(attribs_maps, ent_type, selected) {
        const other_attribs = attribs_maps[_common__WEBPACK_IMPORTED_MODULE_0__["EEntTypeStr"][ent_type]];
        other_attribs.forEach(other_attrib => {
            if (other_attrib.numEnts() > 0) {
                const this_attrib = this._modeldata.attribs.add.addEntAttrib(ent_type, other_attrib.getName(), other_attrib.getDataType());
                this_attrib.dumpSelect(other_attrib, selected);
            }
        });
    }
    /**
     * From JSON data
     * Existing attributes are deleted
     * @param attribs_data
     */
    _setAttribsJSONData(attribs_data, ent_type) {
        this._attribs_maps[_common__WEBPACK_IMPORTED_MODULE_0__["EEntTypeStr"][ent_type]] = new Map();
        attribs_data.forEach(attrib_data => {
            const this_attrib = this._modeldata.attribs.add.addEntAttrib(ent_type, attrib_data.name, attrib_data.data_type);
            this_attrib.setJSONData(attrib_data);
        });
    }
}


/***/ }),

/***/ "./src/assets/libs/geo-info/GIAttribsQuery.ts":
/*!****************************************************!*\
  !*** ./src/assets/libs/geo-info/GIAttribsQuery.ts ***!
  \****************************************************/
/*! exports provided: GIAttribsQuery */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GIAttribsQuery", function() { return GIAttribsQuery; });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common */ "./src/assets/libs/geo-info/common.ts");
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};

/**
 * Class for attributes.
 */
class GIAttribsQuery {
    /**
      * Creates an object to store the attribute data.
      * @param modeldata The JSON data
      */
    constructor(modeldata, attribs_maps) {
        this._modeldata = modeldata;
        this._attribs_maps = attribs_maps;
    }
    /**
     * Checks if an attribute with this name exists.
     * @param name
     */
    hasModelAttrib(name) {
        const attribs_maps_key = _common__WEBPACK_IMPORTED_MODULE_0__["EEntTypeStr"][_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].MOD];
        const attrib = this._attribs_maps[attribs_maps_key];
        return attrib.has(name);
    }
    /**
     * Get attrib data type. Also works for MOD attribs.
     *
     * @param ent_type
     * @param name
     */
    getAttribDataType(ent_type, name) {
        const attribs_maps_key = _common__WEBPACK_IMPORTED_MODULE_0__["EEntTypeStr"][ent_type];
        const attribs = this._attribs_maps[attribs_maps_key];
        if (attribs.get(name) === undefined) {
            throw new Error('Attribute does not exist.');
        }
        if (ent_type === _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].MOD) {
            const mod_attribs = attribs;
            const value = mod_attribs.get(name);
            if (typeof value === 'number') {
                return _common__WEBPACK_IMPORTED_MODULE_0__["EAttribDataTypeStrs"].NUMBER;
            }
            else if (typeof value === 'string') {
                return _common__WEBPACK_IMPORTED_MODULE_0__["EAttribDataTypeStrs"].STRING;
            }
            else if (typeof value === 'boolean') {
                return _common__WEBPACK_IMPORTED_MODULE_0__["EAttribDataTypeStrs"].BOOLEAN;
            }
            else if (Array.isArray(value)) {
                return _common__WEBPACK_IMPORTED_MODULE_0__["EAttribDataTypeStrs"].LIST;
            }
            else if (typeof value === 'object') {
                return _common__WEBPACK_IMPORTED_MODULE_0__["EAttribDataTypeStrs"].DICT;
            }
            throw new Error('Datatype of model attribute not recognised.');
        }
        else {
            const ent_attribs = attribs;
            return ent_attribs.get(name).getDataType();
        }
    }
    /**
     * Get attrib data type. Also works for MOD attribs.
     *
     * @param ent_type
     * @param name
     */
    getAttribDataLength(ent_type, name) {
        const attribs_maps_key = _common__WEBPACK_IMPORTED_MODULE_0__["EEntTypeStr"][ent_type];
        const attribs = this._attribs_maps[attribs_maps_key];
        if (attribs.get(name) === undefined) {
            throw new Error('Attribute does not exist.');
        }
        if (ent_type === _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].MOD) {
            const mod_attribs = attribs;
            const value = mod_attribs.get(name);
            if (typeof value === 'number' || typeof value === 'string' || typeof value === 'boolean') {
                return 1;
            }
            else if (Array.isArray(value)) {
                return value.length;
            }
            else if (typeof value === 'object') {
                return Object.keys(value).length;
            }
            throw new Error('Datatype of model attribute not recognised.');
        }
        else {
            const ent_attribs = attribs;
            return ent_attribs.get(name).getDataLength();
        }
    }
    /**
     * Get an model attrib value, or an array of values given an array of entities.
     * ~
     * If idx_or_key is null, then this must be a simple attrib.
     * If idx_or_key is a number, then this must be indexing a list attrib.
     * if idx_or_key is a string, then this must be indexing a dict attrib.
     * ~
     * If the attribute does not exist, throw an error
     * ~
     * @param ent_type
     * @param name
     */
    getModelAttribValAny(name, idx_or_key) {
        if (idx_or_key === null) {
            return this.getModelAttribVal(name);
        }
        switch (typeof idx_or_key) {
            case 'number':
                return this.getModelAttribListIdxVal(name, idx_or_key);
            case 'string':
                return this.getModelAttribDictKeyVal(name, idx_or_key);
        }
    }
    /**
     * Get a model attrib value
     * @param name
     */
    getModelAttribVal(name) {
        const attribs_maps_key = _common__WEBPACK_IMPORTED_MODULE_0__["EEntTypeStr"][_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].MOD];
        const attribs = this._attribs_maps[attribs_maps_key];
        const value = attribs.get(name);
        if (value === undefined) {
            return null;
        }
        return value;
    }
    /**
     * Get a model attrib list value given an index
     * ~
     * If this attribute is not a list, throw error
     * ~
     * If idx is creater than the length of the list, undefined is returned.
     * ~
     * @param ent_type
     * @param name
     */
    getModelAttribListIdxVal(name, idx) {
        const attribs_maps_key = _common__WEBPACK_IMPORTED_MODULE_0__["EEntTypeStr"][_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].MOD];
        const attribs = this._attribs_maps[attribs_maps_key];
        const list_value = attribs.get(name);
        if (list_value === undefined) {
            throw new Error('Attribute does not exist.');
        }
        if (!Array.isArray(list_value)) {
            throw new Error('Attribute is not a list.');
        }
        return list_value[idx];
    }
    /**
     * Get a model attrib dict value given a key
     * ~
     * If this attribute is not a dict, throw error
     * ~
     * If key does not exist, throw error
     * ~
     * @param ent_type
     * @param name
     */
    getModelAttribDictKeyVal(name, key) {
        const attribs_maps_key = _common__WEBPACK_IMPORTED_MODULE_0__["EEntTypeStr"][_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].MOD];
        const attribs = this._attribs_maps[attribs_maps_key];
        const dict_value = attribs.get(name);
        if (dict_value === undefined) {
            throw new Error('Attribute does not exist.');
        }
        if (Array.isArray(dict_value) || typeof dict_value !== 'object') {
            throw new Error('Attribute is not a dict.');
        }
        return dict_value[key];
    }
    /**
     * Get an entity attrib value, or an array of values given an array of entities.
     * ~
     * If idx_or_key is null, then this must be a simple attrib.
     * If idx_or_key is a number, then this must be indexing a list attrib.
     * if idx_or_key is a string, then this must be indexing a dict attrib.
     * ~
     * If the attribute does not exist, throw an error
     * ~
     * @param ent_type
     * @param name
     */
    getAttribValAny(ent_type, name, ents_i, idx_or_key) {
        if (idx_or_key === null) {
            return this.getAttribVal(ent_type, name, ents_i);
        }
        switch (typeof idx_or_key) {
            case 'number':
                return this.getAttribListIdxVal(ent_type, name, ents_i, idx_or_key);
            case 'string':
                return this.getAttribDictKeyVal(ent_type, name, ents_i, idx_or_key);
        }
    }
    /**
     * Get an entity attrib value, or an array of values given an array of entities.
     * ~
     * If the attribute does not exist, throw an error
     * ~
     * @param ent_type
     * @param name
     */
    getAttribVal(ent_type, name, ents_i) {
        const attribs_maps_key = _common__WEBPACK_IMPORTED_MODULE_0__["EEntTypeStr"][ent_type];
        const attribs = this._attribs_maps[attribs_maps_key];
        const attrib = attribs.get(name);
        if (attrib === undefined) {
            throw new Error('Attribute does not exist.');
        }
        return attrib.getEntVal(ents_i);
    }
    /**
     * Get an entity attrib value in a list.
     * ~
     * If the attribute does not exist, throw error
     * ~
     * If the index is out of range, return undefined.
     * ~
     * @param ent_type
     * @param name
     */
    getAttribListIdxVal(ent_type, name, ents_i, idx) {
        const attribs_maps_key = _common__WEBPACK_IMPORTED_MODULE_0__["EEntTypeStr"][ent_type];
        const attribs = this._attribs_maps[attribs_maps_key];
        const attrib = attribs.get(name);
        if (attrib === undefined) {
            throw new Error('Attribute does not exist.');
        }
        return attrib.getEntListIdxVal(ents_i, idx);
    }
    /**
 * Get an entity attrib value in a dictionary.
 * ~
 * If the attribute does not exist, throw error
 * ~
 * If the key does not exist, return undefined.
 * ~
 * @param ent_type
 * @param name
 */
    getAttribDictKeyVal(ent_type, name, ents_i, key) {
        const attribs_maps_key = _common__WEBPACK_IMPORTED_MODULE_0__["EEntTypeStr"][ent_type];
        const attribs = this._attribs_maps[attribs_maps_key];
        const attrib = attribs.get(name);
        if (attrib === undefined) {
            throw new Error('Attribute does not exist.');
        }
        return attrib.getEntDictKeyVal(ents_i, key);
    }
    /**
     * Check if attribute exists
     * @param ent_type
     * @param name
     */
    hasAttrib(ent_type, name) {
        const attribs_maps_key = _common__WEBPACK_IMPORTED_MODULE_0__["EEntTypeStr"][ent_type];
        const attribs = this._attribs_maps[attribs_maps_key];
        return attribs.has(name);
    }
    /**
     * Get all the attribute names for an entity type
     * @param ent_type
     */
    getAttribNames(ent_type) {
        const attribs_maps_key = _common__WEBPACK_IMPORTED_MODULE_0__["EEntTypeStr"][ent_type];
        const attribs_map = this._attribs_maps[attribs_maps_key];
        return Array.from(attribs_map.keys());
    }
    /**
     * Get all the user defined attribute names for an entity type
     * This excludes the built in attribute names, xyz and anything starting with '_'
     * @param ent_type
     */
    getAttribNamesUser(ent_type) {
        const attribs_maps_key = _common__WEBPACK_IMPORTED_MODULE_0__["EEntTypeStr"][ent_type];
        const attribs_map = this._attribs_maps[attribs_maps_key];
        let attribs = Array.from(attribs_map.keys());
        if (ent_type === _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POSI) {
            attribs = attribs.filter(attrib => attrib !== 'xyz');
        }
        attribs = attribs.filter(attrib => attrib[0] !== '_');
        return attribs;
    }
    /**
     * Get attrib
     * @param ent_type
     * @param name
     */
    getAttrib(ent_type, name) {
        const attribs_maps_key = _common__WEBPACK_IMPORTED_MODULE_0__["EEntTypeStr"][ent_type];
        const attribs = this._attribs_maps[attribs_maps_key];
        return attribs.get(name);
    }
    // /**
    //  * Query the model using a query strings.
    //  * Returns a list of entities in the model.
    //  * @param ent_type The type of the entities being search for
    //  * @param query_str The query string, e.g. '#@name == value'
    //  * @param indices The indices of entites in the model. These are assumed to be of type ent_type.
    //  */
    // public queryAttribs(ent_type: EEntType, query_str: string, indices: number[]): number[] {
    //     // get the map that contains all the ettributes for the ent_type
    //     const attribs_maps_key: string = EEntTypeStr[ent_type];
    //     const attribs: Map<string, TAttribMap> = this._attribs_maps[attribs_maps_key];
    //     // parse the query
    //     const queries: IQueryComponent[][] = parseQuery(query_str);
    //     if (!queries) { return []; }
    //     // do the query, one by one
    //     // [[query1 && query2] || [query3 && query4]]
    //     let union_query_results: number[] = [];
    //     for (const and_queries of queries)  {
    //         // get the ents_i to start the '&&' query
    //         let query_ents_i: number[] = null;
    //         if (indices !== null && indices !== undefined) {
    //             query_ents_i = indices;
    //         } else {
    //             query_ents_i = this._model.modeldata.geom.query.getEnts(ent_type, false);
    //         }
    //         // do the '&&' queries
    //         for (const and_query of and_queries) {
    //             if (attribs && attribs.has(and_query.attrib_name)) {
    //                 const attrib: TAttribMap = attribs.get(and_query.attrib_name);
    //                 query_ents_i = attrib.queryVal(
    //                     query_ents_i,
    //                     and_query.attrib_index,
    //                     and_query.operator_type,
    //                     and_query.attrib_value_str
    //                 );
    //             } else {
    //                 throw new Error('Attribute "' + and_query.attrib_name + '" does not exist.');
    //                 // query_ents_i = [];
    //             }
    //         }
    //         // combine the results of the '&&' queries
    //         if (query_ents_i !== null && query_ents_i.length > 0) {
    //             union_query_results = Array.from(new Set([...union_query_results, ...query_ents_i]));
    //         }
    //     }
    //     // return the result
    //     return union_query_results;
    // }
    /**
     * Query the model using a query strings.
     * Returns a list of entities in the model.
     * @param ent_type The type of the entities being quieried.
     * @param ents_i Entites in the model, assumed to be of type ent_type.
     * @param name
     * @param idx_or_key
     * @param value
     */
    filterByAttribs(ent_type, ents_i, name, idx_or_key, op_type, value) {
        // get the map that contains all the attributes for the ent_type
        const attribs_maps_key = _common__WEBPACK_IMPORTED_MODULE_0__["EEntTypeStr"][ent_type];
        const attribs = this._attribs_maps[attribs_maps_key];
        // do the query
        if (attribs && attribs.has(name)) {
            const attrib = attribs.get(name);
            let query_ents_i;
            if (typeof idx_or_key === 'number') {
                query_ents_i = attrib.queryListIdxVal(ents_i, idx_or_key, op_type, value);
            }
            else if (typeof idx_or_key === 'string') {
                query_ents_i = attrib.queryDictKeyVal(ents_i, idx_or_key, op_type, value);
            }
            else {
                query_ents_i = attrib.queryVal(ents_i, op_type, value);
            }
            // return the result
            return query_ents_i;
        }
        else {
            throw new Error('Attribute "' + name + '" does not exist.');
            // query_ents_i = [];
        }
    }
    /**
     * Sort entities in the model based on attribute values.
     * @param ent_type The type of the entities being sorted.
     * @param ents_i Entites in the model, assumed to be of type ent_type.
     * @param name
     * @param idx_or_key
     * @param value
     */
    sortByAttribs(ent_type, ents_i, name, idx_or_key, method) {
        // get the map that contains all the ettributes for the ent_type
        const attribs_maps_key = _common__WEBPACK_IMPORTED_MODULE_0__["EEntTypeStr"][ent_type];
        const attribs = this._attribs_maps[attribs_maps_key];
        if (!attribs) {
            throw new Error('Bad sort: Entity type does not exist.');
        }
        // get the attribute from the map
        const attrib = attribs.get(name);
        if (attrib === undefined) {
            // if the attribute does not exist then no sort is performed
            return ents_i;
        }
        // create the sort copmapre function
        function _sortCompareVals(ent1_i, ent2_i) {
            const val1 = attrib.getEntVal(ent1_i);
            const val2 = attrib.getEntVal(ent2_i);
            if (method === _common__WEBPACK_IMPORTED_MODULE_0__["ESort"].DESCENDING) {
                if (val1 < val2) {
                    return 1;
                }
                if (val1 > val2) {
                    return -1;
                }
            }
            else {
                if (val1 < val2) {
                    return -1;
                }
                if (val1 > val2) {
                    return 1;
                }
            }
            return 0;
        }
        function _sortCompareListIdxVals(ent1_i, ent2_i) {
            const l1 = attrib.getEntVal(ent1_i);
            const l2 = attrib.getEntVal(ent2_i);
            const val1 = (l1 !== undefined && l1 !== null) ? l1[idx_or_key] : null;
            const val2 = (l2 !== undefined && l2 !== null) ? l2[idx_or_key] : null;
            if (method === _common__WEBPACK_IMPORTED_MODULE_0__["ESort"].DESCENDING) {
                if (val1 < val2) {
                    return 1;
                }
                if (val1 > val2) {
                    return -1;
                }
            }
            else {
                if (val1 < val2) {
                    return -1;
                }
                if (val1 > val2) {
                    return 1;
                }
            }
            return 0;
        }
        function _sortCompareDictKeyVals(ent1_i, ent2_i) {
            const o1 = attrib.getEntVal(ent1_i);
            const o2 = attrib.getEntVal(ent2_i);
            const val1 = (o1 !== undefined && o1 !== null) ? o1[idx_or_key] : null;
            const val2 = (o2 !== undefined && o2 !== null) ? o2[idx_or_key] : null;
            if (method === _common__WEBPACK_IMPORTED_MODULE_0__["ESort"].DESCENDING) {
                if (val1 < val2) {
                    return 1;
                }
                if (val1 > val2) {
                    return -1;
                }
            }
            else {
                if (val1 < val2) {
                    return -1;
                }
                if (val1 > val2) {
                    return 1;
                }
            }
            return 0;
        }
        function _sortCompareLists(ent1_i, ent2_i) {
            const l1 = attrib.getEntVal(ent1_i);
            const l2 = attrib.getEntVal(ent2_i);
            const len = l1.length > l2.length ? l1.length : l2.length;
            if (method === _common__WEBPACK_IMPORTED_MODULE_0__["ESort"].DESCENDING) {
                for (let i = 0; i < len; i++) {
                    if (l1[i] < l2[i]) {
                        return 1;
                    }
                    if (l1[i] > l2[i]) {
                        return -1;
                    }
                }
            }
            else {
                for (let i = 0; i < len; i++) {
                    if (l1[i] < l2[i]) {
                        return -1;
                    }
                    if (l1[i] > l2[i]) {
                        return 1;
                    }
                }
            }
            return 0;
        }
        function _sortCompareDicts(ent1_i, ent2_i) {
            const o1 = attrib.getEntVal(ent1_i);
            const o2 = attrib.getEntVal(ent2_i);
            if (method === _common__WEBPACK_IMPORTED_MODULE_0__["ESort"].DESCENDING) {
                if (o1 < o2) {
                    return 1;
                }
                if (o1 > o2) {
                    return -1;
                }
            }
            else {
                if (o1 < o2) {
                    return -1;
                }
                if (o1 > o2) {
                    return 1;
                }
            }
            return 0;
        }
        // do the sort
        if (attrib.getDataType() === _common__WEBPACK_IMPORTED_MODULE_0__["EAttribDataTypeStrs"].LIST) {
            if (idx_or_key === null || idx_or_key === undefined) {
                ents_i.sort(_sortCompareLists);
            }
            else {
                ents_i.sort(_sortCompareListIdxVals);
            }
        }
        else if (attrib.getDataType() === _common__WEBPACK_IMPORTED_MODULE_0__["EAttribDataTypeStrs"].DICT) {
            if (idx_or_key === null || idx_or_key === undefined) {
                ents_i.sort(_sortCompareDicts);
            }
            else {
                ents_i.sort(_sortCompareDictKeyVals);
            }
        }
        else {
            ents_i.sort(_sortCompareVals);
        }
        return ents_i;
    }
    // ============================================================================
    // Shortcuts for getting xyz
    // ============================================================================
    /**
     * Shortcut for getting a coordinate from a posi_i
     * @param posi_i
     */
    getPosiCoords(posi_i) {
        const result = this._attribs_maps.ps.get(_common__WEBPACK_IMPORTED_MODULE_0__["EAttribNames"].COORDS).getEntVal(posi_i);
        return result;
    }
    /**
     * Shortcut for getting a coordinate from a numeric vertex index (i.e. this is not an ID)
     * @param vert_i
     */
    getVertCoords(vert_i) {
        const posi_i = this._modeldata.geom.nav.navVertToPosi(vert_i);
        return this._attribs_maps.ps.get(_common__WEBPACK_IMPORTED_MODULE_0__["EAttribNames"].COORDS).getEntVal(posi_i);
    }
    /**
     * Shortcut for getting all the xyz coordinates from an ent_i
     * @param posi_i
     */
    getEntCoords(ent_type, ent_i) {
        const posis_i = this._modeldata.geom.nav.navAnyToPosi(ent_type, ent_i);
        const coords_map = this._attribs_maps.ps.get(_common__WEBPACK_IMPORTED_MODULE_0__["EAttribNames"].COORDS);
        return coords_map.getEntVal(posis_i);
    }
}
// ================================================================================================
// Functions for parsing queries
// ================================================================================================
// /**
//  * Parse a query string.
//  * && takes precedence over ||
//  * [ [ query1 && query2 ] || [ query3 && query4 ] ]
//  */
// function parseQuery(query_str: string): IQueryComponent[][] {
//     if (!query_str.startsWith('#')) {throw new Error('Bad query, query string must start with #.'); }
//     const or_query_strs: string[] = query_str.split('||');
//     const query_list: IQueryComponent[][] = [];
//     or_query_strs.forEach(or_query_str => {
//         const and_query_strs: string[] = or_query_str.split('&&');
//         query_list.push(and_query_strs.map( and_query_str => _parse_query_component(and_query_str) ) );
//     });
//     return query_list;
// }
// /**
//  * Parse a query component string.
//  */
// function _parse_query_component(query_component: string): IQueryComponent {
//     let attrib_name_str = '' ;
//     let attrib_value_str = '' ;
//     let operator_type: EFilterOperatorTypes = null;
//     // split the query at the @ sign
//     const [_, attrib_name_value_str]: string[] = query_component.split('@');
//     if (!attrib_name_value_str) { throw new Error('Bad query.'); }
//     // split the attrib_name_value_str based on operator, ==, !=, etc...
//     for (const key of Object.keys(EFilterOperatorTypes)) {
//         const split_query = attrib_name_value_str.split(EFilterOperatorTypes[key]);
//         if (split_query.length === 2) {
//             attrib_name_str =  split_query[0].trim();
//             attrib_value_str = split_query[1].trim();
//             operator_type = EFilterOperatorTypes[key];
//             break;
//         }
//     }
//     // check
//     if (!operator_type) {throw new Error('Bad operator in query.'); }
//     if (!attrib_name_str) {throw new Error('Bad attribute name in query.'); }
//     if (!attrib_value_str) {throw new Error('Bad attribute value in query.'); }
//     // parse the name
//     const attrib_name_index = _parse_name_str(attrib_name_str);
//     const attrib_name  = attrib_name_index[0];
//     const attrib_index  = attrib_name_index[1];
//     // parse the value
//     attrib_value_str = _parse_value_str(attrib_value_str);
//     // return the data for the query component as an object
//     return {
//         attrib_name: attrib_name,
//         attrib_index: attrib_index,
//         attrib_value_str: attrib_value_str,
//         operator_type: operator_type
//     };
// }
// /**
//  * Parse a sort string. #@name1 && #@name2
//  * Rerurns an array,[ query1, query2 ]
//  */
// function parseSort(sort_str: string): ISortComponent[] {
//     if (!sort_str.startsWith('#')) { throw new Error('Bad sort, sort string must start with #.'); }
//     if (sort_str.indexOf('||') !== -1) { throw new Error('Bad sort, sort string cannot contain || conditions.'); }
//     const sort_str_clean: string = sort_str.replace(/\s/g, '');
//     const component_strs: string[] = sort_str_clean.split('&&');
//     const sort_list: ISortComponent[] = [];
//     component_strs.forEach(component_str => {
//         sort_list.push(_parse_sort_component(component_str));
//     });
//     return sort_list;
// }
// /**
//  * Parse a query component string.
//  */
// function _parse_sort_component(sort_component: string): ISortComponent {
//     // split the query at the @ sign
//     const [_, attrib_name_str]: string[] = sort_component.split('@');
//     // check
//     if (!attrib_name_str) {throw new Error('Bad attribute name in query.'); }
//     // parse the name
//     const attrib_name_index = _parse_name_str(attrib_name_str);
//     const attrib_name  = attrib_name_index[0];
//     const attrib_index  = attrib_name_index[1];
//     // return the data for the query component as an object
//     return {
//         attrib_name: attrib_name,
//         attrib_index: attrib_index
//     };
// }
// /**
//  * Parse the attribute value. Handles sting with quotes, e.g. 'this' and "that".
//  * Remove quotes from value string
//  */
// function _parse_value_str(value_str: string): string {
//     const first_char: string = value_str.slice(0, 1);
//     if (first_char ===  '\'' || first_char === '"') {return value_str.slice(1, -1); }
//     return value_str;
// }
// /**
//  * Parese the attribute name. Handles names with indexes, e.g. 'name[2]'
//  * Split the name into the string name and the numeric index
//  */
// function _parse_name_str(value_str: string): [string, number?] {
//     const last_char: string = value_str.slice(-1);
//     if (last_char === ']') {
//         const [name_str, index_str]: [string, string] = value_str.slice(0, -1).split('[') as [string, string];
//         const index: number = Number(index_str);
//         if (isNaN(index)) {throw new Error('Bad query'); }
//         return [name_str, index];
//     }
//     return [value_str, null];
// }


/***/ }),

/***/ "./src/assets/libs/geo-info/GIAttribsThreejs.ts":
/*!******************************************************!*\
  !*** ./src/assets/libs/geo-info/GIAttribsThreejs.ts ***!
  \******************************************************/
/*! exports provided: GIAttribsThreejs */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GIAttribsThreejs", function() { return GIAttribsThreejs; });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common */ "./src/assets/libs/geo-info/common.ts");
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! util */ "./node_modules/util/util.js");
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(util__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _util_maps__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/maps */ "./src/assets/libs/util/maps.ts");
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};



/**
 * Class for attributes.
 */
class GIAttribsThreejs {
    /**
      * Creates an object to store the attribute data.
      * @param modeldata The JSON data
      */
    constructor(modeldata, attribs_maps) {
        this._modeldata = modeldata;
        this._attribs_maps = attribs_maps;
    }
    // ============================================================================
    // Threejs
    // For methods to get the array of edges and triangles, see the geom class
    // get3jsTris() and get3jsEdges()
    // ============================================================================
    /**
     * Get a flat array of all the coordinates of all the vertices.
     * Verts that have been deleted will not be included
     * @param verts An array of vertex indices pointing to the position.
     */
    get3jsSeqPosisCoords() {
        const coords_attrib = this._attribs_maps.ps.get(_common__WEBPACK_IMPORTED_MODULE_0__["EAttribNames"].COORDS);
        //
        const coords = [];
        const posi_map = new Map();
        const posis_i = this._modeldata.geom.query.getEnts(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POSI);
        for (const posi_i of posis_i) {
            const tjs_index = coords.push(coords_attrib.getEntVal(posi_i)) - 1;
            posi_map.set(posi_i, tjs_index);
        }
        // console.log("LIST OF THREEJS COORDS", coords)
        // posis_i.forEach( (posi_i, gi_index) => {
        //     if (posi_i !== null) {
        //         const tjs_index: number = coords.push( coords_attrib.getEntVal(posi_i) as number[] ) - 1;
        //         posi_map.set(gi_index, tjs_index);
        //     }
        // });
        // @ts-ignore
        return [coords.flat(1), posi_map];
    }
    /**
     * Get a flat array of all the coordinates of all the vertices.
     * Verts that have been deleted will not be included
     * @param verts An array of vertex indices pointing to the positio.
     */
    get3jsSeqVertsCoords() {
        const coords_attrib = this._attribs_maps.ps.get(_common__WEBPACK_IMPORTED_MODULE_0__["EAttribNames"].COORDS);
        //
        const coords = [];
        const vertex_map = new Map();
        const verts_i = this._modeldata.geom.query.getEnts(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].VERT);
        for (const vert_i of verts_i) {
            const posi_i = this._modeldata.geom.nav.navVertToPosi(vert_i);
            const tjs_index = coords.push(coords_attrib.getEntVal(posi_i)) - 1;
            vertex_map.set(vert_i, tjs_index);
        }
        // verts_i.forEach( (vert_i, gi_index) => {
        //     if (vert_i !== null) {
        //         const posi_i: number = this._model.modeldata.geom.nav.navVertToPosi(vert_i);
        //         const tjs_index: number = coords.push( coords_attrib.getEntVal(posi_i) as number[] ) - 1;
        //         vertex_map.set(gi_index, tjs_index);
        //     }
        // });
        // @ts-ignore
        return [coords.flat(1), vertex_map];
    }
    /**
     * Get a flat array of normals values for all the vertices.
     * Verts that have been deleted will not be included
     */
    get3jsSeqVertsNormals() {
        if (!this._attribs_maps._v.has(_common__WEBPACK_IMPORTED_MODULE_0__["EAttribNames"].NORMAL)) {
            return null;
        }
        // create a sparse arrays of normals of all verts of polygons
        const verts_attrib = this._attribs_maps._v.get(_common__WEBPACK_IMPORTED_MODULE_0__["EAttribNames"].NORMAL);
        const normals = [];
        for (const pgon_i of this._modeldata.geom.query.getEnts(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PGON)) {
            let pgon_normal = null;
            for (const vert_i of this._modeldata.geom.nav.navAnyToVert(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PGON, pgon_i)) {
                let normal = verts_attrib.getEntVal(vert_i);
                if (!Array.isArray(normal)) {
                    if (pgon_normal === null) {
                        const face_i = this._modeldata.geom.nav.navPgonToFace(pgon_i);
                        pgon_normal = this._modeldata.geom.query.getFaceNormal(face_i);
                    }
                    normal = pgon_normal;
                }
                normals[vert_i] = normal;
            }
        }
        // get all the normals
        const verts_normals = [];
        const verts_i = this._modeldata.geom.query.getEnts(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].VERT);
        for (const vert_i of verts_i) {
            if (vert_i !== undefined) {
                let normal = normals[vert_i];
                normal = normal === undefined ? [0, 0, 0] : normal;
                verts_normals.push(normal);
            }
        }
        // @ts-ignore
        return verts_normals.flat(1);
    }
    /**
     * Get a flat array of colors values for all the vertices.
     */
    get3jsSeqVertsColors() {
        if (!this._attribs_maps._v.has(_common__WEBPACK_IMPORTED_MODULE_0__["EAttribNames"].COLOR)) {
            return null;
        }
        const verts_attrib = this._attribs_maps._v.get(_common__WEBPACK_IMPORTED_MODULE_0__["EAttribNames"].COLOR);
        // get all the colors
        const verts_colors = [];
        const verts_i = this._modeldata.geom.query.getEnts(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].VERT);
        for (const vert_i of verts_i) {
            if (vert_i !== undefined) {
                const value = verts_attrib.getEntVal(vert_i);
                const _value = value === undefined ? [1, 1, 1] : value;
                verts_colors.push(_value);
            }
        }
        // @ts-ignore
        return verts_colors.flat(1);
    }
    /**
     *
     */
    getModelAttribsForTable() {
        const attribs_maps_key = _common__WEBPACK_IMPORTED_MODULE_0__["EEntTypeStr"][_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].MOD];
        const attribs = this._attribs_maps[attribs_maps_key];
        if (attribs === undefined) {
            return [];
        }
        const arr = [];
        attribs.forEach((value, key) => {
            // const _value = isString(value) ? `'${value}'` : value;
            const _value = JSON.stringify(value);
            const obj = { Name: key, Value: _value };
            arr.push(obj);
        });
        // console.log(arr);
        return arr;
    }
    /**
     *
     * @param ent_type
     */
    getAttribsForTable(ent_type) {
        // get the attribs map for this ent type
        const attribs_maps_key = _common__WEBPACK_IMPORTED_MODULE_0__["EEntTypeStr"][ent_type];
        const attribs = this._attribs_maps[attribs_maps_key];
        // create a map of objects to store the data
        // const data_obj_map: Map< number, { '#': number, _id: string} > = new Map();
        const data_obj_map = new Map();
        // create the ID for each table row
        const ents_i = this._modeldata.geom.query.getEnts(ent_type);
        // sessionStorage.setItem('attrib_table_ents', JSON.stringify(ents_i));
        let i = 0;
        for (const ent_i of ents_i) {
            // data_obj_map.set(ent_i, { '#': i, _id: `${attribs_maps_key}${ent_i}`} );
            data_obj_map.set(ent_i, { _id: `${attribs_maps_key}${ent_i}` });
            if (ent_type === _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].COLL) {
                const coll_parent = this._modeldata.geom.query.getCollParent(ent_i);
                data_obj_map.get(ent_i)['_parent'] = coll_parent === -1 ? '' : 'co' + coll_parent;
            }
            i++;
        }
        // loop through all the attributes
        attribs.forEach((attrib, attrib_name) => {
            const data_size = attrib.getDataLength();
            if (attrib.numVals() === 0) {
                return;
            }
            for (const ent_i of ents_i) {
                if (attrib_name.substr(0, 1) === '_' && attrib_name !== '_parent') {
                    const attrib_value = attrib.getEntVal(ent_i);
                    data_obj_map.get(ent_i)[`${attrib_name}`] = attrib_value;
                }
                else {
                    const attrib_value = attrib.getEntVal(ent_i);
                    if (attrib_value && attrib_value.constructor === {}.constructor) {
                        data_obj_map.get(ent_i)[`${attrib_name}`] = JSON.stringify(attrib_value);
                    }
                    else if (data_size > 1) {
                        if (attrib_value === undefined) {
                            for (let idx = 0; idx < data_size; idx++) {
                                data_obj_map.get(ent_i)[`${attrib_name}[${idx}]`] = undefined;
                            }
                        }
                        else {
                            attrib_value.forEach((v, idx) => {
                                const _v = v;
                                data_obj_map.get(ent_i)[`${attrib_name}[${idx}]`] = _v;
                            });
                        }
                    }
                    else {
                        if (ent_type === _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POSI && Array.isArray(attrib_value)) {
                            if (attrib_name === 'xyz') {
                                for (let index = 0; index < attrib_value.length; index++) {
                                    const _v = Array.isArray(attrib_value[index]) ?
                                        JSON.stringify(attrib_value[index]) : attrib_value[index];
                                    data_obj_map.get(ent_i)[`${attrib_name}[${index}]`] = _v;
                                }
                                // if (attrib_value.length < 4) {
                                //     console.log(attrib_value)
                                //     for (let index = 0; index < attrib_value.length; index++) {
                                //         const _v = Array.isArray(attrib_value[index]) ?
                                //         JSON.stringify(attrib_value[index]) : attrib_value[index];
                                //         data_obj_map.get(ent_i)[`${attrib_name}[${index}]`] = _v;
                                //     }
                            }
                            else {
                                data_obj_map.get(ent_i)[attrib_name] = JSON.stringify(attrib_value);
                            }
                        }
                        else {
                            const _attrib_value = Object(util__WEBPACK_IMPORTED_MODULE_1__["isString"])(attrib_value) ? `'${attrib_value}'` : attrib_value;
                            data_obj_map.get(ent_i)[`${attrib_name}`] = _attrib_value;
                        }
                    }
                }
            }
        });
        return { data: Array.from(data_obj_map.values()), ents: ents_i };
    }
    /**
     * @param ent_type
     * @param ents_i
     */
    getEntsVals(selected_ents, ent_type) {
        const attribs_maps_key = _common__WEBPACK_IMPORTED_MODULE_0__["EEntTypeStr"][ent_type];
        const attribs = this._attribs_maps[attribs_maps_key];
        const data_obj_map = new Map();
        if (!selected_ents || selected_ents === undefined) {
            return [];
        }
        let i = 0;
        const selected_ents_sorted = Object(_util_maps__WEBPACK_IMPORTED_MODULE_2__["sortByKey"])(selected_ents);
        selected_ents_sorted.forEach(ent => {
            data_obj_map.set(ent, { _id: `${attribs_maps_key}${ent}` });
            if (ent_type === _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].COLL) {
                const coll_parent = this._modeldata.geom.query.getCollParent(ent);
                data_obj_map.get(ent)['_parent'] = coll_parent === -1 ? '' : coll_parent;
            }
            i++;
        });
        const nullAttribs = new Set();
        attribs.forEach((attrib, attrib_name) => {
            const data_size = attrib.getDataLength();
            if (attrib.numVals() === 0) {
                return;
            }
            nullAttribs.add(attrib_name);
            for (const ent_i of Array.from(selected_ents.values())) {
                if (attrib_name.substr(0, 1) === '_') {
                    const attrib_value = attrib.getEntVal(ent_i);
                    data_obj_map.get(ent_i)[`${attrib_name}`] = attrib_value;
                    nullAttribs.delete(attrib_name);
                }
                else {
                    const attrib_value = attrib.getEntVal(ent_i);
                    if (attrib_value !== undefined) {
                        nullAttribs.delete(attrib_name);
                    }
                    if (data_size > 1) {
                        if (attrib_value === undefined) {
                            for (let idx = 0; idx < data_size; idx++) {
                                data_obj_map.get(ent_i)[`${attrib_name}[${idx}]`] = undefined;
                            }
                        }
                        else if (attrib_value.constructor === {}.constructor) {
                            data_obj_map.get(ent_i)[`${attrib_name}`] = JSON.stringify(attrib_value);
                        }
                        else {
                            attrib_value.forEach((v, idx) => {
                                const _v = v;
                                data_obj_map.get(ent_i)[`${attrib_name}[${idx}]`] = _v;
                            });
                        }
                    }
                    else {
                        if (ent_type === _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POSI && Array.isArray(attrib_value)) {
                            if (attrib_value.length < 4) {
                                for (let index = 0; index < attrib_value.length; index++) {
                                    const _v = Array.isArray(attrib_value[index]) ?
                                        JSON.stringify(attrib_value[index]) : attrib_value[index];
                                    data_obj_map.get(ent_i)[`${attrib_name}[${index}]`] = _v;
                                }
                            }
                            else {
                                data_obj_map.get(ent_i)[attrib_name] = JSON.stringify(attrib_value);
                            }
                        }
                        else {
                            const _attrib_value = Object(util__WEBPACK_IMPORTED_MODULE_1__["isString"])(attrib_value) ? `'${attrib_value}'` : attrib_value;
                            data_obj_map.get(ent_i)[`${attrib_name}`] = _attrib_value;
                        }
                    }
                }
            }
        });
        for (const attrib of nullAttribs) {
            data_obj_map.forEach((val, index) => {
                try {
                    // @ts-ignore
                    delete val[attrib];
                }
                catch (ex) { }
            });
        }
        return Array.from(data_obj_map.values());
    }
}


/***/ }),

/***/ "./src/assets/libs/geo-info/GIGeom.ts":
/*!********************************************!*\
  !*** ./src/assets/libs/geo-info/GIGeom.ts ***!
  \********************************************/
/*! exports provided: GIGeom */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GIGeom", function() { return GIGeom; });
/* harmony import */ var _GIGeomAdd__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GIGeomAdd */ "./src/assets/libs/geo-info/GIGeomAdd.ts");
/* harmony import */ var _GIGeomModify__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GIGeomModify */ "./src/assets/libs/geo-info/GIGeomModify.ts");
/* harmony import */ var _GIGeomQuery__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./GIGeomQuery */ "./src/assets/libs/geo-info/GIGeomQuery.ts");
/* harmony import */ var _GIGeomThreejs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./GIGeomThreejs */ "./src/assets/libs/geo-info/GIGeomThreejs.ts");
/* harmony import */ var _GIGeomIO__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./GIGeomIO */ "./src/assets/libs/geo-info/GIGeomIO.ts");
/* harmony import */ var _GIGeomDel__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./GIGeomDel */ "./src/assets/libs/geo-info/GIGeomDel.ts");
/* harmony import */ var _GIGeomCheck__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./GIGeomCheck */ "./src/assets/libs/geo-info/GIGeomCheck.ts");
/* harmony import */ var _GiGeomCompare__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./GiGeomCompare */ "./src/assets/libs/geo-info/GiGeomCompare.ts");
/* harmony import */ var _GIGeomModifyPline__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./GIGeomModifyPline */ "./src/assets/libs/geo-info/GIGeomModifyPline.ts");
/* harmony import */ var _GIGeomModifyPgon__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./GIGeomModifyPgon */ "./src/assets/libs/geo-info/GIGeomModifyPgon.ts");
/* harmony import */ var _GIGeomModifyColl__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./GIGeomModifyColl */ "./src/assets/libs/geo-info/GIGeomModifyColl.ts");
/* harmony import */ var _GIGeomNav__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./GIGeomNav */ "./src/assets/libs/geo-info/GIGeomNav.ts");
/* harmony import */ var _GIGeomDelVert__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./GIGeomDelVert */ "./src/assets/libs/geo-info/GIGeomDelVert.ts");
/* harmony import */ var _GIGeomDelEdge__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./GIGeomDelEdge */ "./src/assets/libs/geo-info/GIGeomDelEdge.ts");
/* harmony import */ var _GIGeomTimeStamp__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./GIGeomTimeStamp */ "./src/assets/libs/geo-info/GIGeomTimeStamp.ts");
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};















/**
 * Class for geometry.
 */
class GIGeom {
    /**
     * Constructor
     */
    constructor(model) {
        //  all arrays
        this._geom_maps = {
            // num_posis: 0,
            dn_verts_posis: new Map(),
            dn_tris_verts: new Map(),
            dn_edges_verts: new Map(),
            dn_wires_edges: new Map(),
            dn_faces_wires: new Map(),
            dn_faces_tris: new Map(),
            dn_points_verts: new Map(),
            dn_plines_wires: new Map(),
            dn_pgons_faces: new Map(),
            dn_colls_objs: new Map(),
            up_posis_verts: new Map(),
            up_tris_faces: new Map(),
            up_verts_edges: new Map(),
            up_verts_tris: new Map(),
            up_verts_points: new Map(),
            up_edges_wires: new Map(),
            up_wires_faces: new Map(),
            up_wires_plines: new Map(),
            up_faces_pgons: new Map(),
            up_points_colls: new Map(),
            up_plines_colls: new Map(),
            up_pgons_colls: new Map(),
            posis_ts: new Map(),
            points_ts: new Map(),
            plines_ts: new Map(),
            pgons_ts: new Map(),
            colls_ts: new Map()
        };
        this.modeldata = model;
        this.io = new _GIGeomIO__WEBPACK_IMPORTED_MODULE_4__["GIGeomIO"](this, this._geom_maps);
        this.add = new _GIGeomAdd__WEBPACK_IMPORTED_MODULE_0__["GIGeomAdd"](this, this._geom_maps);
        this.del = new _GIGeomDel__WEBPACK_IMPORTED_MODULE_5__["GIGeomDel"](this, this._geom_maps);
        this.del_vert = new _GIGeomDelVert__WEBPACK_IMPORTED_MODULE_12__["GIGeomDelVert"](this, this._geom_maps);
        this.del_edge = new _GIGeomDelEdge__WEBPACK_IMPORTED_MODULE_13__["GIGeomDelEdge"](this, this._geom_maps);
        this.modify = new _GIGeomModify__WEBPACK_IMPORTED_MODULE_1__["GIGeomModify"](this, this._geom_maps);
        this.modify_pline = new _GIGeomModifyPline__WEBPACK_IMPORTED_MODULE_8__["GIGeomModifyPline"](this, this._geom_maps);
        this.modify_pgon = new _GIGeomModifyPgon__WEBPACK_IMPORTED_MODULE_9__["GIGeomModifyPgon"](this, this._geom_maps);
        this.modify_coll = new _GIGeomModifyColl__WEBPACK_IMPORTED_MODULE_10__["GIGeomModifyColl"](this, this._geom_maps);
        this.nav = new _GIGeomNav__WEBPACK_IMPORTED_MODULE_11__["GIGeomNav"](this, this._geom_maps);
        this.query = new _GIGeomQuery__WEBPACK_IMPORTED_MODULE_2__["GIGeomQuery"](this, this._geom_maps);
        this.check = new _GIGeomCheck__WEBPACK_IMPORTED_MODULE_6__["GIGeomCheck"](this, this._geom_maps);
        this.compare = new _GiGeomCompare__WEBPACK_IMPORTED_MODULE_7__["GIGeomCompare"](this, this._geom_maps);
        this.threejs = new _GIGeomThreejs__WEBPACK_IMPORTED_MODULE_3__["GIGeomThreejs"](this, this._geom_maps);
        this.time_stamp = new _GIGeomTimeStamp__WEBPACK_IMPORTED_MODULE_14__["GIGeomTimeStamp"](this, this._geom_maps);
        this.selected = [];
    }
    /**
     * Generate a string for debugging
     */
    toStr() {
        let result = '';
        result += JSON.stringify(this.io.getJSONData());
        return result;
    }
}


/***/ }),

/***/ "./src/assets/libs/geo-info/GIGeomAdd.ts":
/*!***********************************************!*\
  !*** ./src/assets/libs/geo-info/GIGeomAdd.ts ***!
  \***********************************************/
/*! exports provided: GIGeomAdd */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GIGeomAdd", function() { return GIGeomAdd; });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common */ "./src/assets/libs/geo-info/common.ts");
/* harmony import */ var _triangulate_triangulate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../triangulate/triangulate */ "./src/assets/libs/triangulate/triangulate.ts");
/* harmony import */ var _geom_vectors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../geom/vectors */ "./src/assets/libs/geom/vectors.ts");
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};



/**
 * Class for geometry.
 */
class GIGeomAdd {
    /**
     * Constructor
     */
    constructor(geom, geom_arrays) {
        this._geom = geom;
        this._geom_maps = geom_arrays;
    }
    // ============================================================================
    // Add geometry
    // ============================================================================
    /**
     * Adds a new position to the model and returns the index to that position.
     */
    addPosi() {
        // create posi
        const posi_i = this._addPosi();
        return posi_i;
    }
    /**
     * Adds a new point entity to the model.
     * @param posi_i The position for the point.
     */
    addPoint(posi_i) {
        // create vert
        const vert_i = this._addVertex(posi_i);
        // create point
        const point_i = this._geom.modeldata.model.metadata.nextPoint();
        this._geom_maps.dn_points_verts.set(point_i, vert_i);
        this._geom_maps.up_verts_points.set(vert_i, point_i);
        // time stamp
        const ts = this._geom.modeldata.model.metadata.nextTimeStamp();
        this._geom_maps.posis_ts.set(posi_i, ts);
        return point_i;
    }
    /**
     * Adds a new pline entity to the model using numeric indices.
     * @param posis_i
     */
    addPline(posis_i, close = false) {
        // create verts, edges, wires
        const vert_i_arr = posis_i.map(posi_i => this._addVertex(posi_i));
        const edges_i_arr = [];
        for (let i = 0; i < vert_i_arr.length - 1; i++) {
            edges_i_arr.push(this._addEdge(vert_i_arr[i], vert_i_arr[i + 1]));
        }
        if (close) {
            edges_i_arr.push(this._addEdge(vert_i_arr[vert_i_arr.length - 1], vert_i_arr[0]));
        }
        const wire_i = this._addWire(edges_i_arr, close);
        // create pline
        const pline_i = this._geom.modeldata.model.metadata.nextPline();
        this._geom_maps.dn_plines_wires.set(pline_i, wire_i);
        this._geom_maps.up_wires_plines.set(wire_i, pline_i);
        return pline_i;
    }
    /**
     * Adds a new polygon + hole entity to the model using numeric indices.
     * @param posis_id
     */
    addPgon(posis_i, holes_posis_i) {
        const has_holes = (holes_posis_i !== undefined) && (holes_posis_i.length) ? true : false;
        // create verts, edges, wire for face
        const vert_i_arr = posis_i.map(posi_i => this._addVertex(posi_i));
        const edges_i_arr = [];
        for (let i = 0; i < vert_i_arr.length - 1; i++) {
            edges_i_arr.push(this._addEdge(vert_i_arr[i], vert_i_arr[i + 1]));
        }
        edges_i_arr.push(this._addEdge(vert_i_arr[vert_i_arr.length - 1], vert_i_arr[0]));
        const wire_i = this._addWire(edges_i_arr, true);
        let face_i;
        if (has_holes) {
            // create verts, edges, wire for holes
            const holes_wires_i = [];
            for (const hole_posis_i of holes_posis_i) {
                const hole_vert_i_arr = hole_posis_i.map(posi_i => this._addVertex(posi_i));
                const hole_edges_i_arr = [];
                for (let i = 0; i < hole_vert_i_arr.length - 1; i++) {
                    hole_edges_i_arr.push(this._addEdge(hole_vert_i_arr[i], hole_vert_i_arr[i + 1]));
                }
                hole_edges_i_arr.push(this._addEdge(hole_vert_i_arr[hole_vert_i_arr.length - 1], hole_vert_i_arr[0]));
                const hole_wire_i = this._addWire(hole_edges_i_arr, true);
                holes_wires_i.push(hole_wire_i);
            }
            // create the new face with a hole
            face_i = this._addFaceWithHoles(wire_i, holes_wires_i);
        }
        else {
            face_i = this._addFace(wire_i);
        }
        // create polygon
        const pgon_i = this._geom.modeldata.model.metadata.nextPgon();
        this._geom_maps.dn_pgons_faces.set(pgon_i, face_i);
        this._geom_maps.up_faces_pgons.set(face_i, pgon_i);
        return pgon_i;
    }
    /**
     * Adds a collection and updates the rev array using numeric indices.
     * @param parent_i
     * @param points_i
     * @param plines_i
     * @param pgons_i
     */
    addColl(parent_i, points_i, plines_i, pgons_i) {
        parent_i = parent_i === null ? -1 : parent_i;
        // create collection
        const coll_i = this._geom.modeldata.model.metadata.nextColl();
        this._geom_maps.dn_colls_objs.set(coll_i, [parent_i, points_i, plines_i, pgons_i]);
        for (const point_i of points_i) {
            if (!this._geom_maps.up_points_colls.has(point_i)) {
                this._geom_maps.up_points_colls.set(point_i, [coll_i]);
            }
            else {
                this._geom_maps.up_points_colls.get(point_i).push(coll_i);
            }
        }
        for (const pline_i of plines_i) {
            if (!this._geom_maps.up_plines_colls.has(pline_i)) {
                this._geom_maps.up_plines_colls.set(pline_i, [coll_i]);
            }
            else {
                this._geom_maps.up_plines_colls.get(pline_i).push(coll_i);
            }
        }
        for (const pgon_i of pgons_i) {
            if (!this._geom_maps.up_pgons_colls.has(pgon_i)) {
                this._geom_maps.up_pgons_colls.set(pgon_i, [coll_i]);
            }
            else {
                this._geom_maps.up_pgons_colls.get(pgon_i).push(coll_i);
            }
        }
        return coll_i;
    }
    // ============================================================================
    // Copy geometry
    // ============================================================================
    /**
     * Copy positions.
     * @param posis_i
     * @param copy_attribs
     */
    copyMovePosis(posis_i, move_vector, copy_attribs) {
        if (!Array.isArray(posis_i)) {
            const posi_i = posis_i;
            const xyz = this._geom.modeldata.attribs.query.getPosiCoords(posi_i);
            const new_posi_i = this.addPosi();
            this._geom.modeldata.attribs.add.setPosiCoords(new_posi_i, Object(_geom_vectors__WEBPACK_IMPORTED_MODULE_2__["vecAdd"])(xyz, move_vector));
            if (copy_attribs) {
                const attrib_names = this._geom.modeldata.attribs.query.getAttribNames(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POSI);
                for (const attrib_name of attrib_names) {
                    if (attrib_name !== 'xyz') {
                        const value = this._geom.modeldata.attribs.query.getAttribVal(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POSI, attrib_name, posis_i);
                        this._geom.modeldata.attribs.add.setEntAttribVal(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POSI, new_posi_i, attrib_name, value);
                    }
                }
            }
            return new_posi_i;
        }
        else {
            return posis_i.map(posi_i => this.copyPosis(posi_i, copy_attribs));
        }
    }
    /**
     * Copy positions.
     * @param posis_i
     * @param copy_attribs
     */
    copyPosis(posis_i, copy_attribs) {
        if (!Array.isArray(posis_i)) {
            const posi_i = posis_i;
            const xyz = this._geom.modeldata.attribs.query.getPosiCoords(posi_i);
            const new_posi_i = this.addPosi();
            this._geom.modeldata.attribs.add.setPosiCoords(new_posi_i, xyz);
            if (copy_attribs) {
                const attrib_names = this._geom.modeldata.attribs.query.getAttribNames(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POSI);
                for (const attrib_name of attrib_names) {
                    const value = this._geom.modeldata.attribs.query.getAttribVal(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POSI, attrib_name, posis_i);
                    this._geom.modeldata.attribs.add.setEntAttribVal(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POSI, new_posi_i, attrib_name, value);
                }
            }
            return new_posi_i;
        }
        else {
            return posis_i.map(posi_i => this.copyPosis(posi_i, copy_attribs));
        }
    }
    /**
     * Copy points.
     * TODO copy attribs of topo entities
     * @param index
     * @param copy_attribs
     */
    copyPoints(points_i, copy_attribs) {
        // make copies
        if (!Array.isArray(points_i)) {
            const old_point_i = points_i;
            const posis_i = this._geom.nav.navAnyToPosi(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POINT, old_point_i);
            const new_point_i = this.addPoint(posis_i[0]);
            if (copy_attribs) {
                this._geom.modeldata.attribs.add.copyAttribs(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POINT, old_point_i, new_point_i);
            }
            return new_point_i;
        }
        else { // An array of ent_i
            return points_i.map(point_i => this.copyPoints(point_i, copy_attribs));
        }
    }
    /**
     * Copy plines.
     * TODO copy attribs of topo entities
     * @param index
     * @param copy_attribs
     */
    copyPlines(plines_i, copy_attribs) {
        // make copies
        if (!Array.isArray(plines_i)) {
            const old_pline_i = plines_i;
            const posis_i = this._geom.nav.navAnyToPosi(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PLINE, old_pline_i);
            const wire_i = this._geom.nav.navPlineToWire(old_pline_i);
            const is_closed = this._geom.query.isWireClosed(wire_i);
            const new_pline_i = this.addPline(posis_i, is_closed);
            if (copy_attribs) {
                this._geom.modeldata.attribs.add.copyAttribs(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PLINE, old_pline_i, new_pline_i);
            }
            return new_pline_i;
        }
        else { // An array of ent_i
            return plines_i.map(pline_i => this.copyPlines(pline_i, copy_attribs));
        }
    }
    /**
     * Copy polygons.
     * TODO copy attribs of topo entities
     * @param index
     * @param copy_attribs
     */
    copyPgons(pgons_i, copy_attribs) {
        // make copies
        if (!Array.isArray(pgons_i)) {
            const old_pgon_i = pgons_i;
            const wires_i = this._geom.nav.navAnyToWire(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PGON, old_pgon_i);
            const posis_i = this._geom.nav.navAnyToPosi(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].WIRE, wires_i[0]);
            let new_pgon_i;
            if (wires_i.length === 1) {
                new_pgon_i = this.addPgon(posis_i);
            }
            else {
                const holes_posis_i = [];
                for (let i = 1; i < wires_i.length; i++) {
                    const hole_posis_i = this._geom.nav.navAnyToPosi(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].WIRE, wires_i[i]);
                    holes_posis_i.push(hole_posis_i);
                }
                new_pgon_i = this.addPgon(posis_i, holes_posis_i);
            }
            if (copy_attribs) {
                this._geom.modeldata.attribs.add.copyAttribs(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PGON, old_pgon_i, new_pgon_i);
            }
            return new_pgon_i;
        }
        else { // AN array of ent_i
            return pgons_i.map(pgon_i => this.copyPgons(pgon_i, copy_attribs));
        }
    }
    /**
      * Copy a collection
      * TODO Copy attribs of object and topo entities
      * @param ent_type
      * @param index
      * @param copy_posis
      * @param copy_attribs
      */
    copyColls(colls_i, copy_attribs) {
        // make copies
        if (!Array.isArray(colls_i)) {
            const old_coll_i = colls_i;
            // make a deep copy of the objects in the collection
            const points_i = this._geom.nav.navCollToPoint(old_coll_i);
            const res1 = this.copyPoints(points_i, copy_attribs);
            const plines_i = this._geom.nav.navCollToPline(old_coll_i);
            const res2 = this.copyPlines(plines_i, copy_attribs);
            const pgons_i = this._geom.nav.navCollToPgon(old_coll_i);
            const res3 = this.copyPgons(pgons_i, copy_attribs);
            const parent = this._geom.query.getCollParent(old_coll_i);
            // add the new collection
            const new_coll_i = this.addColl(parent, res1, res2, res3);
            // copy the attributes from old collection to new collection
            if (copy_attribs) {
                this._geom.modeldata.attribs.add.copyAttribs(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].COLL, old_coll_i, new_coll_i);
            }
            // return the new collection
            return new_coll_i;
        }
        else {
            return colls_i.map(coll_i => this.copyColls(coll_i, copy_attribs));
        }
    }
    // ============================================================================
    // Methods to create the topological entities
    // These methods have been made public for access from GIGeomModify
    // They should not be called externally, hence the underscore.
    // ============================================================================
    /**
     * Adds a position and updates the arrays.
     */
    _addPosi() {
        // in this case, there are no down arrays
        // because posis are the bottom of the hierarchy
        // update up arrays
        const posi_i = this._geom.modeldata.model.metadata.nextPosi();
        const ts = this._geom.modeldata.model.metadata.nextTimeStamp();
        this._geom_maps.up_posis_verts.set(posi_i, []);
        this._geom_maps.posis_ts.set(posi_i, ts);
        // return the numeric index of the posi
        return posi_i;
    }
    /**
     * Adds a vertex and updates the arrays.
     * @param posi_i
     */
    _addVertex(posi_i) {
        // update down arrays
        const vert_i = this._geom.modeldata.model.metadata.nextVert();
        this._geom_maps.dn_verts_posis.set(vert_i, posi_i);
        // update up arrays
        this._geom_maps.up_posis_verts.get(posi_i).push(vert_i);
        // return the numeric index of the vertex
        return vert_i;
    }
    /**
     * Adds an edge from v1 to v2 and updates the up and down arrays.
     * Each vertex passed into this function can have zero or one edges.
     * The new edge is added to v1 and v2
     * Any existing edges are not affected
     * @param vert_i1
     * @param vert_i2
     */
    _addEdge(vert_i1, vert_i2) {
        // update down arrays
        const edge_i = this._geom.modeldata.model.metadata.nextEdge();
        this._geom_maps.dn_edges_verts.set(edge_i, [vert_i1, vert_i2]);
        // assume there are three edges, prev, edge_i, next
        // for vert_i1, [prev, edge_i] or [edge_i]
        // update up arrays for the start vertex
        if (!this._geom_maps.up_verts_edges.has(vert_i1)) {
            this._geom_maps.up_verts_edges.set(vert_i1, []);
        }
        switch (this._geom_maps.up_verts_edges.get(vert_i1).length) {
            case 0:
                this._geom_maps.up_verts_edges.set(vert_i1, [edge_i]); // [edge_i]
                break;
            case 1:
                this._geom_maps.up_verts_edges.get(vert_i1)[1] = edge_i; // [prev, edge_i]
                break;
            case 2:
                throw new Error('Vertex must have just zero or one edges.');
            default:
                throw new Error('Vertex has wrong number of edges.');
        }
        // for vert_i2, [edge_i, next] or [edge_i]
        // update up arrays for the end vertex
        if (!this._geom_maps.up_verts_edges.has(vert_i2)) {
            this._geom_maps.up_verts_edges.set(vert_i2, []);
        }
        switch (this._geom_maps.up_verts_edges.get(vert_i2).length) {
            case 0:
                this._geom_maps.up_verts_edges.set(vert_i2, [edge_i]); // [edge_i]
                break;
            case 1:
                const next_edge_i = this._geom_maps.up_verts_edges.get(vert_i2)[0];
                this._geom_maps.up_verts_edges.set(vert_i2, [edge_i, next_edge_i]); // [edge_i, next]
                break;
            case 2:
                throw new Error('Vertex must have just zero or one edges.');
            default:
                throw new Error('Vertex has wrong number of edges.');
        }
        // return the numeric index of the edge
        return edge_i;
    }
    /**
     * Adds a wire and updates the arrays.
     * Edges are assumed to be sequential!
     * @param edges_i
     */
    _addWire(edges_i, close = false) {
        // update down arrays
        const wire_i = this._geom.modeldata.model.metadata.nextWire();
        this._geom_maps.dn_wires_edges.set(wire_i, edges_i);
        // update up arrays
        edges_i.forEach(edge_i => this._geom_maps.up_edges_wires.set(edge_i, wire_i));
        // return the numeric index of the wire
        return wire_i;
    }
    /**
     * Adds a face and updates the arrays.
     * Wires are assumed to be closed!
     * This also calls addTris()
     * @param wire_i
     */
    _addFace(wire_i) {
        // create the triangles
        const tris_i = this._addTris(wire_i);
        // create the face
        const face = [wire_i];
        // update down arrays
        const face_i = this._geom.modeldata.model.metadata.nextFace();
        this._geom_maps.dn_faces_wires.set(face_i, face);
        this._geom_maps.dn_faces_tris.set(face_i, tris_i);
        // update up arrays
        this._geom_maps.up_wires_faces.set(wire_i, face_i);
        tris_i.forEach(tri_i => this._geom_maps.up_tris_faces.set(tri_i, face_i));
        // return the numeric index of the face
        return face_i;
    }
    /**
     * Adds a face with a hole and updates the arrays.
     * Wires are assumed to be closed!
     * This also calls addTris()
     * @param wire_i
     */
    _addFaceWithHoles(wire_i, holes_wires_i) {
        // create the triangles
        const tris_i = this._addTris(wire_i, holes_wires_i);
        // create the face
        const face = [wire_i].concat(holes_wires_i);
        // update down arrays
        const face_i = this._geom.modeldata.model.metadata.nextFace();
        this._geom_maps.dn_faces_wires.set(face_i, face);
        this._geom_maps.dn_faces_tris.set(face_i, tris_i);
        // update up arrays
        face.forEach(face_wire_i => this._geom_maps.up_wires_faces.set(face_wire_i, face_i));
        tris_i.forEach(tri_i => this._geom_maps.up_tris_faces.set(tri_i, face_i));
        // return the numeric index of the face
        return face_i;
    }
    /**
     * Adds trangles and updates the arrays.
     * Wires are assumed to be closed!
     * This updates the trie->verts and the verts->tris
     * This does not update the face to which this wire belongs!
     * @param wire_i
     */
    _addTris(wire_i, hole_wires_i) {
        // save all verts
        const all_verts_i = [];
        // get the coords of the outer perimeter edge
        const wire_verts_i = this._geom.nav.navAnyToVert(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].WIRE, wire_i);
        wire_verts_i.forEach(wire_vert_i => all_verts_i.push(wire_vert_i));
        const wire_posis_i = wire_verts_i.map(vert_i => this._geom_maps.dn_verts_posis.get(vert_i));
        const wire_coords = wire_posis_i.map(posi_i => this._geom.modeldata.attribs.query.getPosiCoords(posi_i));
        // get the coords of the holes
        const all_hole_coords = [];
        if (hole_wires_i !== undefined) {
            for (const hole_wire_i of hole_wires_i) {
                const hole_wire_verts_i = this._geom.nav.navAnyToVert(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].WIRE, hole_wire_i);
                hole_wire_verts_i.forEach(wire_vert_i => all_verts_i.push(wire_vert_i));
                const hole_wire_posis_i = hole_wire_verts_i.map(vert_i => this._geom_maps.dn_verts_posis.get(vert_i));
                const hole_wire_coords = hole_wire_posis_i.map(posi_i => this._geom.modeldata.attribs.query.getPosiCoords(posi_i));
                all_hole_coords.push(hole_wire_coords);
            }
        }
        // create the triangles
        const tris_corners = Object(_triangulate_triangulate__WEBPACK_IMPORTED_MODULE_1__["triangulate"])(wire_coords, all_hole_coords);
        const tris_verts_i = tris_corners.map(tri_corners => tri_corners.map(corner => all_verts_i[corner]));
        // update down arrays, tris->verts
        const tris_i = [];
        for (const tri_verts_i of tris_verts_i) {
            const tri_i = this._geom.modeldata.model.metadata.nextTri();
            this._geom_maps.dn_tris_verts.set(tri_i, tri_verts_i);
            tris_i.push(tri_i);
        }
        // update up arrays, verts->tris
        for (let i = 0; i < tris_verts_i.length; i++) {
            const tri_verts_i = tris_verts_i[i];
            const tri_i = tris_i[i];
            for (const tri_vert_i of tri_verts_i) {
                if (!this._geom_maps.up_verts_tris.has(tri_vert_i)) {
                    this._geom_maps.up_verts_tris.set(tri_vert_i, []);
                }
                this._geom_maps.up_verts_tris.get(tri_vert_i).push(tri_i);
            }
        }
        // return an array of numeric indices of the triangles
        return tris_i;
    }
}


/***/ }),

/***/ "./src/assets/libs/geo-info/GIGeomCheck.ts":
/*!*************************************************!*\
  !*** ./src/assets/libs/geo-info/GIGeomCheck.ts ***!
  \*************************************************/
/*! exports provided: GIGeomCheck */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GIGeomCheck", function() { return GIGeomCheck; });
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};
/**
 * Class for geometry.
 */
class GIGeomCheck {
    /**
     * Constructor
     */
    constructor(geom, geom_arrays) {
        this._geom = geom;
        this._geom_maps = geom_arrays;
    }
    /**
     * Checks geometry for internal consistency
     */
    check() {
        const errors = [];
        this._checkPosis().forEach(error => errors.push(error));
        this._checkVerts().forEach(error => errors.push(error));
        this._checkEdges().forEach(error => errors.push(error));
        this._checkWires().forEach(error => errors.push(error));
        this._checkFaces().forEach(error => errors.push(error));
        this._checkPoints().forEach(error => errors.push(error));
        this._checkPlines().forEach(error => errors.push(error));
        this._checkPgons().forEach(error => errors.push(error));
        this._checkEdgeOrder().forEach(error => errors.push(error));
        return errors;
    }
    /**
     * Checks geometry for internal consistency
     */
    _checkPosis() {
        const errors = [];
        this._geom_maps.up_posis_verts.forEach((verts_i, posi_i) => {
            // up
            if (verts_i === null) {
                errors.push('Posi ' + posi_i + ': null.');
                return;
            }
            // down
            for (const vert_i of verts_i) {
                const vert = this._geom_maps.dn_verts_posis.get(vert_i);
                if (vert === undefined) {
                    errors.push('Posi ' + posi_i + ': Vert->Posi undefined.');
                }
                if (vert === null) {
                    errors.push('Posi ' + posi_i + ': Vert->Posi null.');
                }
            }
        });
        return errors;
    }
    _checkVerts() {
        const errors = [];
        this._geom_maps.dn_verts_posis.forEach((vert, vert_i) => {
            // check the vert itself
            if (vert === null) {
                errors.push('Vert ' + vert_i + ': null.');
                return;
            } // deleted
            // check the position
            const posi_i = vert;
            // check that the position points up to this vertex
            const verts_i = this._geom_maps.up_posis_verts.get(posi_i);
            if (verts_i.indexOf(vert_i) === -1) {
                errors.push('Vert ' + vert_i + ': Posi->Vert index is missing.');
            }
            // check if the parent is a popint or edge
            const point_i = this._geom_maps.up_verts_points.get(vert_i);
            const edges_i = this._geom_maps.up_verts_edges.get(vert_i);
            if (point_i !== undefined && edges_i !== undefined) {
                errors.push('Vert ' + vert_i + ': Both Vert->Edge and Vert->Point.');
            }
            if (point_i !== undefined) {
                // up for points
                if (point_i === undefined) {
                    errors.push('Vert ' + vert_i + ': Vert->Point undefined.');
                    return;
                }
                if (point_i === null) {
                    errors.push('Vert ' + vert_i + ': Vert->Point null.');
                    return;
                }
                // down for points
                const point = this._geom_maps.dn_points_verts.get(point_i);
                if (point === undefined) {
                    errors.push('Vert ' + vert_i + ': Point->Vert undefined.');
                }
                if (point === null) {
                    errors.push('Vert ' + vert_i + ': Point->Vert null.');
                }
                // check this point points to this vertex
                if (point !== vert_i) {
                    errors.push('Vert ' + vert_i + ': Point->Vert index is incorrect.');
                }
            }
            else if (edges_i !== undefined) {
                // up for edges
                if (edges_i === undefined) {
                    errors.push('Vert ' + vert_i + ': Vert->Edge undefined.');
                    return;
                }
                if (edges_i === null) {
                    errors.push('Vert ' + vert_i + ': Vert->Edge null.');
                    return;
                }
                if (edges_i.length > 2) {
                    errors.push('Vert ' + vert_i + ': Vert->Edge has more than two edges.');
                }
                for (const edge_i of edges_i) {
                    if (edge_i === undefined) {
                        errors.push('Vert ' + vert_i + ': Vert->Edge undefined.');
                    }
                    if (edge_i === null) {
                        errors.push('Vert ' + vert_i + ': Vert->Edge null.');
                    }
                    // down for edges
                    const edge = this._geom_maps.dn_edges_verts.get(edge_i);
                    if (edge === undefined) {
                        errors.push('Vert ' + vert_i + ': Edge->Vert undefined.');
                    }
                    else if (edge === null) {
                        errors.push('Vert ' + vert_i + ': Edge->Vert null.');
                    }
                    else {
                        // check the egde points down to this vertex
                        if (edge.indexOf(vert_i) === -1) {
                            errors.push('Vert ' + vert_i + ': Edge->Vert index is missing.');
                        }
                    }
                }
            }
            else {
                errors.push('Vert ' + vert_i + ': Both Vert->Edge and Vert->Point undefined.');
            }
        });
        return errors;
    }
    _checkEdges() {
        const errors = [];
        this._geom_maps.dn_edges_verts.forEach((edge, edge_i) => {
            // check the edge itself
            if (edge === null) {
                errors.push('Edge ' + edge_i + ': null.');
                return;
            }
            if (edge.length > 2) {
                errors.push('Edge ' + edge_i + ': Edge has more than two vertices.');
            }
            // down from edge to vertices
            const verts_i = edge;
            for (const vert_i of verts_i) {
                // check the vertex
                if (vert_i === undefined) {
                    errors.push('Edge ' + edge_i + ': Edge->Vert undefined.');
                }
                else if (vert_i === null) {
                    errors.push('Edge ' + edge_i + ': Edge->Vert null.');
                }
                else {
                    // check the vert points up to this edge
                    const vert_edges_i = this._geom_maps.up_verts_edges.get(vert_i);
                    if (vert_edges_i.indexOf(edge_i) === -1) {
                        errors.push('Edge ' + edge_i + ': Vert->Edge index is missing.');
                    }
                }
            }
            // up from edge to wire
            const wire_i = this._geom_maps.up_edges_wires.get(edge_i);
            if (wire_i === undefined) {
                return;
            } // no wire, must be a point
            if (wire_i === null) {
                errors.push('Edge ' + edge_i + ': Edge->Wire null.');
            }
            // check the wire
            const wire = this._geom_maps.dn_wires_edges.get(wire_i);
            if (wire === undefined) {
                errors.push('Edge ' + edge_i + ': Wire->Edge undefined.');
            }
            else if (wire === null) {
                errors.push('Edge ' + edge_i + ': Wire->Edge null.');
            }
            else {
                // check the wire points down to this edge
                if (wire.indexOf(edge_i) === -1) {
                    errors.push('Edge ' + edge_i + ': Wire->Edge index is missing.');
                }
            }
        });
        return errors;
    }
    _checkWires() {
        const errors = [];
        this._geom_maps.dn_wires_edges.forEach((wire, wire_i) => {
            // check the wire itself
            if (wire === null) {
                errors.push('Wire ' + wire_i + ': null.');
                return;
            } // deleted
            // down from wire to edges
            const edges_i = wire;
            for (const edge_i of edges_i) {
                // check the edge
                if (edge_i === undefined) {
                    errors.push('Wire ' + wire_i + ': Wire->Edge undefined.');
                }
                else if (edge_i === null) {
                    errors.push('Wire ' + wire_i + ': Wire->Edge null.');
                }
                else {
                    // check the edge points up to this wire
                    const edge_wire_i = this._geom_maps.up_edges_wires.get(edge_i);
                    if (edge_wire_i !== wire_i) {
                        errors.push('Wire ' + wire_i + ': Edge->Wire index is incorrect.');
                    }
                }
            }
            // up from wire to face or pline
            const face_i = this._geom_maps.up_wires_faces.get(wire_i);
            const pline_i = this._geom_maps.up_wires_plines.get(wire_i);
            if (face_i !== undefined && pline_i !== undefined) {
                // errors.push('Wire ' + wire_i + ': Both Wire->Face and Wire->Pline.');
            }
            if (face_i !== undefined) {
                if (face_i === null) {
                    errors.push('Wire ' + wire_i + ': Wire->Face null.');
                }
                // down from face to wires (and tris)
                const face = this._geom_maps.dn_faces_wires.get(face_i);
                if (face === undefined) {
                    errors.push('Wire ' + wire_i + ': Face->Wire undefined.');
                }
                else if (face === null) {
                    errors.push('Wire ' + wire_i + ': Face->Wire null.');
                }
                else {
                    // check that this face points down to the wire
                    if (face.indexOf(wire_i) === -1) {
                        errors.push('Wire ' + wire_i + ': Face->Wire index is missing.');
                    }
                }
            }
            else if (pline_i !== undefined) {
                if (pline_i === null) {
                    errors.push('Wire ' + wire_i + ': Wire->Pline null.');
                }
                // down from pline to wire
                const pline = this._geom_maps.dn_plines_wires.get(pline_i);
                if (pline === undefined) {
                    errors.push('Wire ' + wire_i + ': Pline->Wire undefined.');
                }
                else if (pline === null) {
                    errors.push('Wire ' + wire_i + ': Pline->Wire null.');
                }
                else {
                    // check that this pline points down to the wire
                    if (pline !== wire_i) {
                        errors.push('Wire ' + wire_i + ': Pline->Wire index is incorrect.');
                    }
                }
            }
            else {
                errors.push('Wire ' + wire_i + ': Both Wire->Face and Wire->Pline undefined.');
            }
        });
        return errors;
    }
    _checkFaces() {
        const errors = [];
        this._geom_maps.dn_faces_wires.forEach((face, face_i) => {
            // check this face itself
            if (face === null) {
                errors.push('Face ' + face_i + ': null.');
                return;
            } // deleted
            // down from face to wires
            const wires_i = face;
            for (const wire_i of wires_i) {
                // check the wire
                if (wire_i === undefined) {
                    errors.push('Face ' + face_i + ': Face->Wire undefined.');
                }
                else if (wire_i === null) {
                    errors.push('Face ' + face_i + ': Face->Wire null.');
                }
                else {
                    // check the wire points up to this face
                    const wire_face_i = this._geom_maps.up_wires_faces.get(wire_i);
                    if (wire_face_i !== face_i) {
                        errors.push('Face ' + face_i + ': Wire->Face index is incorrect.');
                    }
                }
            }
            // up from face to pgon
            const pgon_i = this._geom_maps.up_faces_pgons.get(face_i);
            if (pgon_i === undefined) {
                errors.push('Face ' + face_i + ': Face->Pgon undefined.');
            }
            else if (pgon_i === null) {
                errors.push('Face ' + face_i + ': Face->Pgon null.');
            }
            // down from pgon to face
            const pgon = this._geom_maps.dn_pgons_faces.get(pgon_i);
            if (pgon === undefined) {
                errors.push('Face ' + face_i + ': Pgon->Face undefined.');
            }
            else if (pgon === null) {
                errors.push('Face ' + face_i + ': Pgon->Face null.');
            }
            else {
                // check that this pgon points down to this face
                if (pgon !== face_i) {
                    errors.push('Face ' + face_i + ': Pgon->Face index is incorrect.');
                }
            }
        });
        this._geom_maps.dn_faces_tris.forEach((facetris, face_i) => {
            // check this face itself
            if (facetris === null) {
                errors.push('Face ' + face_i + ': null.');
                return;
            } // deleted
            // down from face to triangles
            const tris_i = facetris;
            for (const tri_i of tris_i) {
                // check the wire
                if (tri_i === undefined) {
                    errors.push('Face ' + face_i + ': Face->Tri undefined.');
                }
                else if (tri_i === null) {
                    errors.push('Face ' + face_i + ': Face->Tri null.');
                }
                else {
                    // check the tri points up to this face
                    const tri_face_i = this._geom_maps.up_tris_faces.get(tri_i);
                    if (tri_face_i !== face_i) {
                        errors.push('Face ' + face_i + ': Tri->Face index is incorrect.');
                    }
                }
            }
        });
        return errors;
    }
    _checkPoints() {
        const errors = [];
        this._geom_maps.dn_points_verts.forEach((point, point_i) => {
            // check the point itself
            if (point === null) {
                errors.push('Point ' + point_i + ': null.');
                return;
            } // deleted
            // down from point to vertex
            const vert_i = point;
            // check that the vertex points up to this point
            const vertex_point_i = this._geom_maps.up_verts_points.get(vert_i);
            if (vertex_point_i !== point_i) {
                errors.push('Point ' + point_i + ': Vertex->Point index is incorrect.');
            }
            // up from point to coll
            const colls_i = this._geom_maps.up_points_colls.get(point_i);
            if (colls_i === undefined) {
                return;
            } // not in coll
            for (const coll_i of colls_i) {
                if (coll_i === undefined) {
                    errors.push('Point ' + point_i + ': Point->Coll undefined.');
                }
                if (coll_i === null) {
                    errors.push('Point ' + point_i + ': Point->Coll null.');
                }
                // down from coll to points
                const coll = this._geom_maps.dn_colls_objs.get(coll_i);
                if (coll === undefined) {
                    errors.push('Point ' + point_i + ': Coll->Objs undefined.');
                }
                if (coll === null) {
                    errors.push('Point ' + point_i + ': Coll->Objs null.');
                }
                if (coll[1].indexOf(point_i) === -1) {
                    errors.push('Point ' + point_i + ': Coll->Point missing.');
                }
            }
        });
        return errors;
    }
    _checkPlines() {
        const errors = [];
        this._geom_maps.dn_plines_wires.forEach((pline, pline_i) => {
            // check the pline itself
            if (pline === null) {
                errors.push('Pline ' + pline_i + ': null.');
                return;
            } // deleted
            // down from pline to wire
            const wire_i = pline;
            // check that the wire points up to this pline
            const wire_pline_i = this._geom_maps.up_wires_plines.get(wire_i);
            if (wire_pline_i !== pline_i) {
                errors.push('Pline ' + pline_i + ': Wire->Pline index is incorrect.');
            }
            // up from pline to coll
            const colls_i = this._geom_maps.up_plines_colls.get(pline_i);
            if (colls_i === undefined) {
                return;
            } // not in coll
            for (const coll_i of colls_i) {
                if (coll_i === undefined) {
                    errors.push('Pline ' + pline_i + ': Pline->Coll undefined.');
                }
                if (coll_i === null) {
                    errors.push('Pline ' + pline_i + ': Pline->Coll null.');
                }
                // down from coll to plines
                const coll = this._geom_maps.dn_colls_objs.get(coll_i);
                if (coll === undefined) {
                    errors.push('Pline ' + pline_i + ': Coll->Objs undefined.');
                }
                if (coll === null) {
                    errors.push('Pline ' + pline_i + ': Coll->Objs null.');
                }
                if (coll[2].indexOf(pline_i) === -1) {
                    errors.push('Pline ' + pline_i + ': Coll->Pline missing.');
                }
            }
        });
        return errors;
    }
    _checkPgons() {
        const errors = [];
        this._geom_maps.dn_pgons_faces.forEach((pgon, pgon_i) => {
            // check the pgon itself
            if (pgon === undefined) {
                return;
            }
            if (pgon === null) {
                errors.push('Pgon ' + pgon_i + ': null.');
                return;
            } // deleted
            // down from pgon to face
            const face_i = pgon;
            // check that the face points up to this pgon
            const face_pgon_i = this._geom_maps.up_faces_pgons.get(face_i);
            if (face_pgon_i !== pgon_i) {
                errors.push('Pgon ' + pgon_i + ': Face->Pgon index is incorrect.');
            }
            // up from pgon to coll
            const colls_i = this._geom_maps.up_pgons_colls.get(pgon_i);
            if (colls_i === undefined) {
                return;
            } // not in coll
            for (const coll_i of colls_i) {
                if (coll_i === undefined) {
                    errors.push('Pgon ' + pgon_i + ': Pgon->Coll undefined.');
                }
                if (coll_i === null) {
                    errors.push('Pgon ' + pgon_i + ': Pgon->Coll null.');
                }
                // down from coll to pgons
                const coll = this._geom_maps.dn_colls_objs.get(coll_i);
                if (coll === undefined) {
                    errors.push('Pgon ' + pgon_i + ': Coll->Objs undefined.');
                }
                if (coll === null) {
                    errors.push('Pgon ' + pgon_i + ': Coll->Objs null.');
                }
                if (coll[3].indexOf(pgon_i) === -1) {
                    errors.push('Pgon ' + pgon_i + ': Coll->Pgon missing.');
                }
            }
        });
        return errors;
    }
    _checkEdgeOrder() {
        const errors = [];
        this._geom_maps.dn_wires_edges.forEach((wire, wire_i) => {
            // down
            if (wire === null) {
                errors.push('Wire ' + wire_i + ': null.');
                return;
            }
            // check if this is closed or open
            const first_edge = this._geom_maps.dn_edges_verts.get(wire[0]);
            const first_vert_i = first_edge[0];
            const last_edge = this._geom_maps.dn_edges_verts.get(wire[wire.length - 1]);
            const last_vert_i = last_edge[1];
            const is_closed = (first_vert_i === last_vert_i);
            if (!is_closed) {
                if (this._geom_maps.up_verts_edges.get(first_edge[0]).length !== 1) {
                    errors.push('Open wire ' + wire_i + ': First vertex does not have one edge.');
                }
                if (this._geom_maps.up_verts_edges.get(last_edge[1]).length !== 1) {
                    errors.push('Open wire ' + wire_i + ': Last vertex does not have one edge.');
                }
            }
            // console.log("==== ==== ====")
            // console.log("WIRE i", wire_i, "WIRE", wire)
            // check the edges of each vertex
            for (const edge_i of wire) {
                const edge = this._geom_maps.dn_edges_verts.get(edge_i);
                const start_vert_i = edge[0];
                const end_vert_i = edge[1];
                // console.log("====")
                // console.log("EDGE i", edge_i, "EDGE", edge)
                // console.log("VERT START", start_vert_i)
                // console.log("VERT END", end_vert_i)
                let exp_num_edges_vert0 = 2;
                let exp_num_edges_vert1 = 2;
                let start_idx = 1;
                let end_idx = 0;
                if (!is_closed) {
                    if (edge_i === wire[0]) { // first edge
                        exp_num_edges_vert0 = 1;
                        start_idx = 0;
                    }
                    if (edge_i === wire[wire.length - 1]) { // last edge
                        exp_num_edges_vert1 = 1;
                        end_idx = 0;
                    }
                }
                // check the start vertex
                const start_vert_edges_i = this._geom_maps.up_verts_edges.get(start_vert_i);
                // console.log("START VERT EDGES", start_vert_edges_i)
                if (start_vert_edges_i.length !== exp_num_edges_vert0) {
                    errors.push('Wire ' + wire_i + ' Edge ' + edge_i + ' Vert ' + start_vert_i +
                        ': Start vertex does not have correct number of edges.');
                }
                if (start_vert_edges_i[start_idx] !== edge_i) {
                    errors.push('Wire ' + wire_i + ' Edge ' + edge_i + ' Vert ' + start_vert_i +
                        ': Vertex edges are in the wrong order.');
                }
                // check the end vertex
                const end_vert_edges_i = this._geom_maps.up_verts_edges.get(end_vert_i);
                // console.log("END VERT EDGES", end_vert_edges_i)
                if (end_vert_edges_i.length !== exp_num_edges_vert1) {
                    errors.push('Wire ' + wire_i + ' Edge ' + edge_i + ' Vert ' + start_vert_i +
                        ': End vertex does not have correct number of edges.');
                }
                if (end_vert_edges_i[end_idx] !== edge_i) {
                    errors.push('Wire ' + wire_i + ' Edge ' + edge_i + ' Vert ' + end_vert_i +
                        ': Vertex edges are in the wrong order.');
                }
            }
        });
        return errors;
    }
}


/***/ }),

/***/ "./src/assets/libs/geo-info/GIGeomDel.ts":
/*!***********************************************!*\
  !*** ./src/assets/libs/geo-info/GIGeomDel.ts ***!
  \***********************************************/
/*! exports provided: GIGeomDel */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GIGeomDel", function() { return GIGeomDel; });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common */ "./src/assets/libs/geo-info/common.ts");
/* harmony import */ var _util_arrs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/arrs */ "./src/assets/libs/util/arrs.ts");
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};


/**
 * Class for deleting geometry.
 */
class GIGeomDel {
    /**
     * Constructor
     */
    constructor(geom, geom_arrays) {
        this._geom = geom;
        this._geom_maps = geom_arrays;
    }
    // ============================================================================
    // Delete geometry
    // ============================================================================
    /**
     * Delete ents
     * @param ent_sets
     */
    del(ent_sets) {
        // delete the ents
        this.delColls(Array.from(ent_sets.colls_i), true);
        this.delPgons(Array.from(ent_sets.pgons_i), true);
        this.delPlines(Array.from(ent_sets.plines_i), true);
        this.delPoints(Array.from(ent_sets.points_i), true);
        this.delPosis(Array.from(ent_sets.posis_i));
        this.delUnusedPosis(Array.from(ent_sets.obj_posis_i));
    }
    /**
     * Del all unused posis in the model.
     * Posi attributes will also be deleted.
     * @param posis_i
     */
    delUnusedPosis(posis_i) {
        // create array
        posis_i = (Array.isArray(posis_i)) ? posis_i : [posis_i];
        if (posis_i.length === 0) {
            return;
        }
        // loop
        const deleted_posis_i = [];
        for (const posi_i of posis_i) {
            if (!this._geom_maps.up_posis_verts.has(posi_i)) {
                continue;
            } // already deleted
            // update up arrays
            const verts_i = this._geom_maps.up_posis_verts.get(posi_i);
            if (verts_i.length === 0) { // only delete posis with no verts
                this._geom_maps.up_posis_verts.delete(posi_i);
                this._geom_maps.posis_ts.delete(posi_i);
                deleted_posis_i.push(posi_i);
            }
            // no need to update down arrays
            // del time stamp
            this._geom.time_stamp.delEntTs(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POSI, posi_i);
        }
        // delete all the posi attributes, for all posis that were deleted
        this._geom.modeldata.attribs.add.delEntFromAttribs(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POSI, deleted_posis_i);
    }
    /**
     * Del posis.
     * Posi attributes will also be deleted.
     * @param posis_i
     */
    delPosis(posis_i) {
        // create array
        posis_i = (Array.isArray(posis_i)) ? posis_i : [posis_i];
        if (posis_i.length === 0) {
            return;
        }
        // loop
        const deleted_posis_i = [];
        for (const posi_i of posis_i) {
            if (!this._geom_maps.up_posis_verts.has(posi_i)) {
                continue;
            } // already deleted
            // delete all verts for this posi
            const copy_verts_i = this._geom_maps.up_posis_verts.get(posi_i).slice(); // make a copy
            copy_verts_i.forEach(vert_i => this._geom.del_vert.delVert(vert_i));
            // delete the posi
            this._geom_maps.up_posis_verts.delete(posi_i);
            this._geom_maps.posis_ts.delete(posi_i);
            deleted_posis_i.push(posi_i);
            // no need to update down arrays
            // del time stamp
            this._geom.time_stamp.delEntTs(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POSI, posi_i);
        }
        // delete all the posi attributes, for all posis that were deleted
        this._geom.modeldata.attribs.add.delEntFromAttribs(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POSI, deleted_posis_i);
    }
    /**
     * Del points.
     * Point attributes will also be deleted.
     * @param points_i
     */
    delPoints(points_i, del_unused_posis) {
        // create array
        points_i = (Array.isArray(points_i)) ? points_i : [points_i];
        if (!points_i.length) {
            return;
        }
        // del attribs
        this._geom.modeldata.attribs.add.delEntFromAttribs(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POINT, points_i);
        // loop
        for (const point_i of points_i) {
            // first get all the arrays so we dont break navigation
            const vert_i = this._geom_maps.dn_points_verts.get(point_i);
            if (vert_i === undefined) {
                continue;
            } // already deleted
            const posi_i = this._geom_maps.dn_verts_posis.get(vert_i);
            // delete the point and check collections
            this._geom_maps.dn_points_verts.delete(point_i);
            this._geom_maps.dn_points_verts.delete(point_i);
            this._geom_maps.dn_colls_objs.forEach(coll => {
                const coll_points_i = coll[1];
                Object(_util_arrs__WEBPACK_IMPORTED_MODULE_1__["arrRem"])(coll_points_i, point_i);
            });
            // delete the vert by setting the up and down arrays to undefined
            this._geom_maps.dn_verts_posis.delete(vert_i);
            this._geom_maps.up_verts_points.delete(vert_i);
            // remove the vert from up_posis_verts
            const posi_verts_i = this._geom_maps.up_posis_verts.get(posi_i);
            Object(_util_arrs__WEBPACK_IMPORTED_MODULE_1__["arrRem"])(posi_verts_i, vert_i);
            // delete unused posis
            if (del_unused_posis) {
                this.delUnusedPosis(posi_i);
            }
            // del time stamp
            this._geom.time_stamp.delEntTs(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POINT, point_i);
        }
    }
    /**
     * Del plines.
     * Pline attributes will also be deleted.
     * @param plines_i
     */
    delPlines(plines_i, del_unused_posis) {
        // del attribs
        this._geom.modeldata.attribs.add.delEntFromAttribs(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PLINE, plines_i);
        // create array
        plines_i = (Array.isArray(plines_i)) ? plines_i : [plines_i];
        if (!plines_i.length) {
            return;
        }
        // loop
        for (const pline_i of plines_i) {
            // first get all the arrays so we dont break navigation
            const wire_i = this._geom_maps.dn_plines_wires.get(pline_i);
            if (wire_i === undefined) {
                continue;
            } // already deleted
            const edges_i = this._geom.nav.navAnyToEdge(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PLINE, pline_i);
            const verts_i = this._geom.nav.navAnyToVert(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PLINE, pline_i);
            const posis_i = this._geom.nav.navAnyToPosi(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PLINE, pline_i);
            // delete the pline and check collections
            this._geom_maps.dn_plines_wires.delete(pline_i);
            this._geom_maps.up_plines_colls.delete(pline_i);
            this._geom_maps.dn_colls_objs.forEach(coll => {
                const coll_plines_i = coll[2];
                Object(_util_arrs__WEBPACK_IMPORTED_MODULE_1__["arrRem"])(coll_plines_i, pline_i);
            });
            // delete the wire
            this._geom_maps.dn_wires_edges.delete(wire_i);
            this._geom_maps.up_wires_plines.delete(wire_i);
            // delete the edges
            edges_i.forEach(edge_i => {
                this._geom_maps.dn_edges_verts.delete(edge_i);
                this._geom_maps.up_edges_wires.delete(edge_i);
            });
            // delete the verts
            verts_i.forEach(vert_i => {
                this._geom_maps.dn_verts_posis.delete(vert_i);
                this._geom_maps.up_verts_edges.delete(vert_i);
            });
            // remove the verts from up_posis_verts
            for (const posi_i of posis_i) {
                const posi_verts_i = this._geom_maps.up_posis_verts.get(posi_i);
                // loop through deleted verts
                for (const vert_i of verts_i) {
                    Object(_util_arrs__WEBPACK_IMPORTED_MODULE_1__["arrRem"])(posi_verts_i, vert_i);
                    if (posi_verts_i.length === 0) {
                        break;
                    }
                }
            }
            // delete unused posis
            if (del_unused_posis) {
                this.delUnusedPosis(posis_i);
            }
            // del time stamp
            this._geom.time_stamp.delEntTs(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PLINE, pline_i);
        }
    }
    /**
     * Del pgons.
     * Pgon attributes will also be deleted.
     * @param pgons_i
     */
    delPgons(pgons_i, del_unused_posis) {
        // del attribs
        this._geom.modeldata.attribs.add.delEntFromAttribs(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PGON, pgons_i);
        // create array
        pgons_i = (Array.isArray(pgons_i)) ? pgons_i : [pgons_i];
        if (!pgons_i.length) {
            return;
        }
        // loop
        for (const pgon_i of pgons_i) {
            // first get all the arrays so we dont break navigation
            const face_i = this._geom_maps.dn_pgons_faces.get(pgon_i);
            if (face_i === undefined) {
                continue;
            } // already deleted
            const wires_i = this._geom.nav.navAnyToWire(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PGON, pgon_i);
            const edges_i = this._geom.nav.navAnyToEdge(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PGON, pgon_i);
            const verts_i = this._geom.nav.navAnyToVert(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PGON, pgon_i);
            const tris_i = this._geom.nav.navAnyToTri(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PGON, pgon_i);
            const posis_i = this._geom.nav.navAnyToPosi(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PGON, pgon_i);
            // delete the pgon and check the collections
            this._geom_maps.dn_pgons_faces.delete(pgon_i);
            this._geom_maps.up_pgons_colls.delete(pgon_i);
            this._geom_maps.dn_colls_objs.forEach(coll => {
                const coll_pgons_i = coll[3];
                Object(_util_arrs__WEBPACK_IMPORTED_MODULE_1__["arrRem"])(coll_pgons_i, pgon_i);
            });
            // delete the face
            this._geom_maps.dn_faces_wires.delete(face_i);
            this._geom_maps.dn_faces_tris.delete(face_i);
            this._geom_maps.up_faces_pgons.delete(face_i);
            // delete the wires
            wires_i.forEach(wire_i => {
                this._geom_maps.dn_wires_edges.delete(wire_i);
                this._geom_maps.up_wires_faces.delete(wire_i);
            });
            // delete the edges
            edges_i.forEach(edge_i => {
                this._geom_maps.dn_edges_verts.delete(edge_i);
                this._geom_maps.up_edges_wires.delete(edge_i);
            });
            // delete the verts
            verts_i.forEach(vert_i => {
                this._geom_maps.dn_verts_posis.delete(vert_i);
                this._geom_maps.up_verts_edges.delete(vert_i);
                this._geom_maps.up_verts_tris.delete(vert_i);
            });
            // delete the tris
            tris_i.forEach(tri_i => {
                this._geom_maps.dn_tris_verts.delete(tri_i);
                this._geom_maps.up_tris_faces.delete(tri_i);
            });
            // clean up, posis up arrays point to verts that may have been deleted
            for (const posi_i of posis_i) {
                const posi_verts_i = this._geom_maps.up_posis_verts.get(posi_i);
                // loop through deleted verts
                for (const vert_i of verts_i) {
                    Object(_util_arrs__WEBPACK_IMPORTED_MODULE_1__["arrRem"])(posi_verts_i, vert_i);
                    if (posi_verts_i.length === 0) {
                        break;
                    }
                }
            }
            // delete unused posis
            if (del_unused_posis) {
                this.delUnusedPosis(posis_i);
            }
            // del time stamp
            this._geom.time_stamp.delEntTs(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PGON, pgon_i);
        }
    }
    /**
     * Delete a collection.
     * Collection attributes will also be deleted.
     * This does not delete any of the object in the collection.
     * Also, does not delete any positions.
     * @param colls_i The collections to delete
     */
    delColls(colls_i, del_unused_posis) {
        // del attribs
        this._geom.modeldata.attribs.add.delEntFromAttribs(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].COLL, colls_i);
        // create array
        colls_i = (Array.isArray(colls_i)) ? colls_i : [colls_i];
        if (!colls_i.length) {
            return;
        }
        // loop
        for (const coll_i of colls_i) {
            const coll = this._geom_maps.dn_colls_objs.get(coll_i);
            if (coll === undefined) {
                continue;
            } // already deleted
            // up arrays, delete points, plines, pgons
            const points_i = coll[1];
            points_i.forEach(point_i => {
                const other_colls_i = this._geom_maps.up_points_colls.get(point_i);
                Object(_util_arrs__WEBPACK_IMPORTED_MODULE_1__["arrRem"])(other_colls_i, coll_i);
                if (other_colls_i.length === 0) {
                    this._geom_maps.up_points_colls.delete(point_i);
                }
            });
            const plines_i = coll[2];
            plines_i.forEach(pline_i => {
                const other_colls_i = this._geom_maps.up_plines_colls.get(pline_i);
                Object(_util_arrs__WEBPACK_IMPORTED_MODULE_1__["arrRem"])(other_colls_i, coll_i);
                if (other_colls_i.length === 0) {
                    this._geom_maps.up_plines_colls.delete(pline_i);
                }
            });
            const pgons_i = coll[3];
            pgons_i.forEach(pgon_i => {
                const other_colls_i = this._geom_maps.up_pgons_colls.get(pgon_i);
                Object(_util_arrs__WEBPACK_IMPORTED_MODULE_1__["arrRem"])(other_colls_i, coll_i);
                if (other_colls_i.length === 0) {
                    this._geom_maps.up_pgons_colls.delete(pgon_i);
                }
            });
            // down arrays
            this._geom_maps.dn_colls_objs.delete(coll_i);
            // del time stamp
            this._geom.time_stamp.delEntTs(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].COLL, coll_i);
        }
        // check parents
        const set_colls_i = new Set(colls_i);
        this._geom_maps.dn_colls_objs.forEach((coll, coll_i) => {
            if (set_colls_i.has(coll[0])) {
                coll[0] = -1;
                // update time stamp
                this._geom.time_stamp.updateEntTs(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].COLL, coll_i);
            }
        });
    }
}


/***/ }),

/***/ "./src/assets/libs/geo-info/GIGeomDelEdge.ts":
/*!***************************************************!*\
  !*** ./src/assets/libs/geo-info/GIGeomDelEdge.ts ***!
  \***************************************************/
/*! exports provided: GIGeomDelEdge */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GIGeomDelEdge", function() { return GIGeomDelEdge; });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common */ "./src/assets/libs/geo-info/common.ts");
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};

/**
 * Class for deleting geometry.
 */
class GIGeomDelEdge {
    /**
     * Constructor
     */
    constructor(geom, geom_arrays) {
        this._geom = geom;
        this._geom_maps = geom_arrays;
    }
    /**
     * Delete edges.
     * ~
     * If heal=true, the gap where teh edge was get healed
     *
     */
    delEdges(edges_i, del_unused_posis, heal) {
        // del attribs
        this._geom.modeldata.attribs.add.delEntFromAttribs(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].EDGE, edges_i);
        // create array
        edges_i = (Array.isArray(edges_i)) ? edges_i : [edges_i];
        if (!edges_i.length) {
            return;
        }
        // loop
        for (const edge_i of edges_i) {
            if (!this._geom.query.entExists(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].EDGE, edge_i)) {
                continue;
            } // already deleted
            // first get all the arrays so we dont break navigation
            const wire_i = this._geom.nav.navEdgeToWire(edge_i);
            const face_i = this._geom.nav.navWireToFace(wire_i); // may be undefined
            const verts_i = this._geom.nav.navEdgeToVert(edge_i);
            const posi0_i = this._geom.nav.navVertToPosi(verts_i[0]);
            const posi1_i = this._geom.nav.navVertToPosi(verts_i[1]);
            // getthe type of wire
            const wire_typ = this._geom.query.getWireType(wire_i);
            // TODO
            throw new Error('Not implemented.');
        }
    }
}


/***/ }),

/***/ "./src/assets/libs/geo-info/GIGeomDelVert.ts":
/*!***************************************************!*\
  !*** ./src/assets/libs/geo-info/GIGeomDelVert.ts ***!
  \***************************************************/
/*! exports provided: GIGeomDelVert */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GIGeomDelVert", function() { return GIGeomDelVert; });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common */ "./src/assets/libs/geo-info/common.ts");
/* harmony import */ var _util_arrs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/arrs */ "./src/assets/libs/util/arrs.ts");
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};


/**
 * Class for deleting geometry.
 */
class GIGeomDelVert {
    /**
     * Constructor
     */
    constructor(geom, geom_arrays) {
        this._geom = geom;
        this._geom_maps = geom_arrays;
    }
    /**
     * Deletes a vert.
     *
     * In the general case, the two edges adjacent to the deleted vert will be merged.
     * This means that the next edge will be deleted.
     * The end vert of the previous edge will connect to the end posi of the next edge.
     *
     * The first special case is if the vert is for a point. In that case, just delete the point.
     *
     * Then there are two special cases for whicj we delete the whole object
     *
     * 1) If the wire is open and has only 1 edge, then delete the wire
     * 2) if the wire is closed pgon and has only 3 edges, then:
     *    a) If the wire is the boundary of the pgon, then delete the whole pgon
     *    b) If the wire is a hole in the pgon, then delete the hole
     *
     * Assuming the special cases above do not apply,
     * then there are two more special cases for open wires
     *
     * 1) If the vert is at the start of an open wire, then delete the first edge
     * 2) If teh vert is at the end of an open wire, then delete the last edge
     *
     * Finally, we come to the standard case.
     * The next edge is deleted, and the prev edge gets rewired.
     *
     * @param vert_i
     */
    delVert(vert_i) {
        // check, has it already been deleted
        if (!this._geom_maps.dn_verts_posis.has(vert_i)) {
            return;
        }
        // check, is this a point, then delete the point and vertex
        const point_i = this._geom_maps.up_verts_points.get(vert_i); // this may be undefined
        if (point_i !== undefined) {
            this._geom.del.delPoints(point_i, false);
            return;
        }
        // get the posis, edges, and wires, and other info
        const edges_i = this._geom_maps.up_verts_edges.get(vert_i);
        const wire_i = this._geom_maps.up_edges_wires.get(edges_i[0]);
        const face_i = this._geom_maps.up_wires_faces.get(wire_i); // this may be undefined
        const wire_edges_i = this._geom_maps.dn_wires_edges.get(wire_i);
        const wire_verts_i = this._geom.nav.navAnyToVert(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].WIRE, wire_i);
        const wire_is_closed = this._geom.query.isWireClosed(wire_i);
        const index_vert_i = wire_verts_i.indexOf(vert_i);
        const num_verts = wire_verts_i.length;
        // update the edges and wires
        if (!wire_is_closed && num_verts === 2) {
            // special case, open pline with 2 verts
            this.__delVert__OpenPline1Edge(wire_i);
        }
        else if (face_i !== undefined && num_verts === 3) {
            // special case, pgon with three verts
            const wires_i = this._geom_maps.dn_faces_wires.get(face_i);
            const index_face_wire = wires_i.indexOf(wire_i);
            if (index_face_wire === 0) {
                // special case, pgon boundary with verts, delete the pgon
                this.__delVert__PgonBoundaryWire3Edge(face_i);
            }
            else {
                // special case, pgon hole with verts, delete the hole
                this.__delVert__PgonHoleWire3Edge(face_i, wire_i);
            }
        }
        else if (!wire_is_closed && index_vert_i === 0) {
            // special case, open pline, delete start edge and vert
            this.__delVert__OpenPlineStart(wire_edges_i, wire_verts_i, vert_i);
            // time stamp
            const pline_i = this._geom_maps.up_wires_plines.get(wire_i);
            this._geom.time_stamp.updateObjsTs(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PLINE, pline_i);
        }
        else if (!wire_is_closed && index_vert_i === num_verts - 1) {
            // special case, open pline, delete end edge and vert
            this.__delVert__OpenPlineEnd(wire_edges_i, wire_verts_i, vert_i);
            // time stamp
            const pline_i = this._geom_maps.up_wires_plines.get(wire_i);
            this._geom.time_stamp.updateObjsTs(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PLINE, pline_i);
        }
        else {
            // standard case, delete the prev edge and reqire the next edge
            this.__delVert__StandardCase(wire_edges_i, vert_i);
            if (face_i === undefined) {
                // time stamp
                const pline_i = this._geom_maps.up_wires_plines.get(wire_i);
                this._geom.time_stamp.updateObjsTs(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PLINE, pline_i);
            }
            else {
                // for pgons, also update tris
                const pgon_i = this._geom.nav.navFaceToPgon(face_i);
                this._geom.modify_pgon.triPgons(pgon_i);
                // triPgons() updates the time stamp
            }
        }
    }
    /**
     * Special case, delete the pline
     * @param wire_i
     */
    __delVert__OpenPline1Edge(wire_i) {
        const pline_i = this._geom_maps.up_wires_plines.get(wire_i);
        this._geom.del.delPlines(pline_i, false);
    }
    /**
     * Special case, delete either the pgon
     * @param face_i
     */
    __delVert__PgonBoundaryWire3Edge(face_i) {
        const pgon_i = this._geom_maps.up_faces_pgons.get(face_i);
        this._geom.del.delPgons(pgon_i, false);
    }
    /**
     * Special case, delete either the hole
     * @param vert_i
     */
    __delVert__PgonHoleWire3Edge(face_i, wire_i) {
        // TODO
        console.log('not implemented');
    }
    /**
     * Special case, delete the first edge
     * @param vert_i
     */
    __delVert__OpenPlineStart(wire_edges_i, wire_verts_i, vert_i) {
        const posi_i = this._geom_maps.dn_verts_posis.get(vert_i);
        // vert_i is at the star of an open wire, we have one edge
        const start_edge_i = wire_edges_i[0];
        // delete the first edge
        this._geom_maps.dn_edges_verts.delete(start_edge_i);
        this._geom_maps.up_edges_wires.delete(start_edge_i);
        this._geom.modeldata.attribs.add.delEntFromAttribs(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].EDGE, start_edge_i);
        // update the second vert
        const second_vert_i = wire_verts_i[1];
        Object(_util_arrs__WEBPACK_IMPORTED_MODULE_1__["arrRem"])(this._geom_maps.up_verts_edges.get(second_vert_i), start_edge_i);
        // update the wire
        Object(_util_arrs__WEBPACK_IMPORTED_MODULE_1__["arrRem"])(wire_edges_i, start_edge_i);
        // delete the vert
        this._geom_maps.dn_verts_posis.delete(vert_i);
        this._geom_maps.up_verts_edges.delete(vert_i);
        this._geom.modeldata.attribs.add.delEntFromAttribs(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].VERT, vert_i);
        // update the posis
        Object(_util_arrs__WEBPACK_IMPORTED_MODULE_1__["arrRem"])(this._geom_maps.up_posis_verts.get(posi_i), vert_i);
    }
    /**
     * Special case, delete the last edge
     * @param vert_i
     */
    __delVert__OpenPlineEnd(wire_edges_i, wire_verts_i, vert_i) {
        const posi_i = this._geom_maps.dn_verts_posis.get(vert_i);
        // vert_i is at the end of an open wire, we have one edge
        const end_edge_i = wire_edges_i[wire_edges_i.length - 1];
        // delete the last edge
        this._geom_maps.dn_edges_verts.delete(end_edge_i);
        this._geom_maps.up_edges_wires.delete(end_edge_i);
        this._geom.modeldata.attribs.add.delEntFromAttribs(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].EDGE, end_edge_i);
        // update the one before last vert
        const before_last_vert_i = wire_verts_i[wire_verts_i.length - 2];
        Object(_util_arrs__WEBPACK_IMPORTED_MODULE_1__["arrRem"])(this._geom_maps.up_verts_edges.get(before_last_vert_i), end_edge_i);
        // update the wire
        Object(_util_arrs__WEBPACK_IMPORTED_MODULE_1__["arrRem"])(wire_edges_i, end_edge_i);
        // delete the vert
        this._geom_maps.dn_verts_posis.delete(vert_i);
        this._geom_maps.up_verts_edges.delete(vert_i);
        this._geom.modeldata.attribs.add.delEntFromAttribs(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].VERT, vert_i);
        // update the posis
        Object(_util_arrs__WEBPACK_IMPORTED_MODULE_1__["arrRem"])(this._geom_maps.up_posis_verts.get(posi_i), vert_i);
    }
    /**
     * Final case, delete the next edge, reqire the previous edge
     * For pgons, this does not update the tris
     * @param vert_i
     */
    __delVert__StandardCase(wire_edges_i, vert_i) {
        const posi_i = this._geom_maps.dn_verts_posis.get(vert_i);
        // vert_i is in the middle of a wire, we must have two edges
        const edges_i = this._geom_maps.up_verts_edges.get(vert_i);
        const prev_edge_i = edges_i[0]; // is_first ? edges_i[1] : edges_i[0];
        const next_edge_i = edges_i[1]; // is_first ? edges_i[0] : edges_i[1];
        // get the verts of the two edges
        const prev_edge_verts_i = this._geom_maps.dn_edges_verts.get(prev_edge_i);
        const next_edge_verts_i = this._geom_maps.dn_edges_verts.get(next_edge_i);
        const prev_vert_i = prev_edge_verts_i[0];
        const next_vert_i = next_edge_verts_i[1];
        // console.log(wire_edges_i);
        // console.log(vert_i);
        // console.log(is_first);
        // console.log(edges_i);
        // console.log(prev_edge_i, next_edge_i)
        // console.log(prev_edge_verts_i, next_edge_verts_i)
        // console.log(prev_vert_i, next_vert_i)
        // run some checks
        if (prev_vert_i === vert_i) {
            throw new Error('Unexpected vertex ordering 1');
        }
        if (next_vert_i === vert_i) {
            throw new Error('Unexpected vertex ordering 2');
        }
        if (prev_edge_verts_i[1] !== next_edge_verts_i[0]) {
            throw new Error('Unexpected vertex ordering 3');
        }
        if (prev_edge_verts_i[1] !== vert_i) {
            throw new Error('Unexpected vertex ordering 4');
        }
        // rewire the end vert of the previous edge to the end vert of the next edge
        prev_edge_verts_i[1] = next_vert_i;
        this._geom_maps.up_verts_edges.get(next_vert_i)[0] = prev_edge_i;
        // delete the next edge
        this._geom_maps.dn_edges_verts.delete(next_edge_i);
        this._geom_maps.up_edges_wires.delete(next_edge_i);
        this._geom.modeldata.attribs.add.delEntFromAttribs(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].EDGE, next_edge_i);
        // update the wire
        Object(_util_arrs__WEBPACK_IMPORTED_MODULE_1__["arrRem"])(wire_edges_i, next_edge_i);
        // delete the vert
        this._geom_maps.dn_verts_posis.delete(vert_i);
        this._geom_maps.up_verts_edges.delete(vert_i);
        this._geom.modeldata.attribs.add.delEntFromAttribs(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].VERT, vert_i);
        // update the posis
        Object(_util_arrs__WEBPACK_IMPORTED_MODULE_1__["arrRem"])(this._geom_maps.up_posis_verts.get(posi_i), vert_i);
    }
}


/***/ }),

/***/ "./src/assets/libs/geo-info/GIGeomIO.ts":
/*!**********************************************!*\
  !*** ./src/assets/libs/geo-info/GIGeomIO.ts ***!
  \**********************************************/
/*! exports provided: GIGeomIO */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GIGeomIO", function() { return GIGeomIO; });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common */ "./src/assets/libs/geo-info/common.ts");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _common_func__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./common_func */ "./src/assets/libs/geo-info/common_func.ts");
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};



/**
 * Class for geometry.
 */
class GIGeomIO {
    /**
     * Constructor
     */
    constructor(geom, geom_arrays) {
        this._geom = geom;
        this._geom_maps = geom_arrays;
    }
    /**
     * Adds data to this model from another model.
     * The data is deep copied.
     * The existing data in the model is not deleted.
     * Conflict detection will be performed based on time stamps.
     * @param geom_maps The geom_arrays of the other model.
     */
    merge(other_geom) {
        // Check that we have correct number of time stamps
        if (this._geom_maps.up_posis_verts.size !== this._geom_maps.posis_ts.size) {
            throw new Error('Incorrent number of time stamps for posis.');
        }
        if (this._geom_maps.dn_points_verts.size !== this._geom_maps.points_ts.size) {
            throw new Error('Incorrent number of time stamps for points.');
        }
        if (this._geom_maps.dn_plines_wires.size !== this._geom_maps.plines_ts.size) {
            throw new Error('Incorrent number of time stamps for plines.');
        }
        if (this._geom_maps.dn_pgons_faces.size !== this._geom_maps.pgons_ts.size) {
            throw new Error('Incorrent number of time stamps for pgons.');
        }
        if (this._geom_maps.dn_colls_objs.size !== this._geom_maps.colls_ts.size) {
            throw new Error('Incorrent number of time stamps for colls.');
        }
        //
        const geom_maps = other_geom._geom_maps;
        // ======================================================================
        this._mergePosis(other_geom); // check for conflicts and merge verts
        this._mergeObjCollEnts(other_geom, _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POINT); // check for conflicts
        this._mergeObjCollEnts(other_geom, _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PLINE); // check for conflicts
        this._mergeObjCollEnts(other_geom, _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PGON); // check for conflicts
        this._mergeObjCollEnts(other_geom, _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].COLL); // check for conflicts
        // ======================================================================
        this._mergeEnts(this._geom_maps.dn_verts_posis, geom_maps.dn_verts_posis);
        this._mergeEnts(this._geom_maps.dn_tris_verts, geom_maps.dn_tris_verts);
        this._mergeEnts(this._geom_maps.dn_edges_verts, geom_maps.dn_edges_verts);
        this._mergeEnts(this._geom_maps.dn_wires_edges, geom_maps.dn_wires_edges);
        this._mergeEnts(this._geom_maps.dn_faces_wires, geom_maps.dn_faces_wires);
        this._mergeEnts(this._geom_maps.dn_faces_tris, geom_maps.dn_faces_tris);
        // ======================================================================
        this._mergeEnts(this._geom_maps.up_verts_tris, geom_maps.up_verts_tris);
        this._mergeEnts(this._geom_maps.up_tris_faces, geom_maps.up_tris_faces);
        this._mergeEnts(this._geom_maps.up_verts_edges, geom_maps.up_verts_edges);
        this._mergeEnts(this._geom_maps.up_edges_wires, geom_maps.up_edges_wires);
        this._mergeEnts(this._geom_maps.up_wires_faces, geom_maps.up_wires_faces);
        this._mergeEnts(this._geom_maps.up_verts_points, geom_maps.up_verts_points);
        this._mergeEnts(this._geom_maps.up_wires_plines, geom_maps.up_wires_plines);
        this._mergeEnts(this._geom_maps.up_faces_pgons, geom_maps.up_faces_pgons);
        // ======================================================================
        this._mergeColls(this._geom_maps.up_points_colls, geom_maps.up_points_colls); // merge colls, no check for conflicts
        this._mergeColls(this._geom_maps.up_plines_colls, geom_maps.up_plines_colls); // merge colls, no check for conflicts
        this._mergeColls(this._geom_maps.up_pgons_colls, geom_maps.up_pgons_colls); // merge colls, no check for conflicts
        // ======================================================================
        // time stamp updated in _mergePosis() and _mergeObjCollEnts() methods
    }
    /**
     * Adds data to this model from another model.
     * The data is deep copied.
     * No conflict detection is performed.
     * Typically, this model is assumed to be empty.
     * @param geom_maps The geom_arrays of the other model.
     */
    dump(geom_maps) {
        // Check that we have correct number of time stamps
        if (this._geom_maps.up_posis_verts.size !== this._geom_maps.posis_ts.size) {
            throw new Error('Incorrent number of time stamps for posis.');
        }
        if (this._geom_maps.dn_points_verts.size !== this._geom_maps.points_ts.size) {
            throw new Error('Incorrent number of time stamps for points.');
        }
        if (this._geom_maps.dn_plines_wires.size !== this._geom_maps.plines_ts.size) {
            throw new Error('Incorrent number of time stamps for plines.');
        }
        if (this._geom_maps.dn_pgons_faces.size !== this._geom_maps.pgons_ts.size) {
            throw new Error('Incorrent number of time stamps for pgons.');
        }
        if (this._geom_maps.dn_colls_objs.size !== this._geom_maps.colls_ts.size) {
            throw new Error('Incorrent number of time stamps for colls.');
        }
        //
        this._geom_maps.dn_points_verts = new Map(geom_maps.dn_points_verts);
        this._geom_maps.dn_plines_wires = new Map(geom_maps.dn_plines_wires);
        this._geom_maps.dn_pgons_faces = new Map(geom_maps.dn_pgons_faces);
        this._geom_maps.dn_colls_objs = lodash__WEBPACK_IMPORTED_MODULE_1__["cloneDeep"](geom_maps.dn_colls_objs);
        this._geom_maps.dn_verts_posis = new Map(geom_maps.dn_verts_posis);
        this._geom_maps.dn_tris_verts = Object(_common_func__WEBPACK_IMPORTED_MODULE_2__["cloneDeepMapArr"])(geom_maps.dn_tris_verts);
        this._geom_maps.dn_edges_verts = Object(_common_func__WEBPACK_IMPORTED_MODULE_2__["cloneDeepMapArr"])(geom_maps.dn_edges_verts);
        this._geom_maps.dn_wires_edges = Object(_common_func__WEBPACK_IMPORTED_MODULE_2__["cloneDeepMapArr"])(geom_maps.dn_wires_edges);
        this._geom_maps.dn_faces_wires = Object(_common_func__WEBPACK_IMPORTED_MODULE_2__["cloneDeepMapArr"])(geom_maps.dn_faces_wires);
        this._geom_maps.dn_faces_tris = Object(_common_func__WEBPACK_IMPORTED_MODULE_2__["cloneDeepMapArr"])(geom_maps.dn_faces_tris);
        // ======================================================================
        this._geom_maps.up_posis_verts = Object(_common_func__WEBPACK_IMPORTED_MODULE_2__["cloneDeepMapArr"])(geom_maps.up_posis_verts);
        this._geom_maps.up_verts_tris = Object(_common_func__WEBPACK_IMPORTED_MODULE_2__["cloneDeepMapArr"])(geom_maps.up_verts_tris);
        this._geom_maps.up_tris_faces = new Map(geom_maps.up_tris_faces);
        this._geom_maps.up_verts_edges = Object(_common_func__WEBPACK_IMPORTED_MODULE_2__["cloneDeepMapArr"])(geom_maps.up_verts_edges);
        this._geom_maps.up_edges_wires = new Map(geom_maps.up_edges_wires);
        this._geom_maps.up_wires_faces = new Map(geom_maps.up_wires_faces);
        this._geom_maps.up_verts_points = new Map(geom_maps.up_verts_points);
        this._geom_maps.up_wires_plines = new Map(geom_maps.up_wires_plines);
        this._geom_maps.up_faces_pgons = new Map(geom_maps.up_faces_pgons);
        this._geom_maps.up_points_colls = Object(_common_func__WEBPACK_IMPORTED_MODULE_2__["cloneDeepMapArr"])(geom_maps.up_points_colls);
        this._geom_maps.up_plines_colls = Object(_common_func__WEBPACK_IMPORTED_MODULE_2__["cloneDeepMapArr"])(geom_maps.up_plines_colls);
        this._geom_maps.up_pgons_colls = Object(_common_func__WEBPACK_IMPORTED_MODULE_2__["cloneDeepMapArr"])(geom_maps.up_pgons_colls);
        // ======================================================================
        this._geom_maps.posis_ts = new Map(geom_maps.posis_ts);
        this._geom_maps.points_ts = new Map(geom_maps.points_ts);
        this._geom_maps.plines_ts = new Map(geom_maps.plines_ts);
        this._geom_maps.pgons_ts = new Map(geom_maps.pgons_ts);
        this._geom_maps.colls_ts = new Map(geom_maps.colls_ts);
    }
    /**
     * Adds data to this model from another model.
     * The data is deep copied.
     * No conflict detection is performed.
     * Typically, this model is assumed to be empty.
     * If ent_sets is null, do nothing.
     * @param geom_maps The geom_arrays of the other model.
     */
    dumpSelect(other_geom, ent_sets) {
        if (ent_sets === null) {
            return;
        }
        // Check that we have correct number of time stamps
        if (this._geom_maps.up_posis_verts.size !== this._geom_maps.posis_ts.size) {
            throw new Error('Incorrent number of time stamps for posis.');
        }
        if (this._geom_maps.dn_points_verts.size !== this._geom_maps.points_ts.size) {
            throw new Error('Incorrent number of time stamps for points.');
        }
        if (this._geom_maps.dn_plines_wires.size !== this._geom_maps.plines_ts.size) {
            throw new Error('Incorrent number of time stamps for plines.');
        }
        if (this._geom_maps.dn_pgons_faces.size !== this._geom_maps.pgons_ts.size) {
            throw new Error('Incorrent number of time stamps for pgons.');
        }
        if (this._geom_maps.dn_colls_objs.size !== this._geom_maps.colls_ts.size) {
            throw new Error('Incorrent number of time stamps for colls.');
        }
        //
        const geom_maps = other_geom._geom_maps;
        // ======================================================================
        this._dumpPosiObjCollSelect(other_geom, _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POSI, ent_sets.posis_i);
        this._dumpPosiObjCollSelect(other_geom, _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POINT, ent_sets.points_i);
        this._dumpPosiObjCollSelect(other_geom, _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PLINE, ent_sets.plines_i);
        this._dumpPosiObjCollSelect(other_geom, _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PGON, ent_sets.pgons_i);
        this._dumpPosiObjCollSelect(other_geom, _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].COLL, ent_sets.colls_i);
        // ======================================================================
        this._dumpEntsSelect(this._geom_maps.dn_verts_posis, geom_maps.dn_verts_posis, ent_sets.verts_i);
        this._dumpEntsSelect(this._geom_maps.dn_tris_verts, geom_maps.dn_tris_verts, ent_sets.tris_i);
        this._dumpEntsSelect(this._geom_maps.dn_edges_verts, geom_maps.dn_edges_verts, ent_sets.edges_i);
        this._dumpEntsSelect(this._geom_maps.dn_wires_edges, geom_maps.dn_wires_edges, ent_sets.wires_i);
        this._dumpEntsSelect(this._geom_maps.dn_faces_wires, geom_maps.dn_faces_wires, ent_sets.faces_i);
        this._dumpEntsSelect(this._geom_maps.dn_faces_tris, geom_maps.dn_faces_tris, ent_sets.faces_i);
        // ======================================================================
        this._dumpEntsSelect(this._geom_maps.up_verts_tris, geom_maps.up_verts_tris, ent_sets.verts_i);
        this._dumpEntsSelect(this._geom_maps.up_tris_faces, geom_maps.up_tris_faces, ent_sets.tris_i);
        this._dumpEntsSelect(this._geom_maps.up_verts_edges, geom_maps.up_verts_edges, ent_sets.verts_i);
        this._dumpEntsSelect(this._geom_maps.up_edges_wires, geom_maps.up_edges_wires, ent_sets.edges_i);
        this._dumpEntsSelect(this._geom_maps.up_wires_faces, geom_maps.up_wires_faces, ent_sets.wires_i);
        this._dumpEntsSelect(this._geom_maps.up_verts_points, geom_maps.up_verts_points, ent_sets.verts_i);
        this._dumpEntsSelect(this._geom_maps.up_wires_plines, geom_maps.up_wires_plines, ent_sets.wires_i);
        this._dumpEntsSelect(this._geom_maps.up_faces_pgons, geom_maps.up_faces_pgons, ent_sets.faces_i);
        this._dumpEntsSelect(this._geom_maps.up_points_colls, geom_maps.up_points_colls, ent_sets.points_i);
        this._dumpEntsSelect(this._geom_maps.up_plines_colls, geom_maps.up_plines_colls, ent_sets.plines_i);
        this._dumpEntsSelect(this._geom_maps.up_pgons_colls, geom_maps.up_pgons_colls, ent_sets.pgons_i);
        // ======================================================================
        // time stamp updated in _dumpPosiObjCollSelect() method
    }
    /**
     * Adds data to this model from another model.
     * The data is deep copied.
     * The existing data in the model is not deleted.
     * The entities in the other model are renumbered.
     * @param other_geom_maps The geom_arrays of the other model.
     */
    mergeAndPurge(other_geom_maps) {
        // get lengths of existing entities before we start adding stuff
        // const num_posis: number = this._geom_maps.num_posis;
        const num_posis = this._geom_maps.up_posis_verts.size;
        const num_verts = this._geom_maps.dn_verts_posis.size;
        const num_tris = this._geom_maps.dn_tris_verts.size;
        const num_edges = this._geom_maps.dn_edges_verts.size;
        const num_wires = this._geom_maps.dn_wires_edges.size;
        const num_faces = this._geom_maps.dn_faces_wires.size;
        const num_points = this._geom_maps.dn_points_verts.size;
        const num_plines = this._geom_maps.dn_plines_wires.size;
        const num_pgons = this._geom_maps.dn_pgons_faces.size;
        const num_colls = this._geom_maps.dn_colls_objs.size;
        // ======================================================================
        // get maps for entities
        // positions
        const renum_posis_map = new Map();
        let posis_count = 0;
        other_geom_maps.up_posis_verts.forEach((_, other_posi_i) => {
            renum_posis_map.set(other_posi_i, posis_count + num_posis);
            posis_count += 1;
        });
        // vertices
        const renum_verts_map = new Map();
        let vert_count = 0;
        other_geom_maps.dn_verts_posis.forEach((_, other_vert_i) => {
            renum_verts_map.set(other_vert_i, vert_count + num_verts);
            vert_count += 1;
        });
        // triangles
        const renum_tris_map = new Map();
        let tris_count = 0;
        other_geom_maps.dn_tris_verts.forEach((_, other_tri_i) => {
            renum_tris_map.set(other_tri_i, tris_count + num_tris);
            tris_count += 1;
        });
        // edges
        const renum_edges_map = new Map();
        let edges_count = 0;
        other_geom_maps.dn_edges_verts.forEach((_, other_edge_i) => {
            renum_edges_map.set(other_edge_i, edges_count + num_edges);
            edges_count += 1;
        });
        // wires
        const renum_wires_map = new Map();
        let wires_count = 0;
        other_geom_maps.dn_wires_edges.forEach((_, other_wire_i) => {
            renum_wires_map.set(other_wire_i, wires_count + num_wires);
            wires_count += 1;
        });
        // faces
        const renum_faces_map = new Map();
        let faces_count = 0;
        other_geom_maps.dn_faces_wires.forEach((_, other_face_i) => {
            renum_faces_map.set(other_face_i, faces_count + num_faces);
            faces_count += 1;
        });
        // points
        const renum_points_map = new Map();
        let points_count = 0;
        other_geom_maps.dn_points_verts.forEach((_, other_point_i) => {
            renum_points_map.set(other_point_i, points_count + num_points);
            points_count += 1;
        });
        // plines
        const renum_plines_map = new Map();
        let plines_count = 0;
        other_geom_maps.dn_plines_wires.forEach((_, other_wire_i) => {
            renum_plines_map.set(other_wire_i, plines_count + num_plines);
            plines_count += 1;
        });
        // pgons
        const renum_pgons_map = new Map();
        let pgons_count = 0;
        other_geom_maps.dn_pgons_faces.forEach((_, other_pgon_i) => {
            renum_pgons_map.set(other_pgon_i, pgons_count + num_pgons);
            pgons_count += 1;
        });
        // colls
        const renum_colls_map = new Map();
        let colls_count = 0;
        other_geom_maps.dn_colls_objs.forEach((_, other_coll_i) => {
            renum_colls_map.set(other_coll_i, colls_count + num_colls);
            colls_count += 1;
        });
        // create data to return
        const renum_maps = new Map();
        renum_maps.set('posis', renum_posis_map);
        renum_maps.set('verts', renum_verts_map);
        renum_maps.set('edges', renum_edges_map);
        renum_maps.set('wires', renum_wires_map);
        renum_maps.set('faces', renum_faces_map);
        renum_maps.set('points', renum_points_map);
        renum_maps.set('plines', renum_plines_map);
        renum_maps.set('pgons', renum_pgons_map);
        renum_maps.set('colls', renum_colls_map);
        // ======================================================================
        // update down arrays
        // add vertices to model
        other_geom_maps.dn_verts_posis.forEach((other_posi_i, other_vert_i) => {
            this._geom_maps.dn_verts_posis.set(renum_verts_map.get(other_vert_i), renum_posis_map.get(other_posi_i));
        });
        // add triangles to model
        other_geom_maps.dn_tris_verts.forEach((other_verts_i, other_tri_i) => {
            this._geom_maps.dn_tris_verts.set(renum_tris_map.get(other_tri_i), other_verts_i.map(other_vert_i => renum_verts_map.get(other_vert_i)));
        });
        // add edges to model
        other_geom_maps.dn_edges_verts.forEach((other_verts_i, other_edge_i) => {
            this._geom_maps.dn_edges_verts.set(renum_edges_map.get(other_edge_i), other_verts_i.map(other_vert_i => renum_verts_map.get(other_vert_i)));
        });
        // add wires to model
        other_geom_maps.dn_wires_edges.forEach((other_edges_i, other_wire_i) => {
            this._geom_maps.dn_wires_edges.set(renum_wires_map.get(other_wire_i), other_edges_i.map(other_edge_i => renum_edges_map.get(other_edge_i)));
        });
        // add faces to model
        other_geom_maps.dn_faces_wires.forEach((other_wires_i, other_face_i) => {
            this._geom_maps.dn_faces_wires.set(renum_faces_map.get(other_face_i), other_wires_i.map(other_wire_i => renum_wires_map.get(other_wire_i)));
        });
        other_geom_maps.dn_faces_tris.forEach((other_tris_i, other_face_i) => {
            this._geom_maps.dn_faces_tris.set(renum_faces_map.get(other_face_i), other_tris_i.map(other_tri_i => renum_tris_map.get(other_tri_i)));
        });
        // add points to model
        other_geom_maps.dn_points_verts.forEach((other_vert_i, other_point_i) => {
            this._geom_maps.dn_points_verts.set(renum_points_map.get(other_point_i), renum_verts_map.get(other_vert_i));
        });
        // add plines to model
        other_geom_maps.dn_plines_wires.forEach((other_wire_i, other_pline_i) => {
            this._geom_maps.dn_plines_wires.set(renum_plines_map.get(other_pline_i), renum_wires_map.get(other_wire_i));
        });
        // add pgons to model
        other_geom_maps.dn_pgons_faces.forEach((other_face_i, other_pgon_i) => {
            this._geom_maps.dn_pgons_faces.set(renum_pgons_map.get(other_pgon_i), renum_faces_map.get(other_face_i));
        });
        // add collections to model
        other_geom_maps.dn_colls_objs.forEach((other_coll, other_coll_i) => {
            const parent = (other_coll[0] === -1) ? -1 : renum_colls_map.get(other_coll[0]);
            const coll_points_i = other_coll[1].map(point_i => renum_points_map.get(point_i));
            const coll_plines_i = other_coll[2].map(pline_i => renum_plines_map.get(pline_i));
            const coll_pgons_i = other_coll[3].map(pgon_i => renum_pgons_map.get(pgon_i));
            const new_coll = [parent, coll_points_i, coll_plines_i, coll_pgons_i];
            this._geom_maps.dn_colls_objs.set(renum_colls_map.get(other_coll_i), new_coll);
        });
        // ======================================================================
        // update up arrays
        // update posis to verts (they can be null or [])
        // this array is used to capture deleted posis
        other_geom_maps.up_posis_verts.forEach((other_verts_i, other_posi_i) => {
            this._geom_maps.up_posis_verts.set(renum_posis_map.get(other_posi_i), other_verts_i.map(other_vert_i => renum_verts_map.get(other_vert_i)));
        });
        // update verts to tris
        other_geom_maps.up_verts_tris.forEach((other_tris_i, other_vert_i) => {
            this._geom_maps.up_verts_tris.set(renum_verts_map.get(other_vert_i), other_tris_i.map(other_tri_i => renum_tris_map.get(other_tri_i)));
        });
        // update tris to faces
        other_geom_maps.up_tris_faces.forEach((other_face_i, other_tri_i) => {
            this._geom_maps.up_tris_faces.set(renum_tris_map.get(other_tri_i), renum_faces_map.get(other_face_i));
        });
        // update verts to edges
        other_geom_maps.up_verts_edges.forEach((other_edges_i, other_vert_i) => {
            this._geom_maps.up_verts_edges.set(renum_verts_map.get(other_vert_i), other_edges_i.map(other_edge_i => renum_edges_map.get(other_edge_i)));
        });
        // update edges to wires
        other_geom_maps.up_edges_wires.forEach((other_wire_i, other_edge_i) => {
            this._geom_maps.up_edges_wires.set(renum_edges_map.get(other_edge_i), renum_wires_map.get(other_wire_i));
        });
        // update wires to faces
        other_geom_maps.up_wires_faces.forEach((other_face_i, other_wire_i) => {
            this._geom_maps.up_wires_faces.set(renum_wires_map.get(other_wire_i), renum_faces_map.get(other_face_i));
        });
        // update verts to points
        other_geom_maps.up_verts_points.forEach((other_vert_i, other_point_i) => {
            this._geom_maps.up_verts_points.set(renum_points_map.get(other_point_i), renum_verts_map.get(other_vert_i));
        });
        // update wires to plines
        other_geom_maps.up_wires_plines.forEach((other_pline_i, other_wire_i) => {
            this._geom_maps.up_wires_plines.set(renum_wires_map.get(other_wire_i), renum_plines_map.get(other_pline_i));
        });
        // update faces to pgons
        other_geom_maps.up_faces_pgons.forEach((other_pgon_i, other_face_i) => {
            this._geom_maps.up_faces_pgons.set(renum_faces_map.get(other_face_i), renum_pgons_map.get(other_pgon_i));
        });
        // update points to colls
        other_geom_maps.up_points_colls.forEach((other_colls_i, other_point_i) => {
            this._geom_maps.up_points_colls.set(renum_points_map.get(other_point_i), other_colls_i.map(other_coll_i => renum_colls_map.get(other_coll_i)));
        });
        // update plines to colls
        other_geom_maps.up_plines_colls.forEach((other_colls_i, other_pline_i) => {
            this._geom_maps.up_plines_colls.set(renum_plines_map.get(other_pline_i), other_colls_i.map(other_coll_i => renum_colls_map.get(other_coll_i)));
        });
        // update pgons to colls
        other_geom_maps.up_pgons_colls.forEach((other_colls_i, other_pgon_i) => {
            this._geom_maps.up_pgons_colls.set(renum_pgons_map.get(other_pgon_i), other_colls_i.map(other_coll_i => renum_colls_map.get(other_coll_i)));
        });
        // return the maps
        return renum_maps;
    }
    /**
     * Sets the data in this model from JSON data.
     * The data is shallow copied.
     * The existing data in the model is deleted.
     * All entities get the same time stamp.
     * @param geom_data The JSON data
     */
    setJSONData(geom_data) {
        // all entities get the same time stamp
        const ts = this._geom.modeldata.model.metadata.nextTimeStamp();
        // update the down arrays
        // add vertices to model
        this._geom_maps.dn_verts_posis = new Map();
        for (let i = 0; i < geom_data.verts.length; i++) {
            this._geom_maps.dn_verts_posis.set(geom_data.verts_i[i], geom_data.verts[i]);
        }
        // add triangles to model
        this._geom_maps.dn_tris_verts = new Map();
        for (let i = 0; i < geom_data.tris.length; i++) {
            this._geom_maps.dn_tris_verts.set(geom_data.tris_i[i], geom_data.tris[i]);
        }
        // add edges to model
        this._geom_maps.dn_edges_verts = new Map();
        for (let i = 0; i < geom_data.edges.length; i++) {
            this._geom_maps.dn_edges_verts.set(geom_data.edges_i[i], geom_data.edges[i]);
        }
        // add wires to model
        this._geom_maps.dn_wires_edges = new Map();
        for (let i = 0; i < geom_data.wires.length; i++) {
            this._geom_maps.dn_wires_edges.set(geom_data.wires_i[i], geom_data.wires[i]);
        }
        // add faces to model
        this._geom_maps.dn_faces_wires = new Map();
        this._geom_maps.dn_faces_tris = new Map();
        for (let i = 0; i < geom_data.faces.length; i++) {
            this._geom_maps.dn_faces_wires.set(geom_data.faces_i[i], geom_data.faces[i]);
            this._geom_maps.dn_faces_tris.set(geom_data.faces_i[i], geom_data.facetris[i]);
        }
        // add points to model
        this._geom_maps.dn_points_verts = new Map();
        for (let i = 0; i < geom_data.points.length; i++) {
            this._geom_maps.dn_points_verts.set(geom_data.points_i[i], geom_data.points[i]);
            this._geom.time_stamp.setEntTs(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POINT, geom_data.points_i[i], ts); // time stamp
        }
        // add plines to model
        this._geom_maps.dn_plines_wires = new Map();
        for (let i = 0; i < geom_data.plines.length; i++) {
            this._geom_maps.dn_plines_wires.set(geom_data.plines_i[i], geom_data.plines[i]);
            this._geom.time_stamp.setEntTs(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PLINE, geom_data.plines_i[i], ts); // time stamp
        }
        // add pgons to model
        this._geom_maps.dn_pgons_faces = new Map();
        for (let i = 0; i < geom_data.pgons.length; i++) {
            this._geom_maps.dn_pgons_faces.set(geom_data.pgons_i[i], geom_data.pgons[i]);
            this._geom.time_stamp.setEntTs(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PGON, geom_data.pgons_i[i], ts); // time stamp
        }
        // add collections to model
        this._geom_maps.dn_colls_objs = new Map();
        for (let i = 0; i < geom_data.colls.length; i++) {
            this._geom_maps.dn_colls_objs.set(geom_data.colls_i[i], geom_data.colls[i]);
            this._geom.time_stamp.setEntTs(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].COLL, geom_data.colls_i[i], ts); // time stamp
        }
        // set selected
        this._geom.selected = geom_data.selected;
        // ========================================================================================
        // update the up arrays
        // posis->verts, create empty []
        this._geom_maps.up_posis_verts = new Map();
        for (let i = 0; i < geom_data.posis_i.length; i++) {
            this._geom_maps.up_posis_verts.set(geom_data.posis_i[i], []);
            this._geom.time_stamp.setEntTs(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POSI, geom_data.posis_i[i], ts); // time stamp
        }
        // posis->verts
        this._geom_maps.dn_verts_posis.forEach((posi_i, vert_i) => {
            this._geom_maps.up_posis_verts.get(posi_i).push(vert_i);
        });
        // verts->tris, one to many
        this._geom_maps.up_verts_tris = new Map();
        this._geom_maps.dn_tris_verts.forEach((vert_i_arr, tri_i) => {
            vert_i_arr.forEach(vert_i => {
                if (!this._geom_maps.up_verts_tris.has(vert_i)) {
                    this._geom_maps.up_verts_tris.set(vert_i, []);
                }
                this._geom_maps.up_verts_tris.get(vert_i).push(tri_i);
            });
        });
        // verts->edges, one to two
        // order is important
        this._geom_maps.up_verts_edges = new Map();
        this._geom_maps.dn_edges_verts.forEach((vert_i_arr, edge_i) => {
            vert_i_arr.forEach((vert_i, index) => {
                if (!this._geom_maps.up_verts_edges.has(vert_i)) {
                    this._geom_maps.up_verts_edges.set(vert_i, []);
                }
                if (index === 0) {
                    this._geom_maps.up_verts_edges.get(vert_i).push(edge_i);
                }
                else if (index === 1) {
                    this._geom_maps.up_verts_edges.get(vert_i).splice(0, 0, edge_i);
                }
                if (index > 1) {
                    throw new Error('Import data error: Found an edge with more than two vertices.');
                }
            });
        });
        // edges->wires
        this._geom_maps.up_edges_wires = new Map();
        this._geom_maps.dn_wires_edges.forEach((edge_i_arr, wire_i) => {
            edge_i_arr.forEach(edge_i => {
                this._geom_maps.up_edges_wires.set(edge_i, wire_i);
            });
        });
        // wires->faces
        this._geom_maps.up_wires_faces = new Map();
        this._geom_maps.dn_faces_wires.forEach((wire_i_arr, face_i) => {
            wire_i_arr.forEach(wire_i => {
                this._geom_maps.up_wires_faces.set(wire_i, face_i);
            });
        });
        // tris->faces
        this._geom_maps.up_tris_faces = new Map();
        this._geom_maps.dn_faces_tris.forEach((tri_i_arr, face_i) => {
            tri_i_arr.forEach(tri_i => {
                this._geom_maps.up_tris_faces.set(tri_i, face_i);
            });
        });
        // points, lines, polygons
        this._geom_maps.up_verts_points = new Map();
        this._geom_maps.dn_points_verts.forEach((vert_i, point_i) => {
            this._geom_maps.up_verts_points.set(vert_i, point_i);
        });
        this._geom_maps.up_wires_plines = new Map();
        this._geom_maps.dn_plines_wires.forEach((wire_i, line_i) => {
            this._geom_maps.up_wires_plines.set(wire_i, line_i);
        });
        this._geom_maps.up_faces_pgons = new Map();
        this._geom_maps.dn_pgons_faces.forEach((face_i, pgon_i) => {
            this._geom_maps.up_faces_pgons.set(face_i, pgon_i);
        });
        // collections of points, polylines, polygons
        this._geom_maps.up_points_colls = new Map();
        this._geom_maps.up_plines_colls = new Map();
        this._geom_maps.up_pgons_colls = new Map();
        this._geom_maps.dn_colls_objs.forEach((coll, coll_i) => {
            const [parent, point_i_arr, pline_i_arr, pgon_i_arr] = coll;
            point_i_arr.forEach(point_i => {
                if (!this._geom_maps.up_points_colls.has(point_i)) {
                    this._geom_maps.up_points_colls.set(point_i, [coll_i]);
                }
                else {
                    this._geom_maps.up_points_colls.get(point_i).push(coll_i);
                }
            });
            pline_i_arr.forEach(pline_i => {
                if (!this._geom_maps.up_plines_colls.has(pline_i)) {
                    this._geom_maps.up_plines_colls.set(pline_i, [coll_i]);
                }
                else {
                    this._geom_maps.up_plines_colls.get(pline_i).push(coll_i);
                }
            });
            pgon_i_arr.forEach(pgon_i => {
                if (!this._geom_maps.up_pgons_colls.has(pgon_i)) {
                    this._geom_maps.up_pgons_colls.set(pgon_i, [coll_i]);
                }
                else {
                    this._geom_maps.up_pgons_colls.get(pgon_i).push(coll_i);
                }
            });
        });
    }
    /**
     * Returns the JSON data for this model.
     * The data is shallow copied.
     */
    getJSONData() {
        const data = {
            posis_i: [],
            verts: [], verts_i: [],
            tris: [], tris_i: [],
            edges: [], edges_i: [],
            wires: [], wires_i: [],
            faces: [], facetris: [], faces_i: [],
            points: [], points_i: [],
            plines: [], plines_i: [],
            pgons: [], pgons_i: [],
            colls: [], colls_i: [],
            selected: this._geom.selected
        };
        this._geom_maps.up_posis_verts.forEach((_, i) => {
            data.posis_i.push(i);
        });
        this._geom_maps.dn_verts_posis.forEach((ent, i) => {
            data.verts.push(ent);
            data.verts_i.push(i);
        });
        this._geom_maps.dn_tris_verts.forEach((ent, i) => {
            data.tris.push(ent);
            data.tris_i.push(i);
        });
        this._geom_maps.dn_edges_verts.forEach((ent, i) => {
            data.edges.push(ent);
            data.edges_i.push(i);
        });
        this._geom_maps.dn_wires_edges.forEach((ent, i) => {
            data.wires.push(ent);
            data.wires_i.push(i);
        });
        this._geom_maps.dn_faces_wires.forEach((ent, i) => {
            data.faces.push(ent);
            data.faces_i.push(i);
        });
        this._geom_maps.dn_faces_tris.forEach((ent, _) => {
            data.facetris.push(ent);
        });
        this._geom_maps.dn_points_verts.forEach((ent, i) => {
            data.points.push(ent);
            data.points_i.push(i);
        });
        this._geom_maps.dn_plines_wires.forEach((ent, i) => {
            data.plines.push(ent);
            data.plines_i.push(i);
        });
        this._geom_maps.dn_pgons_faces.forEach((ent, i) => {
            data.pgons.push(ent);
            data.pgons_i.push(i);
        });
        this._geom_maps.dn_colls_objs.forEach((ent, i) => {
            data.colls.push(ent);
            data.colls_i.push(i);
        });
        return data;
    }
    // --------------------------------------------------------------------------------------------
    // Private methods
    // --------------------------------------------------------------------------------------------
    /**
     * Merge ents, no conflict detection, deep copy.
     * @param this_map
     * @param other_map
     * @param type
     */
    _mergeEnts(this_map, other_map) {
        other_map.forEach((ent, ent_i) => {
            this_map.set(ent_i, lodash__WEBPACK_IMPORTED_MODULE_1__["cloneDeep"](ent)); // TODO change to slice() once colls have been updated
        });
    }
    /**
     * Merge objects and collections, with conflict detection, deep copy.
     * This is for merging"
     * point_i->vert_i
     * pline_i-> wire_i
     * pgon_i->face-i
     * coll_i->[parent, points_i, plines_i, pgons_i]
     * @param other_geom
     * @param ent_type
     */
    _mergeObjCollEnts(other_geom, ent_type) {
        // get key
        const geom_array_key = _common__WEBPACK_IMPORTED_MODULE_0__["EEntStrToGeomMaps"][ent_type];
        // get maps
        const this_map = this._geom_maps[geom_array_key];
        const other_map = other_geom._geom_maps[geom_array_key];
        // merge
        other_map.forEach((ent, ent_i) => {
            const other_ts = other_geom.time_stamp.getEntTs(ent_type, ent_i);
            if (this_map.has(ent_i)) {
                // check time stamp
                const this_ts = this._geom.time_stamp.getEntTs(ent_type, ent_i);
                if (this_ts !== other_ts) {
                    throw new Error('Conflict merging ' + Object(_common_func__WEBPACK_IMPORTED_MODULE_2__["getEntTypeStr"])(ent_type) + '.');
                }
            }
            else {
                this_map.set(ent_i, lodash__WEBPACK_IMPORTED_MODULE_1__["cloneDeep"](ent)); // TODO change to slice() once colls have been updated
                this._geom.time_stamp.setEntTs(ent_type, ent_i, other_ts);
            }
        });
    }
    /**
     * Merge collections, no conflict detection, deep copy.
     * This is for merging:
     * point_i->colls_i
     * pline_i->colls_i
     * pgon_i->colls_i
     * @param other_geom
     */
    _mergeColls(this_map, other_map) {
        // merge
        other_map.forEach((other_colls_i, other_ent_i) => {
            if (this_map.has(other_ent_i)) {
                // merge colls
                const this_colls_i_set = new Set(this_map.get(other_ent_i));
                for (const other_coll_i of other_colls_i) {
                    this_colls_i_set.add(other_coll_i);
                }
                this_map.set(other_ent_i, Array.from(this_colls_i_set));
            }
            else {
                this_map.set(other_ent_i, lodash__WEBPACK_IMPORTED_MODULE_1__["cloneDeep"](other_colls_i)); // TODO change to slice() once colls have been updated
            }
        });
    }
    /**
     * Merge posis, with conflict detection, deep copy.
     * This is for merging:
     * posi_i->verts_i
     * @param other_geom
     */
    _mergePosis(other_geom) {
        // get maps
        const this_map = this._geom_maps.up_posis_verts;
        const other_map = other_geom._geom_maps.up_posis_verts;
        // merge
        other_map.forEach((other_verts_i, other_posi_i) => {
            const other_ts = other_geom.time_stamp.getEntTs(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POSI, other_posi_i);
            if (this_map.has(other_posi_i)) {
                // check time stamp
                const this_ts = this._geom.time_stamp.getEntTs(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POSI, other_posi_i);
                if (this_ts !== other_ts) {
                    throw new Error('Conflict merging positions.');
                }
                // merge verts
                const verts_i_set = new Set(this_map.get(other_posi_i));
                for (const vert_i of other_verts_i) {
                    verts_i_set.add(vert_i);
                }
                this_map.set(other_posi_i, Array.from(verts_i_set));
            }
            else {
                this_map.set(other_posi_i, other_verts_i.slice());
                this._geom.time_stamp.setEntTs(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POSI, other_posi_i, other_ts);
            }
        });
    }
    /**
     *
     * @param this_map
     * @param other_map
     * @param selected
     */
    _dumpEntsSelect(this_map, other_map, selected) {
        selected.forEach(ent_i => {
            const other_ent = other_map.get(ent_i);
            if (other_ent !== undefined) {
                this_map.set(ent_i, lodash__WEBPACK_IMPORTED_MODULE_1__["cloneDeep"](other_ent)); // TODO change to slice() once colls have been updated
            }
        });
    }
    /**
     *
     * @param other_geom
     * @param ent_type
     * @param selected
     */
    _dumpPosiObjCollSelect(other_geom, ent_type, selected) {
        // get key
        const geom_array_key = _common__WEBPACK_IMPORTED_MODULE_0__["EEntStrToGeomMaps"][ent_type];
        // get maps
        const this_map = this._geom_maps[geom_array_key];
        const other_map = other_geom._geom_maps[geom_array_key];
        // dump
        selected.forEach(ent_i => {
            const other_ent = other_map.get(ent_i);
            if (other_ent !== undefined) {
                this_map.set(ent_i, lodash__WEBPACK_IMPORTED_MODULE_1__["cloneDeep"](other_ent)); // TODO change to slice() once colls have been updated
                const other_ts = other_geom.time_stamp.getEntTs(ent_type, ent_i);
                this._geom.time_stamp.setEntTs(ent_type, ent_i, other_ts);
            }
        });
    }
}


/***/ }),

/***/ "./src/assets/libs/geo-info/GIGeomModify.ts":
/*!**************************************************!*\
  !*** ./src/assets/libs/geo-info/GIGeomModify.ts ***!
  \**************************************************/
/*! exports provided: GIGeomModify */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GIGeomModify", function() { return GIGeomModify; });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common */ "./src/assets/libs/geo-info/common.ts");
/* harmony import */ var _util_arrs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/arrs */ "./src/assets/libs/util/arrs.ts");
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};


/**
 * Class for geometry.
 */
class GIGeomModify {
    /**
     * Constructor
     */
    constructor(geom, geom_arrays) {
        this._geom = geom;
        this._geom_maps = geom_arrays;
    }
    // ============================================================================
    // Modify geometry
    // ============================================================================
    /**
     * Insert a vertex into an edge and updates the wire with the new edge
     * ~
     * Applies to both plines and pgons.
     * ~
     * Plines can be open or closed.
     * ~
     */
    insertVertIntoWire(edge_i, posi_i) {
        const wire_i = this._geom.nav.navEdgeToWire(edge_i);
        const wire = this._geom_maps.dn_wires_edges.get(wire_i);
        const old_edge_verts_i = this._geom_maps.dn_edges_verts.get(edge_i);
        const old_and_prev_edge_i = this._geom_maps.up_verts_edges.get(old_edge_verts_i[0]);
        const old_and_next_edge_i = this._geom_maps.up_verts_edges.get(old_edge_verts_i[1]);
        // check prev edge
        if (old_and_prev_edge_i.length === 2) {
            if (old_and_prev_edge_i[0] === edge_i) {
                throw new Error('Edges are in wrong order');
            }
        }
        // check next edge amd save the next edge
        if (old_and_next_edge_i.length === 2) {
            if (old_and_next_edge_i[1] === edge_i) {
                throw new Error('Edges are in wrong order');
            }
            this._geom_maps.up_verts_edges.set(old_edge_verts_i[1], [old_and_next_edge_i[1]]);
        }
        else {
            this._geom_maps.up_verts_edges.set(old_edge_verts_i[1], []);
        }
        // create one new vertex and one new edge
        const new_vert_i = this._geom.add._addVertex(posi_i);
        this._geom_maps.up_verts_edges.set(new_vert_i, [edge_i]);
        const new_edge_i = this._geom.add._addEdge(new_vert_i, old_edge_verts_i[1]);
        // update the down arrays
        old_edge_verts_i[1] = new_vert_i;
        wire.splice(wire.indexOf(edge_i), 1, edge_i, new_edge_i);
        // update the up arrays for edges to wires
        this._geom_maps.up_edges_wires.set(new_edge_i, wire_i);
        // return the new edge
        return new_edge_i;
    }
    /**
         * Insert multiple vertices into an edge and updates the wire with the new edges
         * ~
         * Applies to both plines and pgons.
         * ~
         * Plines can be open or closed.
         * ~
         */
    insertVertsIntoWire(edge_i, posis_i) {
        // check that there are no duplicates in the list
        if (posis_i.length > 1) {
            posis_i = Array.from(new Set(posis_i));
        }
        // check tha the posis being inserted are not already the start or end of this edge
        const edge_posis_i = this._geom.nav.navAnyToPosi(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].EDGE, edge_i);
        if (edge_posis_i[0] === posis_i[0]) {
            posis_i = posis_i.slice(1);
        }
        if (edge_posis_i[1] === posis_i[posis_i.length - 1]) {
            posis_i = posis_i.slice(0, posis_i.length - 1);
        }
        // if no more posis, then return empty list
        if (posis_i.length === 0) {
            return [];
        }
        // proceed to insert posis
        const wire_i = this._geom.nav.navEdgeToWire(edge_i);
        const wire = this._geom_maps.dn_wires_edges.get(wire_i);
        const end_vert_i = this._geom_maps.dn_edges_verts.get(edge_i)[1];
        const next_edge_i = this._geom_maps.up_verts_edges.get(end_vert_i)[1];
        // check next edge amd save the next edge
        if (next_edge_i !== undefined) {
            this._geom_maps.up_verts_edges.set(end_vert_i, [next_edge_i]); // there is next edge
        }
        else {
            this._geom_maps.up_verts_edges.set(end_vert_i, []); // there is no next edge
        }
        // create the new vertices
        const new_verts_i = [];
        for (const posi_i of posis_i) {
            const new_vert_i = this._geom.add._addVertex(posi_i);
            new_verts_i.push(new_vert_i);
        }
        new_verts_i.push(end_vert_i);
        // update the down/ip arrays for teh old edge
        // the old edge becomes the first edge in this list, and it gets a new end vertex
        this._geom_maps.dn_edges_verts.get(edge_i)[1] = new_verts_i[0];
        this._geom_maps.up_verts_edges.set(new_verts_i[0], [edge_i]);
        // create the new edges
        const new_edges_i = [];
        for (let i = 0; i < new_verts_i.length - 1; i++) {
            const new_edge_i = this._geom.add._addEdge(new_verts_i[i], new_verts_i[i + 1]);
            // update the up arrays for edges to wires
            this._geom_maps.up_edges_wires.set(new_edge_i, wire_i);
            // add to the list
            new_edges_i.push(new_edge_i);
        }
        // update the down arrays for the wire
        wire.splice(wire.indexOf(edge_i) + 1, 0, ...new_edges_i);
        // return the new edge
        return new_edges_i;
    }
    /**
     * Replace all positions in an entity with a new set of positions.
     * ~
     */
    replacePosis(ent_type, ent_i, new_posis_i) {
        const old_posis_i = this._geom.nav.navAnyToPosi(ent_type, ent_i);
        if (old_posis_i.length !== new_posis_i.length) {
            throw new Error('Replacing positions operation failed due to incorrect number of positions.');
        }
        const old_posis_i_map = new Map(); // old_posi_i -> index
        for (let i = 0; i < old_posis_i.length; i++) {
            const old_posi_i = old_posis_i[i];
            old_posis_i_map[old_posi_i] = i;
        }
        const verts_i = this._geom.nav.navAnyToVert(ent_type, ent_i);
        for (const vert_i of verts_i) {
            const old_posi_i = this._geom.nav.navVertToPosi(vert_i);
            const i = old_posis_i_map[old_posi_i];
            const new_posi_i = new_posis_i[i];
            // set the down array
            this._geom_maps.dn_verts_posis.set(vert_i, new_posi_i);
            // update the up arrays for the old posi, i.e. remove this vert
            Object(_util_arrs__WEBPACK_IMPORTED_MODULE_1__["arrRem"])(this._geom_maps.up_posis_verts.get(old_posi_i), vert_i);
            // update the up arrays for the new posi, i.e. add this vert
            this._geom_maps.up_posis_verts.get(new_posi_i).push(vert_i);
        }
    }
    /**
     * Replace the position of a vertex with a new position.
     * ~
     * If the result is an edge with two same posis, then the vertex will be deleted if del_if_invalid = true.
     * If del_if_invalid = false, no action will be taken.
     * ~
     * Called by modify.Fuse() and poly2d.Stitch().
     */
    replaceVertPosi(vert_i, new_posi_i, del_if_invalid = true) {
        // special case
        // check if this is a vert for an edge
        const edges_i = this._geom.nav.navVertToEdge(vert_i);
        const num_edges = edges_i.length;
        switch (num_edges) {
            case 1:
                // we must be at an edge at the start or end of an open wire
                const edge_posis_i = this._geom.nav.navAnyToPosi(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].EDGE, edges_i[0]);
                if (edge_posis_i[0] === new_posi_i || edge_posis_i[1] === new_posi_i) {
                    // special case where start or end has new_posi_i
                    if (del_if_invalid) {
                        this._geom.del_vert.delVert(vert_i);
                    }
                    return;
                }
                break;
            case 2:
                // we must be in the middle of a wire
                const prev_edge_i = edges_i[0];
                const next_edge_i = edges_i[1];
                const [a_posi_i, b1_posi_i] = this._geom.nav.navAnyToPosi(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].EDGE, prev_edge_i);
                const [b2_posi_i, c_posi_i] = this._geom.nav.navAnyToPosi(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].EDGE, next_edge_i);
                if (a_posi_i === new_posi_i && c_posi_i === new_posi_i) {
                    // special case where both adjacent edges has new_posi_i
                    const [b2_vert_i, c_vert_i] = this._geom.nav.navEdgeToVert(next_edge_i);
                    if (vert_i !== b2_vert_i) {
                        throw new Error('Bad navigation in geometry data structure.');
                    }
                    if (del_if_invalid) {
                        this._geom.del_vert.delVert(c_vert_i);
                        this._geom.del_vert.delVert(vert_i);
                    }
                    return;
                }
                else if (a_posi_i === new_posi_i || c_posi_i === new_posi_i) {
                    // special case where one adjacent edges has new_posi_i
                    if (del_if_invalid) {
                        this._geom.del_vert.delVert(vert_i);
                    }
                    return;
                }
                break;
            // default:
            //     break;
        }
        // normal case
        const old_posi_i = this._geom.nav.navVertToPosi(vert_i);
        // set the down array
        this._geom_maps.dn_verts_posis.set(vert_i, new_posi_i);
        // update the up arrays for the old posi, i.e. remove this vert
        Object(_util_arrs__WEBPACK_IMPORTED_MODULE_1__["arrRem"])(this._geom_maps.up_posis_verts.get(old_posi_i), vert_i);
        // update the up arrays for the new posi, i.e. add this vert
        this._geom_maps.up_posis_verts.get(new_posi_i).push(vert_i);
    }
    /**
     * Unweld the vertices on naked edges.
     * ~
     */
    unweldVertsShallow(verts_i) {
        // create a map, for each posi_i, count how many verts there are in the input verts
        const exist_posis_i_map = new Map(); // posi_i -> count
        for (const vert_i of verts_i) {
            const posi_i = this._geom.nav.navVertToPosi(vert_i);
            if (!exist_posis_i_map.has(posi_i)) {
                exist_posis_i_map.set(posi_i, 0);
            }
            const vert_count = exist_posis_i_map.get(posi_i);
            exist_posis_i_map.set(posi_i, vert_count + 1);
        }
        // copy positions on the perimeter and make a map
        const old_to_new_posis_i_map = new Map();
        exist_posis_i_map.forEach((vert_count, old_posi_i) => {
            const all_old_verts_i = this._geom.nav.navPosiToVert(old_posi_i);
            const all_vert_count = all_old_verts_i.length;
            if (vert_count !== all_vert_count) {
                if (!old_to_new_posis_i_map.has(old_posi_i)) {
                    const new_posi_i = this._geom.add.copyPosis(old_posi_i, true);
                    old_to_new_posis_i_map.set(old_posi_i, new_posi_i);
                }
            }
        });
        // now go through the geom again and rewire to the new posis
        for (const vert_i of verts_i) {
            const old_posi_i = this._geom.nav.navVertToPosi(vert_i);
            if (old_to_new_posis_i_map.has(old_posi_i)) {
                const new_posi_i = old_to_new_posis_i_map.get(old_posi_i);
                // update the down arrays
                this._geom_maps.dn_verts_posis.set(vert_i, new_posi_i);
                // update the up arrays for the old posi, i.e. remove this vert
                Object(_util_arrs__WEBPACK_IMPORTED_MODULE_1__["arrRem"])(this._geom_maps.up_posis_verts.get(old_posi_i), vert_i);
                // update the up arrays for the new posi, i.e. add this vert
                this._geom_maps.up_posis_verts.get(new_posi_i).push(vert_i);
            }
        }
        // return all the new positions
        return Array.from(old_to_new_posis_i_map.values());
    }
    /**
     * Unweld all vertices by cloning the positions that are shared.
     * ~
     * Attributes on the positions are copied.
     * ~
     * @param verts_i
     */
    cloneVertPositions(verts_i) {
        const new_posis_i = [];
        for (const vert_i of verts_i) {
            const exist_posi_i = this._geom.nav.navVertToPosi(vert_i);
            const all_verts_i = this._geom.nav.navPosiToVert(exist_posi_i);
            const all_verts_count = all_verts_i.length;
            if (all_verts_count > 1) {
                const new_posi_i = this._geom.add.copyPosis(exist_posi_i, true);
                // update the down arrays
                this._geom_maps.dn_verts_posis.set(vert_i, new_posi_i);
                // update the up arrays for the old posi, i.e. remove this vert
                Object(_util_arrs__WEBPACK_IMPORTED_MODULE_1__["arrRem"])(this._geom_maps.up_posis_verts.get(exist_posi_i), vert_i);
                // update the up arrays for the new posi, i.e. add this vert
                this._geom_maps.up_posis_verts.get(new_posi_i).push(vert_i);
                // add the new posi_i to the list, to be returned later
                new_posis_i.push(new_posi_i);
            }
        }
        // return all the new positions
        return new_posis_i;
    }
    /**
     * Weld all vertices by merging the positions that are equal, so that they become shared.
     * ~
     * The old positions are deleted if unused. Attributes on those positions are discarded.
     * ~
     * @param verts_i
     */
    mergeVertPositions(verts_i) {
        // get a list of unique posis to merge
        // at the same time, make a sparse array vert_i -> posi_i
        const map_posis_to_merge_i = new Map();
        const vert_i_to_posi_i = []; // sparese array
        for (const vert_i of verts_i) {
            const exist_posi_i = this._geom.nav.navVertToPosi(vert_i);
            vert_i_to_posi_i[vert_i] = exist_posi_i;
            if (!map_posis_to_merge_i.has(exist_posi_i)) {
                map_posis_to_merge_i.set(exist_posi_i, []);
            }
            map_posis_to_merge_i.get(exist_posi_i).push(vert_i);
        }
        // calculate the new xyz
        // at the same time make a list of posis to del
        const posis_to_del_i = [];
        const new_xyz = [0, 0, 0];
        for (const [exist_posi_i, merge_verts_i] of Array.from(map_posis_to_merge_i)) {
            const posi_xyz = this._geom.modeldata.attribs.query.getPosiCoords(exist_posi_i);
            new_xyz[0] += posi_xyz[0];
            new_xyz[1] += posi_xyz[1];
            new_xyz[2] += posi_xyz[2];
            const all_verts_i = this._geom.nav.navPosiToVert(exist_posi_i);
            const all_verts_count = all_verts_i.length;
            if (all_verts_count === merge_verts_i.length) {
                posis_to_del_i.push(exist_posi_i);
            }
        }
        // make the new posi
        const num_posis = map_posis_to_merge_i.size;
        new_xyz[0] = new_xyz[0] / num_posis;
        new_xyz[1] = new_xyz[1] / num_posis;
        new_xyz[2] = new_xyz[2] / num_posis;
        const new_posi_i = this._geom.add.addPosi();
        this._geom.modeldata.attribs.add.setPosiCoords(new_posi_i, new_xyz);
        // replace the verts posi
        for (const vert_i of verts_i) {
            // update the down arrays
            this._geom_maps.dn_verts_posis.set(vert_i, new_posi_i);
            // update the up arrays for the old posi, i.e. remove this vert
            Object(_util_arrs__WEBPACK_IMPORTED_MODULE_1__["arrRem"])(this._geom_maps.up_posis_verts.get(vert_i_to_posi_i[vert_i]), vert_i);
            // update the up arrays for the new posi, i.e. add this vert
            this._geom_maps.up_posis_verts.get(new_posi_i).push(vert_i);
        }
        // del the posis that are no longer used, i.e. have zero verts
        this._geom.del.delPosis(posis_to_del_i);
        // return all the new positions
        return new_posi_i;
    }
    /**
     * Reverse the edges of a wire.
     * This lists the edges in reverse order, and flips each edge.
     * ~
     * The attributes will not be affected. So the order of edge attribtes will also become reversed.
     *
     * TODO
     * This does not reverse the order of the edges.
     * The method, getWireVertices() in GeomQuery returns the correct vertices.
     * However, you need to be careful with edge order.
     * The next edge after edge 0 may not be edge 1.
     * If reversed it will instead be the last edge.
     */
    reverse(wire_i) {
        const wire = this._geom_maps.dn_wires_edges.get(wire_i);
        wire.reverse();
        // reverse the edges
        for (const edge_i of wire) {
            const edge = this._geom_maps.dn_edges_verts.get(edge_i);
            edge.reverse();
            // the verts pointing up to edges also need to be reversed
            const edges_i = this._geom_maps.up_verts_edges.get(edge[0]);
            edges_i.reverse();
        }
        // if this is the first wire in a face, reverse the triangles
        const face_i = this._geom_maps.up_wires_faces.get(wire_i);
        if (face_i !== undefined) {
            const face = this._geom_maps.dn_faces_wires.get(face_i);
            const facetris = this._geom_maps.dn_faces_tris.get(face_i);
            if (face[0] === wire_i) {
                for (const tri_i of facetris) {
                    const tri = this._geom_maps.dn_tris_verts.get(tri_i);
                    tri.reverse();
                }
            }
        }
    }
    /**
     * Shifts the edges of a wire.
     * ~
     * The attributes will not be affected. For example, lets say a polygon has three edges
     * e1, e2, e3, with attribute values 5, 6, 7
     * If teh edges are shifted by 1, the edges will now be
     * e2, e3, e1, withh attribute values 6, 7, 5
     */
    shift(wire_i, offset) {
        const wire = this._geom_maps.dn_wires_edges.get(wire_i);
        wire.unshift.apply(wire, wire.splice(offset, wire.length));
    }
}


/***/ }),

/***/ "./src/assets/libs/geo-info/GIGeomModifyColl.ts":
/*!******************************************************!*\
  !*** ./src/assets/libs/geo-info/GIGeomModifyColl.ts ***!
  \******************************************************/
/*! exports provided: GIGeomModifyColl */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GIGeomModifyColl", function() { return GIGeomModifyColl; });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common */ "./src/assets/libs/geo-info/common.ts");
/* harmony import */ var _util_arrs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/arrs */ "./src/assets/libs/util/arrs.ts");
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};


/**
 * Class for geometry.
 */
class GIGeomModifyColl {
    /**
     * Constructor
     */
    constructor(geom, geom_arrays) {
        this._geom = geom;
        this._geom_maps = geom_arrays;
    }
    /**
     * Set the parent if a collection
     * @param coll_i The index of teh collection that is the parent
     * @param parent_coll_i
     */
    setCollParent(coll_i, parent_coll_i) {
        this._geom_maps.dn_colls_objs.get(coll_i)[0] = parent_coll_i;
        // update time stamp
        this._geom.time_stamp.updateEntTs(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].COLL, coll_i);
    }
    /**
     * Add entities to a collection.
     * Time stamp is not updated.
     * @param coll_i
     * @param points_i
     * @param plines_i
     * @param pgons_i
     */
    collAddEnts(coll_i, points_i, plines_i, pgons_i) {
        const coll = this._geom_maps.dn_colls_objs.get(coll_i);
        const coll_points = coll[1];
        if (points_i.length) {
            for (const point_i of points_i) {
                if (coll_points.indexOf(point_i) === -1) {
                    // update down arrays
                    coll_points.push(point_i);
                    // update up arrays
                    if (this._geom_maps.up_points_colls.has(point_i)) {
                        this._geom_maps.up_points_colls.get(point_i).push(coll_i);
                    }
                    else {
                        this._geom_maps.up_points_colls.set(point_i, [coll_i]);
                    }
                }
            }
        }
        const coll_plines = coll[2];
        if (plines_i.length) {
            for (const pline_i of plines_i) {
                if (coll_plines.indexOf(pline_i) === -1) {
                    // update down arrays
                    coll_plines.push(pline_i);
                    // update up arrays
                    if (this._geom_maps.up_plines_colls.has(pline_i)) {
                        this._geom_maps.up_plines_colls.get(pline_i).push(coll_i);
                    }
                    else {
                        this._geom_maps.up_plines_colls.set(pline_i, [coll_i]);
                    }
                }
            }
        }
        const coll_pgons = coll[3];
        if (pgons_i.length) {
            for (const pgon_i of pgons_i) {
                if (coll_pgons.indexOf(pgon_i) === -1) {
                    // update down arrays
                    coll_pgons.push(pgon_i);
                    // update up arrays
                    if (this._geom_maps.up_pgons_colls.has(pgon_i)) {
                        this._geom_maps.up_pgons_colls.get(pgon_i).push(coll_i);
                    }
                    else {
                        this._geom_maps.up_pgons_colls.set(pgon_i, [coll_i]);
                    }
                }
            }
        }
    }
    /**
     * Remove entities from a collection.
     * Time stamp is not updated.
     * @param coll_i
     * @param points_i
     * @param plines_i
     * @param pgons_i
     */
    collRemoveEnts(coll_i, points_i, plines_i, pgons_i) {
        const coll = this._geom_maps.dn_colls_objs.get(coll_i);
        const coll_points = coll[1];
        if (points_i && points_i.length) {
            for (const point_i of points_i) {
                // update down arrays
                Object(_util_arrs__WEBPACK_IMPORTED_MODULE_1__["arrRem"])(coll_points, point_i);
                // update up arrays
                Object(_util_arrs__WEBPACK_IMPORTED_MODULE_1__["arrRem"])(this._geom_maps.up_points_colls.get(point_i), coll_i);
            }
        }
        const coll_plines = coll[2];
        if (plines_i && plines_i.length) {
            for (const pline_i of plines_i) {
                // update down arrays
                Object(_util_arrs__WEBPACK_IMPORTED_MODULE_1__["arrRem"])(coll_plines, pline_i);
                // update up arrays
                Object(_util_arrs__WEBPACK_IMPORTED_MODULE_1__["arrRem"])(this._geom_maps.up_plines_colls.get(pline_i), coll_i);
            }
        }
        const coll_pgons = coll[3];
        if (pgons_i && pgons_i.length) {
            for (const pgon_i of pgons_i) {
                // update down arrays
                Object(_util_arrs__WEBPACK_IMPORTED_MODULE_1__["arrRem"])(coll_pgons, pgon_i);
                // update up arrays
                Object(_util_arrs__WEBPACK_IMPORTED_MODULE_1__["arrRem"])(this._geom_maps.up_pgons_colls.get(pgon_i), coll_i);
            }
        }
    }
}


/***/ }),

/***/ "./src/assets/libs/geo-info/GIGeomModifyPgon.ts":
/*!******************************************************!*\
  !*** ./src/assets/libs/geo-info/GIGeomModifyPgon.ts ***!
  \******************************************************/
/*! exports provided: GIGeomModifyPgon */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GIGeomModifyPgon", function() { return GIGeomModifyPgon; });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common */ "./src/assets/libs/geo-info/common.ts");
/* harmony import */ var _util_arrs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/arrs */ "./src/assets/libs/util/arrs.ts");
/* harmony import */ var _geom_vectors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../geom/vectors */ "./src/assets/libs/geom/vectors.ts");
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};



/**
 * Class for geometry.
 */
class GIGeomModifyPgon {
    /**
     * Constructor
     */
    constructor(geom, geom_arrays) {
        this._geom = geom;
        this._geom_maps = geom_arrays;
    }
    /**
     * Creates one or more holes in a polygon.
     * Updates time stamp for the polygon.
     * ~
     */
    cutPgonHoles(pgon_i, posis_i_arr) {
        const face_i = this._geom.nav.navPgonToFace(pgon_i);
        // get the normal of the face
        const face_normal = this._geom.query.getFaceNormal(face_i);
        // make the wires for the holes
        const hole_wires_i = [];
        for (const hole_posis_i of posis_i_arr) {
            const hole_vert_i_arr = hole_posis_i.map(posi_i => this._geom.add._addVertex(posi_i));
            const hole_edges_i_arr = [];
            for (let i = 0; i < hole_vert_i_arr.length - 1; i++) {
                hole_edges_i_arr.push(this._geom.add._addEdge(hole_vert_i_arr[i], hole_vert_i_arr[i + 1]));
            }
            hole_edges_i_arr.push(this._geom.add._addEdge(hole_vert_i_arr[hole_vert_i_arr.length - 1], hole_vert_i_arr[0]));
            const hole_wire_i = this._geom.add._addWire(hole_edges_i_arr, true);
            // get normal of wire and check if we need to reverse the wire
            const wire_normal = this._geom.query.getWireNormal(hole_wire_i);
            if (Object(_geom_vectors__WEBPACK_IMPORTED_MODULE_2__["vecDot"])(face_normal, wire_normal) > 0) {
                this._geom.modify.reverse(hole_wire_i);
            }
            // add to list of holes
            hole_wires_i.push(hole_wire_i);
        }
        // create the holes, does everything at face level
        this._cutFaceHoles(face_i, hole_wires_i);
        // update the time stamp
        this._geom.time_stamp.updateObjsTs(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PGON, pgon_i);
        // no need to change either the up or down arrays
        // return the new wires
        return hole_wires_i;
    }
    /**
     * Retriangulate the polygons.
     * Updates time stamp for the polygons.
     * ~
     */
    triPgons(pgons_i) {
        if (!Array.isArray(pgons_i)) {
            const wires_i = this._geom.nav.navAnyToWire(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PGON, pgons_i);
            const outer_i = wires_i[0];
            const holes_i = wires_i.slice(1);
            // get the face
            const face_i = this._geom.nav.navPgonToFace(pgons_i);
            // create the triangles
            const new_tris_i = this._geom.add._addTris(outer_i, holes_i);
            // delete the old trianges
            const old_face_tris_i = this._geom_maps.dn_faces_tris.get(face_i);
            for (const old_face_tri_i of old_face_tris_i) {
                // verts to tris
                for (const vert_i of this._geom_maps.dn_tris_verts.get(old_face_tri_i)) {
                    const vert_tris_i = this._geom_maps.up_verts_tris.get(vert_i);
                    Object(_util_arrs__WEBPACK_IMPORTED_MODULE_1__["arrRem"])(vert_tris_i, old_face_tri_i);
                }
                // tris to verts
                this._geom_maps.dn_tris_verts.delete(old_face_tri_i);
                // tris to faces
                this._geom_maps.up_tris_faces.delete(old_face_tri_i);
            }
            // update up array for tri to face
            for (const new_tri_i of new_tris_i) {
                this._geom_maps.up_tris_faces.set(new_tri_i, face_i);
            }
            // update down array for face to tri
            this._geom_maps.dn_faces_tris.set(face_i, new_tris_i);
            // update the time stamp
            this._geom.time_stamp.updateObjsTs(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PGON, pgons_i);
        }
        else { // An array of pgons
            pgons_i.forEach(pgon_i => this.triPgons(pgon_i));
        }
    }
    // ============================================================================
    // Private methods
    // ============================================================================
    /**
     * Adds a hole to a face and updates the arrays.
     * Wires are assumed to be closed!
     * This also calls addTris()
     * @param wire_i
     */
    _cutFaceHoles(face_i, hole_wires_i) {
        // get the wires and triangles arrays
        const face_wires_i = this._geom_maps.dn_faces_wires.get(face_i);
        const old_face_tris_i = this._geom_maps.dn_faces_tris.get(face_i);
        // get the outer wire
        const outer_wire_i = face_wires_i[0];
        // get the hole wires
        const all_hole_wires_i = [];
        if (face_wires_i.length > 1) {
            face_wires_i.slice(1).forEach(wire_i => all_hole_wires_i.push(wire_i));
        }
        hole_wires_i.forEach(wire_i => all_hole_wires_i.push(wire_i));
        // create the triangles
        const new_tris_i = this._geom.add._addTris(outer_wire_i, all_hole_wires_i);
        // create the face
        const new_wires_i = face_wires_i.concat(hole_wires_i);
        // update down arrays
        this._geom_maps.dn_faces_wires.set(face_i, new_wires_i);
        this._geom_maps.dn_faces_tris.set(face_i, new_tris_i);
        // update up arrays
        hole_wires_i.forEach(hole_wire_i => this._geom_maps.up_wires_faces.set(hole_wire_i, face_i));
        new_tris_i.forEach(tri_i => this._geom_maps.up_tris_faces.set(tri_i, face_i));
        // delete the old trianges
        for (const old_face_tri_i of old_face_tris_i) {
            // remove these deleted tris from the verts
            for (const vert_i of this._geom_maps.dn_tris_verts.get(old_face_tri_i)) {
                const tris_i = this._geom_maps.up_verts_tris.get(vert_i);
                Object(_util_arrs__WEBPACK_IMPORTED_MODULE_1__["arrRem"])(tris_i, old_face_tri_i);
            }
            // tris to verts
            this._geom_maps.dn_tris_verts.delete(old_face_tri_i);
            // tris to faces
            this._geom_maps.up_tris_faces.delete(old_face_tri_i);
        }
        // return the numeric index of the face
        return face_i;
    }
    /**
     * Updates the tris in a face
     * @param face_i
     */
    _updateFaceTris(face_i) {
        const wires_i = this._geom_maps.dn_faces_wires.get(face_i);
        // get the wires
        const border_wire_i = wires_i[0];
        // get the border and holes
        const holes_wires_i = wires_i.slice(1);
        const tris_i = this._geom.add._addTris(border_wire_i, holes_wires_i);
        // delete the old tris
        for (const tri_i of this._geom_maps.dn_faces_tris.get(face_i)) {
            // update the verts
            const verts_i = this._geom_maps.dn_tris_verts.get(tri_i);
            for (const vert_i of verts_i) {
                this._geom_maps.up_verts_tris.delete(vert_i); // up
            }
            // tris to verts
            this._geom_maps.dn_tris_verts.delete(tri_i); // down
            // tris to faces
            this._geom_maps.up_tris_faces.delete(tri_i); // up
        }
        // update down arrays
        this._geom_maps.dn_faces_tris.set(face_i, tris_i);
        // update up arrays
        for (const tri_i of tris_i) {
            this._geom_maps.up_tris_faces.set(tri_i, face_i);
        }
    }
}


/***/ }),

/***/ "./src/assets/libs/geo-info/GIGeomModifyPline.ts":
/*!*******************************************************!*\
  !*** ./src/assets/libs/geo-info/GIGeomModifyPline.ts ***!
  \*******************************************************/
/*! exports provided: GIGeomModifyPline */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GIGeomModifyPline", function() { return GIGeomModifyPline; });
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};
/**
 * Class for modifying plines.
 */
class GIGeomModifyPline {
    /**
     * Constructor
     */
    constructor(geom, geom_arrays) {
        this._geom = geom;
        this._geom_maps = geom_arrays;
    }
    /**
     * Close a polyline.
     * ~
     * If the pline is already closed, do nothing.
     * ~
     */
    closePline(pline_i) {
        const wire_i = this._geom.nav.navPlineToWire(pline_i);
        // get the wire start and end verts
        const wire = this._geom_maps.dn_wires_edges.get(wire_i);
        const num_edges = wire.length;
        const start_edge_i = wire[0];
        const end_edge_i = wire[num_edges - 1];
        const start_vert_i = this._geom.nav.navEdgeToVert(start_edge_i)[0];
        const end_vert_i = this._geom.nav.navEdgeToVert(end_edge_i)[1];
        if (start_vert_i === end_vert_i) {
            return;
        }
        // add the edge to the model
        const new_edge_i = this._geom.add._addEdge(end_vert_i, start_vert_i);
        // update the down arrays
        this._geom_maps.dn_wires_edges.get(wire_i).push(new_edge_i);
        // update the up arrays
        this._geom_maps.up_edges_wires.set(new_edge_i, wire_i);
        // return the new edge
        return new_edge_i;
    }
    /**
     * Open a wire, by deleting the last edge.
     * ~
     * If the wire is already open, do nothing.
     * ~
     * If the wire does not belong to a pline, then do nothing.
     * @param wire_i The wire to close.
     */
    openPline(pline_i) {
        const wire_i = this._geom.nav.navPlineToWire(pline_i);
        // get the pline
        if (pline_i === undefined) {
            return;
        }
        // get the wire start and end verts
        const wire = this._geom_maps.dn_wires_edges.get(wire_i);
        // check wire has more than two edges
        const num_edges = wire.length;
        if (num_edges < 3) {
            return;
        }
        // get start and end
        const start_edge_i = wire[0];
        const end_edge_i = wire[num_edges - 1];
        const start_vert_i = this._geom.nav.navEdgeToVert(start_edge_i)[0];
        const end_vert_i = this._geom.nav.navEdgeToVert(end_edge_i)[1];
        // if this wire is not closed, then return
        if (start_vert_i !== end_vert_i) {
            return;
        }
        // del the end edge from the pline
        this._geom.del_edge.delEdges(end_edge_i, true, false);
    }
}


/***/ }),

/***/ "./src/assets/libs/geo-info/GIGeomNav.ts":
/*!***********************************************!*\
  !*** ./src/assets/libs/geo-info/GIGeomNav.ts ***!
  \***********************************************/
/*! exports provided: GIGeomNav */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GIGeomNav", function() { return GIGeomNav; });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common */ "./src/assets/libs/geo-info/common.ts");
/* harmony import */ var _id__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./id */ "./src/assets/libs/geo-info/id.ts");
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};


/**
 * Class for navigating the geometry.
 */
class GIGeomNav {
    /**
     * Constructor
     */
    constructor(geom, geom_arrays) {
        this._geom = geom;
        this._geom_maps = geom_arrays;
    }
    // ============================================================================
    // Get entities
    // ============================================================================
    getVert(vert_i) {
        return this._geom_maps.dn_verts_posis.get(vert_i);
    }
    getEdge(edge_i) {
        return this._geom_maps.dn_edges_verts.get(edge_i);
    }
    getWire(wire_i) {
        return this._geom_maps.dn_wires_edges.get(wire_i);
    }
    getFace(face_i) {
        return this._geom_maps.dn_faces_wires.get(face_i);
    }
    getPoint(point_i) {
        return this._geom_maps.dn_points_verts.get(point_i);
    }
    getPline(pline_i) {
        return this._geom_maps.dn_plines_wires.get(pline_i);
    }
    getPgon(pgon_i) {
        return this._geom_maps.dn_pgons_faces.get(pgon_i);
    }
    getColl(coll_i) {
        return this._geom_maps.dn_colls_objs.get(coll_i);
    }
    // ============================================================================
    // Navigate down the hierarchy
    // ============================================================================
    navVertToPosi(vert_i) {
        return this._geom_maps.dn_verts_posis.get(vert_i);
    }
    navTriToVert(tri_i) {
        return this._geom_maps.dn_tris_verts.get(tri_i);
    }
    navEdgeToVert(edge_i) {
        return this._geom_maps.dn_edges_verts.get(edge_i);
    }
    navWireToEdge(wire_i) {
        return this._geom_maps.dn_wires_edges.get(wire_i);
    }
    navFaceToWire(face_i) {
        return this._geom_maps.dn_faces_wires.get(face_i);
    }
    navFaceToTri(face_i) {
        return this._geom_maps.dn_faces_tris.get(face_i);
    }
    navPointToVert(point_i) {
        return this._geom_maps.dn_points_verts.get(point_i);
    }
    navPlineToWire(line_i) {
        return this._geom_maps.dn_plines_wires.get(line_i);
    }
    navPgonToFace(pgon_i) {
        return this._geom_maps.dn_pgons_faces.get(pgon_i);
    }
    navCollToPoint(coll_i) {
        // get the descendants of this collection
        const coll_and_desc_i = this._geom.query.getCollDescendents(coll_i);
        // if no descendants, just return the the ents in this coll
        if (coll_and_desc_i.length === 0) {
            return this._geom_maps.dn_colls_objs.get(coll_i)[1]; // coll points
        }
        // we have descendants, so get all points
        coll_and_desc_i.splice(0, 0, coll_i);
        const points_i_set = new Set();
        for (const one_coll_i of coll_and_desc_i) {
            for (const point_i of this._geom_maps.dn_colls_objs.get(one_coll_i)[1]) {
                points_i_set.add(point_i);
            }
        }
        return Array.from(points_i_set);
    }
    navCollToPline(coll_i) {
        // get the descendants of this collection
        const coll_and_desc_i = this._geom.query.getCollDescendents(coll_i);
        // if no descendants, just return the the ents in this coll
        if (coll_and_desc_i.length === 0) {
            return this._geom_maps.dn_colls_objs.get(coll_i)[2]; // coll lines
        }
        // we have descendants, so get all plines
        coll_and_desc_i.splice(0, 0, coll_i);
        const plines_i_set = new Set();
        for (const one_coll_i of coll_and_desc_i) {
            for (const pline_i of this._geom_maps.dn_colls_objs.get(one_coll_i)[2]) {
                plines_i_set.add(pline_i);
            }
        }
        return Array.from(plines_i_set);
    }
    navCollToPgon(coll_i) {
        // get the descendants of this collection
        const coll_and_desc_i = this._geom.query.getCollDescendents(coll_i);
        // if no descendants, just return the the ents in this coll
        if (coll_and_desc_i.length === 0) {
            return this._geom_maps.dn_colls_objs.get(coll_i)[3]; // coll pgons
        }
        // we have descendants, so get all pgons
        coll_and_desc_i.splice(0, 0, coll_i);
        const pgons_i_set = new Set();
        for (const one_coll_i of coll_and_desc_i) {
            for (const pgon_i of this._geom_maps.dn_colls_objs.get(one_coll_i)[3]) {
                pgons_i_set.add(pgon_i);
            }
        }
        return Array.from(pgons_i_set);
    }
    navCollToCollChildren(coll_i) {
        return this._geom.query.getCollChildren(coll_i); // coll children
    }
    // ============================================================================
    // Navigate up the hierarchy
    // ============================================================================
    navPosiToVert(posi_i) {
        return this._geom_maps.up_posis_verts.get(posi_i);
    }
    navVertToTri(vert_i) {
        return this._geom_maps.up_verts_tris.get(vert_i);
    }
    navVertToEdge(vert_i) {
        return this._geom_maps.up_verts_edges.get(vert_i);
    }
    navTriToFace(tri_i) {
        return this._geom_maps.up_tris_faces.get(tri_i);
    }
    navEdgeToWire(edge_i) {
        return this._geom_maps.up_edges_wires.get(edge_i);
    }
    navWireToFace(wire_i) {
        return this._geom_maps.up_wires_faces.get(wire_i);
    }
    navVertToPoint(vert_i) {
        return this._geom_maps.up_verts_points.get(vert_i);
    }
    navWireToPline(wire_i) {
        return this._geom_maps.up_wires_plines.get(wire_i);
    }
    navFaceToPgon(face) {
        return this._geom_maps.up_faces_pgons.get(face);
    }
    navPointToColl(point_i) {
        return this._geom_maps.up_points_colls.get(point_i);
    }
    navPlineToColl(line_i) {
        return this._geom_maps.up_plines_colls.get(line_i);
    }
    navPgonToColl(pgon_i) {
        return this._geom_maps.up_pgons_colls.get(pgon_i);
    }
    navCollToCollParent(coll_i) {
        return this._geom.query.getCollParent(coll_i); // coll parent
    }
    // ============================================================================
    // Navigate from any level to ? (up or down)
    // ============================================================================
    /**
     * Navigate from any level to the colls
     * @param ent_type
     * @param index
     */
    navAnyToColl(ent_type, index) {
        if (Object(_id__WEBPACK_IMPORTED_MODULE_1__["isColl"])(ent_type)) {
            return [index];
        }
        const points_i = this.navAnyToPoint(ent_type, index);
        const colls1_i = [].concat(...points_i.map(point_i => this.navPointToColl(point_i)));
        const plines_i = this.navAnyToPline(ent_type, index);
        const colls2_i = [].concat(...plines_i.map(pline_i => this.navPlineToColl(pline_i)));
        const pgons_i = this.navAnyToPgon(ent_type, index);
        const colls3_i = [].concat(...pgons_i.map(pgon_i => this.navPgonToColl(pgon_i)));
        return Array.from(new Set([...colls1_i, ...colls2_i, ...colls3_i])).filter(coll_i => coll_i !== undefined); // remove duplicates
    }
    /**
     * Navigate from any level to the pgons
     * @param ent_type
     * @param index
     */
    navAnyToPgon(ent_type, index) {
        if (Object(_id__WEBPACK_IMPORTED_MODULE_1__["isPgon"])(ent_type)) {
            return [index];
        }
        const faces_i = this.navAnyToFace(ent_type, index);
        return faces_i.map(face_i => this.navFaceToPgon(face_i)).filter(pgon_i => pgon_i !== undefined);
    }
    /**
     * Navigate from any level to the plines
     * @param ent_type
     * @param index
     */
    navAnyToPline(ent_type, index) {
        if (Object(_id__WEBPACK_IMPORTED_MODULE_1__["isPline"])(ent_type)) {
            return [index];
        }
        const wires_i = this.navAnyToWire(ent_type, index);
        return wires_i.map(wire_i => this.navWireToPline(wire_i)).filter(pline_i => pline_i !== undefined);
    }
    /**
     * Navigate from any level to the points
     * @param ent_type
     * @param index
     */
    navAnyToPoint(ent_type, index) {
        if (Object(_id__WEBPACK_IMPORTED_MODULE_1__["isPoint"])(ent_type)) {
            return [index];
        }
        const verts_i = this.navAnyToVert(ent_type, index);
        return verts_i.map(vert_i => this.navVertToPoint(vert_i)).filter(point_i => point_i !== undefined);
    }
    /**
     * Navigate from any level to the faces
     * @param ent_type
     * @param index
     */
    navAnyToFace(ent_type, index) {
        if (Object(_id__WEBPACK_IMPORTED_MODULE_1__["isPosi"])(ent_type)) {
            const verts_i = this.navPosiToVert(index);
            // avoid getting duplicates
            const faces_i_set = new Set();
            for (const vert_i of verts_i) {
                const faces_i = this.navAnyToFace(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].VERT, vert_i);
                for (const face_i of faces_i) {
                    faces_i_set.add(face_i);
                }
            }
            return Array.from(new Set(faces_i_set));
        }
        else if (Object(_id__WEBPACK_IMPORTED_MODULE_1__["isVert"])(ent_type)) {
            const edges_i = this.navVertToEdge(index); // two edges
            return this.navAnyToFace(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].EDGE, edges_i[0]);
        }
        else if (Object(_id__WEBPACK_IMPORTED_MODULE_1__["isTri"])(ent_type)) {
            return [this.navTriToFace(index)];
        }
        else if (Object(_id__WEBPACK_IMPORTED_MODULE_1__["isEdge"])(ent_type)) {
            const wire_i = this.navEdgeToWire(index);
            return this.navAnyToFace(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].WIRE, wire_i);
        }
        else if (Object(_id__WEBPACK_IMPORTED_MODULE_1__["isWire"])(ent_type)) {
            return [this.navWireToFace(index)];
        }
        else if (Object(_id__WEBPACK_IMPORTED_MODULE_1__["isFace"])(ent_type)) { // target
            return [index];
        }
        else if (Object(_id__WEBPACK_IMPORTED_MODULE_1__["isPoint"])(ent_type)) {
            return [];
        }
        else if (Object(_id__WEBPACK_IMPORTED_MODULE_1__["isPline"])(ent_type)) {
            return [];
        }
        else if (Object(_id__WEBPACK_IMPORTED_MODULE_1__["isPgon"])(ent_type)) {
            return [this.navPgonToFace(index)];
        }
        else if (Object(_id__WEBPACK_IMPORTED_MODULE_1__["isColl"])(ent_type)) {
            const pgons_i = this.navCollToPgon(index);
            return pgons_i.map(pgon_i => this.navPgonToFace(pgon_i));
        }
        throw new Error('Bad navigation in geometry data structure: ' + ent_type + index);
    }
    /**
     * Navigate from any level to the wires
     * @param ent_type
     * @param index
     */
    navAnyToWire(ent_type, index) {
        if (Object(_id__WEBPACK_IMPORTED_MODULE_1__["isPosi"])(ent_type)) {
            const verts_i = this.navPosiToVert(index);
            // avoid getting duplicates
            const wires_i_set = new Set();
            for (const vert_i of verts_i) {
                const wires_i = this.navAnyToWire(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].VERT, vert_i);
                for (const wire_i of wires_i) {
                    wires_i_set.add(wire_i);
                }
            }
            return Array.from(new Set(wires_i_set));
        }
        else if (Object(_id__WEBPACK_IMPORTED_MODULE_1__["isVert"])(ent_type)) {
            const edges_i = this.navVertToEdge(index);
            return [].concat(...edges_i.map(edge_i => this.navEdgeToWire(edge_i)));
        }
        else if (Object(_id__WEBPACK_IMPORTED_MODULE_1__["isTri"])(ent_type)) {
            return [];
        }
        else if (Object(_id__WEBPACK_IMPORTED_MODULE_1__["isEdge"])(ent_type)) {
            return [this.navEdgeToWire(index)];
        }
        else if (Object(_id__WEBPACK_IMPORTED_MODULE_1__["isWire"])(ent_type)) { // target
            return [index];
        }
        else if (Object(_id__WEBPACK_IMPORTED_MODULE_1__["isFace"])(ent_type)) {
            return this.navFaceToWire(index);
        }
        else if (Object(_id__WEBPACK_IMPORTED_MODULE_1__["isPoint"])(ent_type)) {
            return [];
        }
        else if (Object(_id__WEBPACK_IMPORTED_MODULE_1__["isPline"])(ent_type)) {
            return [this.navPlineToWire(index)];
        }
        else if (Object(_id__WEBPACK_IMPORTED_MODULE_1__["isPgon"])(ent_type)) {
            const face_i = this.navPgonToFace(index);
            return this.navFaceToWire(face_i);
        }
        else if (Object(_id__WEBPACK_IMPORTED_MODULE_1__["isColl"])(ent_type)) {
            const all_wires_i = [];
            const plines_i = this.navCollToPline(index);
            for (const pline_i of plines_i) {
                const wire_i = this.navPlineToWire(pline_i);
                all_wires_i.push(wire_i);
            }
            const pgons_i = this.navCollToPgon(index);
            for (const pgon_i of pgons_i) {
                const wires_i = this.navAnyToWire(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PGON, pgon_i);
                for (const wire_i of wires_i) {
                    all_wires_i.push(wire_i);
                }
            }
            return all_wires_i;
        }
        throw new Error('Bad navigation in geometry data structure: ' + ent_type + index);
    }
    /**
     * Navigate from any level to the edges
     * @param ent_type
     * @param index
     */
    navAnyToEdge(ent_type, index) {
        if (Object(_id__WEBPACK_IMPORTED_MODULE_1__["isPosi"])(ent_type)) {
            const verts_i = this.navPosiToVert(index);
            return [].concat(...verts_i.map(vert_i => this.navVertToEdge(vert_i)));
        }
        else if (Object(_id__WEBPACK_IMPORTED_MODULE_1__["isVert"])(ent_type)) {
            return this.navVertToEdge(index);
        }
        else if (Object(_id__WEBPACK_IMPORTED_MODULE_1__["isTri"])(ent_type)) {
            return [];
        }
        else if (Object(_id__WEBPACK_IMPORTED_MODULE_1__["isEdge"])(ent_type)) {
            return [index];
        }
        else if (Object(_id__WEBPACK_IMPORTED_MODULE_1__["isWire"])(ent_type)) {
            return this.navWireToEdge(index);
        }
        else if (Object(_id__WEBPACK_IMPORTED_MODULE_1__["isFace"])(ent_type)) {
            const wires_i = this.navFaceToWire(index);
            return [].concat(...wires_i.map(wire_i => this.navWireToEdge(wire_i)));
        }
        else if (Object(_id__WEBPACK_IMPORTED_MODULE_1__["isPoint"])(ent_type)) {
            return [];
        }
        else if (Object(_id__WEBPACK_IMPORTED_MODULE_1__["isPline"])(ent_type)) {
            const wire_i = this.navPlineToWire(index);
            return this.navAnyToEdge(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].WIRE, wire_i);
        }
        else if (Object(_id__WEBPACK_IMPORTED_MODULE_1__["isPgon"])(ent_type)) {
            const face_i = this.navPgonToFace(index);
            return this.navAnyToEdge(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].FACE, face_i);
        }
        else if (Object(_id__WEBPACK_IMPORTED_MODULE_1__["isColl"])(ent_type)) {
            const all_edges_i = [];
            const plines_i = this.navCollToPline(index);
            for (const pline_i of plines_i) {
                const edges_i = this.navAnyToEdge(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PLINE, pline_i);
                for (const edge_i of edges_i) {
                    all_edges_i.push(edge_i);
                }
            }
            const pgons_i = this.navCollToPgon(index);
            for (const pgon_i of pgons_i) {
                const edges_i = this.navAnyToEdge(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PGON, pgon_i);
                for (const edge_i of edges_i) {
                    all_edges_i.push(edge_i);
                }
            }
            return all_edges_i;
        }
        throw new Error('Bad navigation in geometry data structure: ' + ent_type + index);
    }
    /**
     * Navigate from any level to the vertices
     * @param ent_type
     * @param index
     */
    navAnyToVert(ent_type, index) {
        if (Object(_id__WEBPACK_IMPORTED_MODULE_1__["isPosi"])(ent_type)) {
            return this.navPosiToVert(index);
        }
        else if (Object(_id__WEBPACK_IMPORTED_MODULE_1__["isVert"])(ent_type)) {
            return [index];
        }
        else if (Object(_id__WEBPACK_IMPORTED_MODULE_1__["isTri"])(ent_type)) {
            return this.navTriToVert(index);
        }
        else if (Object(_id__WEBPACK_IMPORTED_MODULE_1__["isEdge"])(ent_type)) {
            return this.navEdgeToVert(index);
        }
        else if (Object(_id__WEBPACK_IMPORTED_MODULE_1__["isWire"])(ent_type)) {
            return this._geom.query.getWireVerts(index); // avoids duplicate verts
        }
        else if (Object(_id__WEBPACK_IMPORTED_MODULE_1__["isFace"])(ent_type)) {
            const wires_i = this.navFaceToWire(index);
            const verts_i = [];
            for (const wire_i of wires_i) {
                const wire_verts_i = this._geom.query.getWireVerts(wire_i); // avoids duplicate verts
                for (const vert_i of wire_verts_i) {
                    verts_i.push(vert_i);
                }
            }
            return verts_i;
        }
        else if (Object(_id__WEBPACK_IMPORTED_MODULE_1__["isPoint"])(ent_type)) {
            return [this.navPointToVert(index)];
        }
        else if (Object(_id__WEBPACK_IMPORTED_MODULE_1__["isPline"])(ent_type)) {
            const wire_i = this.navPlineToWire(index);
            return this.navAnyToVert(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].WIRE, wire_i);
        }
        else if (Object(_id__WEBPACK_IMPORTED_MODULE_1__["isPgon"])(ent_type)) {
            const face_i = this.navPgonToFace(index);
            return this.navAnyToVert(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].FACE, face_i);
        }
        else if (Object(_id__WEBPACK_IMPORTED_MODULE_1__["isColl"])(ent_type)) {
            const all_verts_i = [];
            const points_i = this.navCollToPoint(index);
            for (const point_i of points_i) {
                const vert_i = this.navPointToVert(point_i);
                all_verts_i.push(vert_i);
            }
            const plines_i = this.navCollToPline(index);
            for (const pline_i of plines_i) {
                const verts_i = this.navAnyToVert(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PLINE, pline_i);
                for (const vert_i of verts_i) {
                    all_verts_i.push(vert_i);
                }
            }
            const pgons_i = this.navCollToPgon(index);
            for (const pgon_i of pgons_i) {
                const verts_i = this.navAnyToVert(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PGON, pgon_i);
                for (const vert_i of verts_i) {
                    all_verts_i.push(vert_i);
                }
            }
            return all_verts_i;
        }
        throw new Error('Bad navigation in geometry data structure: ' + ent_type + index);
    }
    /**
     * Navigate from any level to the triangles
     * @param ent_type
     * @param index
     */
    navAnyToTri(ent_type, index) {
        if (Object(_id__WEBPACK_IMPORTED_MODULE_1__["isPosi"])(ent_type)) {
            const verts_i = this.navPosiToVert(index);
            return [].concat(...verts_i.map(vert_i => this.navVertToTri(vert_i)));
        }
        else if (Object(_id__WEBPACK_IMPORTED_MODULE_1__["isVert"])(ent_type)) {
            return this.navVertToTri(index);
        }
        else if (Object(_id__WEBPACK_IMPORTED_MODULE_1__["isTri"])(ent_type)) {
            return [index];
        }
        else if (Object(_id__WEBPACK_IMPORTED_MODULE_1__["isEdge"])(ent_type)) {
            return [];
        }
        else if (Object(_id__WEBPACK_IMPORTED_MODULE_1__["isWire"])(ent_type)) {
            return [];
        }
        else if (Object(_id__WEBPACK_IMPORTED_MODULE_1__["isFace"])(ent_type)) {
            return this.navFaceToTri(index);
        }
        else if (Object(_id__WEBPACK_IMPORTED_MODULE_1__["isPoint"])(ent_type)) {
            return [];
        }
        else if (Object(_id__WEBPACK_IMPORTED_MODULE_1__["isPline"])(ent_type)) {
            return [];
        }
        else if (Object(_id__WEBPACK_IMPORTED_MODULE_1__["isPgon"])(ent_type)) {
            const face_i = this.navPgonToFace(index);
            return this.navFaceToTri(face_i);
        }
        else if (Object(_id__WEBPACK_IMPORTED_MODULE_1__["isColl"])(ent_type)) {
            const all_tris_i = [];
            const pgons_i = this.navCollToPgon(index);
            for (const pgon_i of pgons_i) {
                const tris_i = this.navAnyToTri(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PGON, pgon_i);
                for (const tri_i of tris_i) {
                    all_tris_i.push(tri_i);
                }
            }
            return all_tris_i;
        }
        throw new Error('Bad navigation in geometry data structure: ' + ent_type + index);
    }
    /**
     * Navigate from any level to the positions
     * @param ent_type
     * @param index
     */
    navAnyToPosi(ent_type, index) {
        if (Object(_id__WEBPACK_IMPORTED_MODULE_1__["isPosi"])(ent_type)) {
            return [index];
        }
        const verts_i = this.navAnyToVert(ent_type, index);
        const posis_i = verts_i.map(vert_i => this.navVertToPosi(vert_i));
        return Array.from(new Set(posis_i)); // remove duplicates
    }
    // ============================================================================
    // Navigate from any to any, general method
    // ============================================================================
    /**
     * Navigate from any level down to the positions
     * @param index
     */
    navAnyToAny(from_ets, to_ets, index) {
        // check if this is nav coll to coll
        // for coll to coll, we assume we are going down, from parent to children
        if (from_ets === _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].COLL && to_ets === _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].COLL) {
            return this.navCollToCollChildren(index);
        }
        // same level
        if (from_ets === to_ets) {
            return [index];
        }
        // from -> to
        switch (to_ets) {
            case _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POSI:
                return this.navAnyToPosi(from_ets, index);
            case _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].VERT:
                return this.navAnyToVert(from_ets, index);
            case _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].EDGE:
                return this.navAnyToEdge(from_ets, index);
            case _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].WIRE:
                return this.navAnyToWire(from_ets, index);
            case _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].FACE:
                return this.navAnyToFace(from_ets, index);
            case _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POINT:
                return this.navAnyToPoint(from_ets, index);
            case _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PLINE:
                return this.navAnyToPline(from_ets, index);
            case _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PGON:
                return this.navAnyToPgon(from_ets, index);
            case _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].COLL:
                return this.navAnyToColl(from_ets, index);
            default:
                throw new Error('Bad navigation in geometry data structure: ' + to_ets + index);
        }
    }
}


/***/ }),

/***/ "./src/assets/libs/geo-info/GIGeomQuery.ts":
/*!*************************************************!*\
  !*** ./src/assets/libs/geo-info/GIGeomQuery.ts ***!
  \*************************************************/
/*! exports provided: GIGeomQuery */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GIGeomQuery", function() { return GIGeomQuery; });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common */ "./src/assets/libs/geo-info/common.ts");
/* harmony import */ var _id__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./id */ "./src/assets/libs/geo-info/id.ts");
/* harmony import */ var _geom_vectors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../geom/vectors */ "./src/assets/libs/geom/vectors.ts");
/* harmony import */ var mathjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! mathjs */ "./node_modules/mathjs/index.js");
/* harmony import */ var mathjs__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(mathjs__WEBPACK_IMPORTED_MODULE_3__);
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};




/**
 * Class for geometry.
 */
class GIGeomQuery {
    /**
     * Constructor
     */
    constructor(geom, geom_arrays) {
        this._geom = geom;
        this._geom_maps = geom_arrays;
    }
    // ============================================================================
    // Entities
    // ============================================================================
    /**
     * Returns a list of indices for ents.
     * @param ent_type
     */
    getEnts(ent_type) {
        // get ents indices array from down arrays
        const geom_map_key = _common__WEBPACK_IMPORTED_MODULE_0__["EEntStrToGeomMaps"][ent_type];
        const geom_map = this._geom_maps[geom_map_key];
        return Array.from(geom_map.keys());
        // const ents_i: number[] = [];
        // geom_map.forEach( (_, i) => ents_i.push(i) );
        // return ents_i;
    }
    /**
     * Returns the number of entities
     */
    numEnts(ent_type) {
        const geom_array_key = _common__WEBPACK_IMPORTED_MODULE_0__["EEntStrToGeomMaps"][ent_type];
        return this._geom_maps[geom_array_key].size;
    }
    /**
     * Returns the number of entities for [posis, point, polylines, polygons, collections].
     */
    numEntsAll() {
        return [
            this.numEnts(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POSI),
            this.numEnts(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POINT),
            this.numEnts(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PLINE),
            this.numEnts(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PGON),
            this.numEnts(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].COLL)
        ];
    }
    /**
     * Check if an entity exists
     * @param ent_type
     * @param index
     */
    entExists(ent_type, index) {
        // if (ent_type === EEntType.POSI) {
        //     return this._geom_maps.up_posis_verts.has(index);
        // }
        const geom_arrays_key = _common__WEBPACK_IMPORTED_MODULE_0__["EEntStrToGeomMaps"][ent_type];
        return this._geom_maps[geom_arrays_key].has(index);
    }
    /**
     * Returns sets of unique indexes, given an array of TEntTypeIdx.
     * ~
     * Object positions are added to the geompack.
     * ~
     * Collections contents is added to teh geompack, including nested collections..
     * ~
     * If invert=true, then the geompack will include the opposite set of entities.
     * ~
     * Used for deleting all entities.
     */
    getDelEntSets(ents) {
        const set_posis_i = new Set();
        const set_ent_posis_i = new Set();
        const set_points_i = new Set();
        const set_plines_i = new Set();
        const set_pgons_i = new Set();
        const set_colls_i = new Set();
        // process all the ents, but not posis of the ents, we will do that at the end
        for (const ent_arr of ents) {
            const [ent_type, ent_i] = ent_arr;
            if (Object(_id__WEBPACK_IMPORTED_MODULE_1__["isColl"])(ent_type)) {
                // get the descendants of this collection
                const coll_and_desc_i = this._geom.query.getCollDescendents(ent_i);
                coll_and_desc_i.splice(0, 0, ent_i);
                // get all the objs
                for (const one_coll_i of coll_and_desc_i) {
                    for (const point_i of this._geom_maps.dn_colls_objs.get(one_coll_i)[1]) {
                        set_points_i.add(point_i);
                    }
                    for (const pline_i of this._geom_maps.dn_colls_objs.get(one_coll_i)[2]) {
                        set_plines_i.add(pline_i);
                    }
                    for (const pgon_i of this._geom_maps.dn_colls_objs.get(one_coll_i)[3]) {
                        set_pgons_i.add(pgon_i);
                    }
                    set_colls_i.add(one_coll_i);
                }
            }
            else if (Object(_id__WEBPACK_IMPORTED_MODULE_1__["isPgon"])(ent_type)) {
                set_pgons_i.add(ent_i);
            }
            else if (Object(_id__WEBPACK_IMPORTED_MODULE_1__["isPline"])(ent_type)) {
                set_plines_i.add(ent_i);
            }
            else if (Object(_id__WEBPACK_IMPORTED_MODULE_1__["isPoint"])(ent_type)) {
                set_points_i.add(ent_i);
            }
            else if (Object(_id__WEBPACK_IMPORTED_MODULE_1__["isPosi"])(ent_type)) {
                set_posis_i.add(ent_i);
            }
        }
        // now get all the posis of the ents and add them to the list
        set_points_i.forEach(point_i => {
            const posis_i = this._geom.nav.navAnyToPosi(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POINT, point_i);
            for (const posi_i of posis_i) {
                set_ent_posis_i.add(posi_i);
            }
        });
        set_plines_i.forEach(pline_i => {
            const posis_i = this._geom.nav.navAnyToPosi(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PLINE, pline_i);
            for (const posi_i of posis_i) {
                set_ent_posis_i.add(posi_i);
            }
        });
        set_pgons_i.forEach(pgon_i => {
            const posis_i = this._geom.nav.navAnyToPosi(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PGON, pgon_i);
            for (const posi_i of posis_i) {
                set_ent_posis_i.add(posi_i);
            }
        });
        // if no invert, then return the result
        return {
            posis_i: set_posis_i,
            points_i: set_points_i,
            plines_i: set_plines_i,
            pgons_i: set_pgons_i,
            colls_i: set_colls_i,
            obj_posis_i: set_ent_posis_i
        };
    }
    /**
     * Fill a map of sets of unique indexes
     */
    getEntSets(ents, ent_types) {
        const set_ent_types = new Set(ent_types);
        const map = new Map();
        ent_types.forEach(ent_type => map.set(ent_type, new Set()));
        for (const [ent_type, ent_i] of ents) {
            if (set_ent_types.has(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].COLL)) {
                this._geom.nav.navAnyToColl(ent_type, ent_i).forEach(coll_i => map.get(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].COLL).add(coll_i));
            }
            if (set_ent_types.has(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PGON)) {
                this._geom.nav.navAnyToPgon(ent_type, ent_i).forEach(pgon_i => map.get(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PGON).add(pgon_i));
            }
            if (set_ent_types.has(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PLINE)) {
                this._geom.nav.navAnyToPline(ent_type, ent_i).forEach(pline_i => map.get(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PLINE).add(pline_i));
            }
            if (set_ent_types.has(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POINT)) {
                this._geom.nav.navAnyToPoint(ent_type, ent_i).forEach(point_i => map.get(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POINT).add(point_i));
            }
            if (set_ent_types.has(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].FACE)) {
                this._geom.nav.navAnyToFace(ent_type, ent_i).forEach(face_i => map.get(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].FACE).add(face_i));
            }
            if (set_ent_types.has(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].WIRE)) {
                this._geom.nav.navAnyToWire(ent_type, ent_i).forEach(wire_i => map.get(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].WIRE).add(wire_i));
            }
            if (set_ent_types.has(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].EDGE)) {
                this._geom.nav.navAnyToEdge(ent_type, ent_i).forEach(edge_i => map.get(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].EDGE).add(edge_i));
            }
            if (set_ent_types.has(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].VERT)) {
                this._geom.nav.navAnyToVert(ent_type, ent_i).forEach(vert_i => map.get(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].VERT).add(vert_i));
            }
            if (set_ent_types.has(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POSI)) {
                this._geom.nav.navAnyToPosi(ent_type, ent_i).forEach(posi_i => map.get(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POSI).add(posi_i));
            }
        }
        return map;
    }
    // ============================================================================
    // Posis
    // ============================================================================
    /**
     * Returns a list of indices for all posis that have no verts
     */
    getUnusedPosis() {
        const posis_i = [];
        this._geom_maps.up_posis_verts.forEach((posi, posi_i) => {
            if (posi.length === 0) {
                posis_i.push(posi_i);
            }
        });
        return posis_i;
    }
    // ============================================================================
    // Verts
    // ============================================================================
    /**
     * Get two edges that are adjacent to this vertex that are both not zero length.
     * In some cases wires and polygons have edges that are zero length.
     * This causes problems for calculating normals etc.
     * The return value can be either one edge (in open polyline [null, edge_i], [edge_i, null])
     * or two edges (in all other cases) [edge_i, edge_i].
     * If the vert has no non-zero edges, then [null, null] is returned.
     * @param vert_i
     */
    getVertNonZeroEdges(vert_i) {
        // get the wire start and end verts
        const edges_i = this._geom_maps.up_verts_edges.get(vert_i);
        const posi_coords = [];
        // get the first edge
        let edge0 = null;
        if (edges_i[0] !== null || edges_i[0] !== undefined) {
            let prev_edge_i = edges_i[0];
            while (edge0 === null) {
                if (prev_edge_i === edges_i[1]) {
                    break;
                }
                const edge_verts_i = this._geom_maps.dn_edges_verts.get(prev_edge_i);
                // first
                const posi0_i = this._geom_maps.dn_verts_posis.get(edge_verts_i[0]);
                if (posi_coords[posi0_i] === undefined) {
                    posi_coords[posi0_i] = this._geom.modeldata.attribs.query.getPosiCoords(posi0_i);
                }
                const xyz0 = posi_coords[posi0_i];
                // second
                const posi1_i = this._geom_maps.dn_verts_posis.get(edge_verts_i[1]);
                if (posi_coords[posi1_i] === undefined) {
                    posi_coords[posi1_i] = this._geom.modeldata.attribs.query.getPosiCoords(posi1_i);
                }
                const xyz1 = posi_coords[posi1_i];
                // check
                if (Math.abs(xyz0[0] - xyz1[0]) > 0 || Math.abs(xyz0[1] - xyz1[1]) > 0 || Math.abs(xyz0[2] - xyz1[2]) > 0) {
                    edge0 = prev_edge_i;
                }
                else {
                    prev_edge_i = this._geom_maps.up_verts_edges.get(edge_verts_i[0])[0];
                    if (prev_edge_i === null || prev_edge_i === undefined) {
                        break;
                    }
                }
            }
        }
        // get the second edge
        let edge1 = null;
        if (edges_i[1] !== null || edges_i[1] !== undefined) {
            let next_edge_i = edges_i[1];
            while (edge1 === null) {
                if (next_edge_i === edges_i[0]) {
                    break;
                }
                const edge_verts_i = this._geom_maps.dn_edges_verts.get(next_edge_i);
                // first
                const posi0_i = this._geom_maps.dn_verts_posis.get(edge_verts_i[0]);
                if (posi_coords[posi0_i] === undefined) {
                    posi_coords[posi0_i] = this._geom.modeldata.attribs.query.getPosiCoords(posi0_i);
                }
                const xyz0 = posi_coords[posi0_i];
                // second
                const posi1_i = this._geom_maps.dn_verts_posis.get(edge_verts_i[1]);
                if (posi_coords[posi1_i] === undefined) {
                    posi_coords[posi1_i] = this._geom.modeldata.attribs.query.getPosiCoords(posi1_i);
                }
                const xyz1 = posi_coords[posi1_i];
                // check
                if (Math.abs(xyz0[0] - xyz1[0]) > 0 || Math.abs(xyz0[1] - xyz1[1]) > 0 || Math.abs(xyz0[2] - xyz1[2]) > 0) {
                    edge1 = next_edge_i;
                }
                else {
                    next_edge_i = this._geom_maps.up_verts_edges.get(edge_verts_i[1])[1];
                    if (next_edge_i === null || next_edge_i === undefined) {
                        break;
                    }
                }
            }
        }
        // return the two edges, they can be null
        return [edge0, edge1];
    }
    // ============================================================================
    // Edges
    // ============================================================================
    /**
     * Get the next edge in a sequence of edges
     * @param edge_i
     */
    getNextEdge(edge_i) {
        // get the wire start and end verts
        const edge = this._geom_maps.dn_edges_verts.get(edge_i);
        const edges_i = this._geom_maps.up_verts_edges.get(edge[1]);
        if (edges_i.length === 1) {
            return null;
        }
        return edges_i[1];
    }
    /**
     * Get the previous edge in a sequence of edges
     * @param edge_i
     */
    getPrevEdge(edge_i) {
        // get the wire start and end verts
        const edge = this._geom_maps.dn_edges_verts.get(edge_i);
        const edges_i = this._geom_maps.up_verts_edges.get(edge[0]);
        if (edges_i.length === 1) {
            return null;
        }
        return edges_i[1];
    }
    /**
     * Get a list of edges that are neighbours ()
     * The list will include the input edge.
     * @param edge_i
     */
    getNeighborEdges(edge_i) {
        // get the wire start and end verts
        const edge = this._geom_maps.dn_edges_verts.get(edge_i);
        const start_posi_i = this._geom_maps.dn_verts_posis.get(edge[0]);
        const end_posi_i = this._geom_maps.dn_verts_posis.get(edge[1]);
        const start_edges_i = this._geom.nav.navAnyToEdge(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POSI, start_posi_i);
        const end_edges_i = this._geom.nav.navAnyToEdge(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POSI, end_posi_i);
        return mathjs__WEBPACK_IMPORTED_MODULE_3__["setIntersect"](start_edges_i, end_edges_i);
    }
    // ============================================================================
    // Wires
    // ============================================================================
    /**
     * Check if a wire is closed.
     * @param wire_i
     */
    isWireClosed(wire_i) {
        // get the wire start and end verts
        const wire = this._geom_maps.dn_wires_edges.get(wire_i);
        const num_edges = wire.length;
        const start_edge_i = wire[0];
        const end_edge_i = wire[num_edges - 1];
        const start_vert_i = this._geom.nav.navEdgeToVert(start_edge_i)[0];
        const end_vert_i = this._geom.nav.navEdgeToVert(end_edge_i)[1];
        // if start and end verts are the same, then wire is closed
        return (start_vert_i === end_vert_i);
    }
    /**
     * Check if a wire belongs to a pline, a pgon or a pgon hole.
     */
    getWireType(wire_i) {
        // get the wire start and end verts
        const wire = this._geom_maps.dn_wires_edges.get(wire_i);
        if (this._geom.nav.navWireToPline(wire_i) !== undefined) {
            return _common__WEBPACK_IMPORTED_MODULE_0__["EWireType"].PLINE;
        }
        const face_i = this._geom.nav.navWireToFace(wire_i);
        const face = this._geom.nav.getFace(face_i);
        const index = face.indexOf(wire_i);
        if (index === 0) {
            return _common__WEBPACK_IMPORTED_MODULE_0__["EWireType"].PGON;
        }
        if (index > 0) {
            return _common__WEBPACK_IMPORTED_MODULE_0__["EWireType"].PGON_HOLE;
        }
        throw new Error('Inconsistencies found in the internal data structure.');
    }
    /**
     * Returns the vertices.
     * For a closed wire, #vertices = #edges
     * For an open wire, #vertices = #edges + 1
     * @param wire_i
     */
    getWireVerts(wire_i) {
        const edges_i = this._geom_maps.dn_wires_edges.get(wire_i);
        const verts_i = [];
        // walk the edges chain
        let next_edge_i = edges_i[0];
        for (let i = 0; i < edges_i.length; i++) {
            const edge_verts_i = this._geom_maps.dn_edges_verts.get(next_edge_i);
            verts_i.push(edge_verts_i[0]);
            next_edge_i = this.getNextEdge(next_edge_i);
            // are we at the end of the chain
            if (next_edge_i === null) { // open wire
                verts_i.push(edge_verts_i[1]);
                break;
            }
            else if (next_edge_i === edges_i[0]) { // closed wire
                break;
            }
        }
        return verts_i;
    }
    // ============================================================================
    // Objects
    // ============================================================================
    // /**
    //  * Returns three arrays of pairs of maps, for points, plines, and pgons.
    //  * This is used for creating a timeline, and is based on an attribute called "visible"
    //  * on collections.
    //  * The visible attribute is an array of strings, where each string is a time-stamp label.
    //  * ~
    //  * For the first map in each pair, keys are the group names, and values are a set of entitie IDs.
    //  * For the second map in each pair, keys are the time-stamp names, and values are a set of group names.
    //  * @return Array of arrays of maps.
    //  */
    // public getObjVisGroups(): [ {}, Map<string, Set<string>> ] {
    //     if (!this._geom.modeldata.attribs.query.hasAttrib(EEntType.COLL, 'visible')) {
    //         return null;
    //     }
    //     // return the result
    //     const colls_i: number[] = this.getEnts(EEntType.COLL);
    //     const full_obj_grp = {'default': []};
    //     const full_lbl_grp = new Map<string, Set<string>>();
    //     const grps = [  this._getObjVisGroups(colls_i, EEntType.POINT),
    //                     this._getObjVisGroups(colls_i, EEntType.EDGE),
    //                     this._getObjVisGroups(colls_i, EEntType.TRI)];
    //     for (let i = 0; i < grps.length; i ++) {
    //         const grp = grps[i];
    //         console.log(grp)
    //         full_obj_grp['default'][i] = grp[0].get('default');
    //         grp[1].forEach((val, key) => {
    //             let lbl_grp = full_lbl_grp.get(key);
    //             if (!lbl_grp) { lbl_grp = new Set<string>(); }
    //             for (const v of val) {
    //                 lbl_grp.add(v);
    //                 if (!full_obj_grp[v]) {
    //                     full_obj_grp[v] = [null, null, null];
    //                 }
    //                 full_obj_grp[v][i] = grp[0].get(v);
    //             }
    //             full_lbl_grp.set(key, lbl_grp);
    //         });
    //     }
    //     return [full_obj_grp, full_lbl_grp];
    // }
    // private _getObjVisGroups(colls_i: number[], ent_type: EEntType): [Map<string, Set<number>>, Map<string, Set<string>>] {
    //     // get objects
    //     const objs_i: number[] = this.getEnts(ent_type);
    //     // create overlapping groups of objects
    //     // keys are for example "2020", "2021" etc
    //     // objects can be in more than one group
    //     const obj_groups: Map<string, Set<number>> = new Map();
    //     for (const coll_i of colls_i) {
    //         const visibility: string[] = this._geom.modeldata.attribs.query.getAttribVal(EEntType.COLL, 'visible', coll_i) as string[];
    //         if (visibility !== undefined) {
    //             // points
    //             const coll_objs_i: number[] = this._geom.nav.navAnyToAny(EEntType.COLL, ent_type, coll_i);
    //             if (coll_objs_i.length > 0) {
    //                 for (const label of visibility) {
    //                     if (!obj_groups.has(label)) { obj_groups.set(label, new Set()); }
    //                 }
    //                 for (const i of coll_objs_i) {
    //                     for (const label of visibility) { obj_groups.get(label).add(i); }
    //                 }
    //             }
    //         }
    //     }
    //     // create non-overlapping groups of objects
    //     // keys are for example "2020_2021", "2022_2023_2024" etc
    //     // objects will only be in one group
    //     const obj_groups2: Map<string, Set<number>> = new Map();
    //     const obj_labels2: Map<string, Set<string>> = new Map();
    //     obj_groups2.set('default', new Set());
    //     for (const i of objs_i) {
    //         const labels: string[] = [];
    //         obj_groups.forEach( (group, label) => {
    //             if (group.has(i)) { labels.push(label); }
    //         });
    //         if (labels.length > 0) {
    //             const label2 = labels.sort().join('_');
    //             if (!obj_groups2.has(label2)) { obj_groups2.set(label2, new Set()); }
    //             obj_groups2.get(label2).add(i);
    //             for (const label of labels) {
    //                 if (!obj_labels2.has(label)) { obj_labels2.set(label, new Set()); }
    //                 obj_labels2.get(label).add(label2);
    //             }
    //         } else {
    //             obj_groups2.get('default').add(i);
    //         }
    //     }
    //     // return the result
    //     return [obj_groups2, obj_labels2];
    // }
    // ============================================================================
    // Collections
    // ============================================================================
    /**
     * Get the parent of a collection.
     * @param coll_i
     */
    getCollParent(coll_i) {
        return this._geom_maps.dn_colls_objs.get(coll_i)[0];
    }
    /**
     * Get the children collections of a collection.
     * @param coll_i
     */
    getCollChildren(coll_i) {
        const children = [];
        this._geom_maps.dn_colls_objs.forEach((coll2, coll2_i) => {
            if (coll2[0] === coll_i) {
                children.push(coll2_i);
            }
        });
        return children;
    }
    /**
     * Get the ancestor collections of a collection.
     * @param coll_i
     */
    getCollAncestors(coll_i) {
        const ancestor_colls_i = [];
        let parent_coll_i = this._geom_maps.dn_colls_objs.get(coll_i)[0];
        while (parent_coll_i !== -1) {
            ancestor_colls_i.push(parent_coll_i);
            parent_coll_i = this._geom_maps.dn_colls_objs.get(parent_coll_i)[0];
        }
        return ancestor_colls_i;
    }
    /**
     * Get the descendent collections of a collection.
     * @param coll_i
     */
    getCollDescendents(coll_i) {
        const descendent_colls_i = [];
        this._geom_maps.dn_colls_objs.forEach((coll2, coll2_i) => {
            if (coll2[0] !== -1 && coll2_i !== coll_i) {
                if (this.isCollDescendent(coll2_i, coll_i)) {
                    descendent_colls_i.push(coll2_i);
                }
            }
        });
        return descendent_colls_i;
    }
    /**
     * Returns true if the first coll is a descendent of the second coll.
     * @param coll_i
     */
    isCollDescendent(coll1_i, coll2_i) {
        let parent_coll_i = this._geom_maps.dn_colls_objs.get(coll1_i)[0];
        while (parent_coll_i !== -1) {
            if (parent_coll_i === coll2_i) {
                return true;
            }
            parent_coll_i = this._geom_maps.dn_colls_objs.get(parent_coll_i)[0];
        }
        return false;
    }
    /**
     * Returns true if the first coll is an ancestor of the second coll.
     * @param coll_i
     */
    isCollAncestor(coll1_i, coll2_i) {
        let parent_coll_i = this._geom_maps.dn_colls_objs.get(coll2_i)[0];
        while (parent_coll_i !== -1) {
            if (parent_coll_i === coll1_i) {
                return true;
            }
            parent_coll_i = this._geom_maps.dn_colls_objs.get(parent_coll_i)[0];
        }
        return false;
    }
    // /**
    //  * I am not sure what this is... TODO
    //  * A collection can only have one parent
    //  * @param coll_i
    //  */
    // public getCollParents(coll_i: number) {
    //     const coll: TColl = this._geom_maps.dn_colls_objs.get(coll_i];
    //     // @ts-ignore
    //     const _parents = coll.flat(1).filter(function (el) {return el != null; });
    //     return _parents;
    // }
    // ============================================================================
    // Faces
    // ============================================================================
    /**
     *
     * @param face_i
     */
    getFaceBoundary(face_i) {
        return this._geom_maps.dn_faces_wires.get(face_i)[0];
    }
    /**
     *
     * @param face_i
     */
    getFaceHoles(face_i) {
        return this._geom_maps.dn_faces_wires.get(face_i).slice(1);
    }
    /**
     *
     * @param face_i
     */
    getFaceNormal(face_i) {
        const normal = [0, 0, 0];
        const tris_i = this._geom._geom_maps.dn_faces_tris.get(face_i);
        let count = 0;
        for (const tri_i of tris_i) {
            const posis_i = this._geom_maps.dn_tris_verts.get(tri_i).map(vert_i => this._geom_maps.dn_verts_posis.get(vert_i));
            const xyzs = posis_i.map(posi_i => this._geom.modeldata.attribs.query.getPosiCoords(posi_i));
            const vec_a = Object(_geom_vectors__WEBPACK_IMPORTED_MODULE_2__["vecFromTo"])(xyzs[0], xyzs[1]);
            const vec_b = Object(_geom_vectors__WEBPACK_IMPORTED_MODULE_2__["vecFromTo"])(xyzs[0], xyzs[2]); // CCW
            const tri_normal = Object(_geom_vectors__WEBPACK_IMPORTED_MODULE_2__["vecCross"])(vec_a, vec_b, true);
            if (!(tri_normal[0] === 0 && tri_normal[1] === 0 && tri_normal[2] === 0)) {
                count += 1;
                normal[0] += tri_normal[0];
                normal[1] += tri_normal[1];
                normal[2] += tri_normal[2];
            }
        }
        if (count === 0) {
            return [0, 0, 0];
        }
        return Object(_geom_vectors__WEBPACK_IMPORTED_MODULE_2__["vecDiv"])(normal, count);
    }
    // ============================================================================
    // Calculate
    // ============================================================================
    /**
     *
     * @param ent_i
     */
    getCentroid(ent_type, ent_i) {
        const posis_i = this._geom.nav.navAnyToPosi(ent_type, ent_i);
        const centroid = [0, 0, 0];
        for (const posi_i of posis_i) {
            const xyz = this._geom.modeldata.attribs.query.getPosiCoords(posi_i);
            centroid[0] += xyz[0];
            centroid[1] += xyz[1];
            centroid[2] += xyz[2];
        }
        return Object(_geom_vectors__WEBPACK_IMPORTED_MODULE_2__["vecDiv"])(centroid, posis_i.length);
    }
    /**
     * Gets a normal from a wire.
     *
     * It triangulates the wire and then adds up all the normals of all the triangles.
     * Each edge has equal weight, irrespective of length.
     *
     * In some cases, the triangles may cancel each other out.
     * In such a case, it will choose the side' where the wire edges are the longest.
     *
     * @param wire_i
     */
    getWireNormal(wire_i) {
        const edges_i = this._geom._geom_maps.dn_wires_edges.get(wire_i);
        // deal with special case, just a single edge
        if (edges_i.length === 1) {
            const posis_i = this._geom_maps.dn_edges_verts.get(edges_i[0]).map(vert_i => this._geom_maps.dn_verts_posis.get(vert_i));
            const xyz0 = this._geom.modeldata.attribs.query.getPosiCoords(posis_i[0]);
            const xyz1 = this._geom.modeldata.attribs.query.getPosiCoords(posis_i[1]);
            if (xyz0[2] === xyz1[2]) {
                return [0, 0, 1];
            }
            if (xyz0[1] === xyz1[1]) {
                return [0, 1, 0];
            }
            if (xyz0[0] === xyz1[0]) {
                return [1, 0, 0];
            }
            return Object(_geom_vectors__WEBPACK_IMPORTED_MODULE_2__["vecNorm"])(Object(_geom_vectors__WEBPACK_IMPORTED_MODULE_2__["vecCross"])(Object(_geom_vectors__WEBPACK_IMPORTED_MODULE_2__["vecFromTo"])(xyz0, xyz1), [0, 0, 1]));
        }
        // proceed with multiple edges
        const centroid = this.getCentroid(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].WIRE, wire_i);
        const normal = [0, 0, 0];
        const tri_normals = [];
        // let count = 0;
        for (const edge_i of edges_i) {
            const posis_i = this._geom_maps.dn_edges_verts.get(edge_i).map(vert_i => this._geom_maps.dn_verts_posis.get(vert_i));
            const xyzs = posis_i.map(posi_i => this._geom.modeldata.attribs.query.getPosiCoords(posi_i));
            const vec_a = Object(_geom_vectors__WEBPACK_IMPORTED_MODULE_2__["vecFromTo"])(centroid, xyzs[0]);
            const vec_b = Object(_geom_vectors__WEBPACK_IMPORTED_MODULE_2__["vecFromTo"])(centroid, xyzs[1]); // CCW
            const tri_normal = Object(_geom_vectors__WEBPACK_IMPORTED_MODULE_2__["vecCross"])(vec_a, vec_b, true);
            tri_normals.push(tri_normal);
            normal[0] += tri_normal[0];
            normal[1] += tri_normal[1];
            normal[2] += tri_normal[2];
        }
        // if we have a non-zero normal, then return it
        if (Math.abs(normal[0]) > 1e-6 || Math.abs(normal[1]) > 1e-6 || Math.abs(normal[2]) > 1e-6) {
            return Object(_geom_vectors__WEBPACK_IMPORTED_MODULE_2__["vecNorm"])(normal);
        }
        // check for special case of a symmetrical shape where all triangle normals are
        // cancelling each other out, we need to look at both 'sides', see which is bigger
        const normal_a = [0, 0, 0];
        const normal_b = [0, 0, 0];
        let len_a = 0;
        let len_b = 0;
        let first_normal_a = null;
        for (const edge_i of edges_i) {
            const posis_i = this._geom_maps.dn_edges_verts.get(edge_i).map(vert_i => this._geom_maps.dn_verts_posis.get(vert_i));
            const xyzs = posis_i.map(posi_i => this._geom.modeldata.attribs.query.getPosiCoords(posi_i));
            const vec_a = Object(_geom_vectors__WEBPACK_IMPORTED_MODULE_2__["vecFromTo"])(centroid, xyzs[0]);
            const vec_b = Object(_geom_vectors__WEBPACK_IMPORTED_MODULE_2__["vecFromTo"])(centroid, xyzs[1]); // CCW
            const tri_normal = Object(_geom_vectors__WEBPACK_IMPORTED_MODULE_2__["vecCross"])(vec_a, vec_b, true);
            if (!(tri_normal[0] === 0 && tri_normal[1] === 0 && tri_normal[2] === 0)) {
                if (first_normal_a === null) {
                    first_normal_a = tri_normal;
                    normal_a[0] = tri_normal[0];
                    normal_a[1] = tri_normal[1];
                    normal_a[2] = tri_normal[2];
                    len_a += Object(_geom_vectors__WEBPACK_IMPORTED_MODULE_2__["vecLen"])(Object(_geom_vectors__WEBPACK_IMPORTED_MODULE_2__["vecFromTo"])(xyzs[0], xyzs[1]));
                }
                else {
                    if (Object(_geom_vectors__WEBPACK_IMPORTED_MODULE_2__["vecDot"])(first_normal_a, tri_normal) > 0) {
                        normal_a[0] += tri_normal[0];
                        normal_a[1] += tri_normal[1];
                        normal_a[2] += tri_normal[2];
                        len_a += Object(_geom_vectors__WEBPACK_IMPORTED_MODULE_2__["vecLen"])(Object(_geom_vectors__WEBPACK_IMPORTED_MODULE_2__["vecFromTo"])(xyzs[0], xyzs[1]));
                    }
                    else {
                        normal_b[0] += tri_normal[0];
                        normal_b[1] += tri_normal[1];
                        normal_b[2] += tri_normal[2];
                        len_b += Object(_geom_vectors__WEBPACK_IMPORTED_MODULE_2__["vecLen"])(Object(_geom_vectors__WEBPACK_IMPORTED_MODULE_2__["vecFromTo"])(xyzs[0], xyzs[1]));
                    }
                }
            }
        }
        // return the normal for the longest set of edges in the wire
        // if they are the same length, return the normal associated with the start of the wire
        if (len_a >= len_b) {
            return Object(_geom_vectors__WEBPACK_IMPORTED_MODULE_2__["vecNorm"])(normal_a);
        }
        return Object(_geom_vectors__WEBPACK_IMPORTED_MODULE_2__["vecNorm"])(normal_b);
    }
    // ============================================================================
    // Other methods
    // ============================================================================
    /**
     * Given a set of vertices, get the welded neighbour entities.
     * @param ent_type
     * @param verts_i
     */
    neighbor(ent_type, verts_i) {
        const neighbour_ents_i = new Set();
        for (const vert_i of verts_i) {
            const posi_i = this._geom.nav.navVertToPosi(vert_i);
            const found_verts_i = this._geom.nav.navPosiToVert(posi_i);
            for (const found_vert_i of found_verts_i) {
                if (verts_i.indexOf(found_vert_i) === -1) {
                    const found_ents_i = this._geom.nav.navAnyToAny(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].VERT, ent_type, found_vert_i);
                    found_ents_i.forEach(found_ent_i => neighbour_ents_i.add(found_ent_i));
                }
            }
        }
        return Array.from(neighbour_ents_i);
    }
    /**
     * Given a set of edges, get the perimeter entities.
     * @param ent_type
     * @param edges_i
     */
    perimeter(ent_type, edges_i) {
        const edge_posis_map = new Map();
        const edge_to_posi_pairs_map = new Map();
        for (const edge_i of edges_i) {
            const posi_pair_i = this._geom.nav.navAnyToPosi(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].EDGE, edge_i);
            if (!edge_posis_map.has(posi_pair_i[0])) {
                edge_posis_map.set(posi_pair_i[0], []);
            }
            edge_posis_map.get(posi_pair_i[0]).push(posi_pair_i[1]);
            edge_to_posi_pairs_map.set(edge_i, posi_pair_i);
        }
        const perimeter_ents_i = new Set();
        for (const edge_i of edges_i) {
            const posi_pair_i = edge_to_posi_pairs_map.get(edge_i);
            if (!edge_posis_map.has(posi_pair_i[1]) || edge_posis_map.get(posi_pair_i[1]).indexOf(posi_pair_i[0]) === -1) {
                const found_ents_i = this._geom.nav.navAnyToAny(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].EDGE, ent_type, edge_i);
                found_ents_i.forEach(found_ent_i => perimeter_ents_i.add(found_ent_i));
            }
        }
        return Array.from(perimeter_ents_i);
    }
    /**
     * Get the object of a topo entity.
     * @param ent_type
     * @param ent_i
     */
    getTopoObj(ent_type, ent_i) {
        switch (ent_type) {
            case _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].FACE:
                return [_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PGON, this._geom.nav.navFaceToPgon(ent_i)];
            case _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].WIRE:
            case _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].EDGE:
            case _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].VERT:
                const pgons_i = this._geom.nav.navAnyToPgon(ent_type, ent_i);
                if (pgons_i.length !== 0) {
                    return [_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PGON, pgons_i[0]];
                }
                const plines_i = this._geom.nav.navAnyToPline(ent_type, ent_i);
                if (plines_i.length !== 0) {
                    return [_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PLINE, plines_i[0]];
                }
                const points_i = this._geom.nav.navAnyToPoint(ent_type, ent_i);
                if (this._geom.nav.navAnyToVert(ent_type, ent_i).length !== 0) {
                    return [_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POINT, points_i[0]];
                }
                break;
            default:
                throw new Error('Invalid entity type: Must be a topo entity.');
        }
    }
    /**
     * Get the object type of a topo entity.
     * @param ent_type
     * @param ent_i
     */
    getTopoObjType(ent_type, ent_i) {
        switch (ent_type) {
            case _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].FACE:
                return _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PGON;
            case _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].WIRE:
            case _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].EDGE:
            case _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].VERT:
                if (this._geom.nav.navAnyToFace(ent_type, ent_i).length !== 0) {
                    return _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PGON;
                }
                else if (this._geom.nav.navAnyToWire(ent_type, ent_i).length !== 0) {
                    return _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PLINE;
                }
                else if (this._geom.nav.navAnyToVert(ent_type, ent_i).length !== 0) {
                    return _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POINT;
                }
                break;
            default:
                throw new Error('Invalid entity type: Must be a topo entity.');
        }
    }
    /**
     * Get the topo entities of an object
     * @param ent_type
     * @param ent_i
     */
    getObjTopo(ent_type, ent_i) {
        return [
            this._geom.nav.navAnyToVert(ent_type, ent_i),
            this._geom.nav.navAnyToEdge(ent_type, ent_i),
            this._geom.nav.navAnyToWire(ent_type, ent_i),
            this._geom.nav.navAnyToFace(ent_type, ent_i),
        ];
    }
}


/***/ }),

/***/ "./src/assets/libs/geo-info/GIGeomThreejs.ts":
/*!***************************************************!*\
  !*** ./src/assets/libs/geo-info/GIGeomThreejs.ts ***!
  \***************************************************/
/*! exports provided: GIGeomThreejs */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GIGeomThreejs", function() { return GIGeomThreejs; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};

/**
 * Class for geometry.
 */
class GIGeomThreejs {
    /**
     * Constructor
     */
    constructor(geom, geom_arrays) {
        this._geom = geom;
        this._geom_maps = geom_arrays;
    }
    // ============================================================================
    // ThreeJS
    // Get arrays for threejs, these retrun arrays of indexes to positions
    // For a method to get the array of positions, see the attrib class
    // getSeqCoords()
    // ============================================================================
    // /**
    //  * Returns a flat list of all vertices.
    //  * The indices in the list point to the sequential coordinates.
    //  */
    // public get3jsVerts(): number[] {
    //     return this._geom_maps.dn_verts_posis;
    // }
    /**
     * Returns that data required for threejs triangles.
     * 0) the vertices, as a flat array
     * 1) the select map, that maps from the threejs tri indices to the gi model tri indices
     * 2) the materials array, which is an array of objects
     * 3) the material groups array, which is an array of [ start, count, mat_index ]
     */
    get3jsTris(vertex_map) {
        // TODO this should not be parsed each time
        const settings = JSON.parse(localStorage.getItem('mpm_settings'));
        // arrays to store threejs data
        const tri_data_arrs = []; // tri_mat_indices, new_tri_verts_i, tri_i
        const mat_f = {
            specular: 0x000000,
            emissive: 0x000000,
            shininess: 0,
            side: three__WEBPACK_IMPORTED_MODULE_0__["FrontSide"],
            wireframe: settings.wireframe.show
        };
        const mat_b = {
            specular: 0x000000,
            emissive: 0x000000,
            shininess: 0,
            side: three__WEBPACK_IMPORTED_MODULE_0__["BackSide"],
            wireframe: settings.wireframe.show
        };
        const materials = [this._getMaterial(mat_f), this._getMaterial(mat_b)];
        const material_names = ['default_front', 'default_back'];
        // get the material attribute from polygons
        const material_attrib = this._geom.modeldata.attribs._attribs_maps.pg.get('material');
        // loop through all tris
        this._geom_maps.dn_tris_verts.forEach((tri_verts_i, tri_i) => {
            // get the verts, face and the polygon for this tri
            const new_tri_verts_i = tri_verts_i.map(v => vertex_map.get(v));
            // get the materials for this tri from the polygon
            const tri_face_i = this._geom_maps.up_tris_faces.get(tri_i);
            const tri_pgon_i = this._geom_maps.up_faces_pgons.get(tri_face_i);
            const tri_mat_indices = [];
            if (material_attrib !== undefined) {
                const mat_attrib_val = material_attrib.getEntVal(tri_pgon_i);
                const pgon_mat_names = (Array.isArray(mat_attrib_val)) ? mat_attrib_val : [mat_attrib_val];
                for (const pgon_mat_name of pgon_mat_names) {
                    let pgon_mat_index = material_names.indexOf(pgon_mat_name);
                    if (pgon_mat_index === -1) {
                        const mat_settings_obj = this._geom.modeldata.attribs._attribs_maps.mo.get(pgon_mat_name);
                        if (mat_settings_obj !== undefined) {
                            pgon_mat_index = materials.length;
                            material_names.push(pgon_mat_name);
                            materials.push(this._getMaterial(mat_settings_obj));
                        }
                    }
                    if (pgon_mat_index !== -1) {
                        tri_mat_indices.push(pgon_mat_index);
                    }
                }
            }
            if (tri_mat_indices.length === 0) {
                tri_mat_indices.push(0); // default material front
                tri_mat_indices.push(1); // default material back
            }
            // add the data to the data_array
            tri_data_arrs.push([tri_mat_indices, new_tri_verts_i, tri_i]);
        });
        // sort that data_array, so that we get triangls sorted according to their materials
        // for each entry in the data_array, the first item is the material indices, so that they are sorted correctly
        tri_data_arrs.sort();
        // loop through the sorted array and create the tris and groups data for threejs
        const tris_verts_i = [];
        const tri_select_map = new Map();
        const mat_groups_map = new Map(); // mat_index -> [start, end][]
        for (const tri_data_arr of tri_data_arrs) {
            // save the tri data
            const tjs_i = tris_verts_i.push(tri_data_arr[1]) - 1;
            tri_select_map.set(tjs_i, tri_data_arr[2]);
            // go through all materials for this tri and add save the mat groups data
            for (const mat_index of tri_data_arr[0]) {
                let start_end_arrs = mat_groups_map.get(mat_index);
                if (start_end_arrs === undefined) {
                    start_end_arrs = [[tjs_i, tjs_i]];
                    mat_groups_map.set(mat_index, start_end_arrs);
                }
                else {
                    const start_end = start_end_arrs[start_end_arrs.length - 1];
                    if (tjs_i === start_end[1] + 1) {
                        start_end[1] = tjs_i;
                    }
                    else {
                        start_end_arrs.push([tjs_i, tjs_i]);
                    }
                }
            }
        }
        // convert the mat_groups_map into the format required for threejs
        // for each material group, we need an array [start, count, mat_index]
        const material_groups = []; // [start, count, mat_index][]
        mat_groups_map.forEach((start_end_arrs, mat_index) => {
            for (const start_end of start_end_arrs) {
                const start = start_end[0];
                const count = start_end[1] - start_end[0] + 1;
                material_groups.push([start * 3, count * 3, mat_index]);
            }
        });
        // convert the verts list to a flat array
        // tslint:disable-next-line:no-unused-expression
        // @ts-ignore
        const tris_verts_i_flat = tris_verts_i.flat(1);
        // return the data
        // there are four sets of data that are returns
        return [
            tris_verts_i_flat,
            tri_select_map,
            materials,
            material_groups // 3) the material groups array, which is an array of [ start, count, mat_index ]
        ];
        // let gi_i = 0;
        // const l = this._geom_maps.dn_tris_verts.length;
        // for (; gi_i < l; gi_i++) {
        //     const tri_verts_i: TTri = this._geom_maps.dn_tris_verts.get(gi_i];
        //     if (tri_verts_i !== null) {
        //         const new_tri_verts_i: TTri = tri_verts_i.map(v => vertex_map.get(v)) as TTri;
        //         const tjs_i = tris_verts_i_filt.push(new_tri_verts_i) - 1;
        //         tri_select_map.set(tjs_i, gi_i);
        //     }
        // }
        // @ts-ignore
        // return [tris_verts_i.flat(1), tri_select_map];
        // return this._geom_maps.dn_tris_verts.flat(1);
        // return [].concat(...this._geom_maps.dn_tris_verts);
    }
    // public get3jsTris(vertex_map: Map<number, number>): [number[], Map<number, number>, object[], [number, number, number][]] {
    //     const settings = JSON.parse(localStorage.getItem('mpm_settings'));
    //     // arrays to store threejs data
    //     const tri_data_arrs: [number[], TTri, number][] = []; // tri_mat_indices, new_tri_verts_i, tri_i
    //     const mat_f: object = {
    //         specular: 0x000000,
    //         emissive: 0x000000,
    //         shininess: 0,
    //         side: THREE.FrontSide,
    //         wireframe: settings.wireframe.show
    //     };
    //     const mat_b: object = {
    //         specular: 0x000000,
    //         emissive: 0x000000,
    //         shininess: 0,
    //         side: THREE.BackSide,
    //         wireframe: settings.wireframe.show
    //     };
    //     const materials: object[] = [this._getMaterial( mat_f ), this._getMaterial( mat_b )];
    //     const material_names:  string[] = ['default_front', 'default_back'];
    //     // get the material attribute from polygons
    //     const material_attrib: GIAttribMap = this._geom.modeldata.attribs._attribs_maps.pg.get('material');
    //     // loop through all tris
    //     let tri_i = 0; const tri_i_max = this._geom_maps.dn_tris_verts.length;
    //     for (; tri_i < tri_i_max; tri_i++) {
    //         const tri_verts_i: number[] = this._geom_maps.dn_tris_verts[tri_i];
    //         if (tri_verts_i !== null) {
    //             // get the verts, face and the polygon for this tri
    //             const new_tri_verts_i: TTri = tri_verts_i.map(v => vertex_map.get(v)) as TTri;
    //             // get the materials for this tri from the polygon
    //             const tri_face_i: number = this._geom_maps.up_tris_faces[tri_i];
    //             const tri_pgon_i: number = this._geom_maps.up_faces_pgons[tri_face_i];
    //             const tri_mat_indices: number[] = [];
    //             if (material_attrib !== undefined) {
    //                 const mat_attrib_val: string|string[] = material_attrib.getEntVal(tri_pgon_i) as string|string[];
    //                 const pgon_mat_names: string[] = (Array.isArray(mat_attrib_val)) ? mat_attrib_val : [mat_attrib_val];
    //                 for (const pgon_mat_name of pgon_mat_names) {
    //                     let pgon_mat_index: number = material_names.indexOf(pgon_mat_name);
    //                     if (pgon_mat_index === -1) {
    //                         const mat_settings_obj: object = this._geom.modeldata.attribs._attribs_maps.mo.get(pgon_mat_name);
    //                         if (mat_settings_obj !== undefined) {
    //                             pgon_mat_index = materials.length;
    //                             material_names.push(pgon_mat_name);
    //                             materials.push(this._getMaterial(mat_settings_obj));
    //                         }
    //                     }
    //                     if (pgon_mat_index !== -1) {
    //                         tri_mat_indices.push(pgon_mat_index);
    //                     }
    //                 }
    //             }
    //             if (tri_mat_indices.length === 0) {
    //                 tri_mat_indices.push(0); // default material front
    //                 tri_mat_indices.push(1); // default material back
    //             }
    //             // add the data to the data_array
    //             tri_data_arrs.push( [ tri_mat_indices, new_tri_verts_i, tri_i ] );
    //         }
    //     }
    //     // sort that data_array, so that we get triangls sorted according to their materials
    //     // for each entry in the data_array, the first item is the material indices, so that they are sorted correctly
    //     tri_data_arrs.sort();
    //     // loop through the sorted array and create the tris and groups data for threejs
    //     const tris_verts_i: TTri[] = [];
    //     const tri_select_map: Map<number, number> = new Map();
    //     const mat_groups_map: Map<number, [number, number][]> = new Map(); // mat_index -> [start, end][]
    //     for (const tri_data_arr of tri_data_arrs) {
    //         // save the tri data
    //         const tjs_i = tris_verts_i.push(tri_data_arr[1]) - 1;
    //         tri_select_map.set(tjs_i, tri_data_arr[2]);
    //         // go through all materials for this tri and add save the mat groups data
    //         for (const mat_index of tri_data_arr[0]) {
    //             let start_end_arrs: [number, number][] = mat_groups_map.get(mat_index);
    //             if (start_end_arrs === undefined) {
    //                 start_end_arrs = [[tjs_i, tjs_i]];
    //                 mat_groups_map.set(mat_index, start_end_arrs);
    //             } else {
    //                 const start_end: [number, number] = start_end_arrs[start_end_arrs.length - 1];
    //                 if (tjs_i === start_end[1] + 1) {
    //                     start_end[1] = tjs_i;
    //                 } else {
    //                     start_end_arrs.push([tjs_i, tjs_i]);
    //                 }
    //             }
    //         }
    //     }
    //     // convert the mat_groups_map into the format required for threejs
    //     // for each material group, we need an array [start, count, mat_index]
    //     const material_groups: [number, number, number][] = []; // [start, count, mat_index][]
    //     mat_groups_map.forEach( (start_end_arrs, mat_index) => {
    //         for (const start_end of start_end_arrs) {
    //             const start: number = start_end[0];
    //             const count: number = start_end[1] - start_end[0] + 1;
    //             material_groups.push( [ start * 3, count * 3, mat_index ] );
    //         }
    //     });
    //     // convert the verts list to a flat array
    //     // tslint:disable-next-line:no-unused-expression
    //     // @ts-ignore
    //     const tris_verts_i_flat: number[] = tris_verts_i.flat(1);
    //     // return the data
    //     // there are four sets of data that are returns
    //     return [
    //         tris_verts_i_flat, // 0) the vertices, as a flat array
    //         tri_select_map,    // 1) the select map, that maps from the threejs tri indices to the gi model tri indices
    //         materials,         // 2) the materials array, which is an array of objects
    //         material_groups    // 3) the material groups array, which is an array of [ start, count, mat_index ]
    //     ];
    //     // let gi_i = 0;
    //     // const l = this._geom_maps.dn_tris_verts.length;
    //     // for (; gi_i < l; gi_i++) {
    //     //     const tri_verts_i: TTri = this._geom_maps.dn_tris_verts[gi_i];
    //     //     if (tri_verts_i !== null) {
    //     //         const new_tri_verts_i: TTri = tri_verts_i.map(v => vertex_map.get(v)) as TTri;
    //     //         const tjs_i = tris_verts_i_filt.push(new_tri_verts_i) - 1;
    //     //         tri_select_map.set(tjs_i, gi_i);
    //     //     }
    //     // }
    //     // @ts-ignore
    //     // return [tris_verts_i.flat(1), tri_select_map];
    //     // return this._geom_maps.dn_tris_verts.flat(1);
    //     // return [].concat(...this._geom_maps.dn_tris_verts);
    // }
    get3jsTriIndices(tri_list, vertex_map) {
        // loop through all tris
        const tris_verts_i = [];
        for (const tri_i of tri_list) {
            const tri_verts_i = this._geom_maps.dn_tris_verts[tri_i];
            if (tri_verts_i !== null) {
                const new_tri_verts_i = tri_verts_i.map(v => vertex_map.get(v));
                tris_verts_i.push(new_tri_verts_i);
            }
        }
        // @ts-ignore
        const tris_verts_i_flat = tris_verts_i.flat(1);
        return tris_verts_i_flat;
    }
    /**
     * Returns a flat list of the sequence of verices for all the edges.
     * This list will be assumed to be in pairs.
     * The indices in the list point to the vertices.
     */
    get3jsEdges(vertex_map) {
        const edges_verts_i_filt = [];
        const edge_select_map = new Map();
        const white_edges_verts_i_filt = [];
        const white_edge_select_map = new Map();
        const visibility_attrib = this._geom.modeldata.attribs._attribs_maps._e.get('visibility');
        let hidden_attrib;
        if (visibility_attrib) {
            hidden_attrib = visibility_attrib.getEntsFromVal('hidden');
        }
        const edge_attrib = this._geom.modeldata.attribs._attribs_maps._e.get('material');
        let edge_material_attrib;
        if (edge_attrib) {
            edge_material_attrib = edge_attrib.getEntsFromVal('white');
        }
        this._geom_maps.dn_edges_verts.forEach((edge_verts_i, edge_i) => {
            const hidden = hidden_attrib && hidden_attrib.indexOf(edge_i) !== -1;
            if (!hidden) {
                let color_check;
                if (edge_material_attrib) {
                    color_check = edge_material_attrib.indexOf(edge_i) !== -1;
                }
                const new_edge_verts_i = edge_verts_i.map(e => vertex_map.get(e));
                if (color_check) {
                    const tjs_i = white_edges_verts_i_filt.push(new_edge_verts_i) - 1;
                    white_edge_select_map.set(tjs_i, edge_i);
                }
                else {
                    const tjs_i = edges_verts_i_filt.push(new_edge_verts_i) - 1;
                    edge_select_map.set(tjs_i, edge_i);
                }
            }
        });
        // @ts-ignore
        return [edges_verts_i_filt.flat(1), edge_select_map, white_edges_verts_i_filt.flat(1), white_edge_select_map];
        // @ts-ignore
        // return this._geom_maps.dn_edges_verts.flat(1);
        // return [].concat(...this._geom_maps.dn_edges_verts);
    }
    /**
     * Returns a flat list of the sequence of verices for all the edges.
     * This list will be assumed to be in pairs.
     * The indices in the list point to the vertices.
     */
    get3jsPlines(vertex_map) {
        const edges_verts_i_filt = [];
        const edge_select_map = new Map();
        this._geom_maps.dn_plines_wires.forEach((wire_i, pline_i) => {
            const edges_i = this._geom_maps.dn_wires_edges.get(wire_i);
            for (const edge_i of edges_i) {
                const edge_verts_i = this._geom_maps.dn_edges_verts.get(edge_i);
                const new_edge_verts_i = edge_verts_i.map(e => vertex_map.get(e));
                const tjs_i = edges_verts_i_filt.push(new_edge_verts_i) - 1;
                edge_select_map.set(tjs_i, pline_i);
            }
        });
        // @ts-ignore
        return [edges_verts_i_filt.flat(1), edge_select_map];
    }
    get3jsEdgeIndices(edge_list, vertex_map) {
        const edges_verts_i_filt = [];
        const white_edges_verts_i_filt = [];
        const visibility_attrib = this._geom.modeldata.attribs._attribs_maps._e.get('visibility');
        let hidden_attrib;
        if (visibility_attrib) {
            hidden_attrib = visibility_attrib.getEntsFromVal('hidden');
        }
        const edge_attrib = this._geom.modeldata.attribs._attribs_maps._e.get('material');
        let edge_material_attrib;
        if (edge_attrib) {
            edge_material_attrib = edge_attrib.getEntsFromVal('white');
        }
        for (const gi_i of edge_list) {
            if (hidden_attrib && hidden_attrib.indexOf(gi_i) !== -1) {
                continue;
            }
            const edge_verts_i = this._geom_maps.dn_edges_verts[gi_i];
            let color_check;
            if (edge_material_attrib) {
                color_check = edge_material_attrib.indexOf(gi_i) !== -1;
            }
            if (edge_verts_i !== null) {
                const new_edge_verts_i = edge_verts_i.map(e => vertex_map.get(e));
                if (color_check) {
                    white_edges_verts_i_filt.push(new_edge_verts_i);
                }
                else {
                    edges_verts_i_filt.push(new_edge_verts_i);
                }
            }
        }
        // @ts-ignore
        return [edges_verts_i_filt.flat(1), white_edges_verts_i_filt.flat(1)];
        // @ts-ignore
        // return this._geom_maps.dn_edges_verts.flat(1);
        // return [].concat(...this._geom_maps.dn_edges_verts);
    }
    /**
     * Returns a flat list of the sequence of verices for all the points.
     * The indices in the list point to the vertices.
     */
    get3jsPoints(vertex_map) {
        const points_verts_i_filt = [];
        const point_select_map = new Map();
        this._geom_maps.dn_points_verts.forEach((vert_i, point_i) => {
            const new_point_verts_i = vertex_map.get(vert_i);
            const tjs_i = points_verts_i_filt.push(new_point_verts_i) - 1;
            point_select_map.set(tjs_i, point_i);
        });
        return [points_verts_i_filt, point_select_map];
    }
    get3jsPointIndices(pt_list, vertex_map) {
        const points_verts_i_filt = [];
        for (const gi_i of pt_list) {
            const point_verts_i = this._geom_maps.dn_points_verts[gi_i];
            // const point_verts_i: TPoint = this._geom_maps.dn_points_verts[gi_i];
            if (point_verts_i !== null) {
                const new_point_verts_i = vertex_map.get(point_verts_i);
                points_verts_i_filt.push(new_point_verts_i);
            }
        }
        return points_verts_i_filt;
    }
    /**
     * Create a threejs material
     * @param settings
     */
    _getMaterial(settings) {
        const material = {
            type: 'MeshPhongMaterial',
            side: three__WEBPACK_IMPORTED_MODULE_0__["DoubleSide"],
            vertexColors: three__WEBPACK_IMPORTED_MODULE_0__["VertexColors"]
        };
        if (settings) {
            for (const key of Object.keys(settings)) {
                material[key] = settings[key];
            }
        }
        return material;
    }
}


/***/ }),

/***/ "./src/assets/libs/geo-info/GIGeomTimeStamp.ts":
/*!*****************************************************!*\
  !*** ./src/assets/libs/geo-info/GIGeomTimeStamp.ts ***!
  \*****************************************************/
/*! exports provided: GIGeomTimeStamp */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GIGeomTimeStamp", function() { return GIGeomTimeStamp; });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common */ "./src/assets/libs/geo-info/common.ts");
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};

/**
 * Class for geometry.
 */
class GIGeomTimeStamp {
    /**
     * Constructor
     */
    constructor(geom, geom_arrays) {
        this._geom = geom;
        this._geom_maps = geom_arrays;
    }
    /**
     * Update time stamp of an object.
     * If the input entity is not an object, then objects will be retrieved.
     * @param point_i
     */
    updateObjsTs(ent_type, ent_i) {
        const ts = this._geom.modeldata.model.metadata.nextTimeStamp();
        switch (ent_type) {
            case _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POSI:
                this._geom_maps.posis_ts.set(ent_i, ts);
                return;
            case _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POINT:
                this._geom_maps.points_ts.set(ent_i, ts);
                return;
            case _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PLINE:
                this._geom_maps.plines_ts.set(ent_i, ts);
                return;
            case _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PGON:
                this._geom_maps.pgons_ts.set(ent_i, ts);
                return;
            case _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].COLL:
                this._geom.nav.navCollToPgon(ent_i).forEach(pgon_i => this._geom_maps.pgons_ts.set(pgon_i, ts));
                this._geom.nav.navCollToPline(ent_i).forEach(pline_i => this._geom_maps.plines_ts.set(pline_i, ts));
                this._geom.nav.navCollToPoint(ent_i).forEach(point_i => this._geom_maps.points_ts.set(point_i, ts));
                return;
            case _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].FACE:
            case _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].WIRE:
            case _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].EDGE:
            case _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].VERT:
                // get the topo object
                const [ent2_type, ent2_i] = this._geom.query.getTopoObj(ent_type, ent_i);
                switch (ent2_type) {
                    case _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POSI:
                        this._geom_maps.posis_ts.set(ent2_i, ts);
                        return;
                    case _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POINT:
                        this._geom_maps.points_ts.set(ent2_i, ts);
                        return;
                    case _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PLINE:
                        this._geom_maps.plines_ts.set(ent2_i, ts);
                        return;
                    case _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PGON:
                        this._geom_maps.pgons_ts.set(ent2_i, ts);
                        return;
                }
        }
    }
    /**
     * Update time stamp of an object.
     * If the input entity is not an object, then objects will be retrieved.
     * @param point_i
     */
    updateEntTs(ent_type, ent_i) {
        const ts = this._geom.modeldata.model.metadata.nextTimeStamp();
        switch (ent_type) {
            case _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POSI:
                this._geom_maps.posis_ts.set(ent_i, ts);
                return;
            case _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POINT:
                this._geom_maps.points_ts.set(ent_i, ts);
                return;
            case _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PLINE:
                this._geom_maps.plines_ts.set(ent_i, ts);
                return;
            case _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PGON:
                this._geom_maps.pgons_ts.set(ent_i, ts);
                return;
            case _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].COLL:
                this._geom_maps.colls_ts.set(ent_i, ts);
                return;
        }
    }
    /**
     * Update time stamp for multiple arrays or sets of entities.
     * @param map
     */
    updateEntsTs(ent_type, ents_i) {
        const ts = this._geom.modeldata.model.metadata.nextTimeStamp();
        switch (ent_type) {
            case _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POSI:
                ents_i.forEach(ent_i => this._geom_maps.posis_ts.set(ent_i, ts));
                return;
            case _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POINT:
                ents_i.forEach(ent_i => this._geom_maps.points_ts.set(ent_i, ts));
                return;
            case _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PLINE:
                ents_i.forEach(ent_i => this._geom_maps.plines_ts.set(ent_i, ts));
                return;
            case _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PGON:
                ents_i.forEach(ent_i => this._geom_maps.pgons_ts.set(ent_i, ts));
                return;
            case _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].COLL:
                ents_i.forEach(ent_i => this._geom_maps.colls_ts.set(ent_i, ts));
                return;
        }
    }
    /**
     * Get the timestamp of a posi
     * @param posi_i
     */
    getEntTs(ent_type, ent_i) {
        switch (ent_type) {
            case _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POSI:
                return this._geom_maps.posis_ts.get(ent_i);
            case _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POINT:
                return this._geom_maps.points_ts.get(ent_i);
            case _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PLINE:
                return this._geom_maps.plines_ts.get(ent_i);
            case _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PGON:
                return this._geom_maps.pgons_ts.get(ent_i);
            case _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].COLL:
                return this._geom_maps.colls_ts.get(ent_i);
            default:
                throw new Error('Get time stamp: Entity type not recognised.');
        }
    }
    /**
     * Set the timestamp for an ent.
     * This is used by merge.
     * @param ent_type
     * @param posi_i
     * @param ts
     */
    setEntTs(ent_type, ent_i, ts) {
        switch (ent_type) {
            case _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POSI:
                this._geom_maps.posis_ts.set(ent_i, ts);
                return;
            case _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POINT:
                this._geom_maps.points_ts.set(ent_i, ts);
                return;
            case _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PLINE:
                this._geom_maps.plines_ts.set(ent_i, ts);
                return;
            case _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PGON:
                this._geom_maps.pgons_ts.set(ent_i, ts);
                return;
            case _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].COLL:
                this._geom_maps.colls_ts.set(ent_i, ts);
                return;
            default:
                throw new Error('Get time stamp: Entity type not recognised.');
        }
    }
    /**
     * Delete the timestamp for an ent.
     * @param ent_type
     * @param ent_i
     */
    delEntTs(ent_type, ent_i) {
        switch (ent_type) {
            case _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POSI:
                this._geom_maps.posis_ts.delete(ent_i);
                return;
            case _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POINT:
                this._geom_maps.points_ts.delete(ent_i);
                return;
            case _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PLINE:
                this._geom_maps.plines_ts.delete(ent_i);
                return;
            case _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PGON:
                this._geom_maps.pgons_ts.delete(ent_i);
                return;
            case _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].COLL:
                this._geom_maps.colls_ts.delete(ent_i);
                return;
            default:
                throw new Error('Get time stamp: Entity type not recognised.');
        }
    }
}


/***/ }),

/***/ "./src/assets/libs/geo-info/GIMetaData.ts":
/*!************************************************!*\
  !*** ./src/assets/libs/geo-info/GIMetaData.ts ***!
  \************************************************/
/*! exports provided: GIMetaData */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GIMetaData", function() { return GIMetaData; });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common */ "./src/assets/libs/geo-info/common.ts");
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};

/**
 * Geo-info model metadata class.
 */
class GIMetaData {
    /**
     * Constructor
     */
    constructor() {
        this._data = {
            time_stamp: 0,
            posi_count: 0,
            vert_count: 0,
            tri_count: 0,
            edge_count: 0,
            wire_count: 0,
            face_count: 0,
            point_count: 0,
            pline_count: 0,
            pgon_count: 0,
            coll_count: 0,
            attrib_values: {
                number: [[], new Map()],
                string: [[], new Map()],
                list: [[], new Map()],
                dict: [[], new Map()] // an array of dicts, and a map: string key -> array index
            }
        };
        // console.log('CREATING META OBJECT');
    }
    /**
     * Get the meta data.
     */
    getJSONData(model_data) {
        const data_filtered = {
            number: [[], new Map()],
            string: [[], new Map()],
            list: [[], new Map()],
            dict: [[], new Map()],
        };
        // filter the metadata values
        // we only want the valyes that are actually used in this model
        for (const key of Object.keys(model_data.attributes)) {
            if (key !== 'model') {
                for (const attrib of model_data.attributes[key]) {
                    const data_type = attrib.data_type;
                    for (const item of attrib.data) {
                        const attrib_idx = item[0];
                        const attrib_val = this._data.attrib_values[data_type][0][attrib_idx];
                        const attrib_key = (data_type === 'number' || data_type === 'string') ? attrib_val : JSON.stringify(attrib_val);
                        let new_attrib_idx;
                        if (attrib_key in data_filtered[data_type][1]) {
                            new_attrib_idx = data_filtered[data_type][1].get(attrib_key);
                        }
                        else {
                            new_attrib_idx = data_filtered[data_type][0].push(attrib_val) - 1;
                            data_filtered[data_type][1].set(attrib_key, new_attrib_idx);
                        }
                        item[0] = new_attrib_idx;
                    }
                }
            }
        }
        const data = {
            time_stamp: this._data.time_stamp,
            posi_count: this._data.posi_count,
            vert_count: this._data.vert_count,
            tri_count: this._data.tri_count,
            edge_count: this._data.edge_count,
            wire_count: this._data.wire_count,
            face_count: this._data.face_count,
            point_count: this._data.point_count,
            pline_count: this._data.pline_count,
            pgon_count: this._data.pgon_count,
            coll_count: this._data.coll_count,
            attrib_values: {
                number_vals: data_filtered.number[0],
                string_vals: data_filtered.string[0],
                list_vals: data_filtered.list[0],
                dict_vals: data_filtered.dict[0]
            }
        };
        return data;
    }
    /**
     * Merge that data into this meta data.
     * The entity counts will be updated.
     * The attribute values will be added, if they do not already exist.
     * The attribute indexes in model data will also be renumbered.
     * @param data
     */
    mergeJSONData(data) {
        const meta_data = data.meta_data;
        const model_data = data.model_data;
        this._data.posi_count += meta_data.posi_count;
        this._data.vert_count += meta_data.vert_count;
        this._data.tri_count += meta_data.tri_count;
        this._data.edge_count += meta_data.edge_count;
        this._data.wire_count += meta_data.wire_count;
        this._data.face_count += meta_data.face_count;
        this._data.point_count += meta_data.point_count;
        this._data.pline_count += meta_data.pline_count;
        this._data.pgon_count += meta_data.pgon_count;
        this._data.coll_count += meta_data.coll_count;
        // update the attribute values in this meta
        // create the renumbering maps
        const attrib_vals = meta_data.attrib_values;
        const renum_num_attrib_vals = new Map();
        for (let other_idx = 0; other_idx < attrib_vals.number_vals.length; other_idx++) {
            const other_key = attrib_vals.number_vals[other_idx];
            if (this.hasAttribKey(other_key, _common__WEBPACK_IMPORTED_MODULE_0__["EAttribDataTypeStrs"].NUMBER)) {
                renum_num_attrib_vals.set(other_idx, this.getAttribIdxFromKey(other_key, _common__WEBPACK_IMPORTED_MODULE_0__["EAttribDataTypeStrs"].NUMBER));
            }
            else {
                const other_val = attrib_vals.number_vals[other_idx];
                const new_idx = this.addAttribByKeyVal(other_key, other_val, _common__WEBPACK_IMPORTED_MODULE_0__["EAttribDataTypeStrs"].NUMBER);
                renum_num_attrib_vals.set(other_idx, new_idx);
            }
        }
        const renum_str_attrib_vals = new Map();
        for (let other_idx = 0; other_idx < attrib_vals.string_vals.length; other_idx++) {
            const other_key = attrib_vals.string_vals[other_idx];
            if (this.hasAttribKey(other_key, _common__WEBPACK_IMPORTED_MODULE_0__["EAttribDataTypeStrs"].STRING)) {
                renum_str_attrib_vals.set(other_idx, this.getAttribIdxFromKey(other_key, _common__WEBPACK_IMPORTED_MODULE_0__["EAttribDataTypeStrs"].STRING));
            }
            else {
                const other_val = attrib_vals.string_vals[other_idx];
                const new_idx = this.addAttribByKeyVal(other_key, other_val, _common__WEBPACK_IMPORTED_MODULE_0__["EAttribDataTypeStrs"].STRING);
                renum_str_attrib_vals.set(other_idx, new_idx);
            }
        }
        const renum_list_attrib_vals = new Map();
        for (let other_idx = 0; other_idx < attrib_vals.list_vals.length; other_idx++) {
            const other_key = JSON.stringify(attrib_vals.list_vals[other_idx]);
            if (this.hasAttribKey(other_key, _common__WEBPACK_IMPORTED_MODULE_0__["EAttribDataTypeStrs"].LIST)) {
                renum_list_attrib_vals.set(other_idx, this.getAttribIdxFromKey(other_key, _common__WEBPACK_IMPORTED_MODULE_0__["EAttribDataTypeStrs"].LIST));
            }
            else {
                const other_val = attrib_vals.list_vals[other_idx];
                const new_idx = this.addAttribByKeyVal(other_key, other_val, _common__WEBPACK_IMPORTED_MODULE_0__["EAttribDataTypeStrs"].LIST);
                renum_list_attrib_vals.set(other_idx, new_idx);
            }
        }
        const renum_dict_attrib_vals = new Map();
        for (let other_idx = 0; other_idx < attrib_vals.dict_vals.length; other_idx++) {
            const other_key = JSON.stringify(attrib_vals.dict_vals[other_idx]);
            if (this.hasAttribKey(other_key, _common__WEBPACK_IMPORTED_MODULE_0__["EAttribDataTypeStrs"].DICT)) {
                renum_dict_attrib_vals.set(other_idx, this.getAttribIdxFromKey(other_key, _common__WEBPACK_IMPORTED_MODULE_0__["EAttribDataTypeStrs"].DICT));
            }
            else {
                const other_val = attrib_vals.dict_vals[other_idx];
                const new_idx = this.addAttribByKeyVal(other_key, other_val, _common__WEBPACK_IMPORTED_MODULE_0__["EAttribDataTypeStrs"].DICT);
                renum_dict_attrib_vals.set(other_idx, new_idx);
            }
        }
        // apply the renumbering of attribute indexes in the model data
        const renum_attrib_vals = new Map();
        renum_attrib_vals.set(_common__WEBPACK_IMPORTED_MODULE_0__["EAttribDataTypeStrs"].NUMBER, renum_num_attrib_vals);
        renum_attrib_vals.set(_common__WEBPACK_IMPORTED_MODULE_0__["EAttribDataTypeStrs"].STRING, renum_str_attrib_vals);
        renum_attrib_vals.set(_common__WEBPACK_IMPORTED_MODULE_0__["EAttribDataTypeStrs"].LIST, renum_list_attrib_vals);
        renum_attrib_vals.set(_common__WEBPACK_IMPORTED_MODULE_0__["EAttribDataTypeStrs"].DICT, renum_dict_attrib_vals);
        this._renumAttribValues(model_data.attributes.posis, renum_attrib_vals);
        this._renumAttribValues(model_data.attributes.verts, renum_attrib_vals);
        this._renumAttribValues(model_data.attributes.edges, renum_attrib_vals);
        this._renumAttribValues(model_data.attributes.wires, renum_attrib_vals);
        this._renumAttribValues(model_data.attributes.faces, renum_attrib_vals);
        this._renumAttribValues(model_data.attributes.points, renum_attrib_vals);
        this._renumAttribValues(model_data.attributes.plines, renum_attrib_vals);
        this._renumAttribValues(model_data.attributes.pgons, renum_attrib_vals);
        this._renumAttribValues(model_data.attributes.colls, renum_attrib_vals);
        // no need to return the model data
    }
    // get next time stamp
    nextTimeStamp() {
        const ts = this._data.time_stamp;
        this._data.time_stamp += 1;
        return ts;
    }
    // get next index
    nextPosi() {
        const index = this._data.posi_count;
        this._data.posi_count += 1;
        return index;
    }
    nextVert() {
        const index = this._data.vert_count;
        this._data.vert_count += 1;
        return index;
    }
    nextTri() {
        const index = this._data.tri_count;
        this._data.tri_count += 1;
        return index;
    }
    nextEdge() {
        const index = this._data.edge_count;
        this._data.edge_count += 1;
        return index;
    }
    nextWire() {
        const index = this._data.wire_count;
        this._data.wire_count += 1;
        return index;
    }
    nextFace() {
        const index = this._data.face_count;
        this._data.face_count += 1;
        return index;
    }
    nextPoint() {
        const index = this._data.point_count;
        this._data.point_count += 1;
        return index;
    }
    nextPline() {
        const index = this._data.pline_count;
        this._data.pline_count += 1;
        return index;
    }
    nextPgon() {
        const index = this._data.pgon_count;
        this._data.pgon_count += 1;
        return index;
    }
    nextColl() {
        const index = this._data.coll_count;
        this._data.coll_count += 1;
        return index;
    }
    // set next index
    setNextPosi(index) {
        this._data.posi_count = index;
    }
    setNextVert(index) {
        this._data.vert_count = index;
    }
    setNextTri(index) {
        this._data.tri_count = index;
    }
    setNextEdge(index) {
        this._data.edge_count = index;
    }
    setNextWire(index) {
        this._data.wire_count = index;
    }
    setNextFace(index) {
        this._data.face_count = index;
    }
    setNextPoint(index) {
        this._data.point_count = index;
    }
    setNextPline(index) {
        this._data.pline_count = index;
    }
    setNextPgon(index) {
        this._data.pgon_count = index;
    }
    setNextColl(index) {
        this._data.coll_count = index;
    }
    // attribute values
    addAttribByKeyVal(key, val, data_type) {
        if (this._data.attrib_values[data_type][1].has(key)) {
            return this._data.attrib_values[data_type][1].get(key);
        }
        const index = this._data.attrib_values[data_type][0].push(val) - 1;
        this._data.attrib_values[data_type][1].set(key, index);
        return index;
    }
    getAttribValFromIdx(index, data_type) {
        return this._data.attrib_values[data_type][0][index];
    }
    getAttribValFromKey(key, data_type) {
        return this._data.attrib_values[data_type][0][this._data.attrib_values[data_type][1].get(key)];
    }
    getAttribIdxFromKey(key, data_type) {
        return this._data.attrib_values[data_type][1].get(key);
    }
    hasAttribKey(key, data_type) {
        return this._data.attrib_values[data_type][1].has(key);
    }
    // create string for debugging
    toDebugStr() {
        return '' +
            'number: ' +
            JSON.stringify(this._data.attrib_values['number'][0]) +
            JSON.stringify(Array.from(this._data.attrib_values['number'][1])) +
            '\nstring: ' +
            JSON.stringify(this._data.attrib_values['string'][0]) +
            JSON.stringify(Array.from(this._data.attrib_values['string'][1])) +
            '\nlist: ' +
            JSON.stringify(this._data.attrib_values['list'][0]) +
            JSON.stringify(Array.from(this._data.attrib_values['list'][1])) +
            '\ndict: ' +
            JSON.stringify(this._data.attrib_values['dict'][0]) +
            JSON.stringify(Array.from(this._data.attrib_values['dict'][1]));
    }
    // --------------------------------------------
    /**
     * Helper method to renumber the indexes of the attribute values in the JSON data.
     * @param attribs_data the attribute data, [val_index, [list of ents]]
     * @param renum_attrib_vals A map of maps, old numbering -> new numbering
     */
    _renumAttribValues(attribs_data, renum_attrib_vals) {
        for (const attrib_data of attribs_data) {
            const renum = renum_attrib_vals.get(attrib_data.data_type);
            for (const val_i_ents of attrib_data.data) {
                val_i_ents[0] = renum.get(val_i_ents[0]);
            }
        }
    }
}


/***/ }),

/***/ "./src/assets/libs/geo-info/GIModel.ts":
/*!*********************************************!*\
  !*** ./src/assets/libs/geo-info/GIModel.ts ***!
  \*********************************************/
/*! exports provided: GIModel */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GIModel", function() { return GIModel; });
/* harmony import */ var _GIMetaData__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GIMetaData */ "./src/assets/libs/geo-info/GIMetaData.ts");
/* harmony import */ var _GIModelData__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GIModelData */ "./src/assets/libs/geo-info/GIModelData.ts");
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};


/**
 * Geo-info model class.
 */
class GIModel {
    /**
     * Constructor
     */
    // constructor(model_data?: IModelData) {
    constructor(meta_data) {
        this.debug = true;
        if (meta_data === undefined) {
            this.metadata = new _GIMetaData__WEBPACK_IMPORTED_MODULE_0__["GIMetaData"]();
        }
        else {
            this.metadata = meta_data;
        }
        this.modeldata = new _GIModelData__WEBPACK_IMPORTED_MODULE_1__["GIModelData"](this);
    }
    /**
     * Set all data from a JSON string.
     * This includes both the meta data and the model data.
     * Any existing metadata will be kept, the new data gets appended.
     * Any existing model data wil be deleted.
     * @param meta
     */
    setJSONStr(json_str) {
        const json_data = JSON.parse(json_str);
        // merge the meta data
        this.metadata.mergeJSONData(json_data);
        // set the model data
        this.modeldata.setJSONData(json_data.model_data);
    }
    /**
     * Gets all data as a JSON string.
     * This includes both the meta data and the model data.
     */
    getJSONStr() {
        const model_data = this.modeldata.getJSONData();
        const meta_data = this.metadata.getJSONData(model_data);
        const data = {
            meta_data: meta_data,
            model_data: model_data
        };
        return JSON.stringify(data);
    }
    /**
     * Sets the data in this model from a JSON data object using shallow copy.
     * Any existing data in the model is deleted.
     * @param model_json_data The JSON data.
     */
    setModelData(model_json_data) {
        this.modeldata.setJSONData(model_json_data);
    }
    /**
     * Returns the JSON data for this model using shallow copy.
     */
    getModelData() {
        return this.modeldata.getJSONData();
    }
    /**
     * Set the meta data str.
     * @param meta
     */
    setModelDataJSONStr(model_json_data_str) {
        this.modeldata.setJSONData(JSON.parse(model_json_data_str));
    }
    /**
     * Get the meta data str.
     */
    getModelDataJSONStr() {
        return JSON.stringify(this.modeldata.getJSONData());
    }
    /**
     * Set the meta data object.
     * Data is not copied.
     * @param meta
     */
    setMetaData(meta) {
        this.metadata = meta;
    }
    /**
     * Get the meta data object.
     * Data is not copied
     */
    getMetaData() {
        return this.metadata;
    }
    /**
     * Returns a deep clone of this model.
     * Any deleted entities will remain.
     * Entity IDs will not change.
     */
    clone() {
        const clone = new GIModel();
        clone.metadata = this.metadata;
        clone.modeldata = this.modeldata.clone();
        // clone.modeldata.merge(this.modeldata);
        return clone;
    }
    /**
     * Deep copies the model data from a second model into this model.
     * Meta data is assumed to be the same for both models.
     * The existing model data in this model is not deleted.
     * Entity IDs will not change.
     * @param model_data The GI model.
     */
    merge(model) {
        this.modeldata.merge(model.modeldata);
    }
    /**
     * Deep copies the model data from a second model into this model.
     * Meta data is assumed to be the same for both models.
     * The existing model data in this model is not deleted.
     * The Entity IDs in this model will not change.
     * The Entity IDs in the second model will change.
     * @param model_data The GI model.
     */
    mergeAndPurge(model) {
        this.modeldata.mergeAndPurge(model.modeldata);
    }
    /**
     * Renumber entities in this model.
     */
    purge() {
        this.modeldata = this.modeldata.purge();
    }
    /**
     * Delete ents in the model.
     * This does not affect the model attribs.
     */
    delete(ent_sets, invert) {
        if (ent_sets === null) {
            if (invert) {
                // delete nothing
                return;
            }
            else {
                // delete everything
                const new_model_data = new _GIModelData__WEBPACK_IMPORTED_MODULE_1__["GIModelData"](this);
                // copy model attribs from existing
                new_model_data.dumpSelect(this.modeldata, ent_sets);
                // reset model data
                this.modeldata = new_model_data;
                // const model_attrib_names: string[] = this.modeldata.attribs.query.getAttribNames(EEntType.MOD);
                // for (const name of model_attrib_names) {
                //     new_model_data.attribs.add.setModelAttribVal(name, this.modeldata.attribs.query.getModelAttribVal(name));
                // }
                // this.modeldata = new_model_data;
            }
        }
        else if (invert) {
            // create empty model data
            const new_model_data = new _GIModelData__WEBPACK_IMPORTED_MODULE_1__["GIModelData"](this);
            // copy data from existing model data
            new_model_data.dumpSelect(this.modeldata, ent_sets);
            // reset model data
            this.modeldata = new_model_data;
        }
        else {
            this.modeldata.geom.del.del(ent_sets);
        }
    }
    /**
     * Check model for internal consistency
     */
    check() {
        return this.modeldata.check();
    }
    /**
     * Compares this model and another model.
     * ~
     * This is the answer model.
     * The other model is the submitted model.
     * ~
     * Both models will be modified in the process.
     * ~
     * @param model The model to compare with.
     */
    compare(model, normalize, check_geom_equality, check_attrib_equality) {
        return this.modeldata.compare(model, normalize, check_geom_equality, check_attrib_equality);
    }
    /**
     * Get the threejs data for this model.
     */
    get3jsData() {
        return this.modeldata.threejs.get3jsData();
    }
}


/***/ }),

/***/ "./src/assets/libs/geo-info/GIModelComparator.ts":
/*!*******************************************************!*\
  !*** ./src/assets/libs/geo-info/GIModelComparator.ts ***!
  \*******************************************************/
/*! exports provided: GIModelComparator */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GIModelComparator", function() { return GIModelComparator; });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common */ "./src/assets/libs/geo-info/common.ts");
/* harmony import */ var _geom_vectors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../geom/vectors */ "./src/assets/libs/geom/vectors.ts");
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};


/**
 * Geo-info model class.
 */
class GIModelComparator {
    /**
      * Constructor
      */
    constructor(model) {
        this._modeldata = model;
    }
    /**
     * Compares this model and another model.
     * ~
     * This is the answer model.
     * The other model is the submitted model.
     * ~
     * This method checks that every entity in the answer model is also in the submitted model.
     * ~
     * Both models will be modified in the process.
     * ~
     * @param model The model to compare with.
     */
    compare(model, normalize, check_geom_equality, check_attrib_equality) {
        // create the result object
        const result = { percent: 0, score: 0, total: 0, comment: [] };
        // check we have exact same number of positions, objects, and colletions
        if (check_geom_equality) {
            this._modeldata.geom.compare.compare(model, result);
        }
        // check that the attributes in this model all exist in the other model
        if (check_attrib_equality) {
            this._modeldata.attribs.compare(model, result);
        }
        // normalize the two models
        if (normalize) {
            this.norm();
            model.modeldata.comparator.norm();
        }
        // compare objects
        let idx_maps = null;
        idx_maps = this.compareObjs(model, result);
        // check for common erros
        // SLOW....
        // this.checkForErrors(model, result, idx_maps);
        // compare colls
        this.compareColls(model, result, idx_maps);
        // compare the material attribs in the model
        this.compareModelAttribs(model, result);
        // Add a final msg
        if (result.score === result.total) {
            result.comment = ['RESULT: The two models match.'];
        }
        else {
            result.comment.push('RESULT: The two models do not match.');
        }
        // calculate percentage score
        result.percent = Math.round(result.score / result.total * 100);
        if (result.percent < 0) {
            result.percent = 0;
        }
        // html formatting
        let formatted_str = '';
        formatted_str += '<p><b>Percentage: ' + result.percent + '%</b></p>';
        formatted_str += '<p>Score: ' + result.score + '/' + result.total + '</p>';
        formatted_str += '<ul>';
        for (const comment of result.comment) {
            if (Array.isArray(comment)) {
                formatted_str += '<ul>';
                for (const sub_comment of comment) {
                    formatted_str += '<li>' + sub_comment + '</li>';
                }
                formatted_str += '</ul>';
            }
            else {
                formatted_str += '<li>' + comment + '</li>';
            }
        }
        formatted_str += '</ul>';
        result.comment = formatted_str;
        // return the result
        return result;
    }
    // ============================================================================
    // Private methods for normalizing
    // ============================================================================
    /**
     * Normalises the direction of open wires
     */
    norm() {
        const trans_padding = this.getTransPadding();
        this.normOpenWires(trans_padding);
        this.normClosedWires(trans_padding);
        this.normHoles(trans_padding);
    }
    /**
     * Get the min max posis
     */
    getTransPadding() {
        const precision = 1e4;
        const min = [Infinity, Infinity, Infinity];
        const max = [-Infinity, -Infinity, -Infinity];
        for (const posi_i of this._modeldata.geom.query.getEnts(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POSI)) {
            const xyz = this._modeldata.attribs.query.getPosiCoords(posi_i);
            if (xyz[0] < min[0]) {
                min[0] = xyz[0];
            }
            if (xyz[1] < min[1]) {
                min[1] = xyz[1];
            }
            if (xyz[2] < min[2]) {
                min[2] = xyz[2];
            }
            if (xyz[0] > max[0]) {
                max[0] = xyz[0];
            }
            if (xyz[1] > max[1]) {
                max[1] = xyz[1];
            }
            if (xyz[2] > max[2]) {
                max[2] = xyz[2];
            }
        }
        const trans_vec = [min[0] * -1, min[1] * -1, min[2] * -1];
        const trans_max = [max[0] + trans_vec[0], max[1] + trans_vec[1], max[2] + trans_vec[2]];
        const padding = [
            String(Math.round(trans_max[0] * precision)).length,
            String(Math.round(trans_max[1] * precision)).length,
            String(Math.round(trans_max[2] * precision)).length
        ];
        return [trans_vec, padding];
    }
    /**
     * Normalises the direction of open wires
     */
    normOpenWires(trans_padding) {
        for (const wire_i of this._modeldata.geom.query.getEnts(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].WIRE)) {
            if (!this._modeldata.geom.query.isWireClosed(wire_i)) {
                // an open wire can only start at the first or last vertex, but the order can be reversed
                const verts_i = this._modeldata.geom.nav.navAnyToVert(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].WIRE, wire_i);
                const fprint_start = this.normXyzFprint(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].VERT, verts_i[0], trans_padding);
                const fprint_end = this.normXyzFprint(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].VERT, verts_i[verts_i.length - 1], trans_padding);
                if (fprint_start > fprint_end) {
                    this._modeldata.geom.modify.reverse(wire_i);
                }
            }
        }
    }
    /**
     * Normalises the edge order of closed wires
     */
    normClosedWires(trans_padding) {
        for (const wire_i of this._modeldata.geom.query.getEnts(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].WIRE)) {
            if (this._modeldata.geom.query.isWireClosed(wire_i)) {
                // a closed wire can start at any edge
                const edges_i = this._modeldata.geom.nav.navAnyToEdge(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].WIRE, wire_i);
                const fprints = [];
                for (let i = 0; i < edges_i.length; i++) {
                    const edge_i = edges_i[i];
                    fprints.push([this.normXyzFprint(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].EDGE, edge_i, trans_padding), i]);
                }
                fprints.sort();
                this._modeldata.geom.modify.shift(wire_i, fprints[0][1]);
                // if polyline, the direction can be any
                // so normalise direction
                if (this._modeldata.geom.nav.navWireToPline(wire_i) !== undefined) {
                    const normal = this._modeldata.geom.query.getWireNormal(wire_i);
                    let dot = Object(_geom_vectors__WEBPACK_IMPORTED_MODULE_1__["vecDot"])(normal, [0, 0, 1]);
                    if (Math.abs(dot) < 1e-6) {
                        dot = Object(_geom_vectors__WEBPACK_IMPORTED_MODULE_1__["vecDot"])(normal, [1, 0, 0]);
                    }
                    if (dot < 0) {
                        this._modeldata.geom.modify.reverse(wire_i);
                    }
                }
            }
        }
    }
    /**
     * Normalises the order of holes in faces
     */
    normHoles(trans_padding) {
        for (const face_i of this._modeldata.geom.query.getEnts(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].FACE)) {
            const holes_i = this._modeldata.geom.query.getFaceHoles(face_i);
            if (holes_i.length > 0) {
                const fprints = [];
                for (const hole_i of holes_i) {
                    fprints.push([this.normXyzFprint(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].WIRE, hole_i, trans_padding), hole_i]);
                }
                fprints.sort();
                const reordered_holes_i = fprints.map(fprint => fprint[1]);
                this._modeldata.geom.compare.setPgonHoles(face_i, reordered_holes_i);
            }
        }
    }
    /**
     * Round the xyz values, rounded to the precision level
     * ~
     * @param posi_i
     */
    normXyzFprint(ent_type, ent_i, trans_padding) {
        const precision = 1e4;
        // get the xyzs
        const fprints = [];
        const posis_i = this._modeldata.geom.nav.navAnyToPosi(ent_type, ent_i);
        for (const posi_i of posis_i) {
            const xyz = this._modeldata.attribs.query.getPosiCoords(posi_i);
            const fprint = [];
            for (let i = 0; i < 3; i++) {
                const xyz_round = Math.round((xyz[i] + trans_padding[0][i]) * precision);
                fprint.push(String(xyz_round).padStart(trans_padding[1][i], '0'));
            }
            fprints.push(fprint.join(','));
        }
        return fprints.join('|');
    }
    // ============================================================================
    // Private methods for comparing objs, colls
    // ============================================================================
    /**
     * For any entity, greate a string that concatenates all the xyz values of its positions.
     * ~
     * These strings will be used for sorting entities into a predictable order,
     * independent of the order in which the geometry was actually created.
     * ~
     * If there are multiple entities in exactly the same position, then the ordering may be unpredictable.
     * ~
     * @param ent_type
     * @param ent_i
     */
    xyzFprint(ent_type, ent_i, trans_vec = [0, 0, 0]) {
        const posis_i = this._modeldata.geom.nav.navAnyToPosi(ent_type, ent_i);
        const xyzs = posis_i.map(posi_i => this._modeldata.attribs.query.getPosiCoords(posi_i));
        const fprints = xyzs.map(xyz => this.getAttribValFprint([
            xyz[0] + trans_vec[0],
            xyz[1] + trans_vec[1],
            xyz[2] + trans_vec[2]
        ]));
        return fprints.join('|');
    }
    /**
     * Compare the objects.
     * ~
     * This will also check the following attributes:
     * For posis, it will check the xyz attribute.
     * For vertices, it will check the rgb attribute, if such an attribute exists in the answer model.
     * For polygons, it will check the material attribute, if such an attribute exists in the answer model.
     */
    compareObjs(other_model, result) {
        result.comment.push('Comparing objects in the two models.');
        const data_comments = [];
        // set attrib names to check when comparing objects and collections
        const attrib_names = new Map();
        attrib_names.set(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POSI, ['xyz']);
        if (this._modeldata.attribs.query.hasAttrib(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].VERT, 'rgb')) {
            attrib_names.set(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].VERT, ['rgb']);
        }
        if (this._modeldata.attribs.query.hasAttrib(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PGON, 'material')) {
            attrib_names.set(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PGON, ['material']);
        }
        // points, polylines, polygons
        const obj_ent_types = [_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POINT, _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PLINE, _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PGON];
        const obj_ent_type_strs = new Map([
            [_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POINT, 'points'],
            [_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PLINE, 'polylines'],
            [_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PGON, 'polygons']
        ]);
        // compare points, plines, pgons
        const this_to_com_idx_maps = new Map();
        const other_to_com_idx_maps = new Map();
        for (const obj_ent_type of obj_ent_types) {
            // create the two maps, and store them in the map of maps
            const this_to_com_idx_map = new Map();
            this_to_com_idx_maps.set(obj_ent_type, this_to_com_idx_map);
            const other_to_com_idx_map = new Map();
            other_to_com_idx_maps.set(obj_ent_type, other_to_com_idx_map);
            // get the fprints for this model
            const [this_fprints_arr, this_ents_i] = this.getEntsFprint(obj_ent_type, attrib_names);
            // get the fprints for the other model
            const [other_fprints_arr, other_ents_i] = other_model.modeldata.comparator.getEntsFprint(obj_ent_type, attrib_names);
            // check that every entity in this model also exists in the other model
            let num_xyz_not_found = 0;
            const num_attribs_not_found = new Map();
            for (let com_idx = 0; com_idx < this_fprints_arr.length; com_idx++) {
                // increment the total by 1
                result.total += 1;
                // get this fprint, i.e. the one we are looking for in the other model
                const this_fprint = this_fprints_arr[com_idx].get('ps:xyz');
                const all_other_fprints = other_fprints_arr.map(att_map => att_map.get('ps:xyz'));
                // get this index and set the map
                const this_ent_i = this_ents_i[com_idx];
                this_to_com_idx_map.set(this_ent_i, com_idx);
                // for other...
                // get the index of this_fprint in the list of other_fprints
                const found_other_idx = all_other_fprints.indexOf(this_fprint);
                // update num_objs_not_found or update result.score
                if (found_other_idx === -1) {
                    num_xyz_not_found++;
                }
                else {
                    // check the attributes
                    const keys = Array.from(this_fprints_arr[com_idx].keys());
                    const ent_num_attribs = keys.length;
                    let ent_num_attribs_mismatch = 0;
                    for (const key of keys) {
                        if (key !== 'ps:xyz') {
                            if (!other_fprints_arr[found_other_idx].has(key) ||
                                this_fprints_arr[com_idx].get(key) !== other_fprints_arr[found_other_idx].get(key)) {
                                ent_num_attribs_mismatch += 1;
                                if (!num_attribs_not_found.has(key)) {
                                    num_attribs_not_found.set(key, 1);
                                }
                                else {
                                    num_attribs_not_found.set(key, num_attribs_not_found.get(key) + 1);
                                }
                            }
                        }
                    }
                    // we other index and set the map
                    const other_ent_i = other_ents_i[found_other_idx];
                    other_to_com_idx_map.set(other_ent_i, com_idx);
                    // update the score
                    const ent_num_attribs_match = ent_num_attribs - ent_num_attribs_mismatch;
                    result.score = result.score + (ent_num_attribs_match / ent_num_attribs);
                }
            }
            // write a msg
            if (this_fprints_arr.length > 0) {
                if (num_xyz_not_found > 0) {
                    data_comments.push('Mismatch: ' + num_xyz_not_found + ' ' +
                        obj_ent_type_strs.get(obj_ent_type) + ' entities could not be found.');
                }
                else {
                    data_comments.push('All ' +
                        obj_ent_type_strs.get(obj_ent_type) + ' entities have been found.');
                }
                for (const key of Array.from(num_attribs_not_found.keys())) {
                    data_comments.push('Mismatch in attribute data: ' + num_attribs_not_found.get(key) + ' ' +
                        obj_ent_type_strs.get(obj_ent_type) + ' entities had mismatched attribute data for: ' + key + '.');
                }
            }
        }
        // return result
        result.comment.push(data_comments);
        // return the maps, needed for comparing collections
        return [this_to_com_idx_maps, other_to_com_idx_maps];
    }
    /**
     * Compare the collections
     */
    compareColls(other_model, result, idx_maps) {
        result.comment.push('Comparing collections in the two models.');
        const data_comments = [];
        // set attrib names to check when comparing objects and collections
        const attrib_names = []; // no attribs to check
        // get the maps
        const this_to_com_idx_maps = idx_maps[0];
        const other_to_com_idx_maps = idx_maps[1];
        // compare collections
        const this_colls_fprints = this.getCollFprints(this_to_com_idx_maps, attrib_names);
        // console.log('this_colls_fprints:', this_colls_fprints);
        const other_colls_fprints = other_model.modeldata.comparator.getCollFprints(other_to_com_idx_maps, attrib_names);
        // console.log('other_colls_fprints:', other_colls_fprints);
        // check that every collection in this model also exists in the other model
        let num_colls_not_found = 0;
        for (const this_colls_fprint of this_colls_fprints) {
            // increment the total score by 1
            result.total += 1;
            // look for this in other
            const found_other_idx = other_colls_fprints.indexOf(this_colls_fprint);
            // add mismatch comment or update score
            if (found_other_idx === -1) {
                num_colls_not_found++;
            }
            else {
                result.score += 1;
            }
        }
        if (num_colls_not_found > 0) {
            data_comments.push('Mismatch: ' + num_colls_not_found + ' collections could not be found.');
        }
        // add a comment if everything matches
        if (result.score === result.total) {
            data_comments.push('Match: The model contains all required entities and collections.');
        }
        // return result
        result.comment.push(data_comments);
    }
    /**
     * Compare the model attribs
     * At the moment, this seems to only compare the material attribute in the model
     */
    compareModelAttribs(other_model, result) {
        result.comment.push('Comparing model attributes in the two models.');
        const data_comments = [];
        // set attrib names to check when comparing objects and collections
        const attrib_names = [];
        if (this._modeldata.attribs.query.hasAttrib(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PGON, 'material')) {
            const pgons_i = this._modeldata.geom.query.getEnts(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PGON);
            const mat_names = new Set(this._modeldata.attribs.query.getAttribVal(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PGON, 'material', pgons_i));
            for (const mat_name of Array.from(mat_names)) {
                if (mat_name !== undefined) {
                    attrib_names.push(mat_name);
                }
            }
        }
        // compare model attributes
        for (const this_mod_attrib_name of attrib_names) {
            // increment the total by 1
            result.total += 1;
            // check if there is a match
            if (other_model.modeldata.attribs.query.hasModelAttrib(this_mod_attrib_name)) {
                const this_value = this._modeldata.attribs.query.getModelAttribVal(this_mod_attrib_name);
                const other_value = other_model.modeldata.attribs.query.getModelAttribVal(this_mod_attrib_name);
                const this_value_fp = this.getAttribValFprint(this_value);
                const other_value_fp = this.getAttribValFprint(other_value);
                if (this_value_fp === other_value_fp) {
                    // correct, so increment the score by 1
                    result.score += 1;
                }
                else {
                    data_comments.push('Mismatch: the value for model attribute "' + this_mod_attrib_name + '" is incorrect.');
                }
            }
            else {
                data_comments.push('Mismatch: model attribute "' + this_mod_attrib_name + '" not be found.');
            }
        }
        // add a comment if everything matches
        if (result.score === result.total) {
            data_comments.push('Match: The model conatins all required model attributes.');
        }
        // return result
        result.comment.push(data_comments);
    }
    /**
     * Check to see if there are any common errors.
     */
    checkForErrors(other_model, result, idx_maps) {
        // set precision of comparing vectors
        // this precision should be a little higher than the precision used in
        // getAttribValFprint()
        const precision = 1e6;
        // get the maps
        const this_to_com_idx_maps = idx_maps[0];
        const other_to_com_idx_maps = idx_maps[1];
        // points, polylines, polygons
        const obj_ent_types = [_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POINT, _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PLINE, _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PGON];
        const obj_ent_type_strs = new Map([
            [_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POINT, 'points'],
            [_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PLINE, 'polylines'],
            [_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PGON, 'polygons']
        ]);
        // compare points, plines, pgons
        const trans_comments = [];
        for (const obj_ent_type of obj_ent_types) {
            // get all the ents in the other model against which nothing has been matched
            // note that this map will be undefined for each ent for which no match was found
            // at the same time, flip the map
            const com_idx_to_other_map = new Map();
            const other_ents_i = other_model.modeldata.geom.query.getEnts(obj_ent_type);
            const other_mia_ents_i = [];
            for (const ent_i of other_ents_i) {
                const com_idx = other_to_com_idx_maps.get(obj_ent_type).get(ent_i);
                if (com_idx === undefined) {
                    other_mia_ents_i.push(ent_i);
                }
                else {
                    com_idx_to_other_map.set(com_idx, ent_i);
                }
            }
            // get all the ents in this model for which no match has been found in the other model
            // note that this map is never empty, it always contains a mapping for each ent, even when no match was found
            const this_ents_i = this._modeldata.geom.query.getEnts(obj_ent_type);
            const this_mia_ents_i = [];
            for (const ent_i of this_ents_i) {
                const com_idx = this_to_com_idx_maps.get(obj_ent_type).get(ent_i);
                const other_ent_i = com_idx_to_other_map.get(com_idx);
                if (other_ent_i === undefined) {
                    this_mia_ents_i.push(ent_i);
                }
            }
            // check that we have enough ents in the otehr model, if nit, exit
            if (other_mia_ents_i.length < this_mia_ents_i.length) {
                return;
            }
            // for each this_mia_ents_i, we need to find the closest other_mia_ents_i, and save the unique trans vec
            const trans_vecs_counts = new Map();
            const flipped_trans_vecs_counts = new Map();
            for (const this_mia_ent_i of this_mia_ents_i) {
                let min_dist = Infinity;
                let min_trans_vec = null;
                const this_posis_i = this._modeldata.geom.nav.navAnyToPosi(obj_ent_type, this_mia_ent_i);
                let flipped = false;
                for (const other_mia_ent_i of other_mia_ents_i) {
                    const other_posis_i = other_model.modeldata.geom.nav.navAnyToPosi(obj_ent_type, other_mia_ent_i);
                    if (this_posis_i.length === other_posis_i.length) {
                        const this_xyz = this._modeldata.attribs.query.getPosiCoords(this_posis_i[0]);
                        const other_xyz = other_model.modeldata.attribs.query.getPosiCoords(other_posis_i[0]);
                        const trans_vec = [
                            other_xyz[0] - this_xyz[0],
                            other_xyz[1] - this_xyz[1],
                            other_xyz[2] - this_xyz[2]
                        ];
                        const this_fp = this.xyzFprint(obj_ent_type, this_mia_ent_i, trans_vec);
                        const other_fp = other_model.modeldata.comparator.xyzFprint(obj_ent_type, other_mia_ent_i);
                        if (this_fp === other_fp) {
                            const dist = Math.abs(trans_vec[0]) + Math.abs(trans_vec[1]) + Math.abs(trans_vec[2]);
                            if (dist < min_dist) {
                                min_dist = dist;
                                min_trans_vec = trans_vec;
                                flipped = false;
                            }
                        }
                        else if (obj_ent_type === _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PGON) {
                            // flip the polygon
                            const this_flip_fps = this_fp.split('|');
                            this_flip_fps.push(this_flip_fps.shift());
                            this_flip_fps.reverse();
                            const this_flip_fp = this_flip_fps.join('|');
                            if (this_flip_fp === other_fp) {
                                const dist = Math.abs(trans_vec[0]) + Math.abs(trans_vec[1]) + Math.abs(trans_vec[2]);
                                if (dist < min_dist) {
                                    min_dist = dist;
                                    min_trans_vec = trans_vec;
                                    flipped = true;
                                }
                            }
                        }
                    }
                }
                // if we have found a match, save it
                if (min_trans_vec !== null) {
                    // round the coords
                    min_trans_vec = min_trans_vec.map(coord => Math.round(coord * precision) / precision);
                    // make a string as key
                    const min_trans_vec_str = JSON.stringify(min_trans_vec);
                    // save the count for this vec
                    if (flipped) {
                        if (!flipped_trans_vecs_counts.has(min_trans_vec_str)) {
                            flipped_trans_vecs_counts.set(min_trans_vec_str, 1);
                        }
                        else {
                            const count = flipped_trans_vecs_counts.get(min_trans_vec_str);
                            flipped_trans_vecs_counts.set(min_trans_vec_str, count + 1);
                        }
                    }
                    else {
                        if (!trans_vecs_counts.has(min_trans_vec_str)) {
                            trans_vecs_counts.set(min_trans_vec_str, 1);
                        }
                        else {
                            const count = trans_vecs_counts.get(min_trans_vec_str);
                            trans_vecs_counts.set(min_trans_vec_str, count + 1);
                        }
                    }
                }
            }
            flipped_trans_vecs_counts.forEach((count, min_trans_vec_str) => {
                if (count > 1) {
                    const comments = [
                        'It looks like there are certain polygon objects that have the correct shape but that are reversed.',
                        count + ' polygons have been found that seem like they should be reversed.'
                    ];
                    if (min_trans_vec_str !== '[0,0,0]') {
                        comments.concat([
                            'They also seem to be in the wrong location.',
                            'It seesm like they should be reversed and translated by the following vector:',
                            min_trans_vec_str + '.'
                        ]);
                    }
                    trans_comments.push(comments.join(' '));
                }
                else if (count === 1) {
                    const comments = [
                        'It looks like there is a polygon object that has the correct shape but that is reversed.'
                    ];
                    if (min_trans_vec_str !== '[0,0,0]') {
                        comments.concat([
                            'It also seems to be in the wrong location.',
                            'It seesm like it should be reversed and translated by the following vector:',
                            min_trans_vec_str + '.'
                        ]);
                    }
                    trans_comments.push(comments.join(' '));
                }
            });
            trans_vecs_counts.forEach((count, min_trans_vec_str) => {
                if (count > 1) {
                    trans_comments.push([
                        'It looks like there are certain',
                        obj_ent_type_strs.get(obj_ent_type),
                        'objects that have the correct shape but that are in the wrong location.',
                        count, obj_ent_type_strs.get(obj_ent_type),
                        'objects have been found that seem like they should be translated by the following vector:',
                        min_trans_vec_str + '.'
                    ].join(' '));
                }
                else if (count === 1) {
                    trans_comments.push([
                        'It looks like there is an',
                        obj_ent_type_strs.get(obj_ent_type),
                        'object that has the correct shape but that is in the wrong location.',
                        'It seems like the object should be translated by the following vector:',
                        min_trans_vec_str + '.'
                    ].join(' '));
                }
            });
        }
        // add some feedback
        if (trans_comments.length > 0) {
            result.comment.push('An analysis of the geometry suggests there might be some objects that are translated.');
            result.comment.push(trans_comments);
        }
    }
    // ============================================================================
    // Private methods for fprinting
    // ============================================================================
    /**
     * Get a fprint of all geometric entities of a certain type in the model.
     * This returns a fprint array, and the entity indexes
     * The two arrays are in the same order
     */
    getEntsFprint(ent_type, attrib_names) {
        const fprints = [];
        const ents_i = this._modeldata.geom.query.getEnts(ent_type);
        for (const ent_i of ents_i) {
            fprints.push(this.getEntFprint(ent_type, ent_i, attrib_names));
        }
        // return the result, do not sort
        return [fprints, ents_i];
    }
    /**
     * Get a fprint of one geometric entity: point, polyline, polygon
     * Returns a map of strings.
     * Keys are attribtes, like this 'ps:xyz'.
     * Values are fprints, as strings.
     */
    getEntFprint(from_ent_type, index, attrib_names_map) {
        const fprints = new Map();
        // define topo entities for each obj (starts with posis and ends with objs)
        const topo_ent_types_map = new Map();
        topo_ent_types_map.set(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POINT, [_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POSI, _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].VERT, _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POINT]);
        topo_ent_types_map.set(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PLINE, [_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POSI, _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].VERT, _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].EDGE, _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].WIRE, _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PLINE]);
        topo_ent_types_map.set(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PGON, [_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POSI, _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].VERT, _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].EDGE, _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].WIRE, _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].FACE, _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PGON]);
        // create fprints of topological entities
        for (const topo_ent_type of topo_ent_types_map.get(from_ent_type)) {
            const ent_type_str = _common__WEBPACK_IMPORTED_MODULE_0__["EEntTypeStr"][topo_ent_type];
            // get the attribute names array that will be used for matching
            const attrib_names = attrib_names_map.get(topo_ent_type);
            if (attrib_names !== undefined) {
                // sort the attrib names
                attrib_names.sort();
                const sub_ents_i = this._modeldata.geom.nav.navAnyToAny(from_ent_type, topo_ent_type, index);
                // for each attrib, make a fingerprint
                for (const attrib_name of attrib_names) {
                    if (this._modeldata.attribs.query.hasAttrib(topo_ent_type, attrib_name)) {
                        const topo_fprints = [];
                        for (const sub_ent_i of sub_ents_i) {
                            const attrib_value = this._modeldata.attribs.query.getAttribVal(topo_ent_type, attrib_name, sub_ent_i);
                            if (attrib_value !== null && attrib_value !== undefined) {
                                topo_fprints.push(this.getAttribValFprint(attrib_value));
                            }
                        }
                        fprints.set(ent_type_str + ':' + attrib_name, topo_fprints.join('#'));
                    }
                }
            }
        }
        // return the final fprint maps for the object
        // no need to sort, the order is predefined
        return fprints;
    }
    /**
     * Get one fprint for all collections
     */
    getCollFprints(idx_maps, attrib_names) {
        const fprints = [];
        // create the fprints for each collection
        const colls_i = this._modeldata.geom.query.getEnts(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].COLL);
        for (const coll_i of colls_i) {
            fprints.push(this.getCollFprint(coll_i, idx_maps, attrib_names));
        }
        // if there are no values for a certain entity type, e.g. no coll, then return []
        if (fprints.length === 0) {
            return [];
        }
        // before we sort, we need to save the original order, which will be required for the parent collection index
        const fprint_to_old_i_map = new Map();
        for (let i = 0; i < fprints.length; i++) {
            fprint_to_old_i_map.set(fprints[i], i);
        }
        // the fprints of the collections are sorted
        fprints.sort();
        // now we need to create a map from old index to new index
        const old_i_to_new_i_map = new Map();
        for (let i = 0; i < fprints.length; i++) {
            const old_i = fprint_to_old_i_map.get(fprints[i]);
            old_i_to_new_i_map.set(old_i, i);
        }
        // for each collection, we now add the parent id, using the new index
        for (let i = 0; i < fprints.length; i++) {
            const idx = fprint_to_old_i_map.get(fprints[i]);
            const coll_old_i = colls_i[idx];
            const coll_parent_old_i = this._modeldata.geom.query.getCollParent(coll_old_i);
            let parent_str = '';
            if (coll_parent_old_i === -1) {
                parent_str = '.^';
            }
            else {
                const coll_parent_new_i = old_i_to_new_i_map.get(coll_parent_old_i);
                parent_str = coll_parent_new_i + '^';
            }
            fprints[i] = parent_str + fprints[i];
        }
        // return the result, an array of fprints
        return fprints;
    }
    /**
     * Get a fprint of one collection
     * Returns a string, something like 'a@b@c#[1,2,3]#[3,5,7]#[2,5,8]'
     */
    getCollFprint(coll_i, com_idx_maps, attrib_names) {
        const to_ent_types = [_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POINT, _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PLINE, _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PGON];
        const fprints = [];
        const attribs_vals = [];
        // for each attrib, make a finderprint of the attrib value
        if (attrib_names !== undefined) {
            for (const attrib_name of attrib_names) {
                const attrib_value = this._modeldata.attribs.query.getAttribVal(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].COLL, attrib_name, coll_i);
                if (attrib_value !== null && attrib_value !== undefined) {
                    attribs_vals.push(this.getAttribValFprint(attrib_value));
                }
            }
            fprints.push(attribs_vals.join('@'));
        }
        // get all the entities in this collection
        // mapping entity numbers means that we map to the equivalent entity numbers in the other model
        // we do this to ensure that, when comparing models, the entity numbers will match
        for (const to_ent_type of to_ent_types) {
            // get the map from ent_i to com_idx
            const com_idx_map = com_idx_maps.get(to_ent_type);
            // the the common indexes of the entities
            const ents_i = this._modeldata.geom.nav.navAnyToAny(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].COLL, to_ent_type, coll_i);
            const com_idxs = [];
            for (const ent_i of ents_i) {
                const com_idx = com_idx_map.get(ent_i);
                com_idxs.push(com_idx);
            }
            // sort so that they are in standard order
            com_idxs.sort();
            // create a string
            fprints.push(JSON.stringify(com_idxs));
        }
        // return the final fprint string for the collection
        // no need to sort, the order is predefined
        return fprints.join('#');
    }
    /**
     * Get a fprint of an attribute value
     */
    getAttribValFprint(value) {
        const precision = 1e2;
        if (value === null) {
            return '.';
        }
        if (value === undefined) {
            return '.';
        }
        if (typeof value === 'number') {
            return String(Math.round(value * precision) / precision);
        }
        if (typeof value === 'string') {
            return value;
        }
        if (typeof value === 'boolean') {
            return String(value);
        }
        if (Array.isArray(value)) {
            const fprints = [];
            for (const item of value) {
                const attrib_value = this.getAttribValFprint(item);
                fprints.push(attrib_value);
            }
            return fprints.join(',');
        }
        if (typeof value === 'object') {
            let fprint = '';
            const prop_names = Object.getOwnPropertyNames(value);
            prop_names.sort();
            for (const prop_name of prop_names) {
                const attrib_value = this.getAttribValFprint(value[prop_name]);
                fprint += prop_name + '=' + attrib_value;
            }
            return fprint;
        }
        throw new Error('Attribute value not recognised.');
    }
}


/***/ }),

/***/ "./src/assets/libs/geo-info/GIModelData.ts":
/*!*************************************************!*\
  !*** ./src/assets/libs/geo-info/GIModelData.ts ***!
  \*************************************************/
/*! exports provided: GIModelData */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GIModelData", function() { return GIModelData; });
/* harmony import */ var _GIGeom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GIGeom */ "./src/assets/libs/geo-info/GIGeom.ts");
/* harmony import */ var _GIAttribs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GIAttribs */ "./src/assets/libs/geo-info/GIAttribs.ts");
/* harmony import */ var _GIModelComparator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./GIModelComparator */ "./src/assets/libs/geo-info/GIModelComparator.ts");
/* harmony import */ var _GIModelThreejs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./GIModelThreejs */ "./src/assets/libs/geo-info/GIModelThreejs.ts");
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};




/**
 * Geo-info model class.
 */
class GIModelData {
    /**
     * Constructor
     */
    // constructor(model_data?: IModelData) {
    constructor(model) {
        this.debug = true;
        this.model = model;
        this.geom = new _GIGeom__WEBPACK_IMPORTED_MODULE_0__["GIGeom"](this);
        this.attribs = new _GIAttribs__WEBPACK_IMPORTED_MODULE_1__["GIAttribs"](this);
        this.comparator = new _GIModelComparator__WEBPACK_IMPORTED_MODULE_2__["GIModelComparator"](this);
        this.threejs = new _GIModelThreejs__WEBPACK_IMPORTED_MODULE_3__["GIModelThreejs"](this);
        // if (model_data) {
        //     this.setData(model_data);
        // }
    }
    /**
     * Sets the data in this model from JSON data.
     * Any existing data in the model is deleted.
     * @param model_data The JSON data.
     */
    setJSONData(model_data) {
        // console.log("SET DATA");
        this.attribs.io.setJSONData(model_data.attributes);
        this.geom.io.setJSONData(model_data.geometry);
    }
    /**
     * Returns the JSON data for this model.
     * This will include any deleted entities, which will be undefined.
     */
    getJSONData() {
        // console.log("GET DATA");
        return {
            geometry: this.geom.io.getJSONData(),
            attributes: this.attribs.io.getJSONData()
        };
    }
    /**
     * Copys the data from a second model into this model.
     * The existing data in this model is not deleted.
     * For the imported data, deleted entities are also merged.
     * @param model_data The GI model.
     */
    merge(modeldata) {
        // const geom_maps: Map<number, number>[] = this.geom.io.merge(model.modeldata.geom._geom_maps);
        // this.attribs.io.merge(model.modeldata.attribs._attribs_maps, geom_maps);
        this.geom.io.merge(modeldata.geom);
        this.attribs.io.merge(modeldata.attribs._attribs_maps);
        this.model.metadata = modeldata.model.metadata;
    }
    /**
     * Copys the data from a second model into this model without conflict detection.
     * Usually, this model is assumed to be empty.
     * If ent_sets is null, then only model attribs are copied.
     * @param model_data The GI model.
     */
    dumpSelect(modeldata, ent_sets) {
        if (ent_sets === null) {
            this.attribs.io.dumpSelect(modeldata.attribs._attribs_maps, ent_sets);
            return;
        }
        // add topo geom sets
        ent_sets.verts_i = new Set();
        ent_sets.tris_i = new Set();
        ent_sets.edges_i = new Set();
        ent_sets.wires_i = new Set();
        ent_sets.faces_i = new Set();
        // add the ent posis to the main posis list to keep
        ent_sets.obj_posis_i.forEach(posi_i => ent_sets.posis_i.add(posi_i));
        // points
        ent_sets.points_i.forEach(point_i => {
            ent_sets.verts_i.add(modeldata.geom.nav.navPointToVert(point_i));
        });
        // plines
        ent_sets.plines_i.forEach(pline_i => {
            const wire_i = modeldata.geom.nav.navPlineToWire(pline_i);
            ent_sets.wires_i.add(wire_i);
            const edges_i = modeldata.geom.nav.navWireToEdge(wire_i);
            edges_i.forEach(edge_i => ent_sets.edges_i.add(edge_i));
            const verts_i = modeldata.geom.query.getWireVerts(wire_i);
            verts_i.forEach(vert_i => ent_sets.verts_i.add(vert_i));
        });
        // pgons
        ent_sets.pgons_i.forEach(pgon_i => {
            const face_i = modeldata.geom.nav.navPgonToFace(pgon_i);
            ent_sets.faces_i.add(face_i);
            const tris_i = modeldata.geom.nav.navFaceToTri(face_i);
            tris_i.forEach(tri_i => ent_sets.tris_i.add(tri_i));
            const wires_i = modeldata.geom.nav.navFaceToWire(face_i);
            wires_i.forEach(wire_i => ent_sets.wires_i.add(wire_i));
            wires_i.forEach(wire_i => {
                const edges_i = modeldata.geom.nav.navWireToEdge(wire_i);
                edges_i.forEach(edge_i => ent_sets.edges_i.add(edge_i));
                const verts_i = modeldata.geom.query.getWireVerts(wire_i);
                verts_i.forEach(vert_i => ent_sets.verts_i.add(vert_i));
            });
        });
        // dump the selected data into this model
        // this model is assumed to be emprt
        this.geom.io.dumpSelect(modeldata.geom, ent_sets);
        this.attribs.io.dumpSelect(modeldata.attribs._attribs_maps, ent_sets);
    }
    /**
     * Returns a clone of this model.
     * Entity IDs will not change.
     */
    clone() {
        const clone = new GIModelData(this.model);
        clone.geom.io.dump(this.geom._geom_maps);
        clone.attribs.io.dump(this.attribs._attribs_maps);
        // this.model.metadata = this.model.metadata;
        // clone.dump(this);
        return clone;
    }
    /**
     * Renumber entities.
     */
    purge() {
        const clone = new GIModelData(this.model);
        clone.mergeAndPurge(this);
        return clone;
    }
    /**
     * Copys the data from a second model into this model.
     * The existing data in this model is not deleted.
     * For the imported data, deleted entities are filtered out (i.e. not merged).
     * @param model_data The GI model.
     */
    mergeAndPurge(modeldata) {
        const geom_maps = this.geom.io.mergeAndPurge(modeldata.geom._geom_maps);
        this.attribs.io.mergeAndPurge(modeldata.attribs._attribs_maps, geom_maps);
    }
    /**
     * Check model for internal consistency
     */
    check() {
        return this.geom.check.check();
    }
    /**
 * Compares this model and another model.
 * ~
 * This is the answer model.
 * The other model is the submitted model.
 * ~
 * Both models will be modified in the process.
 * ~
 * @param model The model to compare with.
 */
    compare(model, normalize, check_geom_equality, check_attrib_equality) {
        return this.comparator.compare(model, normalize, check_geom_equality, check_attrib_equality);
    }
}


/***/ }),

/***/ "./src/assets/libs/geo-info/GIModelThreejs.ts":
/*!****************************************************!*\
  !*** ./src/assets/libs/geo-info/GIModelThreejs.ts ***!
  \****************************************************/
/*! exports provided: GIModelThreejs */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GIModelThreejs", function() { return GIModelThreejs; });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common */ "./src/assets/libs/geo-info/common.ts");
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! util */ "./node_modules/util/util.js");
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(util__WEBPACK_IMPORTED_MODULE_1__);
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};


/**
 * Geo-info model class.
 */
class GIModelThreejs {
    /**
      * Constructor
      */
    constructor(modeldata) {
        this._modeldata = modeldata;
    }
    /**
     * Generate a default color if none exists.
     */
    _generateColors() {
        const colors = [];
        const num_ents = this._modeldata.geom.query.numEnts(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].VERT);
        for (let index = 0; index < num_ents; index++) {
            colors.push(1, 1, 1);
        }
        // const geom_array = this._modeldata.modeldata.geom._geom_maps;
        // for (const e of geom_array.dn_edges_verts) {
        //     for (const v of e) {
        //         const vert_attrb0 = colors[v * 3];
        //         const vert_attrb1 = colors[v * 3 + 1];
        //         const vert_attrb2 = colors[v * 3 + 2];
        //         if (vert_attrb0 === 1 && vert_attrb1 === 1 && vert_attrb2 === 1) {
        //             colors[v * 3] = 0;
        //             colors[v * 3 + 1] = 0;
        //             colors[v * 3 + 2] = 0;
        //         }
        //     }
        // }
        // for (const w of geom_array.dn_plines_wires) {
        //     for (const e of geom_array.dn_wires_edges.get(w]) {
        //         for (const v of geom_array.dn_edges_verts.get(e]) {
        //             const vert_attrb0 = colors[v * 3];
        //             const vert_attrb1 = colors[v * 3 + 1];
        //             const vert_attrb2 = colors[v * 3 + 2];
        //             if (vert_attrb0 === 1 && vert_attrb1 === 1 && vert_attrb2 === 1) {
        //                 colors[v * 3] = 0;
        //                 colors[v * 3 + 1] = 0;
        //                 colors[v * 3 + 2] = 0;
        //             }
        //         }
        //     }
        // }
        return colors;
    }
    // /**
    //  * Generate default normals if non exist.
    //  */
    // private _generateNormals(): number[] {
    //     const normals = [];
    //     const numEnts = this.geom.query.numEnts(EEntType.VERT, false);
    //     for (let index = 0; index < numEnts; index++) {
    //         normals.push(0, 0, 0);
    //     }
    //     return normals;
    // }
    /**
     * Generate a default color if none exists.
     */
    _getTimelineAttr(vertex_map) {
        const time_points = this._modeldata.attribs._attribs_maps.mo.get('time_slider');
        if (!time_points || !Object(util__WEBPACK_IMPORTED_MODULE_1__["isArray"])(time_points)) {
            return null;
        }
        const geom_array = this._modeldata.geom._geom_maps;
        const attr_array = this._modeldata.attribs._attribs_maps.co.get('visible');
        if (!attr_array) {
            return null;
        }
        const timeline_objs = {
            '__time_points__': time_points
        };
        for (const time_point of time_points) {
            const time_point_obj = {
                time_point: time_point,
                point_indices: [],
                // point_select_map: new Map<number, number>(),
                edge_indices: [],
                // edge_select_map: edge_select_map,
                white_edge_indices: [],
                // white_edge_select_map: white_edge_select_map,
                triangle_indices: [],
            };
            timeline_objs[time_point] = time_point_obj;
        }
        for (const attr of attr_array.getEntsVals()) {
            if (!Object(util__WEBPACK_IMPORTED_MODULE_1__["isArray"])(attr[0]) || !Object(util__WEBPACK_IMPORTED_MODULE_1__["isArray"])(attr[1])) {
                continue;
            }
            for (const col_i of attr[0]) {
                const col_pts = this._modeldata.geom.nav.navCollToPoint(col_i);
                const col_edges = this._modeldata.geom.nav.navAnyToEdge(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].COLL, col_i);
                const col_tris = this._modeldata.geom.nav.navAnyToTri(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].COLL, col_i);
                const point_indices = this._modeldata.geom.threejs.get3jsPointIndices(col_pts, vertex_map);
                const edge_indices = this._modeldata.geom.threejs.get3jsEdgeIndices(col_edges, vertex_map);
                const triangle_indices = this._modeldata.geom.threejs.get3jsTriIndices(col_tris, vertex_map);
                // const points_verts_i: number[] = this._modeldata.geom.threejs.get3jsPointIndex(colObjs[1], vertex_map);
                // const [edges_verts_i, edge_select_map, white_edges_verts_i, white_edge_select_map]:
                //         [number[], Map<number, number>, number[], Map<number, number>] =
                //         this._modeldata.geom.threejs.get3jsEdges(vertex_map);
                // const [tris_verts_i, triangle_select_map, materials, material_groups]:
                //         [number[], Map<number, number>, object[], [number, number, number][]] =
                //         this._modeldata.geom.threejs.get3jsTris(vertex_map);
                for (const tp of attr[1]) {
                    if (!timeline_objs[tp]) {
                        continue;
                    }
                    timeline_objs[tp].point_indices = timeline_objs[tp].point_indices.concat(point_indices);
                    timeline_objs[tp].edge_indices = timeline_objs[tp].edge_indices.concat(edge_indices[0]);
                    timeline_objs[tp].white_edge_indices = timeline_objs[tp].white_edge_indices.concat(edge_indices[1]);
                    timeline_objs[tp].triangle_indices = timeline_objs[tp].triangle_indices.concat(triangle_indices);
                }
            }
        }
        return timeline_objs;
        // for (const e of geom_array.dn_edges_verts) {
        //     for (const v of e) {
        //         const vert_attrb0 = colors[v * 3];
        //         const vert_attrb1 = colors[v * 3 + 1];
        //         const vert_attrb2 = colors[v * 3 + 2];
        //         if (vert_attrb0 === 1 && vert_attrb1 === 1 && vert_attrb2 === 1) {
        //             colors[v * 3] = 0;
        //             colors[v * 3 + 1] = 0;
        //             colors[v * 3 + 2] = 0;
        //         }
        //     }
        // }
    }
    /**
     * Returns arrays for visualization in Threejs.
     */
    get3jsData() {
        // get the attribs at the vertex level
        const [posis_xyz, posis_map] = this._modeldata.attribs.threejs.get3jsSeqPosisCoords();
        const [vertex_xyz, vertex_map] = this._modeldata.attribs.threejs.get3jsSeqVertsCoords();
        const normals_values = this._modeldata.attribs.threejs.get3jsSeqVertsNormals();
        let colors_values = this._modeldata.attribs.threejs.get3jsSeqVertsColors();
        if (!colors_values) {
            colors_values = this._generateColors();
        }
        // get posi indices
        const posis_indices = Array.from(posis_map.values());
        // get the indices of the vertices for edges, points and triangles
        const [tris_verts_i, triangle_select_map, materials, material_groups] = this._modeldata.geom.threejs.get3jsTris(vertex_map);
        const [edges_verts_i, edge_select_map, white_edges_verts_i, white_edge_select_map] = this._modeldata.geom.threejs.get3jsEdges(vertex_map);
        const [points_verts_i, point_select_map] = this._modeldata.geom.threejs.get3jsPoints(vertex_map);
        // return an object containing all the data
        const data = {
            posis_xyz: posis_xyz,
            posis_indices: posis_indices,
            posis_map: posis_map,
            vertex_xyz: vertex_xyz,
            vertex_map: vertex_map,
            normals: normals_values,
            colors: colors_values,
            point_indices: points_verts_i,
            point_select_map: point_select_map,
            edge_indices: edges_verts_i,
            edge_select_map: edge_select_map,
            white_edge_indices: white_edges_verts_i,
            white_edge_select_map: white_edge_select_map,
            triangle_indices: tris_verts_i,
            triangle_select_map: triangle_select_map,
            materials: materials,
            material_groups: material_groups,
        };
        // console.log(data);
        return data;
    }
}


/***/ }),

/***/ "./src/assets/libs/geo-info/GiGeomCompare.ts":
/*!***************************************************!*\
  !*** ./src/assets/libs/geo-info/GiGeomCompare.ts ***!
  \***************************************************/
/*! exports provided: GIGeomCompare */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GIGeomCompare", function() { return GIGeomCompare; });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common */ "./src/assets/libs/geo-info/common.ts");
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};

/**
 * Class for comparing the geometry in two models.
 */
class GIGeomCompare {
    /**
     * Constructor
     */
    constructor(geom, geom_arrays) {
        this._geom = geom;
        this._geom_maps = geom_arrays;
    }
    /**
     * Compares this model and another model.
     * ~
     * The max total score for this method is equal to 5.
     * It assigns 1 mark for for each entity type:
     * points, pline, pgons, and colelctions.
     * In each case, if the number of entities is equal, 1 mark is given.
     * ~
     * @param other_model The model to compare with.
     */
    compare(other_model, result) {
        result.comment.push('Comparing number of geometric entities.');
        const eny_types = [
            _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POINT,
            _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PLINE,
            _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PGON
        ];
        const ent_type_strs = new Map([
            [_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POINT, 'points'],
            [_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PLINE, 'polylines'],
            [_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PGON, 'polygons']
        ]);
        const geom_comments = [];
        for (const ent_type of eny_types) {
            // total marks is not updated, we deduct marks
            // get the number of entitoes in each model
            const this_num_ents = this._geom.query.numEnts(ent_type);
            const other_num_ents = other_model.modeldata.geom.query.numEnts(ent_type);
            if (this_num_ents > other_num_ents) {
                geom_comments.push([
                    'Mismatch: Model has too few entities of type:',
                    ent_type_strs.get(ent_type) + '.',
                    'There were ' + (this_num_ents - other_num_ents) + ' missing entities.',
                ].join(' '));
            }
            else if (this_num_ents < other_num_ents) {
                geom_comments.push([
                    'Mismatch: Model has too many entities of type:',
                    ent_type_strs.get(ent_type) + '.',
                    'There were ' + (other_num_ents - this_num_ents) + ' extra entities.',
                    'A penalty of one mark was deducted from the score.'
                ].join(' '));
                // update the score, deduct 1 mark
                result.score -= 1;
            }
            else {
                // correct
            }
        }
        if (geom_comments.length === 0) {
            geom_comments.push('Number of entities all match.');
        }
        // update the comments in the result
        result.comment.push(geom_comments);
    }
    /**
     * Set the holes in a face by specifying a list of wires.
     * ~
     * This is a low level method used by the compare function to normalize hole order.
     * For making holes in faces, it is safer to use the cutFaceHoles method.
     */
    setPgonHoles(face_i, holes_i) {
        const face = this._geom_maps.dn_faces_wires.get(face_i);
        const wires_i = [face[0]];
        for (let i = 0; i < holes_i.length; i++) {
            wires_i.push(holes_i[i]);
        }
        this._geom_maps.dn_faces_wires.set(face_i, wires_i);
    }
}


/***/ }),

/***/ "./src/assets/libs/geo-info/common.ts":
/*!********************************************!*\
  !*** ./src/assets/libs/geo-info/common.ts ***!
  \********************************************/
/*! exports provided: LONGLAT, XYPLANE, YZPLANE, ZXPLANE, YXPLANE, ZYPLANE, XZPLANE, EEntType, EEntTypeCollCP, EEntTypeStr, EEntStrToGeomMaps, EAttribNames, EWireType, EFilterOperatorTypes, ESort, EAttribPush, EAttribDataTypeStrs, RE_SPACES */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LONGLAT", function() { return LONGLAT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "XYPLANE", function() { return XYPLANE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "YZPLANE", function() { return YZPLANE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ZXPLANE", function() { return ZXPLANE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "YXPLANE", function() { return YXPLANE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ZYPLANE", function() { return ZYPLANE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "XZPLANE", function() { return XZPLANE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EEntType", function() { return EEntType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EEntTypeCollCP", function() { return EEntTypeCollCP; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EEntTypeStr", function() { return EEntTypeStr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EEntStrToGeomMaps", function() { return EEntStrToGeomMaps; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EAttribNames", function() { return EAttribNames; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EWireType", function() { return EWireType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EFilterOperatorTypes", function() { return EFilterOperatorTypes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ESort", function() { return ESort; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EAttribPush", function() { return EAttribPush; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EAttribDataTypeStrs", function() { return EAttribDataTypeStrs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RE_SPACES", function() { return RE_SPACES; });
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};
// longitude latitude in Singapore, NUS
const LONGLAT = [103.778329, 1.298759];
// some constants
const XYPLANE = [[0, 0, 0], [1, 0, 0], [0, 1, 0]];
const YZPLANE = [[0, 0, 0], [0, 1, 0], [0, 0, 1]];
const ZXPLANE = [[0, 0, 0], [0, 0, 1], [1, 0, 0]];
const YXPLANE = [[0, 0, 0], [0, 1, 0], [1, 0, 0]];
const ZYPLANE = [[0, 0, 0], [0, 0, 1], [0, 1, 0]];
const XZPLANE = [[0, 0, 0], [1, 0, 0], [0, 0, 1]];
// Types of entities
var EEntType;
(function (EEntType) {
    EEntType[EEntType["POSI"] = 0] = "POSI";
    EEntType[EEntType["TRI"] = 1] = "TRI";
    EEntType[EEntType["VERT"] = 2] = "VERT";
    EEntType[EEntType["EDGE"] = 3] = "EDGE";
    EEntType[EEntType["WIRE"] = 4] = "WIRE";
    EEntType[EEntType["FACE"] = 5] = "FACE";
    EEntType[EEntType["POINT"] = 6] = "POINT";
    EEntType[EEntType["PLINE"] = 7] = "PLINE";
    EEntType[EEntType["PGON"] = 8] = "PGON";
    EEntType[EEntType["COLL"] = 9] = "COLL";
    EEntType[EEntType["MOD"] = 10] = "MOD";
})(EEntType || (EEntType = {}));
var EEntTypeCollCP;
(function (EEntTypeCollCP) {
    EEntTypeCollCP[EEntTypeCollCP["POSI"] = 0] = "POSI";
    EEntTypeCollCP[EEntTypeCollCP["TRI"] = 1] = "TRI";
    EEntTypeCollCP[EEntTypeCollCP["VERT"] = 2] = "VERT";
    EEntTypeCollCP[EEntTypeCollCP["EDGE"] = 3] = "EDGE";
    EEntTypeCollCP[EEntTypeCollCP["WIRE"] = 4] = "WIRE";
    EEntTypeCollCP[EEntTypeCollCP["FACE"] = 5] = "FACE";
    EEntTypeCollCP[EEntTypeCollCP["POINT"] = 6] = "POINT";
    EEntTypeCollCP[EEntTypeCollCP["PLINE"] = 7] = "PLINE";
    EEntTypeCollCP[EEntTypeCollCP["PGON"] = 8] = "PGON";
    EEntTypeCollCP[EEntTypeCollCP["COLL"] = 9] = "COLL";
    EEntTypeCollCP[EEntTypeCollCP["COLLC"] = 10] = "COLLC";
    EEntTypeCollCP[EEntTypeCollCP["COLLP"] = 11] = "COLLP";
    EEntTypeCollCP[EEntTypeCollCP["MOD"] = 12] = "MOD";
})(EEntTypeCollCP || (EEntTypeCollCP = {}));
// Types of entities
var EEntTypeStr;
(function (EEntTypeStr) {
    EEntTypeStr[EEntTypeStr["ps"] = 0] = "ps";
    EEntTypeStr[EEntTypeStr["_t"] = 1] = "_t";
    EEntTypeStr[EEntTypeStr["_v"] = 2] = "_v";
    EEntTypeStr[EEntTypeStr["_e"] = 3] = "_e";
    EEntTypeStr[EEntTypeStr["_w"] = 4] = "_w";
    EEntTypeStr[EEntTypeStr["_f"] = 5] = "_f";
    EEntTypeStr[EEntTypeStr["pt"] = 6] = "pt";
    EEntTypeStr[EEntTypeStr["pl"] = 7] = "pl";
    EEntTypeStr[EEntTypeStr["pg"] = 8] = "pg";
    EEntTypeStr[EEntTypeStr["co"] = 9] = "co";
    EEntTypeStr[EEntTypeStr["mo"] = 10] = "mo";
})(EEntTypeStr || (EEntTypeStr = {}));
var EEntStrToGeomMaps;
(function (EEntStrToGeomMaps) {
    EEntStrToGeomMaps[EEntStrToGeomMaps["up_posis_verts"] = 0] = "up_posis_verts";
    EEntStrToGeomMaps[EEntStrToGeomMaps["dn_tris_verts"] = 1] = "dn_tris_verts";
    EEntStrToGeomMaps[EEntStrToGeomMaps["dn_verts_posis"] = 2] = "dn_verts_posis";
    EEntStrToGeomMaps[EEntStrToGeomMaps["dn_edges_verts"] = 3] = "dn_edges_verts";
    EEntStrToGeomMaps[EEntStrToGeomMaps["dn_wires_edges"] = 4] = "dn_wires_edges";
    EEntStrToGeomMaps[EEntStrToGeomMaps["dn_faces_wires"] = 5] = "dn_faces_wires";
    EEntStrToGeomMaps[EEntStrToGeomMaps["dn_points_verts"] = 6] = "dn_points_verts";
    EEntStrToGeomMaps[EEntStrToGeomMaps["dn_plines_wires"] = 7] = "dn_plines_wires";
    EEntStrToGeomMaps[EEntStrToGeomMaps["dn_pgons_faces"] = 8] = "dn_pgons_faces";
    EEntStrToGeomMaps[EEntStrToGeomMaps["dn_colls_objs"] = 9] = "dn_colls_objs";
})(EEntStrToGeomMaps || (EEntStrToGeomMaps = {}));
// Names of attributes
var EAttribNames;
(function (EAttribNames) {
    EAttribNames["COORDS"] = "xyz";
    EAttribNames["NORMAL"] = "normal";
    EAttribNames["COLOR"] = "rgb";
    EAttribNames["TEXTURE"] = "uv";
    EAttribNames["NAME"] = "name";
    EAttribNames["MATERIAL"] = "material";
    EAttribNames["VISIBILITY"] = "visibility";
    EAttribNames["LABEL"] = "label";
})(EAttribNames || (EAttribNames = {}));
// Wire Type
var EWireType;
(function (EWireType) {
    EWireType["PLINE"] = "pline";
    EWireType["PGON"] = "pgon";
    EWireType["PGON_HOLE"] = "pgon_hole";
})(EWireType || (EWireType = {}));
/**
 * The types of operators that can be used in a filter.
 */
var EFilterOperatorTypes;
(function (EFilterOperatorTypes) {
    EFilterOperatorTypes["IS_EQUAL"] = "==";
    EFilterOperatorTypes["IS_NOT_EQUAL"] = "!=";
    EFilterOperatorTypes["IS_GREATER_OR_EQUAL"] = ">=";
    EFilterOperatorTypes["IS_LESS_OR_EQUAL"] = "<=";
    EFilterOperatorTypes["IS_GREATER"] = ">";
    EFilterOperatorTypes["IS_LESS"] = "<";
    EFilterOperatorTypes["EQUAL"] = "=";
})(EFilterOperatorTypes || (EFilterOperatorTypes = {}));
var ESort;
(function (ESort) {
    ESort["DESCENDING"] = "descending";
    ESort["ASCENDING"] = "ascending";
})(ESort || (ESort = {}));
var EAttribPush;
(function (EAttribPush) {
    EAttribPush[EAttribPush["AVERAGE"] = 0] = "AVERAGE";
    EAttribPush[EAttribPush["MEDIAN"] = 1] = "MEDIAN";
    EAttribPush[EAttribPush["SUM"] = 2] = "SUM";
    EAttribPush[EAttribPush["MIN"] = 3] = "MIN";
    EAttribPush[EAttribPush["MAX"] = 4] = "MAX";
    EAttribPush[EAttribPush["FIRST"] = 5] = "FIRST";
    EAttribPush[EAttribPush["LAST"] = 6] = "LAST";
})(EAttribPush || (EAttribPush = {}));
// enums
var EAttribDataTypeStrs;
(function (EAttribDataTypeStrs) {
    // INT = 'Int',
    EAttribDataTypeStrs["NUMBER"] = "number";
    EAttribDataTypeStrs["STRING"] = "string";
    EAttribDataTypeStrs["BOOLEAN"] = "boolean";
    EAttribDataTypeStrs["LIST"] = "list";
    EAttribDataTypeStrs["DICT"] = "dict // an object";
})(EAttribDataTypeStrs || (EAttribDataTypeStrs = {}));
const RE_SPACES = /\s+/g;


/***/ }),

/***/ "./src/assets/libs/geo-info/common_func.ts":
/*!*************************************************!*\
  !*** ./src/assets/libs/geo-info/common_func.ts ***!
  \*************************************************/
/*! exports provided: cloneDeepMapArr, getEntTypeStr */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cloneDeepMapArr", function() { return cloneDeepMapArr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getEntTypeStr", function() { return getEntTypeStr; });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common */ "./src/assets/libs/geo-info/common.ts");
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};

/**
 * Makes a deep clone of map where keys are integers and values are arrays of integers.
 * @param map
 */
function cloneDeepMapArr(map) {
    const new_map = new Map();
    map.forEach((value, key) => {
        new_map.set(key, value.slice());
    });
    return new_map;
}
/**
 * Used for error messages
 * @param ent_type_str
 */
function getEntTypeStr(ent_type_str) {
    switch (ent_type_str) {
        case _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POSI:
            return 'positions';
        case _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].VERT:
            return 'vertices';
        case _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].TRI:
            return 'triangles';
        case _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].EDGE:
            return 'edges';
        case _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].WIRE:
            return 'wires';
        case _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].FACE:
            return 'faces';
        case _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POINT:
            return 'points';
        case _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PLINE:
            return 'polylines';
        case _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PGON:
            return 'polygons';
        case _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].COLL:
            return 'collections';
    }
}


/***/ }),

/***/ "./src/assets/libs/geo-info/id.ts":
/*!****************************************!*\
  !*** ./src/assets/libs/geo-info/id.ts ***!
  \****************************************/
/*! exports provided: getArrDepth, isEmptyArr, idsMakeFromIndicies, idsMake, idsBreak, idIndicies, isPosi, isVert, isTri, isEdge, isWire, isFace, isPoint, isPline, isPgon, isColl, isTopo, isObj, isDim0, isDim1, isDim2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getArrDepth", function() { return getArrDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isEmptyArr", function() { return isEmptyArr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "idsMakeFromIndicies", function() { return idsMakeFromIndicies; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "idsMake", function() { return idsMake; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "idsBreak", function() { return idsBreak; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "idIndicies", function() { return idIndicies; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isPosi", function() { return isPosi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isVert", function() { return isVert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isTri", function() { return isTri; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isEdge", function() { return isEdge; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isWire", function() { return isWire; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isFace", function() { return isFace; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isPoint", function() { return isPoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isPline", function() { return isPline; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isPgon", function() { return isPgon; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isColl", function() { return isColl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isTopo", function() { return isTopo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isObj", function() { return isObj; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isDim0", function() { return isDim0; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isDim1", function() { return isDim1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isDim2", function() { return isDim2; });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common */ "./src/assets/libs/geo-info/common.ts");
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};

// ============================================================================
function getArrDepth(arr) {
    if (Array.isArray(arr)) {
        return 1 + getArrDepth(arr[0]);
    }
    return 0;
}
function isEmptyArr(arr) {
    if (Array.isArray(arr) && !arr.length) {
        return true;
    }
    return false;
}
// ============================================================================
function idsMakeFromIndicies(ent_type, idxs) {
    const depth = getArrDepth(idxs);
    if (depth === 0) {
        const idx = idxs;
        return _common__WEBPACK_IMPORTED_MODULE_0__["EEntTypeStr"][ent_type] + idx;
    }
    else if (depth === 1) {
        const idxs_arr = idxs;
        if (idxs_arr.length === 0) {
            return [];
        } //  deal with empty array
        return idxs_arr.map(idx => idsMakeFromIndicies(ent_type, idx));
    }
    else { // depth === 2
        const idxs_arrs = idxs;
        return idxs_arrs.map(idxs_arr => idsMakeFromIndicies(ent_type, idxs_arr));
    }
}
function idsMake(ent_type_idxs) {
    const depth = getArrDepth(ent_type_idxs);
    if (depth === 1) {
        if (ent_type_idxs.length === 0) {
            return [];
        } //  deal with empty array
        const ent_type_idx = ent_type_idxs;
        return _common__WEBPACK_IMPORTED_MODULE_0__["EEntTypeStr"][ent_type_idx[0]] + ent_type_idx[1];
    }
    else if (depth === 2) {
        const ent_type_idxs_arr = ent_type_idxs;
        return ent_type_idxs_arr.map(ent_type_idx => idsMake(ent_type_idx));
    }
    else { // depth === 3
        const ent_type_idxs_arrs = ent_type_idxs;
        return ent_type_idxs_arrs.map(ent_type_idxs_arr => idsMake(ent_type_idxs_arr));
    }
}
function idsBreak(id) {
    // const depth: number = getArrDepth(ids);
    if (id === null) {
        return null;
    }
    if (!Array.isArray(id)) {
        id = id;
        if (typeof id !== 'string') {
            throw new Error('Value is not an entity ID.');
        }
        // if (id.length < 3) { throw new Error('String is not an entity ID.'); }
        const ent_type_str = id.slice(0, 2);
        const ent_type = _common__WEBPACK_IMPORTED_MODULE_0__["EEntTypeStr"][ent_type_str];
        if (ent_type === undefined) {
            throw new Error('String is not an entity ID.');
        }
        const index = Number(id.slice(2));
        return [ent_type, index];
    }
    else {
        return id.map(a_id => idsBreak(a_id));
    }
    // } else if (depth === 1) {
    //     const ids_arr: TId[] = ids as TId[];
    //     return ids_arr.map( id => idsBreak(id) ) as TEntTypeIdx[];
    // } else { // depth === 2
    //     const ids_arr: TId[][] = ids as TId[][];
    //     return ids_arr.map( id => idsBreak(id) ) as TEntTypeIdx[][];
    // }
}
function idIndicies(ents_arr) {
    return ents_arr.map(ents => ents[1]);
}
// ============================================================================
function isPosi(ent_type) {
    return ent_type === _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POSI;
}
function isVert(ent_type) {
    return ent_type === _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].VERT;
}
function isTri(ent_type) {
    return ent_type === _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].TRI;
}
function isEdge(ent_type) {
    return ent_type === _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].EDGE;
}
function isWire(ent_type) {
    return ent_type === _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].WIRE;
}
function isFace(ent_type) {
    return ent_type === _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].FACE;
}
function isPoint(ent_type) {
    return ent_type === _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POINT;
}
function isPline(ent_type) {
    return ent_type === _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PLINE;
}
function isPgon(ent_type) {
    return ent_type === _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PGON;
}
function isColl(ent_type) {
    return ent_type === _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].COLL;
}
// more general test
function isTopo(ent_type) {
    if (ent_type === _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].VERT) {
        return true;
    }
    if (ent_type === _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].EDGE) {
        return true;
    }
    if (ent_type === _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].WIRE) {
        return true;
    }
    if (ent_type === _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].FACE) {
        return true;
    }
    return false;
}
function isObj(ent_type) {
    if (ent_type === _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PGON) {
        return true;
    }
    if (ent_type === _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PLINE) {
        return true;
    }
    if (ent_type === _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POINT) {
        return true;
    }
    return false;
}
function isDim0(ent_type) {
    if (ent_type === _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POSI) {
        return true;
    }
    if (ent_type === _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].VERT) {
        return true;
    }
    if (ent_type === _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POINT) {
        return true;
    }
    return false;
}
function isDim1(ent_type) {
    if (ent_type === _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].EDGE) {
        return true;
    }
    if (ent_type === _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PLINE) {
        return true;
    }
    return false;
}
function isDim2(ent_type) {
    if (ent_type === _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].FACE) {
        return true;
    }
    if (ent_type === _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PGON) {
        return true;
    }
    return false;
}


/***/ }),

/***/ "./src/assets/libs/geo-info/io_geojson.ts":
/*!************************************************!*\
  !*** ./src/assets/libs/geo-info/io_geojson.ts ***!
  \************************************************/
/*! exports provided: exportGeojson, importGeojson */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exportGeojson", function() { return exportGeojson; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "importGeojson", function() { return importGeojson; });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common */ "./src/assets/libs/geo-info/common.ts");
/* harmony import */ var _id__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./id */ "./src/assets/libs/geo-info/id.ts");
/* harmony import */ var proj4__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! proj4 */ "./node_modules/proj4/lib/index.js");
/* harmony import */ var _geom_vectors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../geom/vectors */ "./src/assets/libs/geom/vectors.ts");
/* harmony import */ var _geom_matrix__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../geom/matrix */ "./src/assets/libs/geom/matrix.ts");
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};





var EGeojsoFeatureType;
(function (EGeojsoFeatureType) {
    EGeojsoFeatureType["POINT"] = "Point";
    EGeojsoFeatureType["LINESTRING"] = "LineString";
    EGeojsoFeatureType["POLYGON"] = "Polygon";
    EGeojsoFeatureType["MULTIPOINT"] = "MultiPoint";
    EGeojsoFeatureType["MULTILINESTRING"] = "MultiLineString";
    EGeojsoFeatureType["MULTIPOLYGON"] = "MultiPolygon";
})(EGeojsoFeatureType || (EGeojsoFeatureType = {}));
function exportGeojson(model, entities, flatten) {
    // create the projection object
    const proj_obj = _createProjection(model);
    // calculate angle of rotation
    let rot_matrix = null;
    if (model.modeldata.attribs.query.hasModelAttrib('north')) {
        const north = model.modeldata.attribs.query.getModelAttribVal('north');
        if (Array.isArray(north)) {
            const rot_ang = Object(_geom_vectors__WEBPACK_IMPORTED_MODULE_3__["vecAng2"])([0, 1, 0], [north[0], north[1], 0], [0, 0, 1]);
            rot_matrix = Object(_geom_matrix__WEBPACK_IMPORTED_MODULE_4__["rotateMatrix"])([[0, 0, 0], [0, 0, 1]], -rot_ang);
        }
    }
    const features = [];
    for (const [ent_type, ent_i] of entities) {
        switch (ent_type) {
            case _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PGON:
                features.push(_createGeojsonPolygon(model, ent_i, proj_obj, rot_matrix, flatten));
                break;
            case _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PLINE:
                features.push(_createGeojsonLineString(model, ent_i, proj_obj, rot_matrix, flatten));
                break;
            default:
                break;
        }
    }
    const export_json = {
        'type': 'FeatureCollection',
        'features': features
    };
    return JSON.stringify(export_json, null, 2); // pretty
}
function _createGeojsonPolygon(model, pgon_i, proj_obj, rot_matrix, flatten) {
    // {
    //     "type": "Feature",
    //     "geometry": {
    //       "type": "Polygon",
    //       "coordinates": [
    //         [
    //           [100.0, 0.0], [101.0, 0.0], [101.0, 1.0],
    //           [100.0, 1.0], [100.0, 0.0]
    //         ]
    //       ]
    //     },
    //     "properties": {
    //       "prop0": "value0",
    //       "prop1": { "this": "that" }
    //     }
    // }
    const all_coords = [];
    const wires_i = model.modeldata.geom.nav.navAnyToWire(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PGON, pgon_i);
    for (let i = 0; i < wires_i.length; i++) {
        const coords = [];
        const posis_i = model.modeldata.geom.nav.navAnyToPosi(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].WIRE, wires_i[i]);
        for (const posi_i of posis_i) {
            const xyz = model.modeldata.attribs.query.getPosiCoords(posi_i);
            const lat_long = _xformFromXYZToLongLat(xyz, proj_obj, rot_matrix, flatten);
            coords.push(lat_long);
        }
        all_coords.push(coords);
    }
    const all_props = {};
    for (const name of model.modeldata.attribs.query.getAttribNames(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PGON)) {
        all_props[name] = model.modeldata.attribs.query.getAttribVal(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PGON, name, pgon_i);
    }
    return {
        'type': 'Feature',
        'geometry': {
            'type': 'Polygon',
            'coordinates': all_coords
        },
        'properties': all_props
    };
}
function _createGeojsonLineString(model, pline_i, proj_obj, rot_matrix, flatten) {
    // {
    //     "type": "Feature",
    //     "geometry": {
    //       "type": "LineString",
    //       "coordinates": [
    //         [102.0, 0.0], [103.0, 1.0], [104.0, 0.0], [105.0, 1.0]
    //       ]
    //     },
    //     "properties": {
    //       "prop0": "value0",
    //       "prop1": 0.0
    //     }
    // },
    const coords = [];
    const wire_i = model.modeldata.geom.nav.navPlineToWire(pline_i);
    const posis_i = model.modeldata.geom.nav.navAnyToPosi(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].WIRE, wire_i);
    for (const posi_i of posis_i) {
        const xyz = model.modeldata.attribs.query.getPosiCoords(posi_i);
        const lat_long = _xformFromXYZToLongLat(xyz, proj_obj, rot_matrix, flatten);
        coords.push(lat_long);
    }
    if (model.modeldata.geom.query.isWireClosed(wire_i)) {
        coords.push(coords[0]);
    }
    const all_props = {};
    for (const name of model.modeldata.attribs.query.getAttribNames(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PLINE)) {
        all_props[name] = model.modeldata.attribs.query.getAttribVal(_common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PLINE, name, pline_i);
    }
    return {
        'type': 'Feature',
        'geometry': {
            'type': 'LineString',
            'coordinates': coords
        },
        'properties': all_props
    };
}
/**
* Import geojson
*/
function importGeojson(model, geojson_str, elevation) {
    // parse the json data str
    const geojson_obj = JSON.parse(geojson_str);
    const proj_obj = _createProjection(model);
    // calculate angle of rotation
    let rot_matrix = null;
    if (model.modeldata.attribs.query.hasModelAttrib('north')) {
        const north = model.modeldata.attribs.query.getModelAttribVal('north');
        if (Array.isArray(north)) {
            const rot_ang = Object(_geom_vectors__WEBPACK_IMPORTED_MODULE_3__["vecAng2"])([0, 1, 0], [north[0], north[1], 0], [0, 0, 1]);
            rot_matrix = Object(_geom_matrix__WEBPACK_IMPORTED_MODULE_4__["rotateMatrix"])([[0, 0, 0], [0, 0, 1]], rot_ang);
        }
    }
    // arrays for features
    const point_f = [];
    const linestring_f = [];
    const polygon_f = [];
    const multipoint_f = [];
    const multilinestring_f = [];
    const multipolygon_f = [];
    const other_f = [];
    // arrays for objects
    const points_i = new Set();
    const plines_i = new Set();
    const pgons_i = new Set();
    const colls_i = new Set();
    // loop
    for (const feature of geojson_obj.features) {
        // get the features
        switch (feature.geometry.type) {
            case EGeojsoFeatureType.POINT:
                point_f.push(feature);
                const point_i = _addPointToModel(model, feature, proj_obj, rot_matrix, elevation);
                points_i.add(point_i);
                break;
            case EGeojsoFeatureType.LINESTRING:
                linestring_f.push(feature);
                const pline_i = _addPlineToModel(model, feature, proj_obj, rot_matrix, elevation);
                plines_i.add(pline_i);
                break;
            case EGeojsoFeatureType.POLYGON:
                polygon_f.push(feature);
                const pgon_i = _addPgonToModel(model, feature, proj_obj, rot_matrix, elevation);
                pgons_i.add(pgon_i);
                break;
            case EGeojsoFeatureType.MULTIPOINT:
                multipoint_f.push(feature);
                const points_coll_i = _addPointCollToModel(model, feature, proj_obj, rot_matrix, elevation);
                for (const point_coll_i of points_coll_i[0]) {
                    points_i.add(point_coll_i);
                }
                colls_i.add(points_coll_i[1]);
                break;
            case EGeojsoFeatureType.MULTILINESTRING:
                multilinestring_f.push(feature);
                const plines_coll_i = _addPlineCollToModel(model, feature, proj_obj, rot_matrix, elevation);
                for (const pline_coll_i of plines_coll_i[0]) {
                    plines_i.add(pline_coll_i);
                }
                colls_i.add(plines_coll_i[1]);
                break;
            case EGeojsoFeatureType.MULTIPOLYGON:
                multipolygon_f.push(feature);
                const pgons_coll_i = _addPgonCollToModel(model, feature, proj_obj, rot_matrix, elevation);
                for (const pgon_coll_i of pgons_coll_i[0]) {
                    pgons_i.add(pgon_coll_i);
                }
                colls_i.add(pgons_coll_i[1]);
                break;
            default:
                other_f.push(feature);
                break;
        }
    }
    // return sets
    return {
        points_i: points_i,
        plines_i: plines_i,
        pgons_i: pgons_i,
        colls_i: colls_i
    };
}
/**
 * Get long lat, Detect CRS, create projection function
 * @param model The model.
 * @param point The features to add.
 */
function _createProjection(model) {
    // create the function for transformation
    const proj_str_a = '+proj=tmerc +lat_0=';
    const proj_str_b = ' +lon_0=';
    const proj_str_c = '+k=1 +x_0=0 +y_0=0 +ellps=WGS84 +units=m +no_defs';
    let longitude = _common__WEBPACK_IMPORTED_MODULE_0__["LONGLAT"][0];
    let latitude = _common__WEBPACK_IMPORTED_MODULE_0__["LONGLAT"][1];
    if (model.modeldata.attribs.query.hasModelAttrib('geolocation')) {
        const geolocation = model.modeldata.attribs.query.getModelAttribVal('geolocation');
        const long_value = geolocation['longitude'];
        if (typeof long_value !== 'number') {
            throw new Error('Longitude attribute must be a number.');
        }
        longitude = long_value;
        if (longitude < -180 || longitude > 180) {
            throw new Error('Longitude attribute must be between -180 and 180.');
        }
        const lat_value = geolocation['latitude'];
        if (typeof lat_value !== 'number') {
            throw new Error('Latitude attribute must be a number');
        }
        latitude = lat_value;
        if (latitude < 0 || latitude > 90) {
            throw new Error('Latitude attribute must be between 0 and 90.');
        }
    }
    // try to figure out what the projection is of the source file
    // let proj_from_str = 'WGS84';
    // if (geojson_obj.hasOwnProperty('crs')) {
    //     if (geojson_obj.crs.hasOwnProperty('properties')) {
    //         if (geojson_obj.crs.properties.hasOwnProperty('name')) {
    //             const name: string = geojson_obj.crs.properties.name;
    //             const epsg_index = name.indexOf('EPSG');
    //             if (epsg_index !== -1) {
    //                 let epsg = name.slice(epsg_index);
    //                 epsg = epsg.replace(/\s/g, '+');
    //                 if (epsg === 'EPSG:4326') {
    //                     // do nothing, 'WGS84' is fine
    //                 } else if (['EPSG:4269', 'EPSG:3857', 'EPSG:3785', 'EPSG:900913', 'EPSG:102113'].indexOf(epsg) !== -1) {
    //                     // these are the epsg codes that proj4 knows
    //                     proj_from_str = epsg;
    //                 } else if (epsg === 'EPSG:3414') {
    //                     // singapore
    //                     proj_from_str =
    //                         '+proj=tmerc +lat_0=1.366666666666667 +lon_0=103.8333333333333 +k=1 +x_0=28001.642 +y_0=38744.572 ' +
    //                         '+ellps=WGS84 +units=m +no_defs';
    //                 }
    //             }
    //         }
    //     }
    // }
    // console.log('CRS of geojson data', proj_from_str);
    const proj_from_str = 'WGS84';
    const proj_to_str = proj_str_a + latitude + proj_str_b + longitude + proj_str_c;
    const proj_obj = Object(proj4__WEBPACK_IMPORTED_MODULE_2__["default"])(proj_from_str, proj_to_str);
    return proj_obj;
}
/*
    "geometry": {
        "type": "Point",
        "coordinates": [40, 40]
    }
*/
/**
 * Add a point to the model
 * @param model The model.
 * @param point The features to add.
 */
function _addPointToModel(model, point, proj_obj, rot_matrix, elevation) {
    // add feature
    let xyz = _xformFromLongLatToXYZ(point.geometry.coordinates, proj_obj, elevation);
    // rotate to north
    if (rot_matrix !== null) {
        xyz = Object(_geom_matrix__WEBPACK_IMPORTED_MODULE_4__["multMatrix"])(xyz, rot_matrix);
    }
    // create the posi
    const posi_i = model.modeldata.geom.add.addPosi();
    model.modeldata.attribs.add.setPosiCoords(posi_i, xyz);
    // create the point
    const point_i = model.modeldata.geom.add.addPoint(posi_i);
    // add attribs
    _addAttribsToModel(model, _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].POINT, point_i, point);
    // return the index
    return point_i;
}
/*
    "geometry": {
        "type": "LineString",
        "coordinates": [
            [30, 10], [10, 30], [40, 40]
        ]
    }
*/
/**
 * Add a pline to the model
 * @param model The model
 * @param linestrings The features to add.
 */
function _addPlineToModel(model, linestring, proj_obj, rot_matrix, elevation) {
    // add feature
    let xyzs = _xformFromLongLatToXYZ(linestring.geometry.coordinates, proj_obj, elevation);
    const first_xyz = xyzs[0];
    const last_xyz = xyzs[xyzs.length - 1];
    const close = xyzs.length > 2 && first_xyz[0] === last_xyz[0] && first_xyz[1] === last_xyz[1];
    if (close) {
        xyzs = xyzs.slice(0, xyzs.length - 1);
    }
    // rotate to north
    if (rot_matrix !== null) {
        for (let i = 0; i < xyzs.length; i++) {
            xyzs[i] = Object(_geom_matrix__WEBPACK_IMPORTED_MODULE_4__["multMatrix"])(xyzs[i], rot_matrix);
        }
    }
    // create the posis
    const posis_i = [];
    for (const xyz of xyzs) {
        const posi_i = model.modeldata.geom.add.addPosi();
        model.modeldata.attribs.add.setPosiCoords(posi_i, xyz);
        posis_i.push(posi_i);
    }
    // create the pline
    const pline_i = model.modeldata.geom.add.addPline(posis_i, close);
    // add attribs
    _addAttribsToModel(model, _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PLINE, pline_i, linestring);
    // return the index
    return pline_i;
}
/*
    "geometry": {
        "type": "Polygon",
        "coordinates": [
            [[35, 10], [45, 45], [15, 40], [10, 20], [35, 10]],
            [[20, 30], [35, 35], [30, 20], [20, 30]]
        ]
    }
*/
/**
 * Add a pgon to the model
 * @param model The model
 * @param polygons The features to add.
 */
function _addPgonToModel(model, polygon, proj_obj, rot_matrix, elevation) {
    // add feature
    const rings = [];
    for (const ring of polygon.geometry.coordinates) {
        const xyzs = _xformFromLongLatToXYZ(ring, proj_obj, elevation);
        // rotate to north
        if (rot_matrix !== null) {
            for (let i = 0; i < xyzs.length; i++) {
                xyzs[i] = Object(_geom_matrix__WEBPACK_IMPORTED_MODULE_4__["multMatrix"])(xyzs[i], rot_matrix);
            }
        }
        // create the posis
        const posis_i = [];
        for (const xyz of xyzs) {
            const posi_i = model.modeldata.geom.add.addPosi();
            model.modeldata.attribs.add.setPosiCoords(posi_i, xyz);
            posis_i.push(posi_i);
        }
        rings.push(posis_i);
    }
    // create the pgon
    const pgon_i = model.modeldata.geom.add.addPgon(rings[0], rings.slice(1));
    // check if it needs flipping
    // TODO there may be a faster way to do this
    const face_i = model.modeldata.geom.nav.navPgonToFace(pgon_i);
    const normal = model.modeldata.geom.query.getFaceNormal(face_i);
    if (Object(_geom_vectors__WEBPACK_IMPORTED_MODULE_3__["vecDot"])(normal, [0, 0, 1]) < 0) {
        model.modeldata.geom.modify.reverse(model.modeldata.geom.nav.navFaceToWire(face_i)[0]);
    }
    // add attribs
    _addAttribsToModel(model, _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].PGON, pgon_i, polygon);
    // return the index
    return pgon_i;
}
/*
    "geometry": {
        "type": "MultiPoint",
        "coordinates": [
            [10, 10],
            [40, 40]
        ]
    }
*/
/**
 * Adds multipoint to the model
 * @param model The model
 * @param multipoint The features to add.
 */
function _addPointCollToModel(model, multipoint, proj_obj, rot_matrix, elevation) {
    // add features
    const points_i = [];
    for (const coordinates of multipoint.geometry.coordinates) {
        const point_i = _addPointToModel(model, { 'geometry': { 'coordinates': coordinates } }, proj_obj, rot_matrix, elevation);
        points_i.push(point_i);
    }
    // create the collection
    const coll_i = model.modeldata.geom.add.addColl(null, [], points_i, []);
    // add attribs
    _addAttribsToModel(model, _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].COLL, coll_i, multipoint);
    // return the indices of the plines and the index of the collection
    return [points_i, coll_i];
}
/*
    "geometry": {
        "type": "MultiLineString",
        "coordinates": [
            [[10, 10], [20, 20], [10, 40]],
            [[40, 40], [30, 30], [40, 20], [30, 10]]
        ]
    }
*/
/**
 * Adds multilinestrings to the model
 * @param multilinestrings The features to add.
 * @param model The model
 */
function _addPlineCollToModel(model, multilinestring, proj_obj, rot_matrix, elevation) {
    // add features
    const plines_i = [];
    for (const coordinates of multilinestring.geometry.coordinates) {
        const pline_i = _addPlineToModel(model, { 'geometry': { 'coordinates': coordinates } }, proj_obj, rot_matrix, elevation);
        plines_i.push(pline_i);
    }
    // create the collection
    const coll_i = model.modeldata.geom.add.addColl(null, [], plines_i, []);
    // add attribs
    _addAttribsToModel(model, _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].COLL, coll_i, multilinestring);
    // return the indices of the plines and the index of the collection
    return [plines_i, coll_i];
}
/*
    "geometry": {
        "type": "MultiPolygon",
        "coordinates": [
            [
                [[40, 40], [20, 45], [45, 30], [40, 40]]
            ],
            [
                [[20, 35], [10, 30], [10, 10], [30, 5], [45, 20], [20, 35]],
                [[30, 20], [20, 15], [20, 25], [30, 20]]
            ]
        ]
    }
*/
/**
 * Adds multipolygons to the model
 * @param model The model
 * @param multipolygons The features to add.
 */
function _addPgonCollToModel(model, multipolygon, proj_obj, rot_matrix, elevation) {
    // add features
    const pgons_i = [];
    for (const coordinates of multipolygon.geometry.coordinates) {
        const pgon_i = _addPgonToModel(model, { 'geometry': { 'coordinates': coordinates } }, proj_obj, rot_matrix, elevation);
        pgons_i.push(pgon_i);
    }
    // create the collection
    const coll_i = model.modeldata.geom.add.addColl(null, [], [], pgons_i);
    // add attribs
    _addAttribsToModel(model, _common__WEBPACK_IMPORTED_MODULE_0__["EEntType"].COLL, coll_i, multipolygon);
    // return the indices of the plines and the index of the collection
    return [pgons_i, coll_i];
}
/**
 * Adds attributes to the model
 * @param model The model
 */
function _addAttribsToModel(model, ent_type, ent_i, feature) {
    // add attribs
    if (!feature.hasOwnProperty('properties')) {
        return;
    }
    for (const name of Object.keys(feature.properties)) {
        let value = feature.properties[name];
        const value_type = typeof feature.properties[name];
        if (value_type === 'object') {
            value = JSON.stringify(value);
        }
        model.modeldata.attribs.add.setEntAttribVal(ent_type, ent_i, name, value);
    }
}
/**
 * Converts geojson long lat to cartesian coords
 * @param long_lat_arr
 * @param elevation
 */
function _xformFromLongLatToXYZ(long_lat_arr, proj_obj, elevation) {
    if (Object(_id__WEBPACK_IMPORTED_MODULE_1__["getArrDepth"])(long_lat_arr) === 1) {
        const long_lat = long_lat_arr;
        const xy = proj_obj.forward(long_lat);
        return [xy[0], xy[1], elevation];
    }
    else {
        long_lat_arr = long_lat_arr;
        const xyzs_xformed = [];
        for (const long_lat of long_lat_arr) {
            const xyz = _xformFromLongLatToXYZ(long_lat, proj_obj, elevation);
            xyzs_xformed.push(xyz);
        }
        return xyzs_xformed;
    }
}
/**
 * Converts cartesian coords to geojson long lat
 * @param xyz
 * @param flatten
 */
function _xformFromXYZToLongLat(xyz, proj_obj, rot_matrix, flatten) {
    if (Object(_id__WEBPACK_IMPORTED_MODULE_1__["getArrDepth"])(xyz) === 1) {
        xyz = xyz;
        // rotate to north
        if (rot_matrix !== null) {
            xyz = Object(_geom_matrix__WEBPACK_IMPORTED_MODULE_4__["multMatrix"])(xyz, rot_matrix);
        }
        return proj_obj.inverse([xyz[0], xyz[1]]);
    }
    else {
        xyz = xyz;
        const long_lat_arr = [];
        for (const a_xyz of xyz) {
            const lat_long = _xformFromXYZToLongLat(a_xyz, proj_obj, rot_matrix, flatten);
            long_lat_arr.push(lat_long);
        }
        return long_lat_arr;
    }
}


/***/ }),

/***/ "./src/assets/libs/geo-info/io_obj.ts":
/*!********************************************!*\
  !*** ./src/assets/libs/geo-info/io_obj.ts ***!
  \********************************************/
/*! exports provided: importObj, exportVertBasedObj, exportPosiBasedObj */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "importObj", function() { return importObj; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exportVertBasedObj", function() { return exportVertBasedObj; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exportPosiBasedObj", function() { return exportPosiBasedObj; });
/* harmony import */ var _GIModel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GIModel */ "./src/assets/libs/geo-info/GIModel.ts");
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./common */ "./src/assets/libs/geo-info/common.ts");
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};


const NOGROUPS = '---nogroups---';
/**
 * Import obj
 */
function importObj(obj_str) {
    const model = new _GIModel__WEBPACK_IMPORTED_MODULE_0__["GIModel"]();
    let EObjLine;
    (function (EObjLine) {
        EObjLine["OBJ_COMMENT"] = "#";
        EObjLine["OBJ_COORD"] = "v ";
        EObjLine["OBJ_TEXTURE"] = "vt ";
        EObjLine["OBJ_NORMAL"] = "vn ";
        EObjLine["OBJ_FACE"] = "f ";
        EObjLine["OBJ_LINE"] = "l ";
    })(EObjLine || (EObjLine = {}));
    const obj_lines = obj_str.split(/\r?\n/);
    const coords = [];
    const normals = [];
    const textures = [];
    const faces = [];
    const plines = [];
    for (const obj_line of obj_lines) {
        if (obj_line.startsWith(EObjLine.OBJ_COMMENT)) {
            // Do not do anything
        }
        else if (obj_line.startsWith(EObjLine.OBJ_COORD)) {
            const coord = obj_line.split(' ').slice(1, 4).map(v => parseFloat(v));
            coords.push(coord);
        }
        else if (obj_line.startsWith(EObjLine.OBJ_TEXTURE)) {
            const normal = obj_line.split(' ').slice(1, 4).map(v => parseFloat(v));
            normals.push(normal);
        }
        else if (obj_line.startsWith(EObjLine.OBJ_NORMAL)) {
            const texture = obj_line.split(' ').slice(1, 3).map(v => parseFloat(v));
            textures.push(texture);
        }
        else if (obj_line.startsWith(EObjLine.OBJ_FACE)) {
            const face_strs = obj_line.split(' ').slice(1);
            const v_indexes = [];
            const t_indexes = [];
            const n_indexes = [];
            face_strs.forEach(face_str => {
                const face_sub_indexes = face_str.split('/').map(str => parseInt(str, 10) - 1);
                v_indexes.push(face_sub_indexes[0]);
                t_indexes.push(face_sub_indexes[1]);
                n_indexes.push(face_sub_indexes[2]);
            });
            faces.push([v_indexes, t_indexes, n_indexes]);
        }
        else if (obj_line.startsWith(EObjLine.OBJ_LINE)) {
            const pline = obj_line.split(' ').slice(1).map(v => parseInt(v, 10) - 1);
            plines.push(pline);
        }
        else {
            console.log('Found unrecognised line of data in OBJ file');
        }
    }
    for (const coord of coords) {
        const posi_i = model.modeldata.geom.add.addPosi();
        model.modeldata.attribs.add.setEntAttribVal(_common__WEBPACK_IMPORTED_MODULE_1__["EEntType"].POSI, posi_i, _common__WEBPACK_IMPORTED_MODULE_1__["EAttribNames"].COORDS, coord);
    }
    for (const face of faces) {
        const face_i = model.modeldata.geom.add.addPgon(face[0]);
        // TODO: texture uv
        // TODO: normals
    }
    return model;
}
/**
 * Export to obj
 */
function exportVertBasedObj(model, entities) {
    const h_str = '# File generated by Mobius.\n';
    // the order of data is 1) vertex, 2) texture, 3) normal
    let v_str = '';
    let f_str = '';
    let l_str = '';
    // do we have color, texture, normal?
    const has_color_attrib = model.modeldata.attribs.query.hasAttrib(_common__WEBPACK_IMPORTED_MODULE_1__["EEntType"].VERT, _common__WEBPACK_IMPORTED_MODULE_1__["EAttribNames"].COLOR);
    const has_normal_attrib = model.modeldata.attribs.query.hasAttrib(_common__WEBPACK_IMPORTED_MODULE_1__["EEntType"].VERT, _common__WEBPACK_IMPORTED_MODULE_1__["EAttribNames"].NORMAL);
    const has_texture_attrib = model.modeldata.attribs.query.hasAttrib(_common__WEBPACK_IMPORTED_MODULE_1__["EEntType"].VERT, _common__WEBPACK_IMPORTED_MODULE_1__["EAttribNames"].TEXTURE);
    // get the polgons, polylines, verts, posis
    const [pgons_i, plines_i] = _getPgonsPlines(model, entities);
    const [verts_i, posis_i] = _getVertsPosis(model, pgons_i, plines_i);
    // vertices, v
    const vert_i_to_obj_v = [];
    let num_v = 0;
    for (let i = 0; i < verts_i.length; i++) {
        const vert_i = verts_i[i];
        const coord = model.modeldata.attribs.query.getVertCoords(vert_i);
        if (has_color_attrib) {
            let color = model.modeldata.attribs.query.getAttribVal(_common__WEBPACK_IMPORTED_MODULE_1__["EEntType"].VERT, _common__WEBPACK_IMPORTED_MODULE_1__["EAttribNames"].COLOR, vert_i);
            if (color === undefined) {
                color = [1, 1, 1];
            }
            v_str += 'v ' + coord.map(v => v.toString()).join(' ') + ' ' + color.map(c => c.toString()).join(' ') + '\n';
        }
        else {
            v_str += 'v ' + coord.map(v => v.toString()).join(' ') + '\n';
        }
        vert_i_to_obj_v[vert_i] = i;
        num_v += 1;
    }
    // textures, vt
    const [num_vt, vert_i_obj_vt, vt_str] = _getTexturesStr(model, verts_i, has_texture_attrib);
    // normals, vn
    const [num_vn, vert_i_obj_vn, vn_str] = _getNormalsStr(model, verts_i, has_normal_attrib);
    // polygons, f
    const [keys_pgons, map_colls_to_pgons] = _getGroups(model, _common__WEBPACK_IMPORTED_MODULE_1__["EEntType"].PGON, pgons_i);
    // polygons, f
    for (const key of keys_pgons) {
        const [names, group_pgons_i] = map_colls_to_pgons.get(key);
        if (key !== NOGROUPS) {
            f_str += 'g ' + names.join(' ') + '\n';
        }
        for (const pgon_i of group_pgons_i) {
            const pgon_verts_i_outer = model.modeldata.geom.nav.navAnyToVert(_common__WEBPACK_IMPORTED_MODULE_1__["EEntType"].PGON, pgon_i);
            // const verts_i_outer = verts_i[0];
            // TODO what about holes
            f_str += 'f ';
            for (const vert_i of pgon_verts_i_outer) {
                // v
                f_str += (1 + vert_i_to_obj_v[vert_i]);
                if (has_texture_attrib || has_normal_attrib) {
                    // vt
                    if (has_texture_attrib) {
                        // TODO ignore them for now
                        f_str += '/';
                    }
                    else {
                        f_str += '/';
                    }
                    // vn
                    if (has_normal_attrib) {
                        f_str += '/' + (1 + num_v + num_vt + vert_i_obj_vn[vert_i]);
                    }
                    else {
                        f_str += '/';
                    }
                }
                f_str += ' ';
            }
            f_str += '\n';
        }
    }
    // polylines, l
    const [keys_plines, map_colls_to_plines] = _getGroups(model, _common__WEBPACK_IMPORTED_MODULE_1__["EEntType"].PLINE, plines_i);
    // process all the groups
    for (const key of keys_plines) {
        const [names, group_plines_i] = map_colls_to_plines.get(key);
        if (key !== NOGROUPS) {
            f_str += 'g ' + names.join(' ') + '\n';
        }
        for (const pline_i of group_plines_i) {
            const pline_verts_i = model.modeldata.geom.nav.navAnyToVert(_common__WEBPACK_IMPORTED_MODULE_1__["EEntType"].PLINE, pline_i);
            l_str += 'l ' + pline_verts_i.map(vert_i => (vert_i_to_obj_v[vert_i] + 1).toString()).join(' ') + '\n';
        }
    }
    // result
    return h_str + v_str + vt_str + vn_str + f_str + l_str;
}
/**
 * Export to obj
 */
function exportPosiBasedObj(model, entities) {
    const h_str = '# File generated by Mobius.\n';
    // the order of data is 1) vertex, 2) texture, 3) normal
    let v_str = '';
    let f_str = '';
    let l_str = '';
    // do we have color, texture, normal?
    const has_color_attrib = model.modeldata.attribs.query.hasAttrib(_common__WEBPACK_IMPORTED_MODULE_1__["EEntType"].VERT, _common__WEBPACK_IMPORTED_MODULE_1__["EAttribNames"].COLOR);
    const has_normal_attrib = model.modeldata.attribs.query.hasAttrib(_common__WEBPACK_IMPORTED_MODULE_1__["EEntType"].VERT, _common__WEBPACK_IMPORTED_MODULE_1__["EAttribNames"].NORMAL);
    const has_texture_attrib = model.modeldata.attribs.query.hasAttrib(_common__WEBPACK_IMPORTED_MODULE_1__["EEntType"].VERT, _common__WEBPACK_IMPORTED_MODULE_1__["EAttribNames"].TEXTURE);
    // get the polgons, polylines, verts, posis
    const [pgons_i, plines_i] = _getPgonsPlines(model, entities);
    const [verts_i, posis_i] = _getVertsPosis(model, pgons_i, plines_i);
    // positions
    let num_v = 0;
    const posi_i_to_obj_v = [];
    for (let i = 0; i < posis_i.length; i++) {
        const posi_i = posis_i[i];
        const coord = model.modeldata.attribs.query.getPosiCoords(posi_i);
        if (has_color_attrib) {
            // get the average color from the verts
            const posi_verts_i = model.modeldata.geom.nav.navPosiToVert(posi_i);
            let color = [0, 0, 0];
            for (const posi_vert_i of posi_verts_i) {
                let vert_color = model.modeldata.attribs.query.getAttribVal(_common__WEBPACK_IMPORTED_MODULE_1__["EEntType"].VERT, _common__WEBPACK_IMPORTED_MODULE_1__["EAttribNames"].COLOR, posi_vert_i);
                if (vert_color === undefined) {
                    vert_color = [1, 1, 1];
                }
                color = [color[0] + vert_color[0], color[1] + vert_color[1], color[2] + vert_color[2]];
            }
            const div = posi_verts_i.length;
            color = [color[0] / div, color[1] / div, color[2] / div];
            v_str += 'v ' + coord.map(v => v.toString()).join(' ') + ' ' + color.map(c => c.toString()).join(' ') + '\n';
        }
        else {
            v_str += 'v ' + coord.map(v => v.toString()).join(' ') + '\n';
        }
        posi_i_to_obj_v[posi_i] = i;
        num_v += 1;
    }
    // textures, vt
    const [num_vt, vert_i_obj_vt, vt_str] = _getTexturesStr(model, verts_i, has_texture_attrib);
    // normals, vn
    const [num_vn, vert_i_obj_vn, vn_str] = _getNormalsStr(model, verts_i, has_normal_attrib);
    // polygons, f
    const [keys_pgons, map_colls_to_pgons] = _getGroups(model, _common__WEBPACK_IMPORTED_MODULE_1__["EEntType"].PGON, pgons_i);
    // process all the groups
    for (const key of keys_pgons) {
        const [names, group_pgons_i] = map_colls_to_pgons.get(key);
        if (key !== NOGROUPS) {
            f_str += 'g ' + names.join(' ') + '\n';
        }
        for (const pgon_i of group_pgons_i) {
            const pgon_verts_i_outer = model.modeldata.geom.nav.navAnyToVert(_common__WEBPACK_IMPORTED_MODULE_1__["EEntType"].PGON, pgon_i);
            // const verts_i_outer = verts_i[0];
            // TODO what about holes
            f_str += 'f ';
            for (const vert_i of pgon_verts_i_outer) {
                // v
                f_str += (1 + posi_i_to_obj_v[model.modeldata.geom.nav.navVertToPosi(vert_i)]);
                if (has_texture_attrib || has_normal_attrib) {
                    // vt
                    if (has_texture_attrib && vert_i_obj_vt[vert_i] !== undefined) {
                        // TODO ignore them for now
                        f_str += '/';
                    }
                    else {
                        f_str += '/';
                    }
                    // vn
                    if (has_normal_attrib && vert_i_obj_vn[vert_i] !== undefined) {
                        f_str += '/' + (1 + num_v + num_vt + vert_i_obj_vn[vert_i]);
                    }
                    else {
                        f_str += '/';
                    }
                }
                f_str += ' ';
            }
            f_str += '\n';
        }
    }
    // polylines, l
    const [keys_plines, map_colls_to_plines] = _getGroups(model, _common__WEBPACK_IMPORTED_MODULE_1__["EEntType"].PLINE, plines_i);
    // process all the groups
    for (const key of keys_plines) {
        const [names, group_plines_i] = map_colls_to_plines.get(key);
        if (key !== NOGROUPS) {
            f_str += 'g ' + names.join(' ') + '\n';
        }
        for (const pline_i of group_plines_i) {
            const pline_verts_i = model.modeldata.geom.nav.navAnyToVert(_common__WEBPACK_IMPORTED_MODULE_1__["EEntType"].PLINE, pline_i);
            l_str += 'l ' + pline_verts_i.map(vert_i => (posi_i_to_obj_v[model.modeldata.geom.nav.navVertToPosi(vert_i)] + 1).toString()).join(' ') + '\n';
        }
    }
    // result
    return h_str + v_str + vt_str + vn_str + f_str + l_str;
}
/**
 * Get the textures
 */
function _getTexturesStr(model, verts_i, has_texture_attrib) {
    let vt_str = '';
    // textures, vt
    let num_vt = 0;
    const vert_i_obj_vt = []; // sparse array
    if (has_texture_attrib) {
        for (let i = 0; i < verts_i.length; i++) {
            const vert_i = verts_i[i];
            const texture = model.modeldata.attribs.query.getAttribVal(_common__WEBPACK_IMPORTED_MODULE_1__["EEntType"].VERT, _common__WEBPACK_IMPORTED_MODULE_1__["EAttribNames"].TEXTURE, vert_i);
            if (texture !== undefined) {
                vt_str += 'vt ' + texture.map(v => v.toString()).join(' ') + '\n';
                vert_i_obj_vt[vert_i] = i;
                num_vt += 1;
            }
        }
    }
    return [num_vt, vert_i_obj_vt, vt_str];
}
/**
 * Get the normals
 */
function _getNormalsStr(model, verts_i, has_normal_attrib) {
    let vn_str = '';
    // normals, vn
    let num_vn = 0;
    const vert_i_obj_vn = []; // sparse array
    if (has_normal_attrib) {
        for (let i = 0; i < verts_i.length; i++) {
            const vert_i = verts_i[i];
            const normal = model.modeldata.attribs.query.getAttribVal(_common__WEBPACK_IMPORTED_MODULE_1__["EEntType"].VERT, _common__WEBPACK_IMPORTED_MODULE_1__["EAttribNames"].NORMAL, vert_i);
            if (normal !== undefined) {
                vn_str += 'vn ' + normal.map(v => v.toString()).join(' ') + '\n';
                vert_i_obj_vn[vert_i] = i;
                num_vn += 1;
            }
        }
    }
    return [num_vn, vert_i_obj_vn, vn_str];
}
/**
 * Get the groups
 */
function _getGroups(model, ent_type, ents_i) {
    const map_colls_to_ents = new Map();
    // check if the name attribut exists
    if (!model.modeldata.attribs.query.hasAttrib(_common__WEBPACK_IMPORTED_MODULE_1__["EEntType"].COLL, 'name')) {
        return [[NOGROUPS], map_colls_to_ents.set(NOGROUPS, [[], ents_i])];
    }
    // get the collections of each entity
    for (const ent_i of ents_i) {
        const colls_i = model.modeldata.geom.nav.navAnyToColl(ent_type, ent_i);
        const set_all_colls_i = new Set();
        for (const coll_i of colls_i) {
            set_all_colls_i.add(coll_i);
            for (const anc_coll_i of model.modeldata.geom.query.getCollAncestors(coll_i)) {
                set_all_colls_i.add(anc_coll_i);
            }
        }
        const names = model.modeldata.attribs.query.getAttribVal(_common__WEBPACK_IMPORTED_MODULE_1__["EEntType"].COLL, 'name', Array.from(set_all_colls_i));
        let key = NOGROUPS;
        if (names.length > 0) {
            names.sort();
            key = names.join('-');
        }
        if (!map_colls_to_ents.has(key)) {
            map_colls_to_ents.set(key, [names, []]);
        }
        map_colls_to_ents.get(key)[1].push(ent_i);
    }
    // make sure the ---nogroups--- key is first in the list
    let keys = Array.from(map_colls_to_ents.keys());
    const ng_i = keys.indexOf(NOGROUPS);
    if (ng_i !== -1) {
        keys = keys.splice(ng_i, 1).splice(0, 0, NOGROUPS);
    }
    // return the keys arrays, and the map
    return [keys, map_colls_to_ents];
}
/**
 * Get all the polygons and polyline entities.
 */
function _getPgonsPlines(model, entities) {
    let pgons_i = [];
    let plines_i = [];
    if (entities === null) {
        pgons_i = model.modeldata.geom.query.getEnts(_common__WEBPACK_IMPORTED_MODULE_1__["EEntType"].PGON);
        plines_i = model.modeldata.geom.query.getEnts(_common__WEBPACK_IMPORTED_MODULE_1__["EEntType"].PLINE);
    }
    else {
        for (const [ent_type, ent_i] of entities) {
            if (ent_type === _common__WEBPACK_IMPORTED_MODULE_1__["EEntType"].PGON) {
                pgons_i.push(ent_i);
            }
            else if (ent_type === _common__WEBPACK_IMPORTED_MODULE_1__["EEntType"].PLINE) {
                plines_i.push(ent_i);
            }
            else if (ent_type === _common__WEBPACK_IMPORTED_MODULE_1__["EEntType"].COLL) {
                for (const pgon_i of model.modeldata.geom.nav.navAnyToPgon(_common__WEBPACK_IMPORTED_MODULE_1__["EEntType"].COLL, ent_i)) {
                    pgons_i.push(pgon_i);
                }
                for (const pline_i of model.modeldata.geom.nav.navAnyToPline(_common__WEBPACK_IMPORTED_MODULE_1__["EEntType"].COLL, ent_i)) {
                    plines_i.push(pline_i);
                }
            }
        }
    }
    return [pgons_i, plines_i];
}
/**
 * Get all the posis from the polygon and polyline entities.
 */
function _getVertsPosis(model, pgons_i, plines_i) {
    const posis_i = new Set();
    const verts_i = new Set();
    for (const pgon_i of pgons_i) {
        for (const vert_i of model.modeldata.geom.nav.navAnyToVert(_common__WEBPACK_IMPORTED_MODULE_1__["EEntType"].PGON, pgon_i)) {
            verts_i.add(vert_i);
        }
        for (const posi_i of model.modeldata.geom.nav.navAnyToPosi(_common__WEBPACK_IMPORTED_MODULE_1__["EEntType"].PGON, pgon_i)) {
            posis_i.add(posi_i);
        }
    }
    for (const pline_i of plines_i) {
        for (const vert_i of model.modeldata.geom.nav.navAnyToVert(_common__WEBPACK_IMPORTED_MODULE_1__["EEntType"].PLINE, pline_i)) {
            verts_i.add(vert_i);
        }
        for (const posi_i of model.modeldata.geom.nav.navAnyToPosi(_common__WEBPACK_IMPORTED_MODULE_1__["EEntType"].PLINE, pline_i)) {
            posis_i.add(posi_i);
        }
    }
    return [Array.from(verts_i), Array.from(posis_i)];
}


/***/ }),

/***/ "./src/assets/libs/geo-info/virtual.ts":
/*!*********************************************!*\
  !*** ./src/assets/libs/geo-info/virtual.ts ***!
  \*********************************************/
/*! exports provided: isXYZ, isRay, isPlane, isBBox */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isXYZ", function() { return isXYZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isRay", function() { return isRay; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isPlane", function() { return isPlane; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isBBox", function() { return isBBox; });
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};
// ============================================================================
function isXYZ(data) {
    if (!Array.isArray(data)) {
        return false;
    }
    data = data;
    if (data.length !== 3) {
        return false;
    }
    for (const item of data) {
        if (typeof item !== 'number') {
            return false;
        }
    }
    return true;
}
function isRay(data) {
    if (!Array.isArray(data)) {
        return false;
    }
    data = data;
    if (data.length !== 2) {
        return false;
    }
    for (const item of data) {
        if (!isXYZ(item)) {
            return false;
        }
    }
    return true;
}
function isPlane(data) {
    if (!Array.isArray(data)) {
        return false;
    }
    data = data;
    if (data.length !== 3) {
        return false;
    }
    for (const item of data) {
        if (!isXYZ(item)) {
            return false;
        }
    }
    return true;
}
function isBBox(data) {
    if (!Array.isArray(data)) {
        return false;
    }
    data = data;
    if (data.length !== 4) {
        return false;
    }
    for (const item of data) {
        if (!isXYZ(item)) {
            return false;
        }
    }
    return true;
}


/***/ }),

/***/ "./src/assets/libs/geom/constants.ts":
/*!*******************************************!*\
  !*** ./src/assets/libs/geom/constants.ts ***!
  \*******************************************/
/*! exports provided: XAXIS, YAXIS, ZAXIS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "XAXIS", function() { return XAXIS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "YAXIS", function() { return YAXIS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ZAXIS", function() { return ZAXIS; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};

const XAXIS = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](1, 0, 0);
const YAXIS = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](0, 1, 0);
const ZAXIS = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](0, 0, 1);


/***/ }),

/***/ "./src/assets/libs/geom/distance.ts":
/*!******************************************!*\
  !*** ./src/assets/libs/geom/distance.ts ***!
  \******************************************/
/*! exports provided: distance, distanceManhattan, distanceManhattanSq */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distance", function() { return distance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distanceManhattan", function() { return distanceManhattan; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distanceManhattanSq", function() { return distanceManhattanSq; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/* harmony import */ var _vectors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./vectors */ "./src/assets/libs/geom/vectors.ts");
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};


const EPS = 1e-6;
function _distEuclidean(c1, c2) {
    const v = [
        c1[0] - c2[0],
        c1[1] - c2[1],
        c1[2] - c2[2]
    ];
    return Math.hypot(v[0], v[1], v[2]);
}
function _distManhattan(c1, c2) {
    const v = [
        Math.abs(c1[0] - c2[0]),
        Math.abs(c1[1] - c2[1]),
        Math.abs(c1[2] - c2[2])
    ];
    return v[0] + v[1] + v[2];
}
function _distManhattanSq(c1, c2) {
    const v = [
        Math.abs(c1[0] - c2[0]),
        Math.abs(c1[1] - c2[1]),
        Math.abs(c1[2] - c2[2])
    ];
    return (v[0] * v[0]) + (v[1] * v[1]) + (v[2] * v[2]);
}
function _dist(c1, c2, func) {
    if (!Array.isArray(c2[0])) {
        c2 = c2;
        return func(c1, c2);
    }
    else if (c2.length === 2) {
        c2 = c2;
        const tjs_point_proj = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](c1[0], c1[1], c1[2]);
        const tjs_origin = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](c2[0][0], c2[0][1], c2[0][2]);
        const p2 = Object(_vectors__WEBPACK_IMPORTED_MODULE_1__["vecAdd"])(c2[0], c2[1]);
        const tjs_point2 = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](p2[0], p2[1], p2[2]);
        const tjs_new_point = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
        const tjs_line = new three__WEBPACK_IMPORTED_MODULE_0__["Line3"](tjs_origin, tjs_point2);
        // project
        tjs_line.closestPointToPoint(tjs_point_proj, false, tjs_new_point);
        return distance(c1, [tjs_new_point.x, tjs_new_point.y, tjs_new_point.z]);
    }
    else if (c2.length === 3) {
        c2 = c2;
        const tjs_point_proj = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](c1[0], c1[1], c1[2]);
        const tjs_new_point = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
        const normal = Object(_vectors__WEBPACK_IMPORTED_MODULE_1__["vecCross"])(c2[1], c2[2]);
        const tjs_normal = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](normal[0], normal[1], normal[2]);
        const tjs_origin = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](c2[0][0], c2[0][1], c2[0][2]);
        const tjs_plane = new three__WEBPACK_IMPORTED_MODULE_0__["Plane"]();
        // project
        tjs_plane.setFromNormalAndCoplanarPoint(tjs_normal, tjs_origin);
        tjs_plane.projectPoint(tjs_point_proj, tjs_new_point);
        return distance(c1, [tjs_new_point.x, tjs_new_point.y, tjs_new_point.z]);
    }
    else {
        throw new Error('Error calculating distance. Distance must to either an xyz, a ray, or a plane.');
    }
}
function distance(c1, c2) {
    return _dist(c1, c2, _distEuclidean);
}
function distanceManhattan(c1, c2) {
    return _dist(c1, c2, _distManhattan);
}
function distanceManhattanSq(c1, c2) {
    return _dist(c1, c2, _distManhattanSq);
}


/***/ }),

/***/ "./src/assets/libs/geom/intersect.ts":
/*!*******************************************!*\
  !*** ./src/assets/libs/geom/intersect.ts ***!
  \*******************************************/
/*! exports provided: intersect, intersectRayRay, intersectRayPlane, project, projectCoordOntoRay, projectCoordOntoPlane */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "intersect", function() { return intersect; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "intersectRayRay", function() { return intersectRayRay; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "intersectRayPlane", function() { return intersectRayPlane; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "project", function() { return project; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "projectCoordOntoRay", function() { return projectCoordOntoRay; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "projectCoordOntoPlane", function() { return projectCoordOntoPlane; });
/* harmony import */ var _vectors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vectors */ "./src/assets/libs/geom/vectors.ts");
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};

function intersect(r1, r2, met = 2) {
    // function isInRange(num: number, range: [number, number]) {
    //     const range2: [number, number] = range[0] < range[1] ? range : [range[1], range[0]];
    //     if ((num < range2[0]) || (num > range2[1])) { return false; }
    //     return true;
    // }
    // // TODO
    // // This has problems with rounding errors
    // // Especially when lines are orthogonal
    // function isOnLineSegment(coord: Txyz, start: Txyz, end: Txyz): boolean {
    //     const x_range: [number, number] = [start[0], end[0]];
    //     if (!isInRange(coord[0], x_range)) { return false; }
    //     const y_range: [number, number] = [start[1], end[1]];
    //     if (!isInRange(coord[1], y_range)) { return false; }
    //     const z_range: [number, number] = [start[2], end[2]];
    //     if (!isInRange(coord[2], z_range)) { return false; }
    //     return true;
    // }
    // // TODO
    // // This has problems with rounding errors
    // // Especially when lines are orthogonal
    // function isOnRay(coord: Txyz, start: Txyz, end: Txyz): boolean {
    //     const x_range: [number, number] = [start[0], null];
    //     x_range[1] = start[0] === end[0] ? end[0] : start[0] < end[0] ? Infinity : -Infinity;
    //     if (!isInRange(coord[0], x_range)) { return false; }
    //     const y_range: [number, number] = [start[1], null];
    //     y_range[1] = start[1] === end[1] ? end[1] : start[1] < end[1] ? Infinity : -Infinity;
    //     if (!isInRange(coord[1], y_range)) { return false; }
    //     const z_range: [number, number] = [start[2], null];
    //     z_range[1] = start[2] === end[2] ? end[2] : start[2] < end[2] ? Infinity : -Infinity;
    //     if (!isInRange(coord[2], z_range)) { return false; }
    //     return true;
    // }
    if (r2.length === 2) {
        return intersectRayRay(r1, r2, met);
        // const p0: Txyz = r1[0];
        // const p1: Txyz = vecAdd(r1[0], r1[1]);
        // const p2: Txyz = r2[0];
        // const p3: Txyz = vecAdd(r2[0], r2[1]);
        // const isect: Txyz = mathjs.intersect(p0, p1, p2, p3 );
        // if (isect) {
        //     if (met === 2)  {
        //         return isect;
        //     } else if (met === 1) {
        //         if (isOnRay(isect, p0, p1) && isOnRay(isect, p2, p3)) { return isect; }
        //     } else if (met === 0) {
        //         if (isOnLineSegment(isect, p0, p1) && isOnLineSegment(isect, p2, p3)) { return isect; }
        //     } else {
        //         throw new Error('Error calculating intersection. Intersection method not valid. Must be 0, 1, or 2.');
        //     }
        // }
        // return null;
    }
    else if (r2.length === 3) {
        return intersectRayPlane(r1, r2, met);
        // const p0: Txyz = r1[0];
        // const p1: Txyz = vecAdd(r1[0], r1[1]);
        // const [a, b, c]: Txyz = vecCross(r2[1], r2[2]);
        // const [x1, y1, z1]: Txyz = r2[0];
        // const d: number = a * x1 + b * y1 + c * z1;
        // const isect: Txyz = mathjs.intersect(r1[0], vecAdd(r1[0], r1[1]), [a, b, c, d] );
        // if (isect) {
        //     if (met === 2)  {
        //         return isect;
        //     } else if (met === 1) {
        //         if (isOnRay(isect, p0, p1)) { return isect; }
        //     } else if (met === 0) {
        //         if (isOnLineSegment(isect, p0, p1)) { return isect; }
        //     } else {
        //         throw new Error('Error calculating intersection. Intersection method not valid. Must be 0, 1, or 2.');
        //     }
        // }
        // return null;
    }
    else {
        throw new Error('Error calculating intersection. Elements to intersect must be either rays or planes.');
    }
}
function intersectRayRay(r1, r2, met) {
    const dc = Object(_vectors__WEBPACK_IMPORTED_MODULE_0__["vecFromTo"])(r1[0], r2[0]);
    const da = r1[1];
    const db = r2[1];
    if (Object(_vectors__WEBPACK_IMPORTED_MODULE_0__["vecDot"])(dc, Object(_vectors__WEBPACK_IMPORTED_MODULE_0__["vecCross"])(da, db)) !== 0) {
        return null;
    }
    const da_x_db = Object(_vectors__WEBPACK_IMPORTED_MODULE_0__["vecCross"])(da, db);
    const da_x_db_norm2 = (da_x_db[0] * da_x_db[0]) + (da_x_db[1] * da_x_db[1]) + (da_x_db[2] * da_x_db[2]);
    if (da_x_db_norm2 === 0) {
        return null;
    }
    const s = Object(_vectors__WEBPACK_IMPORTED_MODULE_0__["vecDot"])(Object(_vectors__WEBPACK_IMPORTED_MODULE_0__["vecCross"])(dc, db), da_x_db) / da_x_db_norm2;
    const t = Object(_vectors__WEBPACK_IMPORTED_MODULE_0__["vecDot"])(Object(_vectors__WEBPACK_IMPORTED_MODULE_0__["vecCross"])(dc, da), da_x_db) / da_x_db_norm2;
    switch (met) {
        case 2:
            return Object(_vectors__WEBPACK_IMPORTED_MODULE_0__["vecAdd"])(r1[0], Object(_vectors__WEBPACK_IMPORTED_MODULE_0__["vecMult"])(da, s));
        case 1:
            if ((s >= 0) && (t >= 0)) {
                return Object(_vectors__WEBPACK_IMPORTED_MODULE_0__["vecAdd"])(r1[0], Object(_vectors__WEBPACK_IMPORTED_MODULE_0__["vecMult"])(da, s));
            }
            return null;
        case 0:
            if ((s >= 0 && s <= 1) && (t >= 0 && t <= 1)) {
                return Object(_vectors__WEBPACK_IMPORTED_MODULE_0__["vecAdd"])(r1[0], Object(_vectors__WEBPACK_IMPORTED_MODULE_0__["vecMult"])(da, s));
            }
            return null;
        default:
            return null;
    }
}
function intersectRayPlane(r, p, met) {
    const normal = Object(_vectors__WEBPACK_IMPORTED_MODULE_0__["vecCross"])(p[1], p[2]);
    const normal_dot_r = Object(_vectors__WEBPACK_IMPORTED_MODULE_0__["vecDot"])(normal, r[1]);
    if (normal_dot_r === 0) {
        return null;
    }
    const u = Object(_vectors__WEBPACK_IMPORTED_MODULE_0__["vecDot"])(normal, Object(_vectors__WEBPACK_IMPORTED_MODULE_0__["vecFromTo"])(r[0], p[0])) / normal_dot_r;
    switch (met) {
        case 2:
            return Object(_vectors__WEBPACK_IMPORTED_MODULE_0__["vecAdd"])(r[0], Object(_vectors__WEBPACK_IMPORTED_MODULE_0__["vecMult"])(r[1], u));
        case 1:
            if (u >= 0) {
                return Object(_vectors__WEBPACK_IMPORTED_MODULE_0__["vecAdd"])(r[0], Object(_vectors__WEBPACK_IMPORTED_MODULE_0__["vecMult"])(r[1], u));
            }
            return null;
        case 0:
            if (u >= 0 && u <= 1) {
                return Object(_vectors__WEBPACK_IMPORTED_MODULE_0__["vecAdd"])(r[0], Object(_vectors__WEBPACK_IMPORTED_MODULE_0__["vecMult"])(r[1], u));
            }
            return null;
        default:
            return null;
    }
}
function project(c, r, met = 2) {
    if (r.length === 2) {
        return projectCoordOntoRay(c, r, met);
        // const tjs_point_proj: three.Vector3 = new three.Vector3(c[0], c[1], c[2]);
        // const tjs_origin: three.Vector3 =  new three.Vector3(r[0][0], r[0][1], r[0][2]);
        // const p2: Txyz = vecAdd(r[0], r[1]);
        // const tjs_point2: three.Vector3 =  new three.Vector3(p2[0], p2[1], p2[2]);
        // const tjs_new_point: three.Vector3 = new three.Vector3();
        // const tjs_line: three.Line3 = new three.Line3(tjs_origin, tjs_point2);
        // // project
        // tjs_line.closestPointToPoint( tjs_point_proj, false, tjs_new_point );
        // return [tjs_new_point.x, tjs_new_point.y, tjs_new_point.z];
    }
    else if (r.length === 3) {
        return projectCoordOntoPlane(c, r);
        // const tjs_point_proj: three.Vector3 = new three.Vector3(c[0], c[1], c[2]);
        // const tjs_new_point: three.Vector3 = new three.Vector3();
        // const normal: Txyz = vecCross(r[1], r[2]);
        // const tjs_normal: three.Vector3 = new three.Vector3(normal[0], normal[1], normal[2]);
        // const tjs_origin: three.Vector3 = new three.Vector3(r[0][0], r[0][1], r[0][2]);
        // const tjs_plane: three.Plane = new three.Plane();
        // // project
        // tjs_plane.setFromNormalAndCoplanarPoint( tjs_normal, tjs_origin );
        // tjs_plane.projectPoint(tjs_point_proj, tjs_new_point);
        // return [tjs_new_point.x, tjs_new_point.y, tjs_new_point.z];
    }
    else {
        throw new Error('Error calculating projection. Projection must be onto either rays or planes.');
    }
}
function projectCoordOntoRay(c, r, met) {
    const vec = Object(_vectors__WEBPACK_IMPORTED_MODULE_0__["vecFromTo"])(r[0], c);
    const dot = Object(_vectors__WEBPACK_IMPORTED_MODULE_0__["vecDot"])(vec, Object(_vectors__WEBPACK_IMPORTED_MODULE_0__["vecNorm"])(r[1]));
    switch (met) {
        case 2:
            return Object(_vectors__WEBPACK_IMPORTED_MODULE_0__["vecAdd"])(r[0], Object(_vectors__WEBPACK_IMPORTED_MODULE_0__["vecSetLen"])(r[1], dot));
        case 1:
            if (dot <= 0) {
                return r[0].slice();
            }
            return Object(_vectors__WEBPACK_IMPORTED_MODULE_0__["vecAdd"])(r[0], Object(_vectors__WEBPACK_IMPORTED_MODULE_0__["vecSetLen"])(r[1], dot));
        case 0:
            const length = Object(_vectors__WEBPACK_IMPORTED_MODULE_0__["vecLen"])(r[1]);
            if (dot <= 0) {
                return r[0].slice();
            }
            else if (dot >= length) {
                return Object(_vectors__WEBPACK_IMPORTED_MODULE_0__["vecAdd"])(r[0], r[1]);
            }
            return Object(_vectors__WEBPACK_IMPORTED_MODULE_0__["vecAdd"])(r[0], Object(_vectors__WEBPACK_IMPORTED_MODULE_0__["vecSetLen"])(r[1], dot));
        default:
            return null;
    }
}
function projectCoordOntoPlane(c, p) {
    const vec_to_c = Object(_vectors__WEBPACK_IMPORTED_MODULE_0__["vecFromTo"])(p[0], c);
    const pln_z_vec = Object(_vectors__WEBPACK_IMPORTED_MODULE_0__["vecCross"])(p[1], p[2]);
    const vec_a = Object(_vectors__WEBPACK_IMPORTED_MODULE_0__["vecCross"])(vec_to_c, pln_z_vec);
    if (Object(_vectors__WEBPACK_IMPORTED_MODULE_0__["vecLen"])(vec_a) === 0) {
        return p[0].slice();
    }
    const vec_b = Object(_vectors__WEBPACK_IMPORTED_MODULE_0__["vecCross"])(vec_a, pln_z_vec);
    const dot = Object(_vectors__WEBPACK_IMPORTED_MODULE_0__["vecDot"])(vec_to_c, Object(_vectors__WEBPACK_IMPORTED_MODULE_0__["vecNorm"])(vec_b));
    return Object(_vectors__WEBPACK_IMPORTED_MODULE_0__["vecAdd"])(p[0], Object(_vectors__WEBPACK_IMPORTED_MODULE_0__["vecSetLen"])(vec_b, dot));
}


/***/ }),

/***/ "./src/assets/libs/geom/matrix.ts":
/*!****************************************!*\
  !*** ./src/assets/libs/geom/matrix.ts ***!
  \****************************************/
/*! exports provided: multMatrix, mirrorMatrix, rotateMatrix, scaleMatrix, xfromSourceTargetMatrix, xformMatrix */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multMatrix", function() { return multMatrix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mirrorMatrix", function() { return mirrorMatrix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateMatrix", function() { return rotateMatrix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleMatrix", function() { return scaleMatrix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "xfromSourceTargetMatrix", function() { return xfromSourceTargetMatrix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "xformMatrix", function() { return xformMatrix; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/* harmony import */ var _vectors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./vectors */ "./src/assets/libs/geom/vectors.ts");
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};


function multMatrix(xyz, m) {
    const v2 = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](...xyz);
    v2.applyMatrix4(m);
    return v2.toArray();
}
function mirrorMatrix(plane) {
    const origin = plane[0];
    const normal = Object(_vectors__WEBPACK_IMPORTED_MODULE_1__["vecCross"])(plane[1], plane[2]);
    // plane normal
    const [a, b, c] = Object(_vectors__WEBPACK_IMPORTED_MODULE_1__["vecNorm"])(normal);
    // rotation matrix
    const matrix_mirror = new three__WEBPACK_IMPORTED_MODULE_0__["Matrix4"]();
    matrix_mirror.set(1 - (2 * a * a), -2 * a * b, -2 * a * c, 0, -2 * a * b, 1 - (2 * b * b), -2 * b * c, 0, -2 * a * c, -2 * b * c, 1 - (2 * c * c), 0, 0, 0, 0, 1);
    // translation matrix
    const matrix_trn1 = new three__WEBPACK_IMPORTED_MODULE_0__["Matrix4"]();
    matrix_trn1.makeTranslation(-origin[0], -origin[1], -origin[2]);
    const matrix_trn2 = new three__WEBPACK_IMPORTED_MODULE_0__["Matrix4"]();
    matrix_trn2.makeTranslation(origin[0], origin[1], origin[2]);
    // final matrix
    const move_mirror_move = matrix_trn2.multiply(matrix_mirror.multiply(matrix_trn1));
    // do the xform
    return move_mirror_move;
}
function rotateMatrix(ray, angle) {
    const origin = ray[0];
    const axis = Object(_vectors__WEBPACK_IMPORTED_MODULE_1__["vecNorm"])(ray[1]);
    // rotation matrix
    const matrix_rot = new three__WEBPACK_IMPORTED_MODULE_0__["Matrix4"]();
    matrix_rot.makeRotationAxis(new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](...axis), angle);
    // translation matrix
    const matrix_trn1 = new three__WEBPACK_IMPORTED_MODULE_0__["Matrix4"]();
    matrix_trn1.makeTranslation(-origin[0], -origin[1], -origin[2]);
    const matrix_trn2 = new three__WEBPACK_IMPORTED_MODULE_0__["Matrix4"]();
    matrix_trn2.makeTranslation(origin[0], origin[1], origin[2]);
    // final matrix
    const move_rot_move = matrix_trn2.multiply(matrix_rot.multiply(matrix_trn1));
    // do the xform
    return move_rot_move;
}
function scaleMatrix(plane, factor) {
    // scale matrix
    const matrix_scale = new three__WEBPACK_IMPORTED_MODULE_0__["Matrix4"]();
    matrix_scale.makeScale(factor[0], factor[1], factor[2]);
    // xform matrix
    const matrix_xform1 = xformMatrix(plane, true);
    const matrix_xform2 = xformMatrix(plane, false);
    // final matrix
    const xform_scale_xform = matrix_xform2.multiply(matrix_scale.multiply(matrix_xform1));
    // do the xform
    return xform_scale_xform;
}
function xfromSourceTargetMatrix(source_plane, target_plane) {
    // matrix to xform from source to gcs, then from gcs to target
    const matrix_source_to_gcs = xformMatrix(source_plane, true);
    const matrix_gcs_to_target = xformMatrix(target_plane, false);
    // final matrix
    const xform = matrix_gcs_to_target.multiply(matrix_source_to_gcs);
    // return the matrix
    return xform;
}
// ================================================================================================
// Helper functions
// ================================================================================================
function xformMatrix(plane, neg) {
    const o = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](...plane[0]);
    const x = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](...plane[1]);
    const y = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](...plane[2]);
    const z = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](...Object(_vectors__WEBPACK_IMPORTED_MODULE_1__["vecCross"])(plane[1], plane[2]));
    if (neg) {
        o.negate();
    }
    // origin translate matrix
    const m1 = new three__WEBPACK_IMPORTED_MODULE_0__["Matrix4"]();
    m1.setPosition(o);
    // xfrom matrix
    const m2 = new three__WEBPACK_IMPORTED_MODULE_0__["Matrix4"]();
    m2.makeBasis(x, y, z);
    // combine two matrices
    const m3 = new three__WEBPACK_IMPORTED_MODULE_0__["Matrix4"]();
    if (neg) {
        const m2x = (new three__WEBPACK_IMPORTED_MODULE_0__["Matrix4"]()).getInverse(m2);
        // first translate to origin, then xform, so m2 x m1
        m3.multiplyMatrices(m2x, m1);
    }
    else {
        // first xform, then translate to origin, so m1 x m2
        m3.multiplyMatrices(m1, m2);
    }
    // return the combined matrix
    return m3;
}
// ---------------------------------------------------------------------------------
// function _matrixFromXYZ(pts: Txyz[],
//     from_origin: Txyz, from_vectors: Txyz[],
//     to_origin: Txyz, to_vectors: Txyz[]): number[][] {
//     const e1: three.Vector3 = new three.Vector3(from_vectors[0][0]).normalize();
//     const e2: three.Vector3 = new three.Vector3(from_vectors[0][1]).normalize();
//     const e3: three.Vector3 = new three.Vector3(from_vectors[0][2]).normalize();
//     const b1: three.Vector3 = new three.Vector3(to_vectors[0][0]).normalize();
//     const b2: three.Vector3 = new three.Vector3(to_vectors[0][1]).normalize();
//     const b3: three.Vector3 = new three.Vector3(to_vectors[0][2]).normalize();
//     if (e1.dot(e2) === 0) { throw new Error('Orthonormal initial basis required'); }
//     if (e1.dot(e3) === 0) { throw new Error('Orthonormal initial basis required'); }
//     if (e2.dot(e3) === 0) { throw new Error('Orthonormal initial basis required'); }
//     if (b1.dot(b2) === 0) { throw new Error('Orthonormal initial basis required'); }
//     if (b1.dot(b3) === 0) { throw new Error('Orthonormal initial basis required'); }
//     if (b2.dot(b3) === 0) { throw new Error('Orthonormal initial basis required'); }
//     const matrix: three.Matrix3 = new three.Matrix3();
//     matrix.set(e1.dot(b1), e1.dot(b2), e1.dot(b3),
//     e2.dot(b1), e2.dot(b2), e2.dot(b3),
//     e3.dot(b1), e3.dot(b2), e3.dot(b3));
//     const t_x: number = to_origin[0] - from_origin[0];
//     const t_y: number = to_origin[1] - from_origin[1];
//     const t_z: number = to_origin[2] - from_origin[2];
//     return [[e1.dot(b1), e1.dot(b2), e1.dot(b3), t_x],
//     [e2.dot(b1), e2.dot(b2), e2.dot(b3), t_y],
//     [e3.dot(b1), e3.dot(b2), e3.dot(b3), t_z],
//     [0, 0, 0, 1]];
// }
// export function scaleMatrix(plane: TPlane, factor: Txyz): three.Matrix4 {
//     // scale matrix
//     const matrix_scale: three.Matrix4 = new three.Matrix4();
//     matrix_scale.makeScale(factor[0], factor[1], factor[2]);
//     // xform matrix
//     const matrix_xform1: three.Matrix4 = _xformMatrixFromXYZVectors(
//         plane[0], plane[1], plane[2], true);
//     const matrix_xform2: three.Matrix4 = _xformMatrixFromXYZVectors(
//         plane[0], plane[1], plane[2], false);
//     // final matrix
//     const xform_scale_xform: three.Matrix4 = matrix_xform2.multiply(matrix_scale.multiply(matrix_xform1));
//     // do the xform
//     return xform_scale_xform;
// }
// function _dotVectors(v1: three.Vector3, v2: three.Vector3): number {
//     return v1.dot(v2);
// }
// function _xformMatrixNeg(o: three.Vector3, x: three.Vector3, y: three.Vector3): three.Matrix4 {
//     const m1: three.Matrix4 = new three.Matrix4();
//     const o_neg: three.Vector3 = o.clone().negate();
//     m1.setPosition(o_neg);
//     const m2: three.Matrix4 = new three.Matrix4();
//     m2.makeBasis(x.normalize(), y.normalize(), _crossVectors(x, y, true));
//     m2.getInverse(m2);
//     const m3: three.Matrix4 = new three.Matrix4();
//     // first translate to (0,0,0), then xform, so m1 x m2
//     m3.multiplyMatrices(m2, m1);
//     return m3;
// }
// function xformMatrixPos(o: three.Vector3, x: three.Vector3, y: three.Vector3): three.Matrix4 {
//     const m1: three.Matrix4 = new three.Matrix4();
//     m1.setPosition(o);
//     const m2: three.Matrix4 = new three.Matrix4();
//     m2.makeBasis(x.normalize(), y.normalize(), _crossVectors(x, y, true));
//     const m3: three.Matrix4 = new three.Matrix4();
//     // first xform, then translate to origin, so m1 x m2
//     m3.multiplyMatrices(m1, m2);
//     return m3;
// }
// function _xformMatrixFromXYZVectors(o: Txyz, xaxis: Txyz, xyplane: Txyz, neg: boolean): three.Matrix4 {
//     const x_vec: three.Vector3 = new three.Vector3(...xaxis).normalize();
//     const xyplane_vec: three.Vector3 = new three.Vector3(...xyplane).normalize();
//     const z_vec: three.Vector3 = _crossVectors(x_vec, xyplane_vec);
//     const y_vec: three.Vector3 = _crossVectors(z_vec, x_vec);
//     if (neg) {
//         return _xformMatrixNeg(new three.Vector3(...o), x_vec, y_vec);
//     }
//     return xformMatrixPos(new three.Vector3(...o), x_vec, y_vec);
// }
// export function xfromSourceTargetMatrix(source_plane: TPlane, target_plane: TPlane): three.Matrix4 {
//     // matrix to xform from source to gcs, then from gcs to target
//     const matrix_source_to_gcs: three.Matrix4 = _xformMatrixFromXYZVectors(
//         source_plane[0], source_plane[1], source_plane[2], true);
//     const matrix_gcs_to_target: three.Matrix4 = _xformMatrixFromXYZVectors(
//         target_plane[0], target_plane[1], target_plane[2], false);
//     // final matrix
//     const xform: three.Matrix4 = matrix_gcs_to_target.multiply(matrix_source_to_gcs);
//     // return the matrix
//     return xform;
// }
// function _crossVectors(v1: three.Vector3, v2: three.Vector3, norm: boolean = false): three.Vector3 {
//     const v3: three.Vector3 = new three.Vector3();
//     v3.crossVectors(v1, v2);
//     if (norm) { v3.normalize(); }
//     return v3;
// }


/***/ }),

/***/ "./src/assets/libs/geom/mesh.ts":
/*!**************************************!*\
  !*** ./src/assets/libs/geom/mesh.ts ***!
  \**************************************/
/*! exports provided: createMultipleMeshesTjs, createSingleMeshTjs, createSingleMeshBufTjs */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createMultipleMeshesTjs", function() { return createMultipleMeshesTjs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createSingleMeshTjs", function() { return createSingleMeshTjs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createSingleMeshBufTjs", function() { return createSingleMeshBufTjs; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/* harmony import */ var _geo_info_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../geo-info/common */ "./src/assets/libs/geo-info/common.ts");
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};


// ----
// here are three different version of the function to create the threejs mesh, used for raycasting
// the first creates multiple meshes, the second one big mesh, the third one big buffered mesh
// performance tests are not very clear, in theory the big buffered mesh should be faster,
// but it seems that is not the case, the big non-buffered mesh seems faster
// so for now that is the one that is being used
// ----
function createMultipleMeshesTjs(__model__, ents_arrs) {
    // Note that for meshes, faces must be pointed towards the origin of the ray in order to be detected;
    // intersections of the ray passing through the back of a face will not be detected.
    // To raycast against both faces of an object, you'll want to set the material's side property to THREE.DoubleSide.
    const mat_tjs = new three__WEBPACK_IMPORTED_MODULE_0__["MeshBasicMaterial"]();
    mat_tjs.side = three__WEBPACK_IMPORTED_MODULE_0__["DoubleSide"];
    // get all unique posis
    const posis_i_set = new Set();
    for (const [ent_type, ent_i] of ents_arrs) {
        const ent_posis_i = __model__.modeldata.geom.nav.navAnyToPosi(ent_type, ent_i);
        ent_posis_i.forEach(ent_posi_i => posis_i_set.add(ent_posi_i));
    }
    // create tjs vectors for each posi and save them in a sparse array
    // the index to the array is the posi_i
    const posis_tjs = [];
    for (const posi_i of Array.from(posis_i_set)) {
        const xyz = __model__.modeldata.attribs.query.getPosiCoords(posi_i);
        const posi_tjs = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](...xyz);
        posis_tjs[posi_i] = posi_tjs;
    }
    // get an array of all the faces
    const faces_i = [];
    for (const [ent_type, ent_i] of ents_arrs) {
        switch (ent_type) {
            case _geo_info_common__WEBPACK_IMPORTED_MODULE_1__["EEntType"].FACE:
                faces_i.push(ent_i);
                break;
            default:
                const coll_faces_i = __model__.modeldata.geom.nav.navAnyToFace(ent_type, ent_i);
                coll_faces_i.forEach(coll_face_i => faces_i.push(coll_face_i));
                break;
        }
    }
    // create tjs meshes
    const meshes_tjs = [];
    for (const face_i of faces_i) {
        // create the tjs geometry
        const geom_tjs = new three__WEBPACK_IMPORTED_MODULE_0__["Geometry"]();
        const tris_i = __model__.modeldata.geom.nav.navFaceToTri(face_i);
        for (const tri_i of tris_i) {
            const tri_posis_i = __model__.modeldata.geom.nav.navAnyToPosi(_geo_info_common__WEBPACK_IMPORTED_MODULE_1__["EEntType"].TRI, tri_i);
            // add the three vertices to the geometry
            const a = geom_tjs.vertices.push(posis_tjs[tri_posis_i[0]]) - 1;
            const b = geom_tjs.vertices.push(posis_tjs[tri_posis_i[1]]) - 1;
            const c = geom_tjs.vertices.push(posis_tjs[tri_posis_i[2]]) - 1;
            // add the tjs tri to the geometry
            geom_tjs.faces.push(new three__WEBPACK_IMPORTED_MODULE_0__["Face3"](a, b, c));
        }
        // create the mesh, assigning the material
        meshes_tjs.push(new three__WEBPACK_IMPORTED_MODULE_0__["Mesh"](geom_tjs, mat_tjs));
    }
    return meshes_tjs;
}
function createSingleMeshTjs(__model__, ents_arrs) {
    // Note that for meshes, faces must be pointed towards the origin of the ray in order to be detected;
    // intersections of the ray passing through the back of a face will not be detected.
    // To raycast against both faces of an object, you'll want to set the material's side property to THREE.DoubleSide.
    const mat_tjs = new three__WEBPACK_IMPORTED_MODULE_0__["MeshBasicMaterial"]();
    mat_tjs.side = three__WEBPACK_IMPORTED_MODULE_0__["DoubleSide"];
    // get all unique posis
    const posis_i_set = new Set();
    for (const [ent_type, ent_i] of ents_arrs) {
        const ent_posis_i = __model__.modeldata.geom.nav.navAnyToPosi(ent_type, ent_i);
        ent_posis_i.forEach(ent_posi_i => posis_i_set.add(ent_posi_i));
    }
    // create tjs vectors for each posi and save them in a sparse array
    // the index to the array is the posi_i
    const posis_tjs = [];
    for (const posi_i of Array.from(posis_i_set)) {
        const xyz = __model__.modeldata.attribs.query.getPosiCoords(posi_i);
        const posi_tjs = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](...xyz);
        posis_tjs[posi_i] = posi_tjs;
    }
    // get an array of all the pgons
    const pgons_i = [];
    for (const [ent_type, ent_i] of ents_arrs) {
        switch (ent_type) {
            case _geo_info_common__WEBPACK_IMPORTED_MODULE_1__["EEntType"].PGON:
                pgons_i.push(ent_i);
                break;
            default:
                const ent_pgons_i = __model__.modeldata.geom.nav.navAnyToPgon(ent_type, ent_i);
                ent_pgons_i.forEach(ent_pgon_i => pgons_i.push(ent_pgon_i));
                break;
        }
    }
    // create tjs meshes
    const geom_tjs = new three__WEBPACK_IMPORTED_MODULE_0__["Geometry"]();
    const idx_to_pgon_i = [];
    for (const pgon_i of pgons_i) {
        // create the tjs geometry
        const tris_i = __model__.modeldata.geom.nav.navAnyToTri(_geo_info_common__WEBPACK_IMPORTED_MODULE_1__["EEntType"].PGON, pgon_i);
        for (const tri_i of tris_i) {
            const tri_posis_i = __model__.modeldata.geom.nav.navAnyToPosi(_geo_info_common__WEBPACK_IMPORTED_MODULE_1__["EEntType"].TRI, tri_i);
            // add the three vertices to the geometry
            const a = geom_tjs.vertices.push(posis_tjs[tri_posis_i[0]]) - 1;
            const b = geom_tjs.vertices.push(posis_tjs[tri_posis_i[1]]) - 1;
            const c = geom_tjs.vertices.push(posis_tjs[tri_posis_i[2]]) - 1;
            // add the tjs tri to the geometry
            const idx_tjs = geom_tjs.faces.push(new three__WEBPACK_IMPORTED_MODULE_0__["Face3"](a, b, c)) - 1;
            idx_to_pgon_i[idx_tjs] = pgon_i;
        }
    }
    // create the mesh, assigning the material
    return [new three__WEBPACK_IMPORTED_MODULE_0__["Mesh"](geom_tjs, mat_tjs), idx_to_pgon_i];
}
function createSingleMeshBufTjs(__model__, ents_arrs) {
    // Note that for meshes, faces must be pointed towards the origin of the ray in order to be detected;
    // intersections of the ray passing through the back of a face will not be detected.
    // To raycast against both faces of an object, you'll want to set the material's side property to THREE.DoubleSide.
    const mat_tjs = new three__WEBPACK_IMPORTED_MODULE_0__["MeshBasicMaterial"]();
    mat_tjs.side = three__WEBPACK_IMPORTED_MODULE_0__["DoubleSide"];
    // get all unique posis
    const posis_i_set = new Set();
    for (const [ent_type, ent_i] of ents_arrs) {
        const ent_posis_i = __model__.modeldata.geom.nav.navAnyToPosi(ent_type, ent_i);
        ent_posis_i.forEach(ent_posi_i => posis_i_set.add(ent_posi_i));
    }
    // create a flat list of xyz coords
    const xyzs_flat = [];
    const posi_i_to_xyzs_map = new Map();
    const unique_posis_i = Array.from(posis_i_set);
    for (let i = 0; i < unique_posis_i.length; i++) {
        const posi_i = unique_posis_i[i];
        const xyz = __model__.modeldata.attribs.query.getPosiCoords(posi_i);
        xyzs_flat.push(...xyz);
        posi_i_to_xyzs_map.set(posi_i, i);
    }
    // get an array of all the faces
    const faces_i = [];
    for (const [ent_type, ent_i] of ents_arrs) {
        switch (ent_type) {
            case _geo_info_common__WEBPACK_IMPORTED_MODULE_1__["EEntType"].FACE:
                faces_i.push(ent_i);
                break;
            default:
                const coll_faces_i = __model__.modeldata.geom.nav.navAnyToFace(ent_type, ent_i);
                coll_faces_i.forEach(coll_face_i => faces_i.push(coll_face_i));
                break;
        }
    }
    // create tjs meshes
    const tris_flat = [];
    for (const face_i of faces_i) {
        // create the tjs geometry
        const tris_i = __model__.modeldata.geom.nav.navFaceToTri(face_i);
        for (const tri_i of tris_i) {
            const tri_posis_i = __model__.modeldata.geom.nav.navAnyToPosi(_geo_info_common__WEBPACK_IMPORTED_MODULE_1__["EEntType"].TRI, tri_i);
            tris_flat.push(posi_i_to_xyzs_map.get(tri_posis_i[0]));
            tris_flat.push(posi_i_to_xyzs_map.get(tri_posis_i[1]));
            tris_flat.push(posi_i_to_xyzs_map.get(tri_posis_i[2]));
        }
        // create the mesh, assigning the material
    }
    const geom_tjs = new three__WEBPACK_IMPORTED_MODULE_0__["BufferGeometry"]();
    geom_tjs.setIndex(tris_flat);
    // geom_tjs.addAttribute( 'position', new THREE.Float32BufferAttribute( xyzs_flat, 3 ) );
    geom_tjs.setAttribute('position', new three__WEBPACK_IMPORTED_MODULE_0__["Float32BufferAttribute"](xyzs_flat, 3));
    return new three__WEBPACK_IMPORTED_MODULE_0__["Mesh"](geom_tjs, mat_tjs);
}


/***/ }),

/***/ "./src/assets/libs/geom/triangle.ts":
/*!******************************************!*\
  !*** ./src/assets/libs/geom/triangle.ts ***!
  \******************************************/
/*! exports provided: normal, area */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normal", function() { return normal; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "area", function() { return area; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};

const EPS = 1e-6;
function normal(v1, v2, v3, norm = false) {
    const _v1 = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](...v1);
    const _v2 = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](...v2);
    const _v3 = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](...v3);
    const t = new three__WEBPACK_IMPORTED_MODULE_0__["Triangle"](_v1, _v2, _v3);
    const _normal = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
    t.getNormal(_normal);
    if (norm) {
        _normal.normalize();
    }
    return _normal.toArray();
}
function area(v1, v2, v3) {
    const _v1 = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](...v1);
    const _v2 = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](...v2);
    const _v3 = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](...v3);
    const t = new three__WEBPACK_IMPORTED_MODULE_0__["Triangle"](_v1, _v2, _v3);
    return t.getArea();
}


/***/ }),

/***/ "./src/assets/libs/geom/vectors.ts":
/*!*****************************************!*\
  !*** ./src/assets/libs/geom/vectors.ts ***!
  \*****************************************/
/*! exports provided: vecEqual, vecSub, vecsSub, vecAdd, vecsAdd, vecSum, vecAvg, vecDiv, vecMult, vecCross, vecDot, vecNorm, vecRot, vecAng, vecAng2, vecLen, vecSetLen, vecRev, vecFromTo, vecMakeOrtho, vecCodir, dist, newellNorm, interpByNum, interpByLen */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vecEqual", function() { return vecEqual; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vecSub", function() { return vecSub; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vecsSub", function() { return vecsSub; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vecAdd", function() { return vecAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vecsAdd", function() { return vecsAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vecSum", function() { return vecSum; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vecAvg", function() { return vecAvg; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vecDiv", function() { return vecDiv; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vecMult", function() { return vecMult; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vecCross", function() { return vecCross; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vecDot", function() { return vecDot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vecNorm", function() { return vecNorm; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vecRot", function() { return vecRot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vecAng", function() { return vecAng; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vecAng2", function() { return vecAng2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vecLen", function() { return vecLen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vecSetLen", function() { return vecSetLen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vecRev", function() { return vecRev; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vecFromTo", function() { return vecFromTo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vecMakeOrtho", function() { return vecMakeOrtho; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vecCodir", function() { return vecCodir; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dist", function() { return dist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newellNorm", function() { return newellNorm; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "interpByNum", function() { return interpByNum; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "interpByLen", function() { return interpByLen; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/* harmony import */ var mathjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! mathjs */ "./node_modules/mathjs/index.js");
/* harmony import */ var mathjs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(mathjs__WEBPACK_IMPORTED_MODULE_1__);
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};


const EPS = 1e-6;
//  Vectors using Txyz =======================================================================================================
function vecEqual(v1, v2, tol) {
    if (Math.abs(v1[0] - v2[0]) > tol) {
        return false;
    }
    if (Math.abs(v1[1] - v2[1]) > tol) {
        return false;
    }
    if (Math.abs(v1[2] - v2[2]) > tol) {
        return false;
    }
    return true;
}
function vecSub(v1, v2, norm = false) {
    const v3 = [
        v1[0] - v2[0],
        v1[1] - v2[1],
        v1[2] - v2[2],
    ];
    if (norm) {
        return vecNorm(v3);
    }
    return v3;
}
function vecsSub(vecs, norm = false) {
    const vec_sub = [0, 0, 0];
    for (const vec of vecs) {
        vec_sub[0] = vec_sub[0] - vec[0];
        vec_sub[1] = vec_sub[1] - vec[1];
        vec_sub[2] = vec_sub[2] - vec[2];
    }
    if (norm) {
        return vecNorm(vec_sub);
    }
    return vec_sub;
}
function vecAdd(v1, v2, norm = false) {
    const v3 = [
        v1[0] + v2[0],
        v1[1] + v2[1],
        v1[2] + v2[2],
    ];
    if (norm) {
        return vecNorm(v3);
    }
    return v3;
}
function vecsAdd(vecs, norm = false) {
    const vec_add = [0, 0, 0];
    for (const vec of vecs) {
        vec_add[0] = vec_add[0] + vec[0];
        vec_add[1] = vec_add[1] + vec[1];
        vec_add[2] = vec_add[2] + vec[2];
    }
    if (norm) {
        return vecNorm(vec_add);
    }
    return vec_add;
}
function vecSum(vecs, norm = false) {
    const vec_sum = [0, 0, 0];
    for (const vec of vecs) {
        vec_sum[0] += vec[0];
        vec_sum[1] += vec[1];
        vec_sum[2] += vec[2];
    }
    if (norm) {
        return vecNorm(vec_sum);
    }
    return vec_sum;
}
function vecAvg(vecs) {
    const vec_sum = [0, 0, 0];
    for (const vec of vecs) {
        vec_sum[0] += vec[0];
        vec_sum[1] += vec[1];
        vec_sum[2] += vec[2];
    }
    const divisor = vecs.length;
    return [
        vec_sum[0] / divisor,
        vec_sum[1] / divisor,
        vec_sum[2] / divisor
    ];
}
function vecDiv(vec, divisor) {
    return [
        vec[0] / divisor,
        vec[1] / divisor,
        vec[2] / divisor
    ];
}
function vecMult(vec, multiplier) {
    return [
        vec[0] * multiplier,
        vec[1] * multiplier,
        vec[2] * multiplier
    ];
}
function vecCross(v1, v2, norm = false) {
    const n = mathjs__WEBPACK_IMPORTED_MODULE_1__["cross"](v1, v2);
    if (norm) {
        return vecNorm(n);
    }
    return n;
}
function vecDot(v1, v2) {
    return mathjs__WEBPACK_IMPORTED_MODULE_1__["dot"](v1, v2);
}
function vecNorm(v) {
    const length = Math.hypot(...v);
    if (length === 0) {
        return [0, 0, 0];
    }
    return [v[0] / length, v[1] / length, v[2] / length];
}
function vecRot(vec, axis, ang) {
    const vec_tjs = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](...vec);
    const axis_tjs = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](...axis);
    vec_tjs.applyAxisAngle(axis_tjs, ang);
    return [vec_tjs.x, vec_tjs.y, vec_tjs.z];
}
function vecAng(v1, v2) {
    const v1n = vecNorm(v1);
    const v2n = vecNorm(v2);
    const d = mathjs__WEBPACK_IMPORTED_MODULE_1__["dot"](v1n, v2n);
    return Math.acos(d);
}
function vecAng2(v1, v2, n) {
    const v1n = vecNorm(v1);
    const v2n = vecNorm(v2);
    const d = mathjs__WEBPACK_IMPORTED_MODULE_1__["dot"](v1n, v2n);
    if (d === 1) {
        return 0;
    }
    else if (d === -1) {
        return Math.PI;
    }
    let angle = Math.acos(d);
    const c = mathjs__WEBPACK_IMPORTED_MODULE_1__["cross"](v1n, v2n);
    angle = angle * mathjs__WEBPACK_IMPORTED_MODULE_1__["compare"](mathjs__WEBPACK_IMPORTED_MODULE_1__["dot"](n, c), 0);
    if (angle < 0) {
        angle = angle + (Math.PI * 2);
    }
    return angle;
}
function vecLen(v) {
    return Math.hypot(...v);
}
function vecSetLen(v, len) {
    const fac = len / Math.hypot(...v);
    return [v[0] * fac, v[1] * fac, v[2] * fac];
}
function vecRev(v) {
    return [
        v[0] * -1,
        v[1] * -1,
        v[2] * -1
    ];
}
function vecFromTo(v1, v2) {
    return vecSub(v2, v1);
}
function vecMakeOrtho(v1, v2) {
    return vecCross(v2, vecCross(v1, v2));
}
function vecCodir(v1, v2) {
    v1 = vecNorm(v1);
    v2 = vecNorm(v2);
    if (Math.abs(1 - mathjs__WEBPACK_IMPORTED_MODULE_1__["dot"](v1, v2)) > EPS) {
        return false;
    }
    return true;
}
function dist(p1, p2) {
    return mathjs__WEBPACK_IMPORTED_MODULE_1__["distance"](p1, p2);
}
/**
 * Finds the normal to a set of points using Newell's method
 */
function newellNorm(pts) {
    const normal = [0, 0, 0];
    for (let i = 0; i < pts.length - 1; i++) {
        const p0 = pts[i];
        const p1 = pts[i + 1];
        normal[0] += (p0[1] - p1[1]) * (p0[2] + p1[2]);
        normal[1] += (p0[2] - p1[2]) * (p0[0] + p1[0]);
        normal[2] += (p0[0] - p1[0]) * (p0[1] + p1[1]);
    }
    return vecNorm(normal);
}
/**
 * Create new points between two points.
 */
function interpByNum(pt1, pt2, num_points) {
    if (num_points < 1) {
        return [];
    }
    const sub_vec = vecDiv(vecSub(pt2, pt1), num_points + 1);
    const points = [];
    let next = pt1;
    for (let i = 0; i < num_points; i++) {
        next = vecAdd(next, sub_vec);
        points.push(next);
    }
    return points;
}
function interpByLen(pt1, pt2, len) {
    const vec = vecSub(pt2, pt1);
    const num_points = Math.floor(vecLen(vec) / len);
    const sub_vec = vecMult(vecNorm(vec), len);
    const points = [];
    let next = pt1;
    for (let i = 0; i < num_points; i++) {
        next = vecAdd(next, sub_vec);
        points.push(next);
    }
    return points;
}


/***/ }),

/***/ "./src/assets/libs/triangulate/earcut.ts":
/*!***********************************************!*\
  !*** ./src/assets/libs/triangulate/earcut.ts ***!
  \***********************************************/
/*! exports provided: Earcut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Earcut", function() { return Earcut; });
/**
 * @author Mugen87 / https://github.com/Mugen87
 * Port from https://github.com/mapbox/earcut (v2.1.2)
 */
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};
const Earcut = {
    triangulate: function (data, holeIndices, dim) {
        dim = dim || 2;
        const hasHoles = holeIndices && holeIndices.length;
        const outerLen = hasHoles ? holeIndices[0] * dim : data.length;
        let outerNode = linkedList(data, 0, outerLen, dim, true);
        const triangles = [];
        if (!outerNode) {
            return triangles;
        }
        let minX, minY, maxX, maxY, x, y, invSize;
        if (hasHoles) {
            outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
        }
        // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
        if (data.length > 80 * dim) {
            minX = maxX = data[0];
            minY = maxY = data[1];
            for (let i = dim; i < outerLen; i += dim) {
                x = data[i];
                y = data[i + 1];
                if (x < minX) {
                    minX = x;
                }
                if (y < minY) {
                    minY = y;
                }
                if (x > maxX) {
                    maxX = x;
                }
                if (y > maxY) {
                    maxY = y;
                }
            }
            // minX, minY and invSize are later used to transform coords into integers for z-order calculation
            invSize = Math.max(maxX - minX, maxY - minY);
            invSize = invSize !== 0 ? 1 / invSize : 0;
        }
        earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
        return triangles;
    }
};
// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(data, start, end, dim, clockwise) {
    let i, last;
    if (clockwise === (signedArea(data, start, end, dim) > 0)) {
        for (i = start; i < end; i += dim) {
            last = insertNode(i, data[i], data[i + 1], last);
        }
    }
    else {
        for (i = end - dim; i >= start; i -= dim) {
            last = insertNode(i, data[i], data[i + 1], last);
        }
    }
    if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
    }
    return last;
}
// eliminate colinear or duplicate points
function filterPoints(start, end) {
    if (!start) {
        return start;
    }
    if (!end) {
        end = start;
    }
    let p = start, again;
    do {
        again = false;
        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next) {
                break;
            }
            again = true;
        }
        else {
            p = p.next;
        }
    } while (again || p !== end);
    return end;
}
// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear) {
        return;
    }
    // interlink polygon nodes in z-order
    if (!pass && invSize) {
        indexCurve(ear, minX, minY, invSize);
    }
    let stop = ear, prev, next;
    // iterate through ears, slicing them one by one
    while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;
        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
            // cut off the triangle
            triangles.push(prev.i / dim);
            triangles.push(ear.i / dim);
            triangles.push(next.i / dim);
            removeNode(ear);
            // skipping the next vertice leads to less sliver triangles
            ear = next.next;
            stop = next.next;
            continue;
        }
        ear = next;
        // if we looped through the whole remaining polygon and can't find any more ears
        if (ear === stop) {
            // try filtering points and slicing again
            if (!pass) {
                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
                // if this didn't work, try curing all small self-intersections locally
            }
            else if (pass === 1) {
                ear = cureLocalIntersections(ear, triangles, dim);
                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
                // as a last resort, try splitting the remaining polygon into two
            }
            else if (pass === 2) {
                splitEarcut(ear, triangles, dim, minX, minY, invSize);
            }
            break;
        }
    }
}
// check whether a polygon node forms a valid ear with adjacent nodes
function isEar(ear) {
    const a = ear.prev, b = ear, c = ear.next;
    if (area(a, b, c) >= 0) {
        return false;
    } // reflex, can't be an ear
    // now make sure we don't have other points inside the potential ear
    let p = ear.next.next;
    while (p !== ear.prev) {
        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) {
            return false;
        }
        p = p.next;
    }
    return true;
}
function isEarHashed(ear, minX, minY, invSize) {
    const a = ear.prev, b = ear, c = ear.next;
    if (area(a, b, c) >= 0) {
        return false;
    } // reflex, can't be an ear
    // triangle bbox; min & max are calculated like this for speed
    const minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x), minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y), maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x), maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);
    // z-order range for the current triangle bbox;
    const minZ = zOrder(minTX, minTY, minX, minY, invSize), maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
    // first look for points inside the triangle in increasing z-order
    let p = ear.nextZ;
    while (p && p.z <= maxZ) {
        if (p !== ear.prev && p !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) {
            return false;
        }
        p = p.nextZ;
    }
    // then look for points in decreasing z-order
    p = ear.prevZ;
    while (p && p.z >= minZ) {
        if (p !== ear.prev && p !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) {
            return false;
        }
        p = p.prevZ;
    }
    return true;
}
// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections(start, triangles, dim) {
    let p = start;
    do {
        const a = p.prev, b = p.next.next;
        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
            triangles.push(a.i / dim);
            triangles.push(p.i / dim);
            triangles.push(b.i / dim);
            // remove two nodes involved
            removeNode(p);
            removeNode(p.next);
            p = start = b;
        }
        p = p.next;
    } while (p !== start);
    return p;
}
// try splitting polygon into two and triangulate them independently
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
    // look for a valid diagonal that divides the polygon into two
    let a = start;
    do {
        let b = a.next.next;
        while (b !== a.prev) {
            if (a.i !== b.i && isValidDiagonal(a, b)) {
                // split the polygon in two by the diagonal
                let c = splitPolygon(a, b);
                // filter colinear points around the cuts
                a = filterPoints(a, a.next);
                c = filterPoints(c, c.next);
                // run earcut on each half
                earcutLinked(a, triangles, dim, minX, minY, invSize);
                earcutLinked(c, triangles, dim, minX, minY, invSize);
                return;
            }
            b = b.next;
        }
        a = a.next;
    } while (a !== start);
}
// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles(data, holeIndices, outerNode, dim) {
    let queue = [], i, len, start, end, list;
    for (i = 0, len = holeIndices.length; i < len; i++) {
        start = holeIndices[i] * dim;
        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next) {
            list.steiner = true;
        }
        queue.push(getLeftmost(list));
    }
    queue.sort(compareX);
    // process holes from left to right
    for (i = 0; i < queue.length; i++) {
        eliminateHole(queue[i], outerNode);
        outerNode = filterPoints(outerNode, outerNode.next);
    }
    return outerNode;
}
function compareX(a, b) {
    return a.x - b.x;
}
// find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole(hole, outerNode) {
    outerNode = findHoleBridge(hole, outerNode);
    if (outerNode) {
        const b = splitPolygon(outerNode, hole);
        filterPoints(b, b.next);
    }
}
// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(hole, outerNode) {
    let p = outerNode;
    const hx = hole.x;
    const hy = hole.y;
    let qx = -Infinity;
    let m;
    // find a segment intersected by a ray from the hole's leftmost point to the left;
    // segment's endpoint with lesser x will be potential connection point
    do {
        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
            const x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x <= hx && x > qx) {
                qx = x;
                if (x === hx) {
                    if (hy === p.y) {
                        return p;
                    }
                    if (hy === p.next.y) {
                        return p.next;
                    }
                }
                m = p.x < p.next.x ? p : p.next;
            }
        }
        p = p.next;
    } while (p !== outerNode);
    if (!m) {
        return null;
    }
    if (hx === qx) {
        return m.prev;
    } // hole touches outer segment; pick lower endpoint
    // look for points inside the triangle of hole point, segment intersection and endpoint;
    // if there are no points found, we have a valid connection;
    // otherwise choose the point of the minimum angle with the ray as connection point
    const stop = m;
    const mx = m.x;
    const my = m.y;
    let tanMin = Infinity;
    let tan;
    p = m.next;
    while (p !== stop) {
        if (hx >= p.x && p.x >= mx && hx !== p.x &&
            pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential
            if ((tan < tanMin || (tan === tanMin && p.x > m.x)) && locallyInside(p, hole)) {
                m = p;
                tanMin = tan;
            }
        }
        p = p.next;
    }
    return m;
}
// interlink polygon nodes in z-order
function indexCurve(start, minX, minY, invSize) {
    let p = start;
    do {
        if (p.z === null) {
            p.z = zOrder(p.x, p.y, minX, minY, invSize);
        }
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
    } while (p !== start);
    p.prevZ.nextZ = null;
    p.prevZ = null;
    sortLinked(p);
}
// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list) {
    let i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
    do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;
        while (p) {
            numMerges++;
            q = p;
            pSize = 0;
            for (i = 0; i < inSize; i++) {
                pSize++;
                q = q.nextZ;
                if (!q) {
                    break;
                }
            }
            qSize = inSize;
            while (pSize > 0 || (qSize > 0 && q)) {
                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                }
                else {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                }
                if (tail) {
                    tail.nextZ = e;
                }
                else {
                    list = e;
                }
                e.prevZ = tail;
                tail = e;
            }
            p = q;
        }
        tail.nextZ = null;
        inSize *= 2;
    } while (numMerges > 1);
    return list;
}
// z-order of a point given coords and inverse of the longer side of data bbox
function zOrder(x, y, minX, minY, invSize) {
    // coords are transformed into non-negative 15-bit integer range
    x = 32767 * (x - minX) * invSize;
    y = 32767 * (y - minY) * invSize;
    x = (x | (x << 8)) & 0x00FF00FF;
    x = (x | (x << 4)) & 0x0F0F0F0F;
    x = (x | (x << 2)) & 0x33333333;
    x = (x | (x << 1)) & 0x55555555;
    y = (y | (y << 8)) & 0x00FF00FF;
    y = (y | (y << 4)) & 0x0F0F0F0F;
    y = (y | (y << 2)) & 0x33333333;
    y = (y | (y << 1)) & 0x55555555;
    return x | (y << 1);
}
// find the leftmost node of a polygon ring
function getLeftmost(start) {
    let p = start, leftmost = start;
    do {
        if (p.x < leftmost.x) {
            leftmost = p;
        }
        p = p.next;
    } while (p !== start);
    return leftmost;
}
// check if a point lies within a convex triangle
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&
        (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&
        (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
}
// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) &&
        locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b);
}
// signed area of a triangle
function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}
// check if two points are equal
function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
}
// check if two segments intersect
function intersects(p1, q1, p2, q2) {
    if ((equals(p1, q1) && equals(p2, q2)) ||
        (equals(p1, q2) && equals(p2, q1))) {
        return true;
    }
    return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 &&
        area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;
}
// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(a, b) {
    let p = a;
    do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
            intersects(p, p.next, a, b)) {
            return true;
        }
        p = p.next;
    } while (p !== a);
    return false;
}
// check if a polygon diagonal is locally inside the polygon
function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ?
        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :
        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}
// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(a, b) {
    let p = a;
    let inside = false;
    const px = (a.x + b.x) / 2;
    const py = (a.y + b.y) / 2;
    do {
        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&
            (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x)) {
            inside = !inside;
        }
        p = p.next;
    } while (p !== a);
    return inside;
}
// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon(a, b) {
    const a2 = new Node(a.i, a.x, a.y), b2 = new Node(b.i, b.x, b.y), an = a.next, bp = b.prev;
    a.next = b;
    b.prev = a;
    a2.next = an;
    an.prev = a2;
    b2.next = a2;
    a2.prev = b2;
    bp.next = b2;
    b2.prev = bp;
    return b2;
}
// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode(i, x, y, last) {
    const p = new Node(i, x, y);
    if (!last) {
        p.prev = p;
        p.next = p;
    }
    else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
    }
    return p;
}
function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;
    if (p.prevZ) {
        p.prevZ.nextZ = p.nextZ;
    }
    if (p.nextZ) {
        p.nextZ.prevZ = p.prevZ;
    }
}
function Node(i, x, y) {
    // vertice index in coordinates array
    this.i = i;
    // vertex coordinates
    this.x = x;
    this.y = y;
    // previous and next vertice nodes in a polygon ring
    this.prev = null;
    this.next = null;
    // z-order curve value
    this.z = null;
    // previous and next nodes in z-order
    this.prevZ = null;
    this.nextZ = null;
    // indicates whether this is a steiner point
    this.steiner = false;
}
function signedArea(data, start, end, dim) {
    let sum = 0;
    for (let i = start, j = end - dim; i < end; i += dim) {
        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
        j = i;
    }
    return sum;
}



/***/ }),

/***/ "./src/assets/libs/triangulate/threex.ts":
/*!***********************************************!*\
  !*** ./src/assets/libs/triangulate/threex.ts ***!
  \***********************************************/
/*! exports provided: multVectorMatrix, xformMatrix, matrixInv, subVectors, addVectors, crossVectors */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multVectorMatrix", function() { return multVectorMatrix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "xformMatrix", function() { return xformMatrix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "matrixInv", function() { return matrixInv; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subVectors", function() { return subVectors; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addVectors", function() { return addVectors; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "crossVectors", function() { return crossVectors; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};

const EPS = 1e-6;
/**
 * Utility functions for threejs.
 */
// Matrices ======================================================================================================
function multVectorMatrix(v, m) {
    const v2 = v.clone();
    v2.applyMatrix4(m);
    return v2;
}
function xformMatrix(o, x, y, z) {
    x.normalize();
    y.normalize();
    z.normalize();
    const m1 = new three__WEBPACK_IMPORTED_MODULE_0__["Matrix4"]();
    const o_neg = o.clone().negate();
    m1.setPosition(o_neg);
    const m2 = new three__WEBPACK_IMPORTED_MODULE_0__["Matrix4"]();
    m2.makeBasis(x, y, z);
    m2.getInverse(m2);
    const m3 = new three__WEBPACK_IMPORTED_MODULE_0__["Matrix4"]();
    m3.multiplyMatrices(m2, m1);
    return m3;
}
function matrixInv(m) {
    const m2 = new three__WEBPACK_IMPORTED_MODULE_0__["Matrix4"]();
    return m2.getInverse(m);
}
//  Vectors =======================================================================================================
function subVectors(v1, v2, norm = false) {
    const v3 = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
    v3.subVectors(v1, v2);
    if (norm) {
        v3.normalize();
    }
    return v3;
}
function addVectors(v1, v2, norm = false) {
    const v3 = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
    v3.addVectors(v1, v2);
    if (norm) {
        v3.normalize();
    }
    return v3;
}
function crossVectors(v1, v2, norm = false) {
    const v3 = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
    v3.crossVectors(v1, v2);
    if (norm) {
        v3.normalize();
    }
    return v3;
}


/***/ }),

/***/ "./src/assets/libs/triangulate/triangulate.ts":
/*!****************************************************!*\
  !*** ./src/assets/libs/triangulate/triangulate.ts ***!
  \****************************************************/
/*! exports provided: triangulateQuad, triangulate */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "triangulateQuad", function() { return triangulateQuad; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "triangulate", function() { return triangulate; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/* harmony import */ var _threex__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./threex */ "./src/assets/libs/triangulate/threex.ts");
/* harmony import */ var _earcut__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./earcut */ "./src/assets/libs/triangulate/earcut.ts");
/* harmony import */ var _geom_triangle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../geom/triangle */ "./src/assets/libs/geom/triangle.ts");
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};




// import { ConvexHull } from 'three/examples/jsm/math/ConvexHull';
// import { ConvexGeometry } from 'three/examples/jsm/geometries/ConvexGeometry';
// import { Earcut } from 'three/Earcut';
const EPS = 1e-6;
//  3D to 2D ======================================================================================================
/**
 * Function that returns a matrix to transform a set of vertices in 3d space onto the xy plane.
 * This function assumes that the vertices are more or less co-planar.
 * Returns null if the plane cannot be found, e.g. points are all colinear.
 */
// function _getMatrixOld(points: three.Vector3[]): three.Matrix4 {
//     // calculate origin
//     const o: three.Vector3 = new three.Vector3();
//     for (const v of points) {
//         o.add(v);
//     }
//     o.divideScalar(points.length);
//     // find three vectors
//     let vx: three.Vector3;
//     let vz: three.Vector3;
//     let got_vx = false;
//     for (let i = 0; i < points.length; i++) {
//         if (!got_vx) {
//             vx =  threex.subVectors(points[i], o);
//             if (vx.lengthSq() !== 0) {got_vx = true; }
//         } else {
//             vz = threex.crossVectors(vx, threex.subVectors(points[i], o));
//             if (vz.lengthSq() !== 0) { break; }
//         }
//         if (i === points.length - 1) { return null; } // could not find any pair of vectors
//     }
//     const vy: three.Vector3 =  threex.crossVectors(vz, vx);
//     // create matrix
//     vx.normalize();
//     vy.normalize();
//     vz.normalize();
//     const m2: three.Matrix4 = new three.Matrix4();
//     m2.makeBasis(vx, vy, vz);
//     m2.getInverse(m2);
//     return m2;
// }
/**
 * Gtes three extreme points that can be used to calculate the transform matrix
 */
function _getThreePoints(points) {
    // console.log("_getExtremePoints")
    // basic case, a triangle with holes
    if (points.length === 3) {
        return points;
    }
    // find the extreme points
    const extremes = [0, 0, 0, 0, 0, 0];
    // min x, min y, min z, max x, max y, max z
    for (let i = 0; i < points.length; i++) {
        if (points[i].x < points[extremes[0]].x) {
            extremes[0] = i;
        }
        if (points[i].y < points[extremes[1]].y) {
            extremes[1] = i;
        }
        if (points[i].z < points[extremes[2]].z) {
            extremes[2] = i;
        }
        if (points[i].x > points[extremes[3]].x) {
            extremes[3] = i;
        }
        if (points[i].y > points[extremes[4]].y) {
            extremes[4] = i;
        }
        if (points[i].z > points[extremes[5]].z) {
            extremes[5] = i;
        }
    }
    // calc sizes
    const x_size = Math.abs(points[extremes[3]].x - points[extremes[0]].x);
    const y_size = Math.abs(points[extremes[4]].y - points[extremes[1]].y);
    const z_size = Math.abs(points[extremes[5]].z - points[extremes[2]].z);
    // add the extreme points
    const set_selected = new Set();
    if (x_size > 0) {
        set_selected.add(extremes[0]);
        set_selected.add(extremes[3]);
    }
    if (y_size > 0) {
        set_selected.add(extremes[1]);
        set_selected.add(extremes[4]);
    }
    if (z_size > 0) {
        set_selected.add(extremes[2]);
        set_selected.add(extremes[5]);
    }
    // get three points that are not too close together
    const LIMIT = 0.0001; /// I am not sure what to set this to
    const selected = Array.from(set_selected).sort((a, b) => a - b);
    let three_selected = [selected[0]];
    for (let i = 1; i < selected.length; i++) {
        // I am not really sure if this distance check is needed
        // we already got extreme points
        // but it is possible that two or even three extreme points are right next to each other
        // squashed together in a corner... so I leave this check for now
        if (points[selected[i - 1]].manhattanDistanceTo(points[selected[i]]) > LIMIT) {
            three_selected.push(selected[i]);
        }
        if (three_selected.length === 3) {
            break;
        }
    }
    // we should now have three points
    if (three_selected.length === 3) {
        // console.log("FAST METHOD");
        return three_selected.map(i => points[i]);
    }
    else if (three_selected.length === 2) {
        // there is always a special case... the dreaded diagonal shape
        // console.log("SLOW METHOD", [first, second]);
        const [first, second] = three_selected;
        const line = new three__WEBPACK_IMPORTED_MODULE_0__["Line3"](points[first], points[second]);
        let third;
        let dist = 0;
        for (let i = 0; i < points.length; i++) {
            const cur_point = points[i];
            if (cur_point !== points[first] && cur_point !== points[second]) {
                const dummy = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
                const close_point = line.closestPointToPoint(cur_point, true, dummy);
                const cur_dist = cur_point.manhattanDistanceTo(close_point);
                if (dist < cur_dist) {
                    third = i;
                    dist = cur_dist;
                }
            }
            if (dist > LIMIT) {
                break;
            }
        }
        if (third === undefined) {
            return null;
        }
        three_selected = [first, second, third].sort((a, b) => a - b);
        return three_selected.map(i => points[i]);
    }
    // else if (selected.size === 2) { // special diagonal case
    //     console.log("XXXXXXXXXXXXXXX")
    //     return null;
    //     // TODO replace with convex hull
    //     const pair_idxs: number[] = Array.from(selected.values());
    //     const line: three.Line3 = new three.Line3(points[pair_idxs[0]], points[pair_idxs[1]]);
    //     const line_len: number = line.delta(new three.Vector3()).manhattanLength();
    //     let max_dist = 1e-4;
    //     let third_point_idx = null;
    //     for (let i = 0; i < points.length; i++) {
    //         if (i !== pair_idxs[0] && i !== pair_idxs[1]) {
    //             const point_on_line: three.Vector3 = line.closestPointToPoint(points[i], false, new three.Vector3());
    //             const dist_to_line: number = point_on_line.manhattanDistanceTo(points[i]);
    //             if (dist_to_line > max_dist) {
    //                 third_point_idx = i;
    //                 max_dist = dist_to_line;
    //             }
    //             if (dist_to_line / line_len > 0.01) { break; }
    //         }
    //     }
    //     if (third_point_idx === null) { return null; }
    //     const extreme_points: three.Vector3[] =
    // [pair_idxs[0], pair_idxs[1], third_point_idx].sort((a, b) => a - b ).map( i => points[i] );
    //     return extreme_points;
    // }
    // could not find points
    return null;
}
/**
 * Function that returns a matrix to transform a set of vertices in 3d space onto the xy plane.
 * This function assumes that the vertices are more or less co-planar.
 * Returns null if the plane cannot be found, e.g. points are all colinear.
 */
function _getMatrix(points) {
    const three_points = _getThreePoints(points);
    // if (extreme_points === null) {
    //     console.log("POINTS = ",points)
    //     extreme_points = _getExtremePointsConvex(points);
    // }
    if (three_points === null) {
        return null;
    }
    // console.log("points", points)
    // console.log("extremes", extremes)
    // console.log("selected", selected)
    // console.log("points2", points2)
    // calculate origin
    // const o: three.Vector3 = new three.Vector3();
    // o.x = (points2[0].x + points2[0].x + points2[0].x) / 3;
    // o.y = (points2[1].y + points2[1].y + points2[1].y) / 3;
    // o.z = (points2[2].z + points2[2].z + points2[2].z) / 3;
    const vx = _threex__WEBPACK_IMPORTED_MODULE_1__["subVectors"](three_points[1], three_points[0]).normalize();
    const v2 = _threex__WEBPACK_IMPORTED_MODULE_1__["subVectors"](three_points[2], three_points[1]).normalize();
    const vz = _threex__WEBPACK_IMPORTED_MODULE_1__["crossVectors"](vx, v2).normalize();
    const vy = _threex__WEBPACK_IMPORTED_MODULE_1__["crossVectors"](vz, vx).normalize();
    // console.log(vx, vy, vz)
    // create matrix
    const m2 = new three__WEBPACK_IMPORTED_MODULE_0__["Matrix4"]();
    m2.makeBasis(vx, vy, vz);
    m2.getInverse(m2);
    return m2;
}
/**
 * Triangulate a 4 sided shape
 * @param coords
 */
function triangulateQuad(coords) {
    // TODO this does not take into account degenerate cases
    // TODO two points in same location
    // TODO Three points that are colinear
    const area1 = Object(_geom_triangle__WEBPACK_IMPORTED_MODULE_3__["area"])(coords[0], coords[1], coords[2]) + Object(_geom_triangle__WEBPACK_IMPORTED_MODULE_3__["area"])(coords[2], coords[3], coords[0]);
    const area2 = Object(_geom_triangle__WEBPACK_IMPORTED_MODULE_3__["area"])(coords[0], coords[1], coords[3]) + Object(_geom_triangle__WEBPACK_IMPORTED_MODULE_3__["area"])(coords[1], coords[2], coords[3]);
    // const tri1a: Txyz[] = [coords[0], coords[1], coords[2]];
    // const tri1b: Txyz[] = [coords[2], coords[3], coords[0]];
    // const tri2a: Txyz[] = [coords[0], coords[1], coords[3]];
    // const tri2b: Txyz[] = [coords[1], coords[2], coords[3]];
    if (area1 < area2) {
        return [[0, 1, 2], [2, 3, 0]];
    }
    else {
        return [[0, 1, 3], [1, 2, 3]];
    }
}
/**
 * Triangulates a set of coords in 3d with holes
 * If the coords cannot be triangulated, it returns [].
 * @param coords
 */
function triangulate(coords, holes) {
    // check if we have holes
    const has_holes = (holes !== undefined && holes.length !== 0);
    // basic case, a triangle with no holes
    if (coords.length === 3 && !has_holes) {
        return [[0, 1, 2]];
    }
    // basic case, a quad with no holes
    if (coords.length === 4 && !has_holes) {
        return triangulateQuad(coords);
    }
    // get the matrix to transform from 2D to 3D
    const coords_v = coords.map(coord => new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](...coord));
    const matrix = _getMatrix(coords_v);
    // check for null, which means no plane could be found
    if (matrix === null) {
        return [];
    }
    // create an array to store all x y vertex coordinates
    const flat_vert_xys = [];
    // get the perimeter vertices and add them to the array
    const coords_v_2d = coords_v.map((coord_v) => _threex__WEBPACK_IMPORTED_MODULE_1__["multVectorMatrix"](coord_v, matrix));
    if (coords_v_2d === undefined || coords_v_2d === null || coords_v_2d.length === 0) {
        console.log('WARNING: triangulation failed.');
        return [];
    }
    coords_v_2d.forEach(coord_v_2d => flat_vert_xys.push(coord_v_2d.x, coord_v_2d.y));
    // hole vertices uing EARCUT
    // holes is an array of hole indices if any (e.g. [5, 8] for a 12-vertex input would mean
    // one hole with vertices 5–7 and another with 8–11).
    const hole_indices = [];
    let index_counter = coords_v.length;
    if (has_holes) {
        for (const hole of holes) {
            hole_indices.push(index_counter);
            if (hole.length) {
                const hole_coords_v = hole.map(hole_coord => new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](...hole_coord));
                const hole_coords_v_2d = hole_coords_v.map((hole_coord_v) => _threex__WEBPACK_IMPORTED_MODULE_1__["multVectorMatrix"](hole_coord_v, matrix));
                const one_hole = [];
                hole_coords_v_2d.forEach(hole_coord_v => flat_vert_xys.push(hole_coord_v.x, hole_coord_v.y));
                index_counter += hole.length;
            }
        }
    }
    // do the triangulation
    const flat_tris_i = _earcut__WEBPACK_IMPORTED_MODULE_2__["Earcut"].triangulate(flat_vert_xys, hole_indices);
    // convert the triangles into lists of three
    const tris_i = [];
    for (let i = 0; i < flat_tris_i.length; i += 3) {
        tris_i.push([flat_tris_i[i], flat_tris_i[i + 1], flat_tris_i[i + 2]]);
    }
    // return the list of triangles
    return tris_i;
}


/***/ }),

/***/ "./src/assets/libs/util/arrs.ts":
/*!**************************************!*\
  !*** ./src/assets/libs/util/arrs.ts ***!
  \**************************************/
/*! exports provided: arrRem, arrIdxAdd, arrIdxRem, arrMakeFlat, arrMaxDepth, arrFill, getArrDepth2, isEmptyArr2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "arrRem", function() { return arrRem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "arrIdxAdd", function() { return arrIdxAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "arrIdxRem", function() { return arrIdxRem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "arrMakeFlat", function() { return arrMakeFlat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "arrMaxDepth", function() { return arrMaxDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "arrFill", function() { return arrFill; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getArrDepth2", function() { return getArrDepth2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isEmptyArr2", function() { return isEmptyArr2; });
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};
/**
 * Remove an item from an array
 * @param arr
 * @param item
 */
function arrRem(arr, item) {
    const index = arr.indexOf(item);
    if (index === -1) {
        return;
    }
    arr.splice(index, 1);
}
/**
 * Add an item to an array in an array
 * @param arr
 * @param item
 */
function arrIdxAdd(arr, idx, item) {
    if (arr[idx] === undefined || arr[idx] === null) {
        arr[idx] = [];
    }
    arr[idx].push(item);
}
/**
 * Remove an item from an array in an array
 * @param arr
 * @param item
 */
function arrIdxRem(arr, idx, item, del_empty) {
    if (arr[idx] === undefined || arr[idx] === null) {
        return;
    }
    const rem_index = arr[idx].indexOf(item);
    if (rem_index === -1) {
        return;
    }
    arr[idx].splice(rem_index, 1);
    if (del_empty && arr[idx].length === 0) {
        delete arr[idx];
    }
}
/**
 * Make flat array (depth = 1) from anything.
 * ~
 * If it is not an array, then make it an array
 * ~
 * If it is an array, then make it flat
 * ~
 * @param data
 */
function arrMakeFlat(data) {
    if (!Array.isArray(data)) {
        return [data];
    }
    // const depth = arrMaxDepth(data);
    // // @ts-ignore
    // const new_array = data.flat(depth - 1);
    // return new_array;
    const flattend = [];
    function flat(data2) {
        data2.forEach(function (el) {
            if (Array.isArray(el)) {
                flat(el);
            }
            else {
                flattend.push(el);
            }
        });
    }
    flat(data);
    return flattend;
}
/**
 * Make an array of depth 2 from anything.
 * ~
 * If it is not an array, then make it an array
 * ~
 * If it is an array, then make it flat
 * ~
 * @param data
 */
// export function arrMake2Deep(data: any): any[] {
//     if (!Array.isArray(data)) {
//         return [[data]];
//     }
//     // return new_array;
//     const flattend = [];
//     function flat(data2: any) {
//         data2.forEach(function(el: any) {
//             if (!Array.isArray(el)) {
//                 flattend.push([el]);
//             } else if (!Array.isArray(el[0])) {
//                 flattend.push(el);
//             } else {
//                 flat(el);
//             }
//         });
//     }
//     flat(data);
//     return flattend;
// }
/**
 * Maximum depth of an array
 * @param data
 */
function arrMaxDepth(data) {
    let d1 = 0;
    if (Array.isArray(data)) {
        d1 = 1;
        let max = 0;
        for (const item of data) {
            if (Array.isArray(data)) {
                const d2 = arrMaxDepth(item);
                if (d2 > max) {
                    max = d2;
                }
            }
        }
        d1 += max;
    }
    return d1;
}
/**
 * Converts a value to an array of specified length.
 * ~
 * @param data
 */
function arrFill(data, length) {
    if (!Array.isArray(data)) {
        data = [data];
    }
    data = data;
    const last = data[data.length - 1];
    for (let i = data.length; i < length; i++) {
        data[i] = last;
    }
    if (data.length > length) {
        data = data.slice(0, length);
    }
    return data;
}
function getArrDepth2(arr) {
    if (Array.isArray(arr)) {
        return 1 + getArrDepth2(arr[0]);
    }
    return 0;
}
function isEmptyArr2(arr) {
    if (Array.isArray(arr) && !arr.length) {
        return true;
    }
    return false;
}


/***/ }),

/***/ "./src/assets/libs/util/maps.ts":
/*!**************************************!*\
  !*** ./src/assets/libs/util/maps.ts ***!
  \**************************************/
/*! exports provided: sortByKey */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sortByKey", function() { return sortByKey; });
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};
/**
 * Sort Map by Key, return a Sorted Map
 * @param unsortedMap
 */
function sortByKey(unsortedMap) {
    const keys = [];
    const sortedMap = new Map();
    unsortedMap.forEach((value, key) => {
        keys.push(key);
    });
    keys.sort((a, b) => {
        const x = Number(a.substr(2)), y = Number(b.substr(2));
        return ((x < y) ? -1 : ((x > y) ? 1 : 0));
    }).map(function (key) {
        sortedMap.set(key, unsortedMap.get(key));
    });
    return sortedMap;
}


/***/ }),

/***/ "./src/assets/libs/verb/verb.js":
/*!**************************************!*\
  !*** ./src/assets/libs/verb/verb.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Header for verb for JavaScript
// Borrowed from browserify, this header supports AMD (define) and common js (require) style modules

(function(f){
    if(true){
        module.exports=f()
    } else { var g; }
})(function(){
    var verb = {};

    var global = this;

    var isBrowser = new Function("try {return this===window;}catch(e){ return false;}");
	// var isNode=new Function("try {return this===global;}catch(e){return false;}");
	// var isWebworker=new Function("try {return typeof importScripts === 'function';}catch(e){return false;}");

    // // node.js context, but not WebWorker
    // if ( isNode() && !isWebworker() ){
    //     Worker = require('webworker-threads').Worker;
    // }

    // // WebWorker or node.js context
    // if ( isNode() || isWebworker() ){

    //     var window = global; // required for promhx

    //     // WebWorker
    //     if ( isWebworker() ){

    //         var lookup = function(className, methodName){

    //             var obj = global;

    //             className.split(".").forEach(function(x){
    //                 if (obj) obj = obj[ x ];
    //             });

    //             if (!obj) return null;

    //             return obj[ methodName ];
    //         }

    //         onmessage = function( e ){

    //             if (!e.data.className || !e.data.methodName) return;

    //             var method = lookup( e.data.className, e.data.methodName );

    //             if (!method){
    //                 return console.error("could not find " + e.data.className + "." + e.data.methodName)
    //             }

    //             postMessage( { result: method.apply( null, e.data.args ), id: e.data.id } );

    //         };
    //     }
    // }

(function (console, $hx_exports, $global) { "use strict";
$hx_exports.geom = $hx_exports.geom || {};
$hx_exports.exe = $hx_exports.exe || {};
$hx_exports.eval = $hx_exports.eval || {};
$hx_exports.core = $hx_exports.core || {};
$hx_exports.promhx = $hx_exports.promhx || {};
var $hxClasses = {},$estr = function() { return js_Boot.__string_rec(this,''); };
function $extend(from, fields) {
	function Inherit() {} Inherit.prototype = from; var proto = new Inherit();
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var HxOverrides = function() { };
$hxClasses["HxOverrides"] = HxOverrides;
HxOverrides.__name__ = ["HxOverrides"];
HxOverrides.strDate = function(s) {
	var _g = s.length;
	switch(_g) {
	case 8:
		var k = s.split(":");
		var d = new Date();
		d.setTime(0);
		d.setUTCHours(k[0]);
		d.setUTCMinutes(k[1]);
		d.setUTCSeconds(k[2]);
		return d;
	case 10:
		var k1 = s.split("-");
		return new Date(k1[0],k1[1] - 1,k1[2],0,0,0);
	case 19:
		var k2 = s.split(" ");
		var y = k2[0].split("-");
		var t = k2[1].split(":");
		return new Date(y[0],y[1] - 1,y[2],t[0],t[1],t[2]);
	default:
		throw new js__$Boot_HaxeError("Invalid date format : " + s);
	}
};
HxOverrides.cca = function(s,index) {
	var x = s.charCodeAt(index);
	if(x != x) return undefined;
	return x;
};
HxOverrides.substr = function(s,pos,len) {
	if(pos != null && pos != 0 && len != null && len < 0) return "";
	if(len == null) len = s.length;
	if(pos < 0) {
		pos = s.length + pos;
		if(pos < 0) pos = 0;
	} else if(len < 0) len = s.length + len - pos;
	return s.substr(pos,len);
};
HxOverrides.iter = function(a) {
	return { cur : 0, arr : a, hasNext : function() {
		return this.cur < this.arr.length;
	}, next : function() {
		return this.arr[this.cur++];
	}};
};
var Lambda = function() { };
$hxClasses["Lambda"] = Lambda;
Lambda.__name__ = ["Lambda"];
Lambda.fold = function(it,f,first) {
	var $it0 = $iterator(it)();
	while( $it0.hasNext() ) {
		var x = $it0.next();
		first = f(x,first);
	}
	return first;
};
var List = function() {
	this.length = 0;
};
$hxClasses["List"] = List;
List.__name__ = ["List"];
List.prototype = {
	add: function(item) {
		var x = [item];
		if(this.h == null) this.h = x; else this.q[1] = x;
		this.q = x;
		this.length++;
	}
	,pop: function() {
		if(this.h == null) return null;
		var x = this.h[0];
		this.h = this.h[1];
		if(this.h == null) this.q = null;
		this.length--;
		return x;
	}
	,isEmpty: function() {
		return this.h == null;
	}
	,__class__: List
};
Math.__name__ = ["Math"];
var Reflect = function() { };
$hxClasses["Reflect"] = Reflect;
Reflect.__name__ = ["Reflect"];
Reflect.field = function(o,field) {
	try {
		return o[field];
	} catch( e ) {
		if (e instanceof js__$Boot_HaxeError) e = e.val;
		return null;
	}
};
Reflect.callMethod = function(o,func,args) {
	return func.apply(o,args);
};
Reflect.fields = function(o) {
	var a = [];
	if(o != null) {
		var hasOwnProperty = Object.prototype.hasOwnProperty;
		for( var f in o ) {
		if(f != "__id__" && f != "hx__closures__" && hasOwnProperty.call(o,f)) a.push(f);
		}
	}
	return a;
};
Reflect.isFunction = function(f) {
	return typeof(f) == "function" && !(f.__name__ || f.__ename__);
};
Reflect.deleteField = function(o,field) {
	if(!Object.prototype.hasOwnProperty.call(o,field)) return false;
	delete(o[field]);
	return true;
};
var Std = function() { };
$hxClasses["Std"] = Std;
Std.__name__ = ["Std"];
Std.string = function(s) {
	return js_Boot.__string_rec(s,"");
};
Std.parseFloat = function(x) {
	return parseFloat(x);
};
var StringBuf = function() {
	this.b = "";
};
$hxClasses["StringBuf"] = StringBuf;
StringBuf.__name__ = ["StringBuf"];
StringBuf.prototype = {
	add: function(x) {
		this.b += Std.string(x);
	}
	,__class__: StringBuf
};
var StringTools = function() { };
$hxClasses["StringTools"] = StringTools;
StringTools.__name__ = ["StringTools"];
StringTools.fastCodeAt = function(s,index) {
	return s.charCodeAt(index);
};
var ValueType = $hxClasses["ValueType"] = { __ename__ : ["ValueType"], __constructs__ : ["TNull","TInt","TFloat","TBool","TObject","TFunction","TClass","TEnum","TUnknown"] };
ValueType.TNull = ["TNull",0];
ValueType.TNull.toString = $estr;
ValueType.TNull.__enum__ = ValueType;
ValueType.TInt = ["TInt",1];
ValueType.TInt.toString = $estr;
ValueType.TInt.__enum__ = ValueType;
ValueType.TFloat = ["TFloat",2];
ValueType.TFloat.toString = $estr;
ValueType.TFloat.__enum__ = ValueType;
ValueType.TBool = ["TBool",3];
ValueType.TBool.toString = $estr;
ValueType.TBool.__enum__ = ValueType;
ValueType.TObject = ["TObject",4];
ValueType.TObject.toString = $estr;
ValueType.TObject.__enum__ = ValueType;
ValueType.TFunction = ["TFunction",5];
ValueType.TFunction.toString = $estr;
ValueType.TFunction.__enum__ = ValueType;
ValueType.TClass = function(c) { var $x = ["TClass",6,c]; $x.__enum__ = ValueType; $x.toString = $estr; return $x; };
ValueType.TEnum = function(e) { var $x = ["TEnum",7,e]; $x.__enum__ = ValueType; $x.toString = $estr; return $x; };
ValueType.TUnknown = ["TUnknown",8];
ValueType.TUnknown.toString = $estr;
ValueType.TUnknown.__enum__ = ValueType;
var Type = function() { };
$hxClasses["Type"] = Type;
Type.__name__ = ["Type"];
Type.getClassName = function(c) {
	var a = c.__name__;
	if(a == null) return null;
	return a.join(".");
};
Type.getEnumName = function(e) {
	var a = e.__ename__;
	return a.join(".");
};
Type.resolveClass = function(name) {
	var cl = $hxClasses[name];
	if(cl == null || !cl.__name__) return null;
	return cl;
};
Type.resolveEnum = function(name) {
	var e = $hxClasses[name];
	if(e == null || !e.__ename__) return null;
	return e;
};
Type.createEmptyInstance = function(cl) {
	function empty() {}; empty.prototype = cl.prototype;
	return new empty();
};
Type.createEnum = function(e,constr,params) {
	var f = Reflect.field(e,constr);
	if(f == null) throw new js__$Boot_HaxeError("No such constructor " + constr);
	if(Reflect.isFunction(f)) {
		if(params == null) throw new js__$Boot_HaxeError("Constructor " + constr + " need parameters");
		return Reflect.callMethod(e,f,params);
	}
	if(params != null && params.length != 0) throw new js__$Boot_HaxeError("Constructor " + constr + " does not need parameters");
	return f;
};
Type.getEnumConstructs = function(e) {
	var a = e.__constructs__;
	return a.slice();
};
Type["typeof"] = function(v) {
	var _g = typeof(v);
	switch(_g) {
	case "boolean":
		return ValueType.TBool;
	case "string":
		return ValueType.TClass(String);
	case "number":
		if(Math.ceil(v) == v % 2147483648.0) return ValueType.TInt;
		return ValueType.TFloat;
	case "object":
		if(v == null) return ValueType.TNull;
		var e = v.__enum__;
		if(e != null) return ValueType.TEnum(e);
		var c = js_Boot.getClass(v);
		if(c != null) return ValueType.TClass(c);
		return ValueType.TObject;
	case "function":
		if(v.__name__ || v.__ename__) return ValueType.TObject;
		return ValueType.TFunction;
	case "undefined":
		return ValueType.TNull;
	default:
		return ValueType.TUnknown;
	}
};
var haxe_IMap = function() { };
$hxClasses["haxe.IMap"] = haxe_IMap;
haxe_IMap.__name__ = ["haxe","IMap"];
var haxe__$Int64__$_$_$Int64 = function(high,low) {
	this.high = high;
	this.low = low;
};
$hxClasses["haxe._Int64.___Int64"] = haxe__$Int64__$_$_$Int64;
haxe__$Int64__$_$_$Int64.__name__ = ["haxe","_Int64","___Int64"];
haxe__$Int64__$_$_$Int64.prototype = {
	__class__: haxe__$Int64__$_$_$Int64
};
var haxe_Serializer = function() {
	this.buf = new StringBuf();
	this.cache = [];
	this.useCache = haxe_Serializer.USE_CACHE;
	this.useEnumIndex = haxe_Serializer.USE_ENUM_INDEX;
	this.shash = new haxe_ds_StringMap();
	this.scount = 0;
};
$hxClasses["haxe.Serializer"] = haxe_Serializer;
haxe_Serializer.__name__ = ["haxe","Serializer"];
haxe_Serializer.prototype = {
	toString: function() {
		return this.buf.b;
	}
	,serializeString: function(s) {
		var x = this.shash.get(s);
		if(x != null) {
			this.buf.b += "R";
			if(x == null) this.buf.b += "null"; else this.buf.b += "" + x;
			return;
		}
		this.shash.set(s,this.scount++);
		this.buf.b += "y";
		s = encodeURIComponent(s);
		if(s.length == null) this.buf.b += "null"; else this.buf.b += "" + s.length;
		this.buf.b += ":";
		if(s == null) this.buf.b += "null"; else this.buf.b += "" + s;
	}
	,serializeRef: function(v) {
		var vt = typeof(v);
		var _g1 = 0;
		var _g = this.cache.length;
		while(_g1 < _g) {
			var i = _g1++;
			var ci = this.cache[i];
			if(typeof(ci) == vt && ci == v) {
				this.buf.b += "r";
				if(i == null) this.buf.b += "null"; else this.buf.b += "" + i;
				return true;
			}
		}
		this.cache.push(v);
		return false;
	}
	,serializeFields: function(v) {
		var _g = 0;
		var _g1 = Reflect.fields(v);
		while(_g < _g1.length) {
			var f = _g1[_g];
			++_g;
			this.serializeString(f);
			this.serialize(Reflect.field(v,f));
		}
		this.buf.b += "g";
	}
	,serialize: function(v) {
		{
			var _g = Type["typeof"](v);
			switch(_g[1]) {
			case 0:
				this.buf.b += "n";
				break;
			case 1:
				var v1 = v;
				if(v1 == 0) {
					this.buf.b += "z";
					return;
				}
				this.buf.b += "i";
				if(v1 == null) this.buf.b += "null"; else this.buf.b += "" + v1;
				break;
			case 2:
				var v2 = v;
				if(isNaN(v2)) this.buf.b += "k"; else if(!isFinite(v2)) if(v2 < 0) this.buf.b += "m"; else this.buf.b += "p"; else {
					this.buf.b += "d";
					if(v2 == null) this.buf.b += "null"; else this.buf.b += "" + v2;
				}
				break;
			case 3:
				if(v) this.buf.b += "t"; else this.buf.b += "f";
				break;
			case 6:
				var c = _g[2];
				if(c == String) {
					this.serializeString(v);
					return;
				}
				if(this.useCache && this.serializeRef(v)) return;
				switch(c) {
				case Array:
					var ucount = 0;
					this.buf.b += "a";
					var l = v.length;
					var _g1 = 0;
					while(_g1 < l) {
						var i = _g1++;
						if(v[i] == null) ucount++; else {
							if(ucount > 0) {
								if(ucount == 1) this.buf.b += "n"; else {
									this.buf.b += "u";
									if(ucount == null) this.buf.b += "null"; else this.buf.b += "" + ucount;
								}
								ucount = 0;
							}
							this.serialize(v[i]);
						}
					}
					if(ucount > 0) {
						if(ucount == 1) this.buf.b += "n"; else {
							this.buf.b += "u";
							if(ucount == null) this.buf.b += "null"; else this.buf.b += "" + ucount;
						}
					}
					this.buf.b += "h";
					break;
				case List:
					this.buf.b += "l";
					var v3 = v;
					var _g1_head = v3.h;
					var _g1_val = null;
					while(_g1_head != null) {
						var i1;
						_g1_val = _g1_head[0];
						_g1_head = _g1_head[1];
						i1 = _g1_val;
						this.serialize(i1);
					}
					this.buf.b += "h";
					break;
				case Date:
					var d = v;
					this.buf.b += "v";
					this.buf.add(d.getTime());
					break;
				case haxe_ds_StringMap:
					this.buf.b += "b";
					var v4 = v;
					var $it0 = v4.keys();
					while( $it0.hasNext() ) {
						var k = $it0.next();
						this.serializeString(k);
						this.serialize(__map_reserved[k] != null?v4.getReserved(k):v4.h[k]);
					}
					this.buf.b += "h";
					break;
				case haxe_ds_IntMap:
					this.buf.b += "q";
					var v5 = v;
					var $it1 = v5.keys();
					while( $it1.hasNext() ) {
						var k1 = $it1.next();
						this.buf.b += ":";
						if(k1 == null) this.buf.b += "null"; else this.buf.b += "" + k1;
						this.serialize(v5.h[k1]);
					}
					this.buf.b += "h";
					break;
				case haxe_ds_ObjectMap:
					this.buf.b += "M";
					var v6 = v;
					var $it2 = v6.keys();
					while( $it2.hasNext() ) {
						var k2 = $it2.next();
						var id = Reflect.field(k2,"__id__");
						Reflect.deleteField(k2,"__id__");
						this.serialize(k2);
						k2.__id__ = id;
						this.serialize(v6.h[k2.__id__]);
					}
					this.buf.b += "h";
					break;
				case haxe_io_Bytes:
					var v7 = v;
					var i2 = 0;
					var max = v7.length - 2;
					var charsBuf = new StringBuf();
					var b64 = haxe_Serializer.BASE64;
					while(i2 < max) {
						var b1 = v7.get(i2++);
						var b2 = v7.get(i2++);
						var b3 = v7.get(i2++);
						charsBuf.add(b64.charAt(b1 >> 2));
						charsBuf.add(b64.charAt((b1 << 4 | b2 >> 4) & 63));
						charsBuf.add(b64.charAt((b2 << 2 | b3 >> 6) & 63));
						charsBuf.add(b64.charAt(b3 & 63));
					}
					if(i2 == max) {
						var b11 = v7.get(i2++);
						var b21 = v7.get(i2++);
						charsBuf.add(b64.charAt(b11 >> 2));
						charsBuf.add(b64.charAt((b11 << 4 | b21 >> 4) & 63));
						charsBuf.add(b64.charAt(b21 << 2 & 63));
					} else if(i2 == max + 1) {
						var b12 = v7.get(i2++);
						charsBuf.add(b64.charAt(b12 >> 2));
						charsBuf.add(b64.charAt(b12 << 4 & 63));
					}
					var chars = charsBuf.b;
					this.buf.b += "s";
					if(chars.length == null) this.buf.b += "null"; else this.buf.b += "" + chars.length;
					this.buf.b += ":";
					if(chars == null) this.buf.b += "null"; else this.buf.b += "" + chars;
					break;
				default:
					if(this.useCache) this.cache.pop();
					if(v.hxSerialize != null) {
						this.buf.b += "C";
						this.serializeString(Type.getClassName(c));
						if(this.useCache) this.cache.push(v);
						v.hxSerialize(this);
						this.buf.b += "g";
					} else {
						this.buf.b += "c";
						this.serializeString(Type.getClassName(c));
						if(this.useCache) this.cache.push(v);
						this.serializeFields(v);
					}
				}
				break;
			case 4:
				if(js_Boot.__instanceof(v,Class)) {
					var className = Type.getClassName(v);
					this.buf.b += "A";
					this.serializeString(className);
				} else if(js_Boot.__instanceof(v,Enum)) {
					this.buf.b += "B";
					this.serializeString(Type.getEnumName(v));
				} else {
					if(this.useCache && this.serializeRef(v)) return;
					this.buf.b += "o";
					this.serializeFields(v);
				}
				break;
			case 7:
				var e = _g[2];
				if(this.useCache) {
					if(this.serializeRef(v)) return;
					this.cache.pop();
				}
				if(this.useEnumIndex) this.buf.b += "j"; else this.buf.b += "w";
				this.serializeString(Type.getEnumName(e));
				if(this.useEnumIndex) {
					this.buf.b += ":";
					this.buf.b += Std.string(v[1]);
				} else this.serializeString(v[0]);
				this.buf.b += ":";
				var l1 = v.length;
				this.buf.b += Std.string(l1 - 2);
				var _g11 = 2;
				while(_g11 < l1) {
					var i3 = _g11++;
					this.serialize(v[i3]);
				}
				if(this.useCache) this.cache.push(v);
				break;
			case 5:
				throw new js__$Boot_HaxeError("Cannot serialize function");
				break;
			default:
				throw new js__$Boot_HaxeError("Cannot serialize " + Std.string(v));
			}
		}
	}
	,__class__: haxe_Serializer
};
var haxe_Unserializer = function(buf) {
	this.buf = buf;
	this.length = buf.length;
	this.pos = 0;
	this.scache = [];
	this.cache = [];
	var r = haxe_Unserializer.DEFAULT_RESOLVER;
	if(r == null) {
		r = Type;
		haxe_Unserializer.DEFAULT_RESOLVER = r;
	}
	this.setResolver(r);
};
$hxClasses["haxe.Unserializer"] = haxe_Unserializer;
haxe_Unserializer.__name__ = ["haxe","Unserializer"];
haxe_Unserializer.initCodes = function() {
	var codes = [];
	var _g1 = 0;
	var _g = haxe_Unserializer.BASE64.length;
	while(_g1 < _g) {
		var i = _g1++;
		codes[haxe_Unserializer.BASE64.charCodeAt(i)] = i;
	}
	return codes;
};
haxe_Unserializer.prototype = {
	setResolver: function(r) {
		if(r == null) this.resolver = { resolveClass : function(_) {
			return null;
		}, resolveEnum : function(_1) {
			return null;
		}}; else this.resolver = r;
	}
	,get: function(p) {
		return this.buf.charCodeAt(p);
	}
	,readDigits: function() {
		var k = 0;
		var s = false;
		var fpos = this.pos;
		while(true) {
			var c = this.buf.charCodeAt(this.pos);
			if(c != c) break;
			if(c == 45) {
				if(this.pos != fpos) break;
				s = true;
				this.pos++;
				continue;
			}
			if(c < 48 || c > 57) break;
			k = k * 10 + (c - 48);
			this.pos++;
		}
		if(s) k *= -1;
		return k;
	}
	,readFloat: function() {
		var p1 = this.pos;
		while(true) {
			var c = this.buf.charCodeAt(this.pos);
			if(c >= 43 && c < 58 || c == 101 || c == 69) this.pos++; else break;
		}
		return Std.parseFloat(HxOverrides.substr(this.buf,p1,this.pos - p1));
	}
	,unserializeObject: function(o) {
		while(true) {
			if(this.pos >= this.length) throw new js__$Boot_HaxeError("Invalid object");
			if(this.buf.charCodeAt(this.pos) == 103) break;
			var k = this.unserialize();
			if(!(typeof(k) == "string")) throw new js__$Boot_HaxeError("Invalid object key");
			var v = this.unserialize();
			o[k] = v;
		}
		this.pos++;
	}
	,unserializeEnum: function(edecl,tag) {
		if(this.get(this.pos++) != 58) throw new js__$Boot_HaxeError("Invalid enum format");
		var nargs = this.readDigits();
		if(nargs == 0) return Type.createEnum(edecl,tag);
		var args = [];
		while(nargs-- > 0) args.push(this.unserialize());
		return Type.createEnum(edecl,tag,args);
	}
	,unserialize: function() {
		var _g = this.get(this.pos++);
		switch(_g) {
		case 110:
			return null;
		case 116:
			return true;
		case 102:
			return false;
		case 122:
			return 0;
		case 105:
			return this.readDigits();
		case 100:
			return this.readFloat();
		case 121:
			var len = this.readDigits();
			if(this.get(this.pos++) != 58 || this.length - this.pos < len) throw new js__$Boot_HaxeError("Invalid string length");
			var s = HxOverrides.substr(this.buf,this.pos,len);
			this.pos += len;
			s = decodeURIComponent(s.split("+").join(" "));
			this.scache.push(s);
			return s;
		case 107:
			return NaN;
		case 109:
			return -Infinity;
		case 112:
			return Infinity;
		case 97:
			var buf = this.buf;
			var a = [];
			this.cache.push(a);
			while(true) {
				var c = this.buf.charCodeAt(this.pos);
				if(c == 104) {
					this.pos++;
					break;
				}
				if(c == 117) {
					this.pos++;
					var n = this.readDigits();
					a[a.length + n - 1] = null;
				} else a.push(this.unserialize());
			}
			return a;
		case 111:
			var o = { };
			this.cache.push(o);
			this.unserializeObject(o);
			return o;
		case 114:
			var n1 = this.readDigits();
			if(n1 < 0 || n1 >= this.cache.length) throw new js__$Boot_HaxeError("Invalid reference");
			return this.cache[n1];
		case 82:
			var n2 = this.readDigits();
			if(n2 < 0 || n2 >= this.scache.length) throw new js__$Boot_HaxeError("Invalid string reference");
			return this.scache[n2];
		case 120:
			throw new js__$Boot_HaxeError(this.unserialize());
			break;
		case 99:
			var name = this.unserialize();
			var cl = this.resolver.resolveClass(name);
			if(cl == null) throw new js__$Boot_HaxeError("Class not found " + name);
			var o1 = Type.createEmptyInstance(cl);
			this.cache.push(o1);
			this.unserializeObject(o1);
			return o1;
		case 119:
			var name1 = this.unserialize();
			var edecl = this.resolver.resolveEnum(name1);
			if(edecl == null) throw new js__$Boot_HaxeError("Enum not found " + name1);
			var e = this.unserializeEnum(edecl,this.unserialize());
			this.cache.push(e);
			return e;
		case 106:
			var name2 = this.unserialize();
			var edecl1 = this.resolver.resolveEnum(name2);
			if(edecl1 == null) throw new js__$Boot_HaxeError("Enum not found " + name2);
			this.pos++;
			var index = this.readDigits();
			var tag = Type.getEnumConstructs(edecl1)[index];
			if(tag == null) throw new js__$Boot_HaxeError("Unknown enum index " + name2 + "@" + index);
			var e1 = this.unserializeEnum(edecl1,tag);
			this.cache.push(e1);
			return e1;
		case 108:
			var l = new List();
			this.cache.push(l);
			var buf1 = this.buf;
			while(this.buf.charCodeAt(this.pos) != 104) l.add(this.unserialize());
			this.pos++;
			return l;
		case 98:
			var h = new haxe_ds_StringMap();
			this.cache.push(h);
			var buf2 = this.buf;
			while(this.buf.charCodeAt(this.pos) != 104) {
				var s1 = this.unserialize();
				h.set(s1,this.unserialize());
			}
			this.pos++;
			return h;
		case 113:
			var h1 = new haxe_ds_IntMap();
			this.cache.push(h1);
			var buf3 = this.buf;
			var c1 = this.get(this.pos++);
			while(c1 == 58) {
				var i = this.readDigits();
				h1.set(i,this.unserialize());
				c1 = this.get(this.pos++);
			}
			if(c1 != 104) throw new js__$Boot_HaxeError("Invalid IntMap format");
			return h1;
		case 77:
			var h2 = new haxe_ds_ObjectMap();
			this.cache.push(h2);
			var buf4 = this.buf;
			while(this.buf.charCodeAt(this.pos) != 104) {
				var s2 = this.unserialize();
				h2.set(s2,this.unserialize());
			}
			this.pos++;
			return h2;
		case 118:
			var d;
			if(this.buf.charCodeAt(this.pos) >= 48 && this.buf.charCodeAt(this.pos) <= 57 && this.buf.charCodeAt(this.pos + 1) >= 48 && this.buf.charCodeAt(this.pos + 1) <= 57 && this.buf.charCodeAt(this.pos + 2) >= 48 && this.buf.charCodeAt(this.pos + 2) <= 57 && this.buf.charCodeAt(this.pos + 3) >= 48 && this.buf.charCodeAt(this.pos + 3) <= 57 && this.buf.charCodeAt(this.pos + 4) == 45) {
				var s3 = HxOverrides.substr(this.buf,this.pos,19);
				d = HxOverrides.strDate(s3);
				this.pos += 19;
			} else {
				var t = this.readFloat();
				var d1 = new Date();
				d1.setTime(t);
				d = d1;
			}
			this.cache.push(d);
			return d;
		case 115:
			var len1 = this.readDigits();
			var buf5 = this.buf;
			if(this.get(this.pos++) != 58 || this.length - this.pos < len1) throw new js__$Boot_HaxeError("Invalid bytes length");
			var codes = haxe_Unserializer.CODES;
			if(codes == null) {
				codes = haxe_Unserializer.initCodes();
				haxe_Unserializer.CODES = codes;
			}
			var i1 = this.pos;
			var rest = len1 & 3;
			var size;
			size = (len1 >> 2) * 3 + (rest >= 2?rest - 1:0);
			var max = i1 + (len1 - rest);
			var bytes = haxe_io_Bytes.alloc(size);
			var bpos = 0;
			while(i1 < max) {
				var c11 = codes[StringTools.fastCodeAt(buf5,i1++)];
				var c2 = codes[StringTools.fastCodeAt(buf5,i1++)];
				bytes.set(bpos++,c11 << 2 | c2 >> 4);
				var c3 = codes[StringTools.fastCodeAt(buf5,i1++)];
				bytes.set(bpos++,c2 << 4 | c3 >> 2);
				var c4 = codes[StringTools.fastCodeAt(buf5,i1++)];
				bytes.set(bpos++,c3 << 6 | c4);
			}
			if(rest >= 2) {
				var c12 = codes[StringTools.fastCodeAt(buf5,i1++)];
				var c21 = codes[StringTools.fastCodeAt(buf5,i1++)];
				bytes.set(bpos++,c12 << 2 | c21 >> 4);
				if(rest == 3) {
					var c31 = codes[StringTools.fastCodeAt(buf5,i1++)];
					bytes.set(bpos++,c21 << 4 | c31 >> 2);
				}
			}
			this.pos += len1;
			this.cache.push(bytes);
			return bytes;
		case 67:
			var name3 = this.unserialize();
			var cl1 = this.resolver.resolveClass(name3);
			if(cl1 == null) throw new js__$Boot_HaxeError("Class not found " + name3);
			var o2 = Type.createEmptyInstance(cl1);
			this.cache.push(o2);
			o2.hxUnserialize(this);
			if(this.get(this.pos++) != 103) throw new js__$Boot_HaxeError("Invalid custom data");
			return o2;
		case 65:
			var name4 = this.unserialize();
			var cl2 = this.resolver.resolveClass(name4);
			if(cl2 == null) throw new js__$Boot_HaxeError("Class not found " + name4);
			return cl2;
		case 66:
			var name5 = this.unserialize();
			var e2 = this.resolver.resolveEnum(name5);
			if(e2 == null) throw new js__$Boot_HaxeError("Enum not found " + name5);
			return e2;
		default:
		}
		this.pos--;
		throw new js__$Boot_HaxeError("Invalid char " + this.buf.charAt(this.pos) + " at position " + this.pos);
	}
	,__class__: haxe_Unserializer
};
var haxe_ds_IntMap = function() {
	this.h = { };
};
$hxClasses["haxe.ds.IntMap"] = haxe_ds_IntMap;
haxe_ds_IntMap.__name__ = ["haxe","ds","IntMap"];
haxe_ds_IntMap.__interfaces__ = [haxe_IMap];
haxe_ds_IntMap.prototype = {
	set: function(key,value) {
		this.h[key] = value;
	}
	,remove: function(key) {
		if(!this.h.hasOwnProperty(key)) return false;
		delete(this.h[key]);
		return true;
	}
	,keys: function() {
		var a = [];
		for( var key in this.h ) {
		if(this.h.hasOwnProperty(key)) a.push(key | 0);
		}
		return HxOverrides.iter(a);
	}
	,__class__: haxe_ds_IntMap
};
var haxe_ds_ObjectMap = function() {
	this.h = { };
	this.h.__keys__ = { };
};
$hxClasses["haxe.ds.ObjectMap"] = haxe_ds_ObjectMap;
haxe_ds_ObjectMap.__name__ = ["haxe","ds","ObjectMap"];
haxe_ds_ObjectMap.__interfaces__ = [haxe_IMap];
haxe_ds_ObjectMap.prototype = {
	set: function(key,value) {
		var id = key.__id__ || (key.__id__ = ++haxe_ds_ObjectMap.count);
		this.h[id] = value;
		this.h.__keys__[id] = key;
	}
	,keys: function() {
		var a = [];
		for( var key in this.h.__keys__ ) {
		if(this.h.hasOwnProperty(key)) a.push(this.h.__keys__[key]);
		}
		return HxOverrides.iter(a);
	}
	,__class__: haxe_ds_ObjectMap
};
var haxe_ds_Option = $hxClasses["haxe.ds.Option"] = { __ename__ : ["haxe","ds","Option"], __constructs__ : ["Some","None"] };
haxe_ds_Option.Some = function(v) { var $x = ["Some",0,v]; $x.__enum__ = haxe_ds_Option; $x.toString = $estr; return $x; };
haxe_ds_Option.None = ["None",1];
haxe_ds_Option.None.toString = $estr;
haxe_ds_Option.None.__enum__ = haxe_ds_Option;
var haxe_ds_StringMap = function() {
	this.h = { };
};
$hxClasses["haxe.ds.StringMap"] = haxe_ds_StringMap;
haxe_ds_StringMap.__name__ = ["haxe","ds","StringMap"];
haxe_ds_StringMap.__interfaces__ = [haxe_IMap];
haxe_ds_StringMap.prototype = {
	set: function(key,value) {
		if(__map_reserved[key] != null) this.setReserved(key,value); else this.h[key] = value;
	}
	,get: function(key) {
		if(__map_reserved[key] != null) return this.getReserved(key);
		return this.h[key];
	}
	,setReserved: function(key,value) {
		if(this.rh == null) this.rh = { };
		this.rh["$" + key] = value;
	}
	,getReserved: function(key) {
		if(this.rh == null) return null; else return this.rh["$" + key];
	}
	,keys: function() {
		var _this = this.arrayKeys();
		return HxOverrides.iter(_this);
	}
	,arrayKeys: function() {
		var out = [];
		for( var key in this.h ) {
		if(this.h.hasOwnProperty(key)) out.push(key);
		}
		if(this.rh != null) {
			for( var key in this.rh ) {
			if(key.charCodeAt(0) == 36) out.push(key.substr(1));
			}
		}
		return out;
	}
	,__class__: haxe_ds_StringMap
};
var haxe_io_Bytes = function(data) {
	this.length = data.byteLength;
	this.b = new Uint8Array(data);
	this.b.bufferValue = data;
	data.hxBytes = this;
	data.bytes = this.b;
};
$hxClasses["haxe.io.Bytes"] = haxe_io_Bytes;
haxe_io_Bytes.__name__ = ["haxe","io","Bytes"];
haxe_io_Bytes.alloc = function(length) {
	return new haxe_io_Bytes(new ArrayBuffer(length));
};
haxe_io_Bytes.prototype = {
	get: function(pos) {
		return this.b[pos];
	}
	,set: function(pos,v) {
		this.b[pos] = v & 255;
	}
	,__class__: haxe_io_Bytes
};
var haxe_io_Error = $hxClasses["haxe.io.Error"] = { __ename__ : ["haxe","io","Error"], __constructs__ : ["Blocked","Overflow","OutsideBounds","Custom"] };
haxe_io_Error.Blocked = ["Blocked",0];
haxe_io_Error.Blocked.toString = $estr;
haxe_io_Error.Blocked.__enum__ = haxe_io_Error;
haxe_io_Error.Overflow = ["Overflow",1];
haxe_io_Error.Overflow.toString = $estr;
haxe_io_Error.Overflow.__enum__ = haxe_io_Error;
haxe_io_Error.OutsideBounds = ["OutsideBounds",2];
haxe_io_Error.OutsideBounds.toString = $estr;
haxe_io_Error.OutsideBounds.__enum__ = haxe_io_Error;
haxe_io_Error.Custom = function(e) { var $x = ["Custom",3,e]; $x.__enum__ = haxe_io_Error; $x.toString = $estr; return $x; };
var haxe_io_FPHelper = function() { };
$hxClasses["haxe.io.FPHelper"] = haxe_io_FPHelper;
haxe_io_FPHelper.__name__ = ["haxe","io","FPHelper"];
haxe_io_FPHelper.i32ToFloat = function(i) {
	var sign = 1 - (i >>> 31 << 1);
	var exp = i >>> 23 & 255;
	var sig = i & 8388607;
	if(sig == 0 && exp == 0) return 0.0;
	return sign * (1 + Math.pow(2,-23) * sig) * Math.pow(2,exp - 127);
};
haxe_io_FPHelper.floatToI32 = function(f) {
	if(f == 0) return 0;
	var af;
	if(f < 0) af = -f; else af = f;
	var exp = Math.floor(Math.log(af) / 0.6931471805599453);
	if(exp < -127) exp = -127; else if(exp > 128) exp = 128;
	var sig = Math.round((af / Math.pow(2,exp) - 1) * 8388608) & 8388607;
	return (f < 0?-2147483648:0) | exp + 127 << 23 | sig;
};
haxe_io_FPHelper.i64ToDouble = function(low,high) {
	var sign = 1 - (high >>> 31 << 1);
	var exp = (high >> 20 & 2047) - 1023;
	var sig = (high & 1048575) * 4294967296. + (low >>> 31) * 2147483648. + (low & 2147483647);
	if(sig == 0 && exp == -1023) return 0.0;
	return sign * (1.0 + Math.pow(2,-52) * sig) * Math.pow(2,exp);
};
haxe_io_FPHelper.doubleToI64 = function(v) {
	var i64 = haxe_io_FPHelper.i64tmp;
	if(v == 0) {
		i64.low = 0;
		i64.high = 0;
	} else {
		var av;
		if(v < 0) av = -v; else av = v;
		var exp = Math.floor(Math.log(av) / 0.6931471805599453);
		var sig;
		var v1 = (av / Math.pow(2,exp) - 1) * 4503599627370496.;
		sig = Math.round(v1);
		var sig_l = sig | 0;
		var sig_h = sig / 4294967296.0 | 0;
		i64.low = sig_l;
		i64.high = (v < 0?-2147483648:0) | exp + 1023 << 20 | sig_h;
	}
	return i64;
};
var js__$Boot_HaxeError = function(val) {
	Error.call(this);
	this.val = val;
	this.message = String(val);
	if(Error.captureStackTrace) Error.captureStackTrace(this,js__$Boot_HaxeError);
};
$hxClasses["js._Boot.HaxeError"] = js__$Boot_HaxeError;
js__$Boot_HaxeError.__name__ = ["js","_Boot","HaxeError"];
js__$Boot_HaxeError.__super__ = Error;
js__$Boot_HaxeError.prototype = $extend(Error.prototype,{
	__class__: js__$Boot_HaxeError
});
var js_Boot = function() { };
$hxClasses["js.Boot"] = js_Boot;
js_Boot.__name__ = ["js","Boot"];
js_Boot.getClass = function(o) {
	if((o instanceof Array) && o.__enum__ == null) return Array; else {
		var cl = o.__class__;
		if(cl != null) return cl;
		var name = js_Boot.__nativeClassName(o);
		if(name != null) return js_Boot.__resolveNativeClass(name);
		return null;
	}
};
js_Boot.__string_rec = function(o,s) {
	if(o == null) return "null";
	if(s.length >= 5) return "<...>";
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) t = "object";
	switch(t) {
	case "object":
		if(o instanceof Array) {
			if(o.__enum__) {
				if(o.length == 2) return o[0];
				var str2 = o[0] + "(";
				s += "\t";
				var _g1 = 2;
				var _g = o.length;
				while(_g1 < _g) {
					var i1 = _g1++;
					if(i1 != 2) str2 += "," + js_Boot.__string_rec(o[i1],s); else str2 += js_Boot.__string_rec(o[i1],s);
				}
				return str2 + ")";
			}
			var l = o.length;
			var i;
			var str1 = "[";
			s += "\t";
			var _g2 = 0;
			while(_g2 < l) {
				var i2 = _g2++;
				str1 += (i2 > 0?",":"") + js_Boot.__string_rec(o[i2],s);
			}
			str1 += "]";
			return str1;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( e ) {
			if (e instanceof js__$Boot_HaxeError) e = e.val;
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") return s2;
		}
		var k = null;
		var str = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		for( var k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str.length != 2) str += ", \n";
		str += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str += "\n" + s + "}";
		return str;
	case "function":
		return "<function>";
	case "string":
		return o;
	default:
		return String(o);
	}
};
js_Boot.__interfLoop = function(cc,cl) {
	if(cc == null) return false;
	if(cc == cl) return true;
	var intf = cc.__interfaces__;
	if(intf != null) {
		var _g1 = 0;
		var _g = intf.length;
		while(_g1 < _g) {
			var i = _g1++;
			var i1 = intf[i];
			if(i1 == cl || js_Boot.__interfLoop(i1,cl)) return true;
		}
	}
	return js_Boot.__interfLoop(cc.__super__,cl);
};
js_Boot.__instanceof = function(o,cl) {
	if(cl == null) return false;
	switch(cl) {
	case Int:
		return (o|0) === o;
	case Float:
		return typeof(o) == "number";
	case Bool:
		return typeof(o) == "boolean";
	case String:
		return typeof(o) == "string";
	case Array:
		return (o instanceof Array) && o.__enum__ == null;
	case Dynamic:
		return true;
	default:
		if(o != null) {
			if(typeof(cl) == "function") {
				if(o instanceof cl) return true;
				if(js_Boot.__interfLoop(js_Boot.getClass(o),cl)) return true;
			} else if(typeof(cl) == "object" && js_Boot.__isNativeObj(cl)) {
				if(o instanceof cl) return true;
			}
		} else return false;
		if(cl == Class && o.__name__ != null) return true;
		if(cl == Enum && o.__ename__ != null) return true;
		return o.__enum__ == cl;
	}
};
js_Boot.__nativeClassName = function(o) {
	var name = js_Boot.__toStr.call(o).slice(8,-1);
	if(name == "Object" || name == "Function" || name == "Math" || name == "JSON") return null;
	return name;
};
js_Boot.__isNativeObj = function(o) {
	return js_Boot.__nativeClassName(o) != null;
};
js_Boot.__resolveNativeClass = function(name) {
	return $global[name];
};
var js_html_compat_ArrayBuffer = function(a) {
	if((a instanceof Array) && a.__enum__ == null) {
		this.a = a;
		this.byteLength = a.length;
	} else {
		var len = a;
		this.a = [];
		var _g = 0;
		while(_g < len) {
			var i = _g++;
			this.a[i] = 0;
		}
		this.byteLength = len;
	}
};
$hxClasses["js.html.compat.ArrayBuffer"] = js_html_compat_ArrayBuffer;
js_html_compat_ArrayBuffer.__name__ = ["js","html","compat","ArrayBuffer"];
js_html_compat_ArrayBuffer.sliceImpl = function(begin,end) {
	var u = new Uint8Array(this,begin,end == null?null:end - begin);
	var result = new ArrayBuffer(u.byteLength);
	var resultArray = new Uint8Array(result);
	resultArray.set(u);
	return result;
};
js_html_compat_ArrayBuffer.prototype = {
	slice: function(begin,end) {
		return new js_html_compat_ArrayBuffer(this.a.slice(begin,end));
	}
	,__class__: js_html_compat_ArrayBuffer
};
var js_html_compat_DataView = function(buffer,byteOffset,byteLength) {
	this.buf = buffer;
	if(byteOffset == null) this.offset = 0; else this.offset = byteOffset;
	if(byteLength == null) this.length = buffer.byteLength - this.offset; else this.length = byteLength;
	if(this.offset < 0 || this.length < 0 || this.offset + this.length > buffer.byteLength) throw new js__$Boot_HaxeError(haxe_io_Error.OutsideBounds);
};
$hxClasses["js.html.compat.DataView"] = js_html_compat_DataView;
js_html_compat_DataView.__name__ = ["js","html","compat","DataView"];
js_html_compat_DataView.prototype = {
	getInt8: function(byteOffset) {
		var v = this.buf.a[this.offset + byteOffset];
		if(v >= 128) return v - 256; else return v;
	}
	,getUint8: function(byteOffset) {
		return this.buf.a[this.offset + byteOffset];
	}
	,getInt16: function(byteOffset,littleEndian) {
		var v = this.getUint16(byteOffset,littleEndian);
		if(v >= 32768) return v - 65536; else return v;
	}
	,getUint16: function(byteOffset,littleEndian) {
		if(littleEndian) return this.buf.a[this.offset + byteOffset] | this.buf.a[this.offset + byteOffset + 1] << 8; else return this.buf.a[this.offset + byteOffset] << 8 | this.buf.a[this.offset + byteOffset + 1];
	}
	,getInt32: function(byteOffset,littleEndian) {
		var p = this.offset + byteOffset;
		var a = this.buf.a[p++];
		var b = this.buf.a[p++];
		var c = this.buf.a[p++];
		var d = this.buf.a[p++];
		if(littleEndian) return a | b << 8 | c << 16 | d << 24; else return d | c << 8 | b << 16 | a << 24;
	}
	,getUint32: function(byteOffset,littleEndian) {
		var v = this.getInt32(byteOffset,littleEndian);
		if(v < 0) return v + 4294967296.; else return v;
	}
	,getFloat32: function(byteOffset,littleEndian) {
		return haxe_io_FPHelper.i32ToFloat(this.getInt32(byteOffset,littleEndian));
	}
	,getFloat64: function(byteOffset,littleEndian) {
		var a = this.getInt32(byteOffset,littleEndian);
		var b = this.getInt32(byteOffset + 4,littleEndian);
		return haxe_io_FPHelper.i64ToDouble(littleEndian?a:b,littleEndian?b:a);
	}
	,setInt8: function(byteOffset,value) {
		if(value < 0) this.buf.a[byteOffset + this.offset] = value + 128 & 255; else this.buf.a[byteOffset + this.offset] = value & 255;
	}
	,setUint8: function(byteOffset,value) {
		this.buf.a[byteOffset + this.offset] = value & 255;
	}
	,setInt16: function(byteOffset,value,littleEndian) {
		this.setUint16(byteOffset,value < 0?value + 65536:value,littleEndian);
	}
	,setUint16: function(byteOffset,value,littleEndian) {
		var p = byteOffset + this.offset;
		if(littleEndian) {
			this.buf.a[p] = value & 255;
			this.buf.a[p++] = value >> 8 & 255;
		} else {
			this.buf.a[p++] = value >> 8 & 255;
			this.buf.a[p] = value & 255;
		}
	}
	,setInt32: function(byteOffset,value,littleEndian) {
		this.setUint32(byteOffset,value,littleEndian);
	}
	,setUint32: function(byteOffset,value,littleEndian) {
		var p = byteOffset + this.offset;
		if(littleEndian) {
			this.buf.a[p++] = value & 255;
			this.buf.a[p++] = value >> 8 & 255;
			this.buf.a[p++] = value >> 16 & 255;
			this.buf.a[p++] = value >>> 24;
		} else {
			this.buf.a[p++] = value >>> 24;
			this.buf.a[p++] = value >> 16 & 255;
			this.buf.a[p++] = value >> 8 & 255;
			this.buf.a[p++] = value & 255;
		}
	}
	,setFloat32: function(byteOffset,value,littleEndian) {
		this.setUint32(byteOffset,haxe_io_FPHelper.floatToI32(value),littleEndian);
	}
	,setFloat64: function(byteOffset,value,littleEndian) {
		var i64 = haxe_io_FPHelper.doubleToI64(value);
		if(littleEndian) {
			this.setUint32(byteOffset,i64.low);
			this.setUint32(byteOffset,i64.high);
		} else {
			this.setUint32(byteOffset,i64.high);
			this.setUint32(byteOffset,i64.low);
		}
	}
	,__class__: js_html_compat_DataView
};
var js_html_compat_Uint8Array = function() { };
$hxClasses["js.html.compat.Uint8Array"] = js_html_compat_Uint8Array;
js_html_compat_Uint8Array.__name__ = ["js","html","compat","Uint8Array"];
js_html_compat_Uint8Array._new = function(arg1,offset,length) {
	var arr;
	if(typeof(arg1) == "number") {
		arr = [];
		var _g = 0;
		while(_g < arg1) {
			var i = _g++;
			arr[i] = 0;
		}
		arr.byteLength = arr.length;
		arr.byteOffset = 0;
		arr.buffer = new js_html_compat_ArrayBuffer(arr);
	} else if(js_Boot.__instanceof(arg1,js_html_compat_ArrayBuffer)) {
		var buffer = arg1;
		if(offset == null) offset = 0;
		if(length == null) length = buffer.byteLength - offset;
		if(offset == 0) arr = buffer.a; else arr = buffer.a.slice(offset,offset + length);
		arr.byteLength = arr.length;
		arr.byteOffset = offset;
		arr.buffer = buffer;
	} else if((arg1 instanceof Array) && arg1.__enum__ == null) {
		arr = arg1.slice();
		arr.byteLength = arr.length;
		arr.byteOffset = 0;
		arr.buffer = new js_html_compat_ArrayBuffer(arr);
	} else throw new js__$Boot_HaxeError("TODO " + Std.string(arg1));
	arr.subarray = js_html_compat_Uint8Array._subarray;
	arr.set = js_html_compat_Uint8Array._set;
	return arr;
};
js_html_compat_Uint8Array._set = function(arg,offset) {
	var t = this;
	if(js_Boot.__instanceof(arg.buffer,js_html_compat_ArrayBuffer)) {
		var a = arg;
		if(arg.byteLength + offset > t.byteLength) throw new js__$Boot_HaxeError("set() outside of range");
		var _g1 = 0;
		var _g = arg.byteLength;
		while(_g1 < _g) {
			var i = _g1++;
			t[i + offset] = a[i];
		}
	} else if((arg instanceof Array) && arg.__enum__ == null) {
		var a1 = arg;
		if(a1.length + offset > t.byteLength) throw new js__$Boot_HaxeError("set() outside of range");
		var _g11 = 0;
		var _g2 = a1.length;
		while(_g11 < _g2) {
			var i1 = _g11++;
			t[i1 + offset] = a1[i1];
		}
	} else throw new js__$Boot_HaxeError("TODO");
};
js_html_compat_Uint8Array._subarray = function(start,end) {
	var t = this;
	var a = js_html_compat_Uint8Array._new(t.slice(start,end));
	a.byteOffset = start;
	return a;
};
var promhx_base_AsyncBase = function(d) {
	this._resolved = false;
	this._pending = false;
	this._errorPending = false;
	this._fulfilled = false;
	this._update = [];
	this._error = [];
	this._errored = false;
	if(d != null) promhx_base_AsyncBase.link(d,this,function(x) {
		return x;
	});
};
$hxClasses["promhx.base.AsyncBase"] = promhx_base_AsyncBase;
promhx_base_AsyncBase.__name__ = ["promhx","base","AsyncBase"];
promhx_base_AsyncBase.link = function(current,next,f) {
	current._update.push({ async : next, linkf : function(x) {
		next.handleResolve(f(x));
	}});
	promhx_base_AsyncBase.immediateLinkUpdate(current,next,f);
};
promhx_base_AsyncBase.immediateLinkUpdate = function(current,next,f) {
	if(current._errored && !current._errorPending && !(current._error.length > 0)) next.handleError(current._errorVal);
	if(current._resolved && !current._pending) try {
		next.handleResolve(f(current._val));
	} catch( e ) {
		if (e instanceof js__$Boot_HaxeError) e = e.val;
		next.handleError(e);
	}
};
promhx_base_AsyncBase.linkAll = function(all,next) {
	var cthen = function(arr,current,v) {
		if(arr.length == 0 || promhx_base_AsyncBase.allFulfilled(arr)) {
			var vals;
			var _g = [];
			var $it0 = $iterator(all)();
			while( $it0.hasNext() ) {
				var a = $it0.next();
				_g.push(a == current?v:a._val);
			}
			vals = _g;
			next.handleResolve(vals);
		}
		null;
		return;
	};
	var $it1 = $iterator(all)();
	while( $it1.hasNext() ) {
		var a1 = $it1.next();
		a1._update.push({ async : next, linkf : (function(f,a11,a2) {
			return function(v1) {
				f(a11,a2,v1);
				return;
			};
		})(cthen,(function($this) {
			var $r;
			var _g1 = [];
			var $it2 = $iterator(all)();
			while( $it2.hasNext() ) {
				var a21 = $it2.next();
				if(a21 != a1) _g1.push(a21);
			}
			$r = _g1;
			return $r;
		}(this)),a1)});
	}
	if(promhx_base_AsyncBase.allFulfilled(all)) next.handleResolve((function($this) {
		var $r;
		var _g2 = [];
		var $it3 = $iterator(all)();
		while( $it3.hasNext() ) {
			var a3 = $it3.next();
			_g2.push(a3._val);
		}
		$r = _g2;
		return $r;
	}(this)));
};
promhx_base_AsyncBase.pipeLink = function(current,ret,f) {
	var linked = false;
	var linkf = function(x) {
		if(!linked) {
			linked = true;
			var pipe_ret = f(x);
			pipe_ret._update.push({ async : ret, linkf : $bind(ret,ret.handleResolve)});
			promhx_base_AsyncBase.immediateLinkUpdate(pipe_ret,ret,function(x1) {
				return x1;
			});
		}
	};
	current._update.push({ async : ret, linkf : linkf});
	if(current._resolved && !current._pending) try {
		linkf(current._val);
	} catch( e ) {
		if (e instanceof js__$Boot_HaxeError) e = e.val;
		ret.handleError(e);
	}
};
promhx_base_AsyncBase.allResolved = function($as) {
	var $it0 = $iterator($as)();
	while( $it0.hasNext() ) {
		var a = $it0.next();
		if(!a._resolved) return false;
	}
	return true;
};
promhx_base_AsyncBase.allFulfilled = function($as) {
	var $it0 = $iterator($as)();
	while( $it0.hasNext() ) {
		var a = $it0.next();
		if(!a._fulfilled) return false;
	}
	return true;
};
promhx_base_AsyncBase.prototype = {
	catchError: function(f) {
		this._error.push(f);
		return this;
	}
	,errorThen: function(f) {
		this._errorMap = f;
		return this;
	}
	,isResolved: function() {
		return this._resolved;
	}
	,isErrored: function() {
		return this._errored;
	}
	,isErrorHandled: function() {
		return this._error.length > 0;
	}
	,isErrorPending: function() {
		return this._errorPending;
	}
	,isFulfilled: function() {
		return this._fulfilled;
	}
	,isPending: function() {
		return this._pending;
	}
	,handleResolve: function(val) {
		this._resolve(val);
	}
	,_resolve: function(val) {
		var _g = this;
		if(this._pending) promhx_base_EventLoop.enqueue((function(f,a1) {
			return function() {
				f(a1);
			};
		})($bind(this,this._resolve),val)); else {
			this._resolved = true;
			this._pending = true;
			promhx_base_EventLoop.queue.add(function() {
				_g._val = val;
				var _g1 = 0;
				var _g2 = _g._update;
				while(_g1 < _g2.length) {
					var up = _g2[_g1];
					++_g1;
					try {
						up.linkf(val);
					} catch( e ) {
						if (e instanceof js__$Boot_HaxeError) e = e.val;
						up.async.handleError(e);
					}
				}
				_g._fulfilled = true;
				_g._pending = false;
			});
			promhx_base_EventLoop.continueOnNextLoop();
		}
	}
	,handleError: function(error) {
		this._handleError(error);
	}
	,_handleError: function(error) {
		var _g = this;
		var update_errors = function(e) {
			if(_g._error.length > 0) {
				var _g1 = 0;
				var _g2 = _g._error;
				while(_g1 < _g2.length) {
					var ef = _g2[_g1];
					++_g1;
					ef(e);
				}
			} else if(_g._update.length > 0) {
				var _g11 = 0;
				var _g21 = _g._update;
				while(_g11 < _g21.length) {
					var up = _g21[_g11];
					++_g11;
					up.async.handleError(e);
				}
			} else throw new js__$Boot_HaxeError(e);
			_g._errorPending = false;
		};
		if(!this._errorPending) {
			this._errorPending = true;
			this._errored = true;
			this._errorVal = error;
			promhx_base_EventLoop.queue.add(function() {
				if(_g._errorMap != null) try {
					_g._resolve(_g._errorMap(error));
				} catch( e1 ) {
					if (e1 instanceof js__$Boot_HaxeError) e1 = e1.val;
					update_errors(e1);
				} else update_errors(error);
			});
			promhx_base_EventLoop.continueOnNextLoop();
		}
	}
	,then: function(f) {
		var ret = new promhx_base_AsyncBase(null);
		promhx_base_AsyncBase.link(this,ret,f);
		return ret;
	}
	,unlink: function(to) {
		var _g = this;
		promhx_base_EventLoop.queue.add(function() {
			_g._update = _g._update.filter(function(x) {
				return x.async != to;
			});
		});
		promhx_base_EventLoop.continueOnNextLoop();
	}
	,isLinked: function(to) {
		var updated = false;
		var _g = 0;
		var _g1 = this._update;
		while(_g < _g1.length) {
			var u = _g1[_g];
			++_g;
			if(u.async == to) return true;
		}
		return updated;
	}
	,__class__: promhx_base_AsyncBase
};
var promhx_Deferred = $hx_exports.promhx.Deferred = function() {
	promhx_base_AsyncBase.call(this);
};
$hxClasses["promhx.Deferred"] = promhx_Deferred;
promhx_Deferred.__name__ = ["promhx","Deferred"];
promhx_Deferred.__super__ = promhx_base_AsyncBase;
promhx_Deferred.prototype = $extend(promhx_base_AsyncBase.prototype,{
	resolve: function(val) {
		this.handleResolve(val);
	}
	,throwError: function(e) {
		this.handleError(e);
	}
	,promise: function() {
		return new promhx_Promise(this);
	}
	,stream: function() {
		return new promhx_Stream(this);
	}
	,publicStream: function() {
		return new promhx_PublicStream(this);
	}
	,__class__: promhx_Deferred
});
var promhx_Promise = $hx_exports.promhx.Promise = function(d) {
	promhx_base_AsyncBase.call(this,d);
	this._rejected = false;
};
$hxClasses["promhx.Promise"] = promhx_Promise;
promhx_Promise.__name__ = ["promhx","Promise"];
promhx_Promise.whenAll = function(itb) {
	var ret = new promhx_Promise(null);
	promhx_base_AsyncBase.linkAll(itb,ret);
	return ret;
};
promhx_Promise.promise = function(_val) {
	var ret = new promhx_Promise();
	ret.handleResolve(_val);
	return ret;
};
promhx_Promise.__super__ = promhx_base_AsyncBase;
promhx_Promise.prototype = $extend(promhx_base_AsyncBase.prototype,{
	isRejected: function() {
		return this._rejected;
	}
	,reject: function(e) {
		this._rejected = true;
		this.handleError(e);
	}
	,handleResolve: function(val) {
		if(this._resolved) {
			var msg = "Promise has already been resolved";
			throw new js__$Boot_HaxeError(promhx_error_PromiseError.AlreadyResolved(msg));
		}
		this._resolve(val);
	}
	,then: function(f) {
		var ret = new promhx_Promise(null);
		promhx_base_AsyncBase.link(this,ret,f);
		return ret;
	}
	,unlink: function(to) {
		var _g = this;
		promhx_base_EventLoop.queue.add(function() {
			if(!_g._fulfilled) {
				var msg = "Downstream Promise is not fullfilled";
				_g.handleError(promhx_error_PromiseError.DownstreamNotFullfilled(msg));
			} else _g._update = _g._update.filter(function(x) {
				return x.async != to;
			});
		});
		promhx_base_EventLoop.continueOnNextLoop();
	}
	,handleError: function(error) {
		this._rejected = true;
		this._handleError(error);
	}
	,pipe: function(f) {
		var ret = new promhx_Promise(null);
		promhx_base_AsyncBase.pipeLink(this,ret,f);
		return ret;
	}
	,errorPipe: function(f) {
		var ret = new promhx_Promise();
		this.catchError(function(e) {
			var piped = f(e);
			piped.then($bind(ret,ret._resolve));
		});
		this.then($bind(ret,ret._resolve));
		return ret;
	}
	,__class__: promhx_Promise
});
var promhx_Stream = $hx_exports.promhx.Stream = function(d) {
	promhx_base_AsyncBase.call(this,d);
	this._end_promise = new promhx_Promise();
};
$hxClasses["promhx.Stream"] = promhx_Stream;
promhx_Stream.__name__ = ["promhx","Stream"];
promhx_Stream.foreach = function(itb) {
	var s = new promhx_Stream(null);
	var $it0 = $iterator(itb)();
	while( $it0.hasNext() ) {
		var i = $it0.next();
		s.handleResolve(i);
	}
	s.end();
	return s;
};
promhx_Stream.wheneverAll = function(itb) {
	var ret = new promhx_Stream(null);
	promhx_base_AsyncBase.linkAll(itb,ret);
	return ret;
};
promhx_Stream.concatAll = function(itb) {
	var ret = new promhx_Stream(null);
	var $it0 = $iterator(itb)();
	while( $it0.hasNext() ) {
		var i = $it0.next();
		ret.concat(i);
	}
	return ret;
};
promhx_Stream.mergeAll = function(itb) {
	var ret = new promhx_Stream(null);
	var $it0 = $iterator(itb)();
	while( $it0.hasNext() ) {
		var i = $it0.next();
		ret.merge(i);
	}
	return ret;
};
promhx_Stream.stream = function(_val) {
	var ret = new promhx_Stream(null);
	ret.handleResolve(_val);
	return ret;
};
promhx_Stream.__super__ = promhx_base_AsyncBase;
promhx_Stream.prototype = $extend(promhx_base_AsyncBase.prototype,{
	then: function(f) {
		var ret = new promhx_Stream(null);
		promhx_base_AsyncBase.link(this,ret,f);
		this._end_promise._update.push({ async : ret._end_promise, linkf : function(x) {
			ret.end();
		}});
		return ret;
	}
	,detachStream: function(str) {
		var filtered = [];
		var removed = false;
		var _g = 0;
		var _g1 = this._update;
		while(_g < _g1.length) {
			var u = _g1[_g];
			++_g;
			if(u.async == str) {
				this._end_promise._update = this._end_promise._update.filter(function(x) {
					return x.async != str._end_promise;
				});
				removed = true;
			} else filtered.push(u);
		}
		this._update = filtered;
		return removed;
	}
	,first: function() {
		var s = new promhx_Promise(null);
		this.then(function(x) {
			if(!s._resolved) s.handleResolve(x);
		});
		return s;
	}
	,handleResolve: function(val) {
		if(!this._end && !this._pause) this._resolve(val);
	}
	,pause: function(set) {
		if(set == null) set = !this._pause;
		this._pause = set;
	}
	,pipe: function(f) {
		var ret = new promhx_Stream(null);
		promhx_base_AsyncBase.pipeLink(this,ret,f);
		this._end_promise.then(function(x) {
			ret.end();
		});
		return ret;
	}
	,errorPipe: function(f) {
		var ret = new promhx_Stream(null);
		this.catchError(function(e) {
			var piped = f(e);
			piped.then($bind(ret,ret._resolve));
			piped._end_promise.then(($_=ret._end_promise,$bind($_,$_._resolve)));
		});
		this.then($bind(ret,ret._resolve));
		this._end_promise.then(function(x) {
			ret.end();
		});
		return ret;
	}
	,handleEnd: function() {
		if(this._pending) {
			promhx_base_EventLoop.queue.add($bind(this,this.handleEnd));
			promhx_base_EventLoop.continueOnNextLoop();
		} else if(this._end_promise._resolved) return; else {
			this._end = true;
			var o;
			if(this._resolved) o = haxe_ds_Option.Some(this._val); else o = haxe_ds_Option.None;
			this._end_promise.handleResolve(o);
			this._update = [];
			this._error = [];
		}
	}
	,end: function() {
		promhx_base_EventLoop.queue.add($bind(this,this.handleEnd));
		promhx_base_EventLoop.continueOnNextLoop();
		return this;
	}
	,endThen: function(f) {
		return this._end_promise.then(f);
	}
	,filter: function(f) {
		var ret = new promhx_Stream(null);
		this._update.push({ async : ret, linkf : function(x) {
			if(f(x)) ret.handleResolve(x);
		}});
		promhx_base_AsyncBase.immediateLinkUpdate(this,ret,function(x1) {
			return x1;
		});
		return ret;
	}
	,concat: function(s) {
		var ret = new promhx_Stream(null);
		this._update.push({ async : ret, linkf : $bind(ret,ret.handleResolve)});
		promhx_base_AsyncBase.immediateLinkUpdate(this,ret,function(x) {
			return x;
		});
		this._end_promise.then(function(_) {
			s.pipe(function(x1) {
				ret.handleResolve(x1);
				return ret;
			});
			s._end_promise.then(function(_1) {
				ret.end();
			});
		});
		return ret;
	}
	,merge: function(s) {
		var ret = new promhx_Stream(null);
		this._update.push({ async : ret, linkf : $bind(ret,ret.handleResolve)});
		s._update.push({ async : ret, linkf : $bind(ret,ret.handleResolve)});
		promhx_base_AsyncBase.immediateLinkUpdate(this,ret,function(x) {
			return x;
		});
		promhx_base_AsyncBase.immediateLinkUpdate(s,ret,function(x1) {
			return x1;
		});
		return ret;
	}
	,__class__: promhx_Stream
});
var promhx_PublicStream = $hx_exports.promhx.PublicStream = function(def) {
	promhx_Stream.call(this,def);
};
$hxClasses["promhx.PublicStream"] = promhx_PublicStream;
promhx_PublicStream.__name__ = ["promhx","PublicStream"];
promhx_PublicStream.publicstream = function(val) {
	var ps = new promhx_PublicStream(null);
	ps.handleResolve(val);
	return ps;
};
promhx_PublicStream.__super__ = promhx_Stream;
promhx_PublicStream.prototype = $extend(promhx_Stream.prototype,{
	resolve: function(val) {
		this.handleResolve(val);
	}
	,throwError: function(e) {
		this.handleError(e);
	}
	,update: function(val) {
		this.handleResolve(val);
	}
	,__class__: promhx_PublicStream
});
var promhx_base_EventLoop = function() { };
$hxClasses["promhx.base.EventLoop"] = promhx_base_EventLoop;
promhx_base_EventLoop.__name__ = ["promhx","base","EventLoop"];
promhx_base_EventLoop.enqueue = function(eqf) {
	promhx_base_EventLoop.queue.add(eqf);
	promhx_base_EventLoop.continueOnNextLoop();
};
promhx_base_EventLoop.set_nextLoop = function(f) {
	if(promhx_base_EventLoop.nextLoop != null) throw new js__$Boot_HaxeError("nextLoop has already been set"); else promhx_base_EventLoop.nextLoop = f;
	return promhx_base_EventLoop.nextLoop;
};
promhx_base_EventLoop.queueEmpty = function() {
	return promhx_base_EventLoop.queue.isEmpty();
};
promhx_base_EventLoop.finish = function(max_iterations) {
	if(max_iterations == null) max_iterations = 1000;
	var fn = null;
	while(max_iterations-- > 0 && (fn = promhx_base_EventLoop.queue.pop()) != null) fn();
	return promhx_base_EventLoop.queue.isEmpty();
};
promhx_base_EventLoop.clear = function() {
	promhx_base_EventLoop.queue = new List();
};
promhx_base_EventLoop.f = function() {
	var fn = promhx_base_EventLoop.queue.pop();
	if(fn != null) fn();
	if(!promhx_base_EventLoop.queue.isEmpty()) promhx_base_EventLoop.continueOnNextLoop();
};
promhx_base_EventLoop.continueOnNextLoop = function() {
	if(promhx_base_EventLoop.nextLoop != null) promhx_base_EventLoop.nextLoop(promhx_base_EventLoop.f); else setImmediate(promhx_base_EventLoop.f);
};
var promhx_error_PromiseError = $hxClasses["promhx.error.PromiseError"] = { __ename__ : ["promhx","error","PromiseError"], __constructs__ : ["AlreadyResolved","DownstreamNotFullfilled"] };
promhx_error_PromiseError.AlreadyResolved = function(message) { var $x = ["AlreadyResolved",0,message]; $x.__enum__ = promhx_error_PromiseError; $x.toString = $estr; return $x; };
promhx_error_PromiseError.DownstreamNotFullfilled = function(message) { var $x = ["DownstreamNotFullfilled",1,message]; $x.__enum__ = promhx_error_PromiseError; $x.toString = $estr; return $x; };
var verb_Verb = function() { };
$hxClasses["verb.Verb"] = verb_Verb;
verb_Verb.__name__ = ["verb","Verb"];
verb_Verb.main = function() {
	console.log("verb 2.1.0");
};
var verb_core_ArrayExtensions = function() { };
$hxClasses["verb.core.ArrayExtensions"] = verb_core_ArrayExtensions;
verb_core_ArrayExtensions.__name__ = ["verb","core","ArrayExtensions"];
verb_core_ArrayExtensions.alloc = function(a,n) {
	if(n < 0) return;
	while(a.length < n) a.push(null);
};
verb_core_ArrayExtensions.reversed = function(a) {
	var ac = a.slice();
	ac.reverse();
	return ac;
};
verb_core_ArrayExtensions.last = function(a) {
	return a[a.length - 1];
};
verb_core_ArrayExtensions.first = function(a) {
	return a[0];
};
verb_core_ArrayExtensions.spliceAndInsert = function(a,start,end,ele) {
	a.splice(start,end);
	a.splice(start,0,ele);
};
verb_core_ArrayExtensions.left = function(arr) {
	if(arr.length == 0) return [];
	var len = Math.ceil(arr.length / 2);
	return arr.slice(0,len);
};
verb_core_ArrayExtensions.right = function(arr) {
	if(arr.length == 0) return [];
	var len = Math.ceil(arr.length / 2);
	return arr.slice(len);
};
verb_core_ArrayExtensions.rightWithPivot = function(arr) {
	if(arr.length == 0) return [];
	var len = Math.ceil(arr.length / 2);
	return arr.slice(len - 1);
};
verb_core_ArrayExtensions.unique = function(arr,comp) {
	if(arr.length == 0) return [];
	var uniques = [arr.pop()];
	while(arr.length > 0) {
		var ele = arr.pop();
		var isUnique = true;
		var _g = 0;
		while(_g < uniques.length) {
			var unique = uniques[_g];
			++_g;
			if(comp(ele,unique)) {
				isUnique = false;
				break;
			}
		}
		if(isUnique) uniques.push(ele);
	}
	return uniques;
};
var verb_core_Binomial = function() { };
$hxClasses["verb.core.Binomial"] = verb_core_Binomial;
verb_core_Binomial.__name__ = ["verb","core","Binomial"];
verb_core_Binomial.get = function(n,k) {
	if(k == 0.0) return 1.0;
	if(n == 0 || k > n) return 0.0;
	if(k > n - k) k = n - k;
	if(verb_core_Binomial.memo_exists(n,k)) return verb_core_Binomial.get_memo(n,k);
	var r = 1;
	var n_o = n;
	var _g1 = 1;
	var _g = k + 1;
	while(_g1 < _g) {
		var d = _g1++;
		if(verb_core_Binomial.memo_exists(n_o,d)) {
			n--;
			r = verb_core_Binomial.get_memo(n_o,d);
			continue;
		}
		r *= n--;
		r /= d;
		verb_core_Binomial.memoize(n_o,d,r);
	}
	return r;
};
verb_core_Binomial.get_no_memo = function(n,k) {
	if(k == 0) return 1;
	if(n == 0 || k > n) return 0;
	if(k > n - k) k = n - k;
	var r = 1;
	var n_o = n;
	var _g1 = 1;
	var _g = k + 1;
	while(_g1 < _g) {
		var d = _g1++;
		r *= n--;
		r /= d;
	}
	return r;
};
verb_core_Binomial.memo_exists = function(n,k) {
	return verb_core_Binomial.memo.h.hasOwnProperty(n) && verb_core_Binomial.memo.h[n].h.hasOwnProperty(k);
};
verb_core_Binomial.get_memo = function(n,k) {
	return verb_core_Binomial.memo.h[n].h[k];
};
verb_core_Binomial.memoize = function(n,k,val) {
	if(!verb_core_Binomial.memo.h.hasOwnProperty(n)) verb_core_Binomial.memo.set(n,new haxe_ds_IntMap());
	verb_core_Binomial.memo.h[n].h[k] = val;
};
var verb_core_BoundingBox = $hx_exports.core.BoundingBox = function(pts) {
	this.max = null;
	this.min = null;
	this.dim = 3;
	this.initialized = false;
	if(pts != null) this.addRange(pts);
};
$hxClasses["verb.core.BoundingBox"] = verb_core_BoundingBox;
verb_core_BoundingBox.__name__ = ["verb","core","BoundingBox"];
verb_core_BoundingBox.intervalsOverlap = function(a1,a2,b1,b2,tol) {
	if(tol == null) tol = -1;
	var tol1;
	if(tol < -0.5) tol1 = verb_core_Constants.TOLERANCE; else tol1 = tol;
	var x1 = Math.min(a1,a2) - tol1;
	var x2 = Math.max(a1,a2) + tol1;
	var y1 = Math.min(b1,b2) - tol1;
	var y2 = Math.max(b1,b2) + tol1;
	return x1 >= y1 && x1 <= y2 || x2 >= y1 && x2 <= y2 || y1 >= x1 && y1 <= x2 || y2 >= x1 && y2 <= x2;
};
verb_core_BoundingBox.prototype = {
	fromPoint: function(pt) {
		return new verb_core_BoundingBox([pt]);
	}
	,add: function(point) {
		if(!this.initialized) {
			this.dim = point.length;
			this.min = point.slice(0);
			this.max = point.slice(0);
			this.initialized = true;
			return this;
		}
		var _g1 = 0;
		var _g = this.dim;
		while(_g1 < _g) {
			var i = _g1++;
			if(point[i] > this.max[i]) this.max[i] = point[i];
			if(point[i] < this.min[i]) this.min[i] = point[i];
		}
		return this;
	}
	,addRange: function(points) {
		var l = points.length;
		var _g = 0;
		while(_g < l) {
			var i = _g++;
			this.add(points[i]);
		}
		return this;
	}
	,contains: function(point,tol) {
		if(tol == null) tol = -1;
		if(!this.initialized) return false;
		return this.intersects(new verb_core_BoundingBox([point]),tol);
	}
	,intersects: function(bb,tol) {
		if(tol == null) tol = -1;
		if(!this.initialized || !bb.initialized) return false;
		var a1 = this.min;
		var a2 = this.max;
		var b1 = bb.min;
		var b2 = bb.max;
		var _g1 = 0;
		var _g = this.dim;
		while(_g1 < _g) {
			var i = _g1++;
			if(!verb_core_BoundingBox.intervalsOverlap(a1[i],a2[i],b1[i],b2[i],tol)) return false;
		}
		return true;
	}
	,clear: function() {
		this.initialized = false;
		return this;
	}
	,getLongestAxis: function() {
		var max = 0.0;
		var id = 0;
		var _g1 = 0;
		var _g = this.dim;
		while(_g1 < _g) {
			var i = _g1++;
			var l = this.getAxisLength(i);
			if(l > max) {
				max = l;
				id = i;
			}
		}
		return id;
	}
	,getAxisLength: function(i) {
		if(i < 0 || i > this.dim - 1) return 0.0;
		return Math.abs(this.min[i] - this.max[i]);
	}
	,intersect: function(bb,tol) {
		if(!this.initialized) return null;
		var a1 = this.min;
		var a2 = this.max;
		var b1 = bb.min;
		var b2 = bb.max;
		if(!this.intersects(bb,tol)) return null;
		var maxbb = [];
		var minbb = [];
		var _g1 = 0;
		var _g = this.dim;
		while(_g1 < _g) {
			var i = _g1++;
			maxbb.push(Math.min(a2[i],b2[i]));
			minbb.push(Math.max(a1[i],b1[i]));
		}
		return new verb_core_BoundingBox([minbb,maxbb]);
	}
	,__class__: verb_core_BoundingBox
};
var verb_core_Constants = $hx_exports.core.Constants = function() { };
$hxClasses["verb.core.Constants"] = verb_core_Constants;
verb_core_Constants.__name__ = ["verb","core","Constants"];
var verb_core_SerializableBase = $hx_exports.core.SerializableBase = function() { };
$hxClasses["verb.core.SerializableBase"] = verb_core_SerializableBase;
verb_core_SerializableBase.__name__ = ["verb","core","SerializableBase"];
verb_core_SerializableBase.prototype = {
	serialize: function() {
		var serializer = new haxe_Serializer();
		serializer.serialize(this);
		return serializer.toString();
	}
	,__class__: verb_core_SerializableBase
};
var verb_core_Plane = $hx_exports.core.Plane = function(origin,normal) {
	this.origin = origin;
	this.normal = normal;
};
$hxClasses["verb.core.Plane"] = verb_core_Plane;
verb_core_Plane.__name__ = ["verb","core","Plane"];
verb_core_Plane.__super__ = verb_core_SerializableBase;
verb_core_Plane.prototype = $extend(verb_core_SerializableBase.prototype,{
	__class__: verb_core_Plane
});
var verb_core_Ray = $hx_exports.core.Ray = function(origin,dir) {
	this.origin = origin;
	this.dir = dir;
};
$hxClasses["verb.core.Ray"] = verb_core_Ray;
verb_core_Ray.__name__ = ["verb","core","Ray"];
verb_core_Ray.__super__ = verb_core_SerializableBase;
verb_core_Ray.prototype = $extend(verb_core_SerializableBase.prototype,{
	__class__: verb_core_Ray
});
var verb_core_NurbsCurveData = $hx_exports.core.NurbsCurveData = function(degree,knots,controlPoints) {
	this.degree = degree;
	this.controlPoints = controlPoints;
	this.knots = knots;
};
$hxClasses["verb.core.NurbsCurveData"] = verb_core_NurbsCurveData;
verb_core_NurbsCurveData.__name__ = ["verb","core","NurbsCurveData"];
verb_core_NurbsCurveData.__super__ = verb_core_SerializableBase;
verb_core_NurbsCurveData.prototype = $extend(verb_core_SerializableBase.prototype,{
	__class__: verb_core_NurbsCurveData
});
var verb_core_NurbsSurfaceData = $hx_exports.core.NurbsSurfaceData = function(degreeU,degreeV,knotsU,knotsV,controlPoints) {
	this.degreeU = degreeU;
	this.degreeV = degreeV;
	this.knotsU = knotsU;
	this.knotsV = knotsV;
	this.controlPoints = controlPoints;
};
$hxClasses["verb.core.NurbsSurfaceData"] = verb_core_NurbsSurfaceData;
verb_core_NurbsSurfaceData.__name__ = ["verb","core","NurbsSurfaceData"];
verb_core_NurbsSurfaceData.__super__ = verb_core_SerializableBase;
verb_core_NurbsSurfaceData.prototype = $extend(verb_core_SerializableBase.prototype,{
	__class__: verb_core_NurbsSurfaceData
});
var verb_core_MeshData = $hx_exports.core.MeshData = function(faces,points,normals,uvs) {
	this.faces = faces;
	this.points = points;
	this.normals = normals;
	this.uvs = uvs;
};
$hxClasses["verb.core.MeshData"] = verb_core_MeshData;
verb_core_MeshData.__name__ = ["verb","core","MeshData"];
verb_core_MeshData.empty = function() {
	return new verb_core_MeshData([],[],[],[]);
};
verb_core_MeshData.__super__ = verb_core_SerializableBase;
verb_core_MeshData.prototype = $extend(verb_core_SerializableBase.prototype,{
	__class__: verb_core_MeshData
});
var verb_core_PolylineData = $hx_exports.core.PolylineData = function(points,params) {
	this.points = points;
	this.params = params;
};
$hxClasses["verb.core.PolylineData"] = verb_core_PolylineData;
verb_core_PolylineData.__name__ = ["verb","core","PolylineData"];
verb_core_PolylineData.__super__ = verb_core_SerializableBase;
verb_core_PolylineData.prototype = $extend(verb_core_SerializableBase.prototype,{
	__class__: verb_core_PolylineData
});
var verb_core_VolumeData = $hx_exports.core.VolumeData = function(degreeU,degreeV,degreeW,knotsU,knotsV,knotsW,controlPoints) {
	this.degreeU = degreeU;
	this.degreeV = degreeV;
	this.degreeW = degreeW;
	this.knotsU = knotsU;
	this.knotsV = knotsV;
	this.knotsW = knotsW;
	this.controlPoints = controlPoints;
};
$hxClasses["verb.core.VolumeData"] = verb_core_VolumeData;
verb_core_VolumeData.__name__ = ["verb","core","VolumeData"];
verb_core_VolumeData.__super__ = verb_core_SerializableBase;
verb_core_VolumeData.prototype = $extend(verb_core_SerializableBase.prototype,{
	__class__: verb_core_VolumeData
});
var verb_core_Pair = $hx_exports.core.Pair = function(item1,item2) {
	this.item0 = item1;
	this.item1 = item2;
};
$hxClasses["verb.core.Pair"] = verb_core_Pair;
verb_core_Pair.__name__ = ["verb","core","Pair"];
verb_core_Pair.prototype = {
	__class__: verb_core_Pair
};
var verb_core_Interval = $hx_exports.core.Interval = function(min,max) {
	this.min = min;
	this.max = max;
};
$hxClasses["verb.core.Interval"] = verb_core_Interval;
verb_core_Interval.__name__ = ["verb","core","Interval"];
verb_core_Interval.prototype = {
	__class__: verb_core_Interval
};
var verb_core_CurveCurveIntersection = $hx_exports.core.CurveCurveIntersection = function(point0,point1,u0,u1) {
	this.point0 = point0;
	this.point1 = point1;
	this.u0 = u0;
	this.u1 = u1;
};
$hxClasses["verb.core.CurveCurveIntersection"] = verb_core_CurveCurveIntersection;
verb_core_CurveCurveIntersection.__name__ = ["verb","core","CurveCurveIntersection"];
verb_core_CurveCurveIntersection.prototype = {
	__class__: verb_core_CurveCurveIntersection
};
var verb_core_CurveSurfaceIntersection = $hx_exports.core.CurveSurfaceIntersection = function(u,uv,curvePoint,surfacePoint) {
	this.u = u;
	this.uv = uv;
	this.curvePoint = curvePoint;
	this.surfacePoint = surfacePoint;
};
$hxClasses["verb.core.CurveSurfaceIntersection"] = verb_core_CurveSurfaceIntersection;
verb_core_CurveSurfaceIntersection.__name__ = ["verb","core","CurveSurfaceIntersection"];
verb_core_CurveSurfaceIntersection.prototype = {
	__class__: verb_core_CurveSurfaceIntersection
};
var verb_core_MeshIntersectionPoint = $hx_exports.core.MeshIntersectionPoint = function(uv0,uv1,point,faceIndex0,faceIndex1) {
	this.visited = false;
	this.adj = null;
	this.opp = null;
	this.uv0 = uv0;
	this.uv1 = uv1;
	this.point = point;
	this.faceIndex0;
	this.faceIndex1;
};
$hxClasses["verb.core.MeshIntersectionPoint"] = verb_core_MeshIntersectionPoint;
verb_core_MeshIntersectionPoint.__name__ = ["verb","core","MeshIntersectionPoint"];
verb_core_MeshIntersectionPoint.prototype = {
	__class__: verb_core_MeshIntersectionPoint
};
var verb_core_PolylineMeshIntersection = $hx_exports.core.PolylineMeshIntersection = function(point,u,uv,polylineIndex,faceIndex) {
	this.point = point;
	this.u = u;
	this.uv = uv;
	this.polylineIndex = polylineIndex;
	this.faceIndex = faceIndex;
};
$hxClasses["verb.core.PolylineMeshIntersection"] = verb_core_PolylineMeshIntersection;
verb_core_PolylineMeshIntersection.__name__ = ["verb","core","PolylineMeshIntersection"];
verb_core_PolylineMeshIntersection.prototype = {
	__class__: verb_core_PolylineMeshIntersection
};
var verb_core_SurfaceSurfaceIntersectionPoint = $hx_exports.core.SurfaceSurfaceIntersectionPoint = function(uv0,uv1,point,dist) {
	this.uv0 = uv0;
	this.uv1 = uv1;
	this.point = point;
	this.dist = dist;
};
$hxClasses["verb.core.SurfaceSurfaceIntersectionPoint"] = verb_core_SurfaceSurfaceIntersectionPoint;
verb_core_SurfaceSurfaceIntersectionPoint.__name__ = ["verb","core","SurfaceSurfaceIntersectionPoint"];
verb_core_SurfaceSurfaceIntersectionPoint.prototype = {
	__class__: verb_core_SurfaceSurfaceIntersectionPoint
};
var verb_core_TriSegmentIntersection = $hx_exports.core.TriSegmentIntersection = function(point,s,t,r) {
	this.point = point;
	this.s = s;
	this.t = t;
	this.p = r;
};
$hxClasses["verb.core.TriSegmentIntersection"] = verb_core_TriSegmentIntersection;
verb_core_TriSegmentIntersection.__name__ = ["verb","core","TriSegmentIntersection"];
verb_core_TriSegmentIntersection.prototype = {
	__class__: verb_core_TriSegmentIntersection
};
var verb_core_CurveTriPoint = $hx_exports.core.CurveTriPoint = function(u,point,uv) {
	this.u = u;
	this.point = point;
	this.uv = uv;
};
$hxClasses["verb.core.CurveTriPoint"] = verb_core_CurveTriPoint;
verb_core_CurveTriPoint.__name__ = ["verb","core","CurveTriPoint"];
verb_core_CurveTriPoint.prototype = {
	__class__: verb_core_CurveTriPoint
};
var verb_core_SurfacePoint = function(point,normal,uv,id,degen) {
	if(degen == null) degen = false;
	if(id == null) id = -1;
	this.uv = uv;
	this.point = point;
	this.normal = normal;
	this.id = id;
	this.degen = degen;
};
$hxClasses["verb.core.SurfacePoint"] = verb_core_SurfacePoint;
verb_core_SurfacePoint.__name__ = ["verb","core","SurfacePoint"];
verb_core_SurfacePoint.fromUv = function(u,v) {
	return new verb_core_SurfacePoint(null,null,[u,v]);
};
verb_core_SurfacePoint.prototype = {
	__class__: verb_core_SurfacePoint
};
var verb_core_CurvePoint = $hx_exports.core.CurvePoint = function(u,pt) {
	this.u = u;
	this.pt = pt;
};
$hxClasses["verb.core.CurvePoint"] = verb_core_CurvePoint;
verb_core_CurvePoint.__name__ = ["verb","core","CurvePoint"];
verb_core_CurvePoint.prototype = {
	__class__: verb_core_CurvePoint
};
var verb_core_KdTree = $hx_exports.core.KdTree = function(points,distanceFunction) {
	this.dim = 3;
	this.points = points;
	this.distanceFunction = distanceFunction;
	this.dim = points[0].point.length;
	this.root = this.buildTree(points,0,null);
};
$hxClasses["verb.core.KdTree"] = verb_core_KdTree;
verb_core_KdTree.__name__ = ["verb","core","KdTree"];
verb_core_KdTree.prototype = {
	buildTree: function(points,depth,parent) {
		var dim = depth % this.dim;
		var median;
		var node;
		if(points.length == 0) return null;
		if(points.length == 1) return new verb_core_KdNode(points[0],dim,parent);
		points.sort(function(a,b) {
			var diff = a.point[dim] - b.point[dim];
			if(diff == 0.0) return 0; else if(diff > 0) return 1; else return -1;
		});
		median = Math.floor(points.length / 2);
		node = new verb_core_KdNode(points[median],dim,parent);
		node.left = this.buildTree(points.slice(0,median),depth + 1,node);
		node.right = this.buildTree(points.slice(median + 1),depth + 1,node);
		return node;
	}
	,nearest: function(point,maxNodes,maxDistance) {
		var _g = this;
		var bestNodes = new verb_core_BinaryHeap(function(e) {
			return -e.item1;
		});
		var nearestSearch;
		var nearestSearch1 = null;
		nearestSearch1 = function(node) {
			var bestChild;
			var dimension = node.dimension;
			var ownDistance = _g.distanceFunction(point,node.kdPoint.point);
			var linearPoint;
			var _g1 = [];
			var _g3 = 0;
			var _g2 = _g.dim;
			while(_g3 < _g2) {
				var i1 = _g3++;
				_g1.push(0.0);
			}
			linearPoint = _g1;
			var linearDistance;
			var otherChild;
			var i;
			var saveNode = function(node1,distance) {
				bestNodes.push(new verb_core_Pair(node1,distance));
				if(bestNodes.size() > maxNodes) bestNodes.pop();
			};
			var _g31 = 0;
			var _g21 = _g.dim;
			while(_g31 < _g21) {
				var i2 = _g31++;
				if(i2 == node.dimension) linearPoint[i2] = point[i2]; else linearPoint[i2] = node.kdPoint.point[i2];
			}
			linearDistance = _g.distanceFunction(linearPoint,node.kdPoint.point);
			if(node.right == null && node.left == null) {
				if(bestNodes.size() < maxNodes || ownDistance < bestNodes.peek().item1) saveNode(node,ownDistance);
				return;
			}
			if(node.right == null) bestChild = node.left; else if(node.left == null) bestChild = node.right; else if(point[dimension] < node.kdPoint.point[dimension]) bestChild = node.left; else bestChild = node.right;
			nearestSearch1(bestChild);
			if(bestNodes.size() < maxNodes || ownDistance < bestNodes.peek().item1) saveNode(node,ownDistance);
			if(bestNodes.size() < maxNodes || Math.abs(linearDistance) < bestNodes.peek().item1) {
				if(bestChild == node.left) otherChild = node.right; else otherChild = node.left;
				if(otherChild != null) nearestSearch1(otherChild);
			}
		};
		nearestSearch = nearestSearch1;
		var _g4 = 0;
		while(_g4 < maxNodes) {
			var i3 = _g4++;
			bestNodes.push(new verb_core_Pair(null,maxDistance));
		}
		nearestSearch(this.root);
		var result = [];
		var _g5 = 0;
		while(_g5 < maxNodes) {
			var i4 = _g5++;
			if(bestNodes.content[i4].item0 != null) result.push(new verb_core_Pair(bestNodes.content[i4].item0.kdPoint,bestNodes.content[i4].item1));
		}
		return result;
	}
	,__class__: verb_core_KdTree
};
var verb_core_BinaryHeap = function(scoreFunction) {
	this.content = [];
	this.scoreFunction = scoreFunction;
};
$hxClasses["verb.core.BinaryHeap"] = verb_core_BinaryHeap;
verb_core_BinaryHeap.__name__ = ["verb","core","BinaryHeap"];
verb_core_BinaryHeap.prototype = {
	push: function(element) {
		this.content.push(element);
		this.bubbleUp(this.content.length - 1);
	}
	,pop: function() {
		var result = this.content[0];
		var end = this.content.pop();
		if(this.content.length > 0) {
			this.content[0] = end;
			this.sinkDown(0);
		}
		return result;
	}
	,peek: function() {
		return this.content[0];
	}
	,remove: function(node) {
		var len = this.content.length;
		var _g = 0;
		while(_g < len) {
			var i = _g++;
			if(this.content[i] == node) {
				var end = this.content.pop();
				if(i != len - 1) {
					this.content[i] = end;
					if(this.scoreFunction(end) < this.scoreFunction(node)) this.bubbleUp(i); else this.sinkDown(i);
				}
				return;
			}
		}
		throw new js__$Boot_HaxeError("Node not found.");
	}
	,size: function() {
		return this.content.length;
	}
	,bubbleUp: function(n) {
		var element = this.content[n];
		while(n > 0) {
			var parentN = Math.floor((n + 1.0) / 2) - 1;
			var parent = this.content[parentN];
			if(this.scoreFunction(element) < this.scoreFunction(parent)) {
				this.content[parentN] = element;
				this.content[n] = parent;
				n = parentN;
			} else break;
		}
	}
	,sinkDown: function(n) {
		var length = this.content.length;
		var element = this.content[n];
		var elemScore = this.scoreFunction(element);
		while(true) {
			var child2N = (n + 1) * 2;
			var child1N = child2N - 1;
			var swap = -1;
			var child1Score = 0.0;
			if(child1N < length) {
				var child1 = this.content[child1N];
				child1Score = this.scoreFunction(child1);
				if(child1Score < elemScore) swap = child1N;
			}
			if(child2N < length) {
				var child2 = this.content[child2N];
				var child2Score = this.scoreFunction(child2);
				if(child2Score < (swap == -1?elemScore:child1Score)) swap = child2N;
			}
			if(swap != -1) {
				this.content[n] = this.content[swap];
				this.content[swap] = element;
				n = swap;
			} else break;
		}
	}
	,__class__: verb_core_BinaryHeap
};
var verb_core_KdPoint = $hx_exports.core.KdPoint = function(point,obj) {
	this.point = point;
	this.obj = obj;
};
$hxClasses["verb.core.KdPoint"] = verb_core_KdPoint;
verb_core_KdPoint.__name__ = ["verb","core","KdPoint"];
verb_core_KdPoint.prototype = {
	__class__: verb_core_KdPoint
};
var verb_core_KdNode = $hx_exports.core.KdNode = function(kdPoint,dimension,parent) {
	this.kdPoint = kdPoint;
	this.left = null;
	this.right = null;
	this.parent = parent;
	this.dimension = dimension;
};
$hxClasses["verb.core.KdNode"] = verb_core_KdNode;
verb_core_KdNode.__name__ = ["verb","core","KdNode"];
verb_core_KdNode.prototype = {
	__class__: verb_core_KdNode
};
var verb_eval_IBoundingBoxTree = function() { };
$hxClasses["verb.eval.IBoundingBoxTree"] = verb_eval_IBoundingBoxTree;
verb_eval_IBoundingBoxTree.__name__ = ["verb","eval","IBoundingBoxTree"];
verb_eval_IBoundingBoxTree.prototype = {
	__class__: verb_eval_IBoundingBoxTree
};
var verb_core_LazyCurveBoundingBoxTree = function(curve,knotTol) {
	this._boundingBox = null;
	this._curve = curve;
	if(knotTol == null) knotTol = verb_core_Vec.domain(this._curve.knots) / 64;
	this._knotTol = knotTol;
};
$hxClasses["verb.core.LazyCurveBoundingBoxTree"] = verb_core_LazyCurveBoundingBoxTree;
verb_core_LazyCurveBoundingBoxTree.__name__ = ["verb","core","LazyCurveBoundingBoxTree"];
verb_core_LazyCurveBoundingBoxTree.__interfaces__ = [verb_eval_IBoundingBoxTree];
verb_core_LazyCurveBoundingBoxTree.prototype = {
	split: function() {
		var min = verb_core_ArrayExtensions.first(this._curve.knots);
		var max = verb_core_ArrayExtensions.last(this._curve.knots);
		var dom = max - min;
		var crvs = verb_eval_Divide.curveSplit(this._curve,(max + min) / 2.0 + dom * 0.1 * Math.random());
		return new verb_core_Pair(new verb_core_LazyCurveBoundingBoxTree(crvs[0],this._knotTol),new verb_core_LazyCurveBoundingBoxTree(crvs[1],this._knotTol));
	}
	,boundingBox: function() {
		if(this._boundingBox == null) this._boundingBox = new verb_core_BoundingBox(verb_eval_Eval.dehomogenize1d(this._curve.controlPoints));
		return this._boundingBox;
	}
	,'yield': function() {
		return this._curve;
	}
	,indivisible: function(tolerance) {
		return verb_core_Vec.domain(this._curve.knots) < this._knotTol;
	}
	,empty: function() {
		return false;
	}
	,__class__: verb_core_LazyCurveBoundingBoxTree
};
var verb_core_LazyMeshBoundingBoxTree = function(mesh,faceIndices) {
	this._boundingBox = null;
	this._mesh = mesh;
	if(faceIndices == null) {
		var _g = [];
		var _g2 = 0;
		var _g1 = mesh.faces.length;
		while(_g2 < _g1) {
			var i = _g2++;
			_g.push(i);
		}
		faceIndices = _g;
	}
	this._faceIndices = faceIndices;
};
$hxClasses["verb.core.LazyMeshBoundingBoxTree"] = verb_core_LazyMeshBoundingBoxTree;
verb_core_LazyMeshBoundingBoxTree.__name__ = ["verb","core","LazyMeshBoundingBoxTree"];
verb_core_LazyMeshBoundingBoxTree.__interfaces__ = [verb_eval_IBoundingBoxTree];
verb_core_LazyMeshBoundingBoxTree.prototype = {
	split: function() {
		var $as = verb_core_Mesh.sortTrianglesOnLongestAxis(this.boundingBox(),this._mesh,this._faceIndices);
		var l = verb_core_ArrayExtensions.left($as);
		var r = verb_core_ArrayExtensions.right($as);
		return new verb_core_Pair(new verb_core_LazyMeshBoundingBoxTree(this._mesh,l),new verb_core_LazyMeshBoundingBoxTree(this._mesh,r));
	}
	,boundingBox: function() {
		if(this._boundingBox == null) this._boundingBox = verb_core_Mesh.makeMeshAabb(this._mesh,this._faceIndices);
		return this._boundingBox;
	}
	,'yield': function() {
		return this._faceIndices[0];
	}
	,indivisible: function(tolerance) {
		return this._faceIndices.length == 1;
	}
	,empty: function() {
		return this._faceIndices.length == 0;
	}
	,__class__: verb_core_LazyMeshBoundingBoxTree
};
var verb_core_LazyPolylineBoundingBoxTree = function(polyline,interval) {
	this._boundingBox = null;
	this._polyline = polyline;
	if(interval == null) interval = new verb_core_Interval(0,polyline.points.length != 0?polyline.points.length - 1:0);
	this._interval = interval;
};
$hxClasses["verb.core.LazyPolylineBoundingBoxTree"] = verb_core_LazyPolylineBoundingBoxTree;
verb_core_LazyPolylineBoundingBoxTree.__name__ = ["verb","core","LazyPolylineBoundingBoxTree"];
verb_core_LazyPolylineBoundingBoxTree.__interfaces__ = [verb_eval_IBoundingBoxTree];
verb_core_LazyPolylineBoundingBoxTree.prototype = {
	split: function() {
		var min = this._interval.min;
		var max = this._interval.max;
		var pivot = min + Math.ceil((max - min) / 2);
		var l = new verb_core_Interval(min,pivot);
		var r = new verb_core_Interval(pivot,max);
		return new verb_core_Pair(new verb_core_LazyPolylineBoundingBoxTree(this._polyline,l),new verb_core_LazyPolylineBoundingBoxTree(this._polyline,r));
	}
	,boundingBox: function() {
		if(this._boundingBox == null) this._boundingBox = new verb_core_BoundingBox(this._polyline.points);
		return this._boundingBox;
	}
	,'yield': function() {
		return this._interval.min;
	}
	,indivisible: function(tolerance) {
		return this._interval.max - this._interval.min == 1;
	}
	,empty: function() {
		return this._interval.max - this._interval.min == 0;
	}
	,__class__: verb_core_LazyPolylineBoundingBoxTree
};
var verb_core_LazySurfaceBoundingBoxTree = function(surface,splitV,knotTolU,knotTolV) {
	if(splitV == null) splitV = false;
	this._boundingBox = null;
	this._surface = surface;
	this._splitV = splitV;
	if(knotTolU == null) knotTolU = verb_core_Vec.domain(surface.knotsU) / 16;
	if(knotTolV == null) knotTolV = verb_core_Vec.domain(surface.knotsV) / 16;
	this._knotTolU = knotTolU;
	this._knotTolV = knotTolV;
};
$hxClasses["verb.core.LazySurfaceBoundingBoxTree"] = verb_core_LazySurfaceBoundingBoxTree;
verb_core_LazySurfaceBoundingBoxTree.__name__ = ["verb","core","LazySurfaceBoundingBoxTree"];
verb_core_LazySurfaceBoundingBoxTree.__interfaces__ = [verb_eval_IBoundingBoxTree];
verb_core_LazySurfaceBoundingBoxTree.prototype = {
	split: function() {
		var min;
		var max;
		if(this._splitV) {
			min = verb_core_ArrayExtensions.first(this._surface.knotsV);
			max = verb_core_ArrayExtensions.last(this._surface.knotsV);
		} else {
			min = verb_core_ArrayExtensions.first(this._surface.knotsU);
			max = verb_core_ArrayExtensions.last(this._surface.knotsU);
		}
		var dom = max - min;
		var pivot = (min + max) / 2.0;
		var srfs = verb_eval_Divide.surfaceSplit(this._surface,pivot,this._splitV);
		return new verb_core_Pair(new verb_core_LazySurfaceBoundingBoxTree(srfs[0],!this._splitV,this._knotTolU,this._knotTolV),new verb_core_LazySurfaceBoundingBoxTree(srfs[1],!this._splitV,this._knotTolU,this._knotTolV));
	}
	,boundingBox: function() {
		if(this._boundingBox == null) {
			this._boundingBox = new verb_core_BoundingBox();
			var _g = 0;
			var _g1 = this._surface.controlPoints;
			while(_g < _g1.length) {
				var row = _g1[_g];
				++_g;
				this._boundingBox.addRange(verb_eval_Eval.dehomogenize1d(row));
			}
		}
		return this._boundingBox;
	}
	,'yield': function() {
		return this._surface;
	}
	,indivisible: function(tolerance) {
		return verb_core_Vec.domain(this._surface.knotsV) < this._knotTolV && verb_core_Vec.domain(this._surface.knotsU) < this._knotTolU;
	}
	,empty: function() {
		return false;
	}
	,__class__: verb_core_LazySurfaceBoundingBoxTree
};
var verb_core_Mat = $hx_exports.core.Mat = function() { };
$hxClasses["verb.core.Mat"] = verb_core_Mat;
verb_core_Mat.__name__ = ["verb","core","Mat"];
verb_core_Mat.mul = function(a,b) {
	var _g = [];
	var _g2 = 0;
	var _g1 = b.length;
	while(_g2 < _g1) {
		var i = _g2++;
		_g.push(verb_core_Vec.mul(a,b[i]));
	}
	return _g;
};
verb_core_Mat.mult = function(x,y) {
	var p;
	var q;
	var r;
	var ret;
	var foo;
	var bar;
	var woo;
	var i0;
	var k0;
	var p0;
	var r0;
	p = x.length;
	q = y.length;
	r = y[0].length;
	ret = [];
	var i = p - 1;
	var j = 0;
	var k = 0;
	while(i >= 0) {
		foo = [];
		bar = x[i];
		k = r - 1;
		while(k >= 0) {
			woo = bar[q - 1] * y[q - 1][k];
			j = q - 2;
			while(j >= 1) {
				i0 = j - 1;
				woo += bar[j] * y[j][k] + bar[i0] * y[i0][k];
				j -= 2;
			}
			if(j == 0) woo += bar[0] * y[0][k];
			foo[k] = woo;
			k--;
		}
		ret[i] = foo;
		i--;
	}
	return ret;
};
verb_core_Mat.add = function(a,b) {
	var _g = [];
	var _g2 = 0;
	var _g1 = a.length;
	while(_g2 < _g1) {
		var i = _g2++;
		_g.push(verb_core_Vec.add(a[i],b[i]));
	}
	return _g;
};
verb_core_Mat.div = function(a,b) {
	var _g = [];
	var _g2 = 0;
	var _g1 = a.length;
	while(_g2 < _g1) {
		var i = _g2++;
		_g.push(verb_core_Vec.div(a[i],b));
	}
	return _g;
};
verb_core_Mat.sub = function(a,b) {
	var _g = [];
	var _g2 = 0;
	var _g1 = a.length;
	while(_g2 < _g1) {
		var i = _g2++;
		_g.push(verb_core_Vec.sub(a[i],b[i]));
	}
	return _g;
};
verb_core_Mat.dot = function(a,b) {
	var _g = [];
	var _g2 = 0;
	var _g1 = a.length;
	while(_g2 < _g1) {
		var i = _g2++;
		_g.push(verb_core_Vec.dot(a[i],b));
	}
	return _g;
};
verb_core_Mat.identity = function(n) {
	var zeros = verb_core_Vec.zeros2d(n,n);
	var _g = 0;
	while(_g < n) {
		var i = _g++;
		zeros[i][i] = 1.0;
	}
	return zeros;
};
verb_core_Mat.transpose = function(a) {
	if(a.length == 0) return [];
	var _g = [];
	var _g2 = 0;
	var _g1 = a[0].length;
	while(_g2 < _g1) {
		var i = _g2++;
		_g.push((function($this) {
			var $r;
			var _g3 = [];
			{
				var _g5 = 0;
				var _g4 = a.length;
				while(_g5 < _g4) {
					var j = _g5++;
					_g3.push(a[j][i]);
				}
			}
			$r = _g3;
			return $r;
		}(this)));
	}
	return _g;
};
verb_core_Mat.solve = function(A,b) {
	return verb_core_Mat.LUsolve(verb_core_Mat.LU(A),b);
};
verb_core_Mat.LUsolve = function(LUP,b) {
	var i;
	var j;
	var LU = LUP.LU;
	var n = LU.length;
	var x = b.slice();
	var P = LUP.P;
	var Pi;
	var LUi;
	var LUii;
	var tmp;
	i = n - 1;
	while(i != -1) {
		x[i] = b[i];
		--i;
	}
	i = 0;
	while(i < n) {
		Pi = P[i];
		if(P[i] != i) {
			tmp = x[i];
			x[i] = x[Pi];
			x[Pi] = tmp;
		}
		LUi = LU[i];
		j = 0;
		while(j < i) {
			x[i] -= x[j] * LUi[j];
			++j;
		}
		++i;
	}
	i = n - 1;
	while(i >= 0) {
		LUi = LU[i];
		j = i + 1;
		while(j < n) {
			x[i] -= x[j] * LUi[j];
			++j;
		}
		x[i] /= LUi[i];
		--i;
	}
	return x;
};
verb_core_Mat.LU = function(A) {
	var abs = Math.abs;
	var i;
	var j;
	var k;
	var absAjk;
	var Akk;
	var Ak;
	var Pk;
	var Ai;
	var max;
	var _g = [];
	var _g2 = 0;
	var _g1 = A.length;
	while(_g2 < _g1) {
		var i1 = _g2++;
		_g.push(A[i1].slice());
	}
	A = _g;
	var n = A.length;
	var n1 = n - 1;
	var P = [];
	k = 0;
	while(k < n) {
		Pk = k;
		Ak = A[k];
		max = Math.abs(Ak[k]);
		j = k + 1;
		while(j < n) {
			absAjk = Math.abs(A[j][k]);
			if(max < absAjk) {
				max = absAjk;
				Pk = j;
			}
			++j;
		}
		P[k] = Pk;
		if(Pk != k) {
			A[k] = A[Pk];
			A[Pk] = Ak;
			Ak = A[k];
		}
		Akk = Ak[k];
		i = k + 1;
		while(i < n) {
			A[i][k] /= Akk;
			++i;
		}
		i = k + 1;
		while(i < n) {
			Ai = A[i];
			j = k + 1;
			while(j < n1) {
				Ai[j] -= Ai[k] * Ak[j];
				++j;
				Ai[j] -= Ai[k] * Ak[j];
				++j;
			}
			if(j == n1) Ai[j] -= Ai[k] * Ak[j];
			++i;
		}
		++k;
	}
	return new verb_core__$Mat_LUDecomp(A,P);
};
var verb_core__$Mat_LUDecomp = function(lu,p) {
	this.LU = lu;
	this.P = p;
};
$hxClasses["verb.core._Mat.LUDecomp"] = verb_core__$Mat_LUDecomp;
verb_core__$Mat_LUDecomp.__name__ = ["verb","core","_Mat","LUDecomp"];
verb_core__$Mat_LUDecomp.prototype = {
	__class__: verb_core__$Mat_LUDecomp
};
var verb_core_Mesh = $hx_exports.core.Mesh = function() { };
$hxClasses["verb.core.Mesh"] = verb_core_Mesh;
verb_core_Mesh.__name__ = ["verb","core","Mesh"];
verb_core_Mesh.getTriangleNorm = function(points,tri) {
	var v0 = points[tri[0]];
	var v1 = points[tri[1]];
	var v2 = points[tri[2]];
	var u = verb_core_Vec.sub(v1,v0);
	var v = verb_core_Vec.sub(v2,v0);
	var n = verb_core_Vec.cross(u,v);
	return verb_core_Vec.mul(1 / verb_core_Vec.norm(n),n);
};
verb_core_Mesh.makeMeshAabb = function(mesh,faceIndices) {
	var bb = new verb_core_BoundingBox();
	var _g = 0;
	while(_g < faceIndices.length) {
		var x = faceIndices[_g];
		++_g;
		bb.add(mesh.points[mesh.faces[x][0]]);
		bb.add(mesh.points[mesh.faces[x][1]]);
		bb.add(mesh.points[mesh.faces[x][2]]);
	}
	return bb;
};
verb_core_Mesh.sortTrianglesOnLongestAxis = function(bb,mesh,faceIndices) {
	var longAxis = bb.getLongestAxis();
	var minCoordFaceMap = [];
	var _g = 0;
	while(_g < faceIndices.length) {
		var faceIndex = faceIndices[_g];
		++_g;
		var tri_min = verb_core_Mesh.getMinCoordOnAxis(mesh.points,mesh.faces[faceIndex],longAxis);
		minCoordFaceMap.push(new verb_core_Pair(tri_min,faceIndex));
	}
	minCoordFaceMap.sort(function(a,b) {
		var a0 = a.item0;
		var b0 = b.item0;
		if(a0 == b0) return 0; else if(a0 > b0) return 1; else return -1;
	});
	var sortedFaceIndices = [];
	var _g1 = 0;
	var _g2 = minCoordFaceMap.length;
	while(_g1 < _g2) {
		var i = _g1++;
		sortedFaceIndices.push(minCoordFaceMap[i].item1);
	}
	return sortedFaceIndices;
};
verb_core_Mesh.getMinCoordOnAxis = function(points,tri,axis) {
	var min = Infinity;
	var _g = 0;
	while(_g < 3) {
		var i = _g++;
		var coord = points[tri[i]][axis];
		if(coord < min) min = coord;
	}
	return min;
};
verb_core_Mesh.getTriangleCentroid = function(points,tri) {
	var centroid = [0.0,0.0,0.0];
	var _g = 0;
	while(_g < 3) {
		var i = _g++;
		var _g1 = 0;
		while(_g1 < 3) {
			var j = _g1++;
			centroid[j] += points[tri[i]][j];
		}
	}
	var _g2 = 0;
	while(_g2 < 3) {
		var i1 = _g2++;
		centroid[i1] /= 3;
	}
	return centroid;
};
verb_core_Mesh.triangleUVFromPoint = function(mesh,faceIndex,f) {
	var tri = mesh.faces[faceIndex];
	var p1 = mesh.points[tri[0]];
	var p2 = mesh.points[tri[1]];
	var p3 = mesh.points[tri[2]];
	var uv1 = mesh.uvs[tri[0]];
	var uv2 = mesh.uvs[tri[1]];
	var uv3 = mesh.uvs[tri[2]];
	var f1 = verb_core_Vec.sub(p1,f);
	var f2 = verb_core_Vec.sub(p2,f);
	var f3 = verb_core_Vec.sub(p3,f);
	var a = verb_core_Vec.norm(verb_core_Vec.cross(verb_core_Vec.sub(p1,p2),verb_core_Vec.sub(p1,p3)));
	var a1 = verb_core_Vec.norm(verb_core_Vec.cross(f2,f3)) / a;
	var a2 = verb_core_Vec.norm(verb_core_Vec.cross(f3,f1)) / a;
	var a3 = verb_core_Vec.norm(verb_core_Vec.cross(f1,f2)) / a;
	return verb_core_Vec.add(verb_core_Vec.mul(a1,uv1),verb_core_Vec.add(verb_core_Vec.mul(a2,uv2),verb_core_Vec.mul(a3,uv3)));
};
var verb_core_MeshBoundingBoxTree = function(mesh,faceIndices) {
	this._empty = false;
	this._face = -1;
	if(faceIndices == null) {
		var _g = [];
		var _g2 = 0;
		var _g1 = mesh.faces.length;
		while(_g2 < _g1) {
			var i = _g2++;
			_g.push(i);
		}
		faceIndices = _g;
	}
	this._boundingBox = verb_core_Mesh.makeMeshAabb(mesh,faceIndices);
	if(faceIndices.length < 1) {
		this._empty = true;
		return;
	} else if(faceIndices.length < 2) {
		this._face = faceIndices[0];
		return;
	}
	var $as = verb_core_Mesh.sortTrianglesOnLongestAxis(this._boundingBox,mesh,faceIndices);
	var l = verb_core_ArrayExtensions.left($as);
	var r = verb_core_ArrayExtensions.right($as);
	this._children = new verb_core_Pair(new verb_core_MeshBoundingBoxTree(mesh,l),new verb_core_MeshBoundingBoxTree(mesh,r));
};
$hxClasses["verb.core.MeshBoundingBoxTree"] = verb_core_MeshBoundingBoxTree;
verb_core_MeshBoundingBoxTree.__name__ = ["verb","core","MeshBoundingBoxTree"];
verb_core_MeshBoundingBoxTree.__interfaces__ = [verb_eval_IBoundingBoxTree];
verb_core_MeshBoundingBoxTree.prototype = {
	split: function() {
		return this._children;
	}
	,boundingBox: function() {
		return this._boundingBox;
	}
	,'yield': function() {
		return this._face;
	}
	,indivisible: function(tolerance) {
		return this._children == null;
	}
	,empty: function() {
		return this._empty;
	}
	,__class__: verb_core_MeshBoundingBoxTree
};
var verb_core_Minimizer = $hx_exports.core.Minimizer = function() { };
$hxClasses["verb.core.Minimizer"] = verb_core_Minimizer;
verb_core_Minimizer.__name__ = ["verb","core","Minimizer"];
verb_core_Minimizer.uncmin = function(f,x0,tol,gradient,maxit) {
	if(tol == null) tol = 1e-8;
	if(gradient == null) gradient = function(x) {
		return verb_core_Minimizer.numericalGradient(f,x);
	};
	if(maxit == null) maxit = 1000;
	x0 = x0.slice(0);
	var n = x0.length;
	var f0 = f(x0);
	var f1 = f0;
	var df0;
	if(isNaN(f0)) throw new js__$Boot_HaxeError("uncmin: f(x0) is a NaN!");
	tol = Math.max(tol,verb_core_Constants.EPSILON);
	var step;
	var g0;
	var g1;
	var H1 = verb_core_Mat.identity(n);
	var it = 0;
	var i;
	var s = [];
	var x1;
	var y;
	var Hy;
	var Hs;
	var ys;
	var i0;
	var t;
	var nstep;
	var t1;
	var t2;
	var msg = "";
	g0 = gradient(x0);
	while(it < maxit) {
		if(!verb_core_Vec.all(verb_core_Vec.finite(g0))) {
			msg = "Gradient has Infinity or NaN";
			break;
		}
		step = verb_core_Vec.neg(verb_core_Mat.dot(H1,g0));
		if(!verb_core_Vec.all(verb_core_Vec.finite(step))) {
			msg = "Search direction has Infinity or NaN";
			break;
		}
		nstep = verb_core_Vec.norm(step);
		if(nstep < tol) {
			msg = "Newton step smaller than tol";
			break;
		}
		t = 1.0;
		df0 = verb_core_Vec.dot(g0,step);
		x1 = x0;
		while(it < maxit) {
			if(t * nstep < tol) break;
			s = verb_core_Vec.mul(t,step);
			x1 = verb_core_Vec.add(x0,s);
			f1 = f(x1);
			if(f1 - f0 >= 0.1 * t * df0 || isNaN(f1)) {
				t *= 0.5;
				++it;
				continue;
			}
			break;
		}
		if(t * nstep < tol) {
			msg = "Line search step size smaller than tol";
			break;
		}
		if(it == maxit) {
			msg = "maxit reached during line search";
			break;
		}
		g1 = gradient(x1);
		y = verb_core_Vec.sub(g1,g0);
		ys = verb_core_Vec.dot(y,s);
		Hy = verb_core_Mat.dot(H1,y);
		H1 = verb_core_Mat.sub(verb_core_Mat.add(H1,verb_core_Mat.mul((ys + verb_core_Vec.dot(y,Hy)) / (ys * ys),verb_core_Minimizer.tensor(s,s))),verb_core_Mat.div(verb_core_Mat.add(verb_core_Minimizer.tensor(Hy,s),verb_core_Minimizer.tensor(s,Hy)),ys));
		x0 = x1;
		f0 = f1;
		g0 = g1;
		++it;
	}
	return new verb_core_MinimizationResult(x0,f0,g0,H1,it,msg);
};
verb_core_Minimizer.numericalGradient = function(f,x) {
	var n = x.length;
	var f0 = f(x);
	if(f0 == NaN) throw new js__$Boot_HaxeError("gradient: f(x) is a NaN!");
	var i;
	var x0 = x.slice(0);
	var f1;
	var f2;
	var J = [];
	var errest;
	var roundoff;
	var eps = 1e-3;
	var t0;
	var t1;
	var t2;
	var it = 0;
	var d1;
	var d2;
	var N;
	var _g = 0;
	while(_g < n) {
		var i1 = _g++;
		var h = Math.max(1e-6 * f0,1e-8);
		while(true) {
			++it;
			if(it > 20) throw new js__$Boot_HaxeError("Numerical gradient fails");
			x0[i1] = x[i1] + h;
			f1 = f(x0);
			x0[i1] = x[i1] - h;
			f2 = f(x0);
			x0[i1] = x[i1];
			if(isNaN(f1) || isNaN(f2)) {
				h /= 16;
				continue;
			}
			J[i1] = (f1 - f2) / (2 * h);
			t0 = x[i1] - h;
			t1 = x[i1];
			t2 = x[i1] + h;
			d1 = (f1 - f0) / h;
			d2 = (f0 - f2) / h;
			N = verb_core_Vec.max([Math.abs(J[i1]),Math.abs(f0),Math.abs(f1),Math.abs(f2),Math.abs(t0),Math.abs(t1),Math.abs(t2),1e-8]);
			errest = Math.min(verb_core_Vec.max([Math.abs(d1 - J[i1]),Math.abs(d2 - J[i1]),Math.abs(d1 - d2)]) / N,h / N);
			if(errest > eps) h /= 16; else break;
		}
	}
	return J;
};
verb_core_Minimizer.tensor = function(x,y) {
	var m = x.length;
	var n = y.length;
	var A = [];
	var Ai;
	var xi;
	var i = m - 1;
	while(i >= 0) {
		Ai = [];
		xi = x[i];
		var j = n - 1;
		while(j >= 3) {
			Ai[j] = xi * y[j];
			--j;
			Ai[j] = xi * y[j];
			--j;
			Ai[j] = xi * y[j];
			--j;
			Ai[j] = xi * y[j];
			--j;
		}
		while(j >= 0) {
			Ai[j] = xi * y[j];
			--j;
		}
		A[i] = Ai;
		i--;
	}
	return A;
};
var verb_core_MinimizationResult = function(solution,value,gradient,invHessian,iterations,message) {
	this.solution = solution;
	this.value = value;
	this.gradient = gradient;
	this.invHessian = invHessian;
	this.iterations = iterations;
	this.message = message;
};
$hxClasses["verb.core.MinimizationResult"] = verb_core_MinimizationResult;
verb_core_MinimizationResult.__name__ = ["verb","core","MinimizationResult"];
verb_core_MinimizationResult.prototype = {
	__class__: verb_core_MinimizationResult
};
var verb_core_ISerializable = function() { };
$hxClasses["verb.core.ISerializable"] = verb_core_ISerializable;
verb_core_ISerializable.__name__ = ["verb","core","ISerializable"];
verb_core_ISerializable.prototype = {
	__class__: verb_core_ISerializable
};
var verb_core_Deserializer = $hx_exports.core.Deserializer = function() { };
$hxClasses["verb.core.Deserializer"] = verb_core_Deserializer;
verb_core_Deserializer.__name__ = ["verb","core","Deserializer"];
verb_core_Deserializer.deserialize = function(s) {
	var unserializer = new haxe_Unserializer(s);
	var r = unserializer.unserialize();
	return r;
};
var verb_core_Trig = $hx_exports.core.Trig = function() { };
$hxClasses["verb.core.Trig"] = verb_core_Trig;
verb_core_Trig.__name__ = ["verb","core","Trig"];
verb_core_Trig.isPointInPlane = function(pt,p,tol) {
	return Math.abs(verb_core_Vec.dot(verb_core_Vec.sub(pt,p.origin),p.normal)) < tol;
};
verb_core_Trig.distToSegment = function(a,b,c) {
	var res = verb_core_Trig.segmentClosestPoint(b,a,c,0.0,1.0);
	return verb_core_Vec.dist(b,res.pt);
};
verb_core_Trig.rayClosestPoint = function(pt,o,r) {
	var o2pt = verb_core_Vec.sub(pt,o);
	var do2ptr = verb_core_Vec.dot(o2pt,r);
	var proj = verb_core_Vec.add(o,verb_core_Vec.mul(do2ptr,r));
	return proj;
};
verb_core_Trig.distToRay = function(pt,o,r) {
	var d = verb_core_Trig.rayClosestPoint(pt,o,r);
	var dif = verb_core_Vec.sub(d,pt);
	return verb_core_Vec.norm(dif);
};
verb_core_Trig.threePointsAreFlat = function(p1,p2,p3,tol) {
	var p2mp1 = verb_core_Vec.sub(p2,p1);
	var p3mp1 = verb_core_Vec.sub(p3,p1);
	var norm = verb_core_Vec.cross(p2mp1,p3mp1);
	var area = verb_core_Vec.dot(norm,norm);
	return area < tol;
};
verb_core_Trig.segmentClosestPoint = function(pt,segpt0,segpt1,u0,u1) {
	var dif = verb_core_Vec.sub(segpt1,segpt0);
	var l = verb_core_Vec.norm(dif);
	if(l < verb_core_Constants.EPSILON) return { u : u0, pt : segpt0};
	var o = segpt0;
	var r = verb_core_Vec.mul(1 / l,dif);
	var o2pt = verb_core_Vec.sub(pt,o);
	var do2ptr = verb_core_Vec.dot(o2pt,r);
	if(do2ptr < 0) return { u : u0, pt : segpt0}; else if(do2ptr > l) return { u : u1, pt : segpt1};
	return { u : u0 + (u1 - u0) * do2ptr / l, pt : verb_core_Vec.add(o,verb_core_Vec.mul(do2ptr,r))};
};
var verb_core_Vec = $hx_exports.core.Vec = function() { };
$hxClasses["verb.core.Vec"] = verb_core_Vec;
verb_core_Vec.__name__ = ["verb","core","Vec"];
verb_core_Vec.angleBetween = function(a,b) {
	return Math.acos(verb_core_Vec.dot(a,b) / (verb_core_Vec.norm(a) * verb_core_Vec.norm(b)));
};
verb_core_Vec.positiveAngleBetween = function(a,b,n) {
	var nab = verb_core_Vec.cross(a,b);
	var al = verb_core_Vec.norm(a);
	var bl = verb_core_Vec.norm(b);
	var abl = al * bl;
	var adb = verb_core_Vec.dot(a,b);
	var sina = verb_core_Vec.norm(nab) / abl;
	var cosa = adb / abl;
	var w = Math.atan2(sina,cosa);
	var s = verb_core_Vec.dot(n,nab);
	if(Math.abs(s) < verb_core_Constants.EPSILON) return w;
	if(s > 0) return w; else return -w;
};
verb_core_Vec.signedAngleBetween = function(a,b,n) {
	var nab = verb_core_Vec.cross(a,b);
	var al = verb_core_Vec.norm(a);
	var bl = verb_core_Vec.norm(b);
	var abl = al * bl;
	var adb = verb_core_Vec.dot(a,b);
	var sina = verb_core_Vec.norm(nab) / abl;
	var cosa = adb / abl;
	var w = Math.atan2(sina,cosa);
	var s = verb_core_Vec.dot(n,nab);
	if(s > 0.0) return w; else return 2 * Math.PI - w;
};
verb_core_Vec.angleBetweenNormalized2d = function(a,b) {
	var perpDot = a[0] * b[1] - a[1] * b[0];
	return Math.atan2(perpDot,verb_core_Vec.dot(a,b));
};
verb_core_Vec.domain = function(a) {
	return verb_core_ArrayExtensions.last(a) - verb_core_ArrayExtensions.first(a);
};
verb_core_Vec.range = function(max) {
	var l = [];
	var f = 0.0;
	var _g = 0;
	while(_g < max) {
		var i = _g++;
		l.push(f);
		f += 1.0;
	}
	return l;
};
verb_core_Vec.span = function(min,max,step) {
	if(step == null) return [];
	if(step < verb_core_Constants.EPSILON) return [];
	if(min > max && step > 0.0) return [];
	if(max > min && step < 0.0) return [];
	var l = [];
	var cur = min;
	while(cur <= max) {
		l.push(cur);
		cur += step;
	}
	return l;
};
verb_core_Vec.neg = function(arr) {
	return arr.map(function(x) {
		return -x;
	});
};
verb_core_Vec.min = function(arr) {
	return Lambda.fold(arr,function(x,a) {
		return Math.min(x,a);
	},Infinity);
};
verb_core_Vec.max = function(arr) {
	return Lambda.fold(arr,function(x,a) {
		return Math.max(x,a);
	},-Infinity);
};
verb_core_Vec.all = function(arr) {
	return Lambda.fold(arr,function(x,a) {
		return a && x;
	},true);
};
verb_core_Vec.finite = function(arr) {
	return arr.map(function(x) {
		return isFinite(x);
	});
};
verb_core_Vec.onRay = function(origin,dir,u) {
	return verb_core_Vec.add(origin,verb_core_Vec.mul(u,dir));
};
verb_core_Vec.lerp = function(i,u,v) {
	return verb_core_Vec.add(verb_core_Vec.mul(i,u),verb_core_Vec.mul(1.0 - i,v));
};
verb_core_Vec.normalized = function(arr) {
	return verb_core_Vec.div(arr,verb_core_Vec.norm(arr));
};
verb_core_Vec.cross = function(u,v) {
	return [u[1] * v[2] - u[2] * v[1],u[2] * v[0] - u[0] * v[2],u[0] * v[1] - u[1] * v[0]];
};
verb_core_Vec.dist = function(a,b) {
	return verb_core_Vec.norm(verb_core_Vec.sub(a,b));
};
verb_core_Vec.distSquared = function(a,b) {
	return verb_core_Vec.normSquared(verb_core_Vec.sub(a,b));
};
verb_core_Vec.sum = function(a) {
	return Lambda.fold(a,function(x,a1) {
		return a1 + x;
	},0);
};
verb_core_Vec.addAll = function(a) {
	var i = $iterator(a)();
	if(!i.hasNext()) return null;
	var f = i.next().length;
	return Lambda.fold(a,function(x,a1) {
		return verb_core_Vec.add(a1,x);
	},verb_core_Vec.rep(f,0.0));
};
verb_core_Vec.addAllMutate = function(a) {
	var f = a[0];
	var _g1 = 1;
	var _g = a.length;
	while(_g1 < _g) {
		var i = _g1++;
		verb_core_Vec.addMutate(f,a[i]);
	}
};
verb_core_Vec.addMulMutate = function(a,s,b) {
	var _g1 = 0;
	var _g = a.length;
	while(_g1 < _g) {
		var i = _g1++;
		a[i] = a[i] + s * b[i];
	}
};
verb_core_Vec.subMulMutate = function(a,s,b) {
	var _g1 = 0;
	var _g = a.length;
	while(_g1 < _g) {
		var i = _g1++;
		a[i] = a[i] - s * b[i];
	}
};
verb_core_Vec.addMutate = function(a,b) {
	var _g1 = 0;
	var _g = a.length;
	while(_g1 < _g) {
		var i = _g1++;
		a[i] = a[i] + b[i];
	}
};
verb_core_Vec.subMutate = function(a,b) {
	var _g1 = 0;
	var _g = a.length;
	while(_g1 < _g) {
		var i = _g1++;
		a[i] = a[i] - b[i];
	}
};
verb_core_Vec.mulMutate = function(a,b) {
	var _g1 = 0;
	var _g = b.length;
	while(_g1 < _g) {
		var i = _g1++;
		b[i] = b[i] * a;
	}
};
verb_core_Vec.norm = function(a) {
	var norm2 = verb_core_Vec.normSquared(a);
	if(norm2 != 0.0) return Math.sqrt(norm2); else return norm2;
};
verb_core_Vec.normSquared = function(a) {
	return Lambda.fold(a,function(x,a1) {
		return a1 + x * x;
	},0);
};
verb_core_Vec.rep = function(num,ele) {
	var _g = [];
	var _g1 = 0;
	while(_g1 < num) {
		var i = _g1++;
		_g.push(ele);
	}
	return _g;
};
verb_core_Vec.zeros1d = function(rows) {
	var _g = [];
	var _g1 = 0;
	while(_g1 < rows) {
		var i = _g1++;
		_g.push(0.0);
	}
	return _g;
};
verb_core_Vec.zeros2d = function(rows,cols) {
	var _g = [];
	var _g1 = 0;
	while(_g1 < rows) {
		var i = _g1++;
		_g.push(verb_core_Vec.zeros1d(cols));
	}
	return _g;
};
verb_core_Vec.zeros3d = function(rows,cols,depth) {
	var _g = [];
	var _g1 = 0;
	while(_g1 < rows) {
		var i = _g1++;
		_g.push(verb_core_Vec.zeros2d(cols,depth));
	}
	return _g;
};
verb_core_Vec.dot = function(a,b) {
	var sum = 0;
	var _g1 = 0;
	var _g = a.length;
	while(_g1 < _g) {
		var i = _g1++;
		sum += a[i] * b[i];
	}
	return sum;
};
verb_core_Vec.add = function(a,b) {
	var _g = [];
	var _g2 = 0;
	var _g1 = a.length;
	while(_g2 < _g1) {
		var i = _g2++;
		_g.push(a[i] + b[i]);
	}
	return _g;
};
verb_core_Vec.mul = function(a,b) {
	var _g = [];
	var _g2 = 0;
	var _g1 = b.length;
	while(_g2 < _g1) {
		var i = _g2++;
		_g.push(a * b[i]);
	}
	return _g;
};
verb_core_Vec.div = function(a,b) {
	var _g = [];
	var _g2 = 0;
	var _g1 = a.length;
	while(_g2 < _g1) {
		var i = _g2++;
		_g.push(a[i] / b);
	}
	return _g;
};
verb_core_Vec.sub = function(a,b) {
	var _g = [];
	var _g2 = 0;
	var _g1 = a.length;
	while(_g2 < _g1) {
		var i = _g2++;
		_g.push(a[i] - b[i]);
	}
	return _g;
};
verb_core_Vec.isZero = function(vec) {
	var _g1 = 0;
	var _g = vec.length;
	while(_g1 < _g) {
		var i = _g1++;
		if(Math.abs(vec[i]) > verb_core_Constants.TOLERANCE) return false;
	}
	return true;
};
verb_core_Vec.sortedSetUnion = function(a,b) {
	var merged = [];
	var ai = 0;
	var bi = 0;
	while(ai < a.length || bi < b.length) {
		if(ai >= a.length) {
			merged.push(b[bi]);
			bi++;
			continue;
		} else if(bi >= b.length) {
			merged.push(a[ai]);
			ai++;
			continue;
		}
		var diff = a[ai] - b[bi];
		if(Math.abs(diff) < verb_core_Constants.EPSILON) {
			merged.push(a[ai]);
			ai++;
			bi++;
			continue;
		}
		if(diff > 0.0) {
			merged.push(b[bi]);
			bi++;
			continue;
		}
		merged.push(a[ai]);
		ai++;
	}
	return merged;
};
verb_core_Vec.sortedSetSub = function(a,b) {
	var result = [];
	var ai = 0;
	var bi = 0;
	while(ai < a.length) {
		if(bi >= b.length) {
			result.push(a[ai]);
			ai++;
			continue;
		}
		if(Math.abs(a[ai] - b[bi]) < verb_core_Constants.EPSILON) {
			ai++;
			bi++;
			continue;
		}
		result.push(a[ai]);
		ai++;
	}
	return result;
};
var verb_eval_Analyze = $hx_exports.eval.Analyze = function() { };
$hxClasses["verb.eval.Analyze"] = verb_eval_Analyze;
verb_eval_Analyze.__name__ = ["verb","eval","Analyze"];
verb_eval_Analyze.knotMultiplicities = function(knots) {
	var mults = [new verb_eval_KnotMultiplicity(knots[0],0)];
	var curr = mults[0];
	var _g = 0;
	while(_g < knots.length) {
		var knot = knots[_g];
		++_g;
		if(Math.abs(knot - curr.knot) > verb_core_Constants.EPSILON) {
			curr = new verb_eval_KnotMultiplicity(knot,0);
			mults.push(curr);
		}
		curr.inc();
	}
	return mults;
};
verb_eval_Analyze.isRationalSurfaceClosed = function(surface,uDir) {
	if(uDir == null) uDir = true;
	var cpts;
	if(uDir) cpts = surface.controlPoints; else cpts = verb_core_Mat.transpose(surface.controlPoints);
	var _g1 = 0;
	var _g = cpts[0].length;
	while(_g1 < _g) {
		var i = _g1++;
		var test = verb_core_Vec.dist(verb_core_ArrayExtensions.first(cpts)[i],verb_core_ArrayExtensions.last(cpts)[i]) < verb_core_Constants.EPSILON;
		if(!test) return false;
	}
	return true;
};
verb_eval_Analyze.rationalSurfaceClosestPoint = function(surface,p) {
	var uv = verb_eval_Analyze.rationalSurfaceClosestParam(surface,p);
	return verb_eval_Eval.rationalSurfacePoint(surface,uv[0],uv[1]);
};
verb_eval_Analyze.rationalSurfaceClosestParam = function(surface,p) {
	var maxits = 5;
	var i = 0;
	var e;
	var eps1 = 0.0001;
	var eps2 = 0.0005;
	var dif;
	var minu = surface.knotsU[0];
	var maxu = verb_core_ArrayExtensions.last(surface.knotsU);
	var minv = surface.knotsV[0];
	var maxv = verb_core_ArrayExtensions.last(surface.knotsV);
	var closedu = verb_eval_Analyze.isRationalSurfaceClosed(surface);
	var closedv = verb_eval_Analyze.isRationalSurfaceClosed(surface,false);
	var cuv;
	var tess = verb_eval_Tess.rationalSurfaceAdaptive(surface,new verb_eval_AdaptiveRefinementOptions());
	var dmin = Infinity;
	var _g1 = 0;
	var _g = tess.points.length;
	while(_g1 < _g) {
		var i1 = _g1++;
		var x = tess.points[i1];
		var d1 = verb_core_Vec.normSquared(verb_core_Vec.sub(p,x));
		if(d1 < dmin) {
			dmin = d1;
			cuv = tess.uvs[i1];
		}
	}
	var f = function(uv) {
		return verb_eval_Eval.rationalSurfaceDerivatives(surface,uv[0],uv[1],2);
	};
	var n = function(uv1,e1,r) {
		var Su = e1[1][0];
		var Sv = e1[0][1];
		var Suu = e1[2][0];
		var Svv = e1[0][2];
		var Suv = e1[1][1];
		var Svu = e1[1][1];
		var f1 = verb_core_Vec.dot(Su,r);
		var g = verb_core_Vec.dot(Sv,r);
		var k = [-f1,-g];
		var J00 = verb_core_Vec.dot(Su,Su) + verb_core_Vec.dot(Suu,r);
		var J01 = verb_core_Vec.dot(Su,Sv) + verb_core_Vec.dot(Suv,r);
		var J10 = verb_core_Vec.dot(Su,Sv) + verb_core_Vec.dot(Svu,r);
		var J11 = verb_core_Vec.dot(Sv,Sv) + verb_core_Vec.dot(Svv,r);
		var J = [[J00,J01],[J10,J11]];
		var d = verb_core_Mat.solve(J,k);
		return verb_core_Vec.add(d,uv1);
	};
	while(i < maxits) {
		e = f(cuv);
		dif = verb_core_Vec.sub(e[0][0],p);
		var c1v = verb_core_Vec.norm(dif);
		var c2an = verb_core_Vec.dot(e[1][0],dif);
		var c2ad = verb_core_Vec.norm(e[1][0]) * c1v;
		var c2bn = verb_core_Vec.dot(e[0][1],dif);
		var c2bd = verb_core_Vec.norm(e[0][1]) * c1v;
		var c2av = c2an / c2ad;
		var c2bv = c2bn / c2bd;
		var c1 = c1v < eps1;
		var c2a = c2av < eps2;
		var c2b = c2bv < eps2;
		if(c1 && c2a && c2b) return cuv;
		var ct = n(cuv,e,dif);
		if(ct[0] < minu) if(closedu) ct = [maxu - (ct[0] - minu),ct[1]]; else ct = [minu + verb_core_Constants.EPSILON,ct[1]]; else if(ct[0] > maxu) if(closedu) ct = [minu + (ct[0] - maxu),ct[1]]; else ct = [maxu - verb_core_Constants.EPSILON,ct[1]];
		if(ct[1] < minv) if(closedv) ct = [ct[0],maxv - (ct[1] - minv)]; else ct = [ct[0],minv + verb_core_Constants.EPSILON]; else if(ct[1] > maxv) if(closedv) ct = [ct[0],minv + (ct[0] - maxv)]; else ct = [ct[0],maxv - verb_core_Constants.EPSILON];
		var c3v0 = verb_core_Vec.norm(verb_core_Vec.mul(ct[0] - cuv[0],e[1][0]));
		var c3v1 = verb_core_Vec.norm(verb_core_Vec.mul(ct[1] - cuv[1],e[0][1]));
		if(c3v0 + c3v1 < eps1) return cuv;
		cuv = ct;
		i++;
	}
	return cuv;
};
verb_eval_Analyze.rationalCurveClosestPoint = function(curve,p) {
	return verb_eval_Eval.rationalCurvePoint(curve,verb_eval_Analyze.rationalCurveClosestParam(curve,p));
};
verb_eval_Analyze.rationalCurveClosestParam = function(curve,p) {
	var min = Infinity;
	var u = 0.0;
	var pts = verb_eval_Tess.rationalCurveRegularSample(curve,curve.controlPoints.length * curve.degree,true);
	var _g1 = 0;
	var _g = pts.length - 1;
	while(_g1 < _g) {
		var i1 = _g1++;
		var u0 = pts[i1][0];
		var u11 = pts[i1 + 1][0];
		var p0 = pts[i1].slice(1);
		var p1 = pts[i1 + 1].slice(1);
		var proj = verb_core_Trig.segmentClosestPoint(p,p0,p1,u0,u11);
		var d1 = verb_core_Vec.norm(verb_core_Vec.sub(p,proj.pt));
		if(d1 < min) {
			min = d1;
			u = proj.u;
		}
	}
	var maxits = 5;
	var i = 0;
	var e;
	var eps1 = 0.0001;
	var eps2 = 0.0005;
	var dif;
	var minu = curve.knots[0];
	var maxu = verb_core_ArrayExtensions.last(curve.knots);
	var closed = verb_core_Vec.normSquared(verb_core_Vec.sub(curve.controlPoints[0],verb_core_ArrayExtensions.last(curve.controlPoints))) < verb_core_Constants.EPSILON;
	var cu = u;
	var f = function(u1) {
		return verb_eval_Eval.rationalCurveDerivatives(curve,u1,2);
	};
	var n = function(u2,e1,d) {
		var f1 = verb_core_Vec.dot(e1[1],d);
		var s0 = verb_core_Vec.dot(e1[2],d);
		var s1 = verb_core_Vec.dot(e1[1],e1[1]);
		var df = s0 + s1;
		return u2 - f1 / df;
	};
	while(i < maxits) {
		e = f(cu);
		dif = verb_core_Vec.sub(e[0],p);
		var c1v = verb_core_Vec.norm(dif);
		var c2n = verb_core_Vec.dot(e[1],dif);
		var c2d = verb_core_Vec.norm(e[1]) * c1v;
		var c2v = c2n / c2d;
		var c1 = c1v < eps1;
		var c2 = Math.abs(c2v) < eps2;
		if(c1 && c2) return cu;
		var ct = n(cu,e,dif);
		if(ct < minu) if(closed) ct = maxu - (ct - minu); else ct = minu; else if(ct > maxu) if(closed) ct = minu + (ct - maxu); else ct = maxu;
		var c3v = verb_core_Vec.norm(verb_core_Vec.mul(ct - cu,e[1]));
		if(c3v < eps1) return cu;
		cu = ct;
		i++;
	}
	return cu;
};
verb_eval_Analyze.rationalCurveParamAtArcLength = function(curve,len,tol,beziers,bezierLengths) {
	if(tol == null) tol = 1e-3;
	if(len < verb_core_Constants.EPSILON) return curve.knots[0];
	var crvs;
	if(beziers != null) crvs = beziers; else crvs = verb_eval_Modify.decomposeCurveIntoBeziers(curve);
	var i = 0;
	var cc = crvs[i];
	var cl = -verb_core_Constants.EPSILON;
	var bezier_lengths;
	if(bezierLengths != null) bezier_lengths = bezierLengths; else bezier_lengths = [];
	while(cl < len && i < crvs.length) {
		if(i < bezier_lengths.length) bezier_lengths[i] = bezier_lengths[i]; else bezier_lengths[i] = verb_eval_Analyze.rationalBezierCurveArcLength(curve);
		cl += bezier_lengths[i];
		if(len < cl + verb_core_Constants.EPSILON) return verb_eval_Analyze.rationalBezierCurveParamAtArcLength(curve,len,tol,bezier_lengths[i]);
		i++;
	}
	return -1;
};
verb_eval_Analyze.rationalBezierCurveParamAtArcLength = function(curve,len,tol,totalLength) {
	if(len < 0) return curve.knots[0];
	var totalLen;
	if(totalLength != null) totalLen = totalLength; else totalLen = verb_eval_Analyze.rationalBezierCurveArcLength(curve);
	if(len > totalLen) return verb_core_ArrayExtensions.last(curve.knots);
	var start_p = curve.knots[0];
	var start_l = 0.0;
	var end_p = verb_core_ArrayExtensions.last(curve.knots);
	var end_l = totalLen;
	var mid_p = 0.0;
	var mid_l = 0.0;
	var tol1;
	if(tol != null) tol1 = tol; else tol1 = verb_core_Constants.TOLERANCE * 2;
	while(end_l - start_l > tol1) {
		mid_p = (start_p + end_p) / 2;
		mid_l = verb_eval_Analyze.rationalBezierCurveArcLength(curve,mid_p);
		if(mid_l > len) {
			end_p = mid_p;
			end_l = mid_l;
		} else {
			start_p = mid_p;
			start_l = mid_l;
		}
	}
	return (start_p + end_p) / 2;
};
verb_eval_Analyze.rationalCurveArcLength = function(curve,u,gaussDegIncrease) {
	if(gaussDegIncrease == null) gaussDegIncrease = 16;
	if(u == null) u = verb_core_ArrayExtensions.last(curve.knots); else u = u;
	var crvs = verb_eval_Modify.decomposeCurveIntoBeziers(curve);
	var i = 0;
	var cc = crvs[0];
	var sum = 0.0;
	while(i < crvs.length && cc.knots[0] + verb_core_Constants.EPSILON < u) {
		var param = Math.min(verb_core_ArrayExtensions.last(cc.knots),u);
		sum += verb_eval_Analyze.rationalBezierCurveArcLength(cc,param,gaussDegIncrease);
		cc = crvs[++i];
	}
	return sum;
};
verb_eval_Analyze.rationalBezierCurveArcLength = function(curve,u,gaussDegIncrease) {
	if(gaussDegIncrease == null) gaussDegIncrease = 16;
	var u1;
	if(u == null) u1 = verb_core_ArrayExtensions.last(curve.knots); else u1 = u;
	var z = (u1 - curve.knots[0]) / 2;
	var sum = 0.0;
	var gaussDeg = curve.degree + gaussDegIncrease;
	var cu;
	var tan;
	var _g = 0;
	while(_g < gaussDeg) {
		var i = _g++;
		cu = z * verb_eval_Analyze.Tvalues[gaussDeg][i] + z + curve.knots[0];
		tan = verb_eval_Eval.rationalCurveDerivatives(curve,cu,1);
		sum += verb_eval_Analyze.Cvalues[gaussDeg][i] * verb_core_Vec.norm(tan[1]);
	}
	return z * sum;
};
var verb_eval_KnotMultiplicity = $hx_exports.eval.KnotMultiplicity = function(knot,mult) {
	this.knot = knot;
	this.mult = mult;
};
$hxClasses["verb.eval.KnotMultiplicity"] = verb_eval_KnotMultiplicity;
verb_eval_KnotMultiplicity.__name__ = ["verb","eval","KnotMultiplicity"];
verb_eval_KnotMultiplicity.prototype = {
	inc: function() {
		this.mult++;
	}
	,__class__: verb_eval_KnotMultiplicity
};
var verb_eval_Check = $hx_exports.eval.Check = function() { };
$hxClasses["verb.eval.Check"] = verb_eval_Check;
verb_eval_Check.__name__ = ["verb","eval","Check"];
verb_eval_Check.isValidKnotVector = function(vec,degree) {
	if(vec.length == 0) return false;
	if(vec.length < (degree + 1) * 2) return false;
	var rep = verb_core_ArrayExtensions.first(vec);
	var _g1 = 0;
	var _g = degree + 1;
	while(_g1 < _g) {
		var i = _g1++;
		if(Math.abs(vec[i] - rep) > verb_core_Constants.EPSILON) return false;
	}
	rep = verb_core_ArrayExtensions.last(vec);
	var _g11 = vec.length - degree - 1;
	var _g2 = vec.length;
	while(_g11 < _g2) {
		var i1 = _g11++;
		if(Math.abs(vec[i1] - rep) > verb_core_Constants.EPSILON) return false;
	}
	return verb_eval_Check.isNonDecreasing(vec);
};
verb_eval_Check.isNonDecreasing = function(vec) {
	var rep = verb_core_ArrayExtensions.first(vec);
	var _g1 = 0;
	var _g = vec.length;
	while(_g1 < _g) {
		var i = _g1++;
		if(vec[i] < rep - verb_core_Constants.EPSILON) return false;
		rep = vec[i];
	}
	return true;
};
verb_eval_Check.isValidNurbsCurveData = function(data) {
	if(data.controlPoints == null) throw new js__$Boot_HaxeError("Control points array cannot be null!");
	if(data.degree == null) throw new js__$Boot_HaxeError("Degree cannot be null!");
	if(data.degree < 1) throw new js__$Boot_HaxeError("Degree must be greater than 1!");
	if(data.knots == null) throw new js__$Boot_HaxeError("Knots cannot be null!");
	if(data.knots.length != data.controlPoints.length + data.degree + 1) throw new js__$Boot_HaxeError("controlPoints.length + degree + 1 must equal knots.length!");
	if(!verb_eval_Check.isValidKnotVector(data.knots,data.degree)) throw new js__$Boot_HaxeError("Invalid knot vector format!  Should begin with degree + 1 repeats and end with degree + 1 repeats!");
	return data;
};
verb_eval_Check.isValidNurbsSurfaceData = function(data) {
	if(data.controlPoints == null) throw new js__$Boot_HaxeError("Control points array cannot be null!");
	if(data.degreeU == null) throw new js__$Boot_HaxeError("DegreeU cannot be null!");
	if(data.degreeV == null) throw new js__$Boot_HaxeError("DegreeV cannot be null!");
	if(data.degreeU < 1) throw new js__$Boot_HaxeError("DegreeU must be greater than 1!");
	if(data.degreeV < 1) throw new js__$Boot_HaxeError("DegreeV must be greater than 1!");
	if(data.knotsU == null) throw new js__$Boot_HaxeError("KnotsU cannot be null!");
	if(data.knotsV == null) throw new js__$Boot_HaxeError("KnotsV cannot be null!");
	if(data.knotsU.length != data.controlPoints.length + data.degreeU + 1) throw new js__$Boot_HaxeError("controlPointsU.length + degreeU + 1 must equal knotsU.length!");
	if(data.knotsV.length != data.controlPoints[0].length + data.degreeV + 1) throw new js__$Boot_HaxeError("controlPointsV.length + degreeV + 1 must equal knotsV.length!");
	if(!verb_eval_Check.isValidKnotVector(data.knotsU,data.degreeU) || !verb_eval_Check.isValidKnotVector(data.knotsV,data.degreeV)) throw new js__$Boot_HaxeError("Invalid knot vector format!  Should begin with degree + 1 repeats and end with degree + 1 repeats!");
	return data;
};
var verb_eval_Divide = $hx_exports.eval.Divide = function() { };
$hxClasses["verb.eval.Divide"] = verb_eval_Divide;
verb_eval_Divide.__name__ = ["verb","eval","Divide"];
verb_eval_Divide.surfaceSplit = function(surface,u,useV) {
	if(useV == null) useV = false;
	var knots;
	var degree;
	var controlPoints;
	if(!useV) {
		controlPoints = verb_core_Mat.transpose(surface.controlPoints);
		knots = surface.knotsU;
		degree = surface.degreeU;
	} else {
		controlPoints = surface.controlPoints;
		knots = surface.knotsV;
		degree = surface.degreeV;
	}
	var knots_to_insert;
	var _g = [];
	var _g2 = 0;
	var _g1 = degree + 1;
	while(_g2 < _g1) {
		var i = _g2++;
		_g.push(u);
	}
	knots_to_insert = _g;
	var newpts0 = [];
	var newpts1 = [];
	var s = verb_eval_Eval.knotSpan(degree,u,knots);
	var res = null;
	var _g11 = 0;
	while(_g11 < controlPoints.length) {
		var cps = controlPoints[_g11];
		++_g11;
		res = verb_eval_Modify.curveKnotRefine(new verb_core_NurbsCurveData(degree,knots,cps),knots_to_insert);
		newpts0.push(res.controlPoints.slice(0,s + 1));
		newpts1.push(res.controlPoints.slice(s + 1));
	}
	var knots0 = res.knots.slice(0,s + degree + 2);
	var knots1 = res.knots.slice(s + 1);
	if(!useV) {
		newpts0 = verb_core_Mat.transpose(newpts0);
		newpts1 = verb_core_Mat.transpose(newpts1);
		return [new verb_core_NurbsSurfaceData(degree,surface.degreeV,knots0,surface.knotsV.slice(),newpts0),new verb_core_NurbsSurfaceData(degree,surface.degreeV,knots1,surface.knotsV.slice(),newpts1)];
	}
	return [new verb_core_NurbsSurfaceData(surface.degreeU,degree,surface.knotsU.slice(),knots0,newpts0),new verb_core_NurbsSurfaceData(surface.degreeU,degree,surface.knotsU.slice(),knots1,newpts1)];
};
verb_eval_Divide.curveSplit = function(curve,u) {
	var degree = curve.degree;
	var controlPoints = curve.controlPoints;
	var knots = curve.knots;
	var knots_to_insert;
	var _g = [];
	var _g2 = 0;
	var _g1 = degree + 1;
	while(_g2 < _g1) {
		var i = _g2++;
		_g.push(u);
	}
	knots_to_insert = _g;
	var res = verb_eval_Modify.curveKnotRefine(curve,knots_to_insert);
	var s = verb_eval_Eval.knotSpan(degree,u,knots);
	var knots0 = res.knots.slice(0,s + degree + 2);
	var knots1 = res.knots.slice(s + 1);
	var cpts0 = res.controlPoints.slice(0,s + 1);
	var cpts1 = res.controlPoints.slice(s + 1);
	return [new verb_core_NurbsCurveData(degree,knots0,cpts0),new verb_core_NurbsCurveData(degree,knots1,cpts1)];
};
verb_eval_Divide.rationalCurveByEqualArcLength = function(curve,num) {
	var tlen = verb_eval_Analyze.rationalCurveArcLength(curve);
	var inc = tlen / num;
	return verb_eval_Divide.rationalCurveByArcLength(curve,inc);
};
verb_eval_Divide.rationalCurveByArcLength = function(curve,l) {
	var crvs = verb_eval_Modify.decomposeCurveIntoBeziers(curve);
	var crvlens = crvs.map(function(x) {
		return verb_eval_Analyze.rationalBezierCurveArcLength(x);
	});
	var totlen = verb_core_Vec.sum(crvlens);
	var pts = [new verb_eval_CurveLengthSample(curve.knots[0],0.0)];
	if(l > totlen) return pts;
	var inc = l;
	var i = 0;
	var lc = inc;
	var runsum = 0.0;
	var runsum1 = 0.0;
	var u;
	while(i < crvs.length) {
		runsum += crvlens[i];
		while(lc < runsum + verb_core_Constants.EPSILON) {
			u = verb_eval_Analyze.rationalBezierCurveParamAtArcLength(crvs[i],lc - runsum1,verb_core_Constants.TOLERANCE,crvlens[i]);
			pts.push(new verb_eval_CurveLengthSample(u,lc));
			lc += inc;
		}
		runsum1 += crvlens[i];
		i++;
	}
	return pts;
};
var verb_eval_CurveLengthSample = $hx_exports.eval.CurveLengthSample = function(u,len) {
	this.u = u;
	this.len = len;
};
$hxClasses["verb.eval.CurveLengthSample"] = verb_eval_CurveLengthSample;
verb_eval_CurveLengthSample.__name__ = ["verb","eval","CurveLengthSample"];
verb_eval_CurveLengthSample.prototype = {
	__class__: verb_eval_CurveLengthSample
};
var verb_eval_Eval = $hx_exports.eval.Eval = function() { };
$hxClasses["verb.eval.Eval"] = verb_eval_Eval;
verb_eval_Eval.__name__ = ["verb","eval","Eval"];
verb_eval_Eval.rationalCurveTangent = function(curve,u) {
	var derivs = verb_eval_Eval.rationalCurveDerivatives(curve,u,1);
	return derivs[1];
};
verb_eval_Eval.rationalSurfaceNormal = function(surface,u,v) {
	var derivs = verb_eval_Eval.rationalSurfaceDerivatives(surface,u,v,1);
	return verb_core_Vec.cross(derivs[1][0],derivs[0][1]);
};
verb_eval_Eval.rationalSurfaceDerivatives = function(surface,u,v,numDerivs) {
	if(numDerivs == null) numDerivs = 1;
	var ders = verb_eval_Eval.surfaceDerivatives(surface,u,v,numDerivs);
	var Aders = verb_eval_Eval.rational2d(ders);
	var wders = verb_eval_Eval.weight2d(ders);
	var SKL = [];
	var dim = Aders[0][0].length;
	var _g1 = 0;
	var _g = numDerivs + 1;
	while(_g1 < _g) {
		var k = _g1++;
		SKL.push([]);
		var _g3 = 0;
		var _g2 = numDerivs - k + 1;
		while(_g3 < _g2) {
			var l = _g3++;
			var v1 = Aders[k][l];
			var _g5 = 1;
			var _g4 = l + 1;
			while(_g5 < _g4) {
				var j = _g5++;
				verb_core_Vec.subMulMutate(v1,verb_core_Binomial.get(l,j) * wders[0][j],SKL[k][l - j]);
			}
			var _g51 = 1;
			var _g41 = k + 1;
			while(_g51 < _g41) {
				var i = _g51++;
				verb_core_Vec.subMulMutate(v1,verb_core_Binomial.get(k,i) * wders[i][0],SKL[k - i][l]);
				var v2 = verb_core_Vec.zeros1d(dim);
				var _g7 = 1;
				var _g6 = l + 1;
				while(_g7 < _g6) {
					var j1 = _g7++;
					verb_core_Vec.addMulMutate(v2,verb_core_Binomial.get(l,j1) * wders[i][j1],SKL[k - i][l - j1]);
				}
				verb_core_Vec.subMulMutate(v1,verb_core_Binomial.get(k,i),v2);
			}
			verb_core_Vec.mulMutate(1 / wders[0][0],v1);
			SKL[k].push(v1);
		}
	}
	return SKL;
};
verb_eval_Eval.rationalSurfacePoint = function(surface,u,v) {
	return verb_eval_Eval.dehomogenize(verb_eval_Eval.surfacePoint(surface,u,v));
};
verb_eval_Eval.rationalCurveDerivatives = function(curve,u,numDerivs) {
	if(numDerivs == null) numDerivs = 1;
	var ders = verb_eval_Eval.curveDerivatives(curve,u,numDerivs);
	var Aders = verb_eval_Eval.rational1d(ders);
	var wders = verb_eval_Eval.weight1d(ders);
	var k = 0;
	var i = 0;
	var CK = [];
	var _g1 = 0;
	var _g = numDerivs + 1;
	while(_g1 < _g) {
		var k1 = _g1++;
		var v = Aders[k1];
		var _g3 = 1;
		var _g2 = k1 + 1;
		while(_g3 < _g2) {
			var i1 = _g3++;
			verb_core_Vec.subMulMutate(v,verb_core_Binomial.get(k1,i1) * wders[i1],CK[k1 - i1]);
		}
		verb_core_Vec.mulMutate(1 / wders[0],v);
		CK.push(v);
	}
	return CK;
};
verb_eval_Eval.rationalCurvePoint = function(curve,u) {
	return verb_eval_Eval.dehomogenize(verb_eval_Eval.curvePoint(curve,u));
};
verb_eval_Eval.surfaceDerivatives = function(surface,u,v,numDerivs) {
	var n = surface.knotsU.length - surface.degreeU - 2;
	var m = surface.knotsV.length - surface.degreeV - 2;
	return verb_eval_Eval.surfaceDerivativesGivenNM(n,m,surface,u,v,numDerivs);
};
verb_eval_Eval.surfaceDerivativesGivenNM = function(n,m,surface,u,v,numDerivs) {
	var degreeU = surface.degreeU;
	var degreeV = surface.degreeV;
	var controlPoints = surface.controlPoints;
	var knotsU = surface.knotsU;
	var knotsV = surface.knotsV;
	if(!verb_eval_Eval.areValidRelations(degreeU,controlPoints.length,knotsU.length) || !verb_eval_Eval.areValidRelations(degreeV,controlPoints[0].length,knotsV.length)) throw new js__$Boot_HaxeError("Invalid relations between control points, knot vector, and n");
	var dim = controlPoints[0][0].length;
	var du;
	if(numDerivs < degreeU) du = numDerivs; else du = degreeU;
	var dv;
	if(numDerivs < degreeV) dv = numDerivs; else dv = degreeV;
	var SKL = verb_core_Vec.zeros3d(numDerivs + 1,numDerivs + 1,dim);
	var knotSpan_index_u = verb_eval_Eval.knotSpanGivenN(n,degreeU,u,knotsU);
	var knotSpan_index_v = verb_eval_Eval.knotSpanGivenN(m,degreeV,v,knotsV);
	var uders = verb_eval_Eval.derivativeBasisFunctionsGivenNI(knotSpan_index_u,u,degreeU,n,knotsU);
	var vders = verb_eval_Eval.derivativeBasisFunctionsGivenNI(knotSpan_index_v,v,degreeV,m,knotsV);
	var temp = verb_core_Vec.zeros2d(degreeV + 1,dim);
	var dd = 0;
	var _g1 = 0;
	var _g = du + 1;
	while(_g1 < _g) {
		var k = _g1++;
		var _g3 = 0;
		var _g2 = degreeV + 1;
		while(_g3 < _g2) {
			var s = _g3++;
			temp[s] = verb_core_Vec.zeros1d(dim);
			var _g5 = 0;
			var _g4 = degreeU + 1;
			while(_g5 < _g4) {
				var r = _g5++;
				verb_core_Vec.addMulMutate(temp[s],uders[k][r],controlPoints[knotSpan_index_u - degreeU + r][knotSpan_index_v - degreeV + s]);
			}
		}
		var nk = numDerivs - k;
		if(nk < dv) dd = nk; else dd = dv;
		var _g31 = 0;
		var _g21 = dd + 1;
		while(_g31 < _g21) {
			var l = _g31++;
			SKL[k][l] = verb_core_Vec.zeros1d(dim);
			var _g51 = 0;
			var _g41 = degreeV + 1;
			while(_g51 < _g41) {
				var s1 = _g51++;
				verb_core_Vec.addMulMutate(SKL[k][l],vders[l][s1],temp[s1]);
			}
		}
	}
	return SKL;
};
verb_eval_Eval.surfacePoint = function(surface,u,v) {
	var n = surface.knotsU.length - surface.degreeU - 2;
	var m = surface.knotsV.length - surface.degreeV - 2;
	return verb_eval_Eval.surfacePointGivenNM(n,m,surface,u,v);
};
verb_eval_Eval.surfacePointGivenNM = function(n,m,surface,u,v) {
	var degreeU = surface.degreeU;
	var degreeV = surface.degreeV;
	var controlPoints = surface.controlPoints;
	var knotsU = surface.knotsU;
	var knotsV = surface.knotsV;
	if(!verb_eval_Eval.areValidRelations(degreeU,controlPoints.length,knotsU.length) || !verb_eval_Eval.areValidRelations(degreeV,controlPoints[0].length,knotsV.length)) throw new js__$Boot_HaxeError("Invalid relations between control points, knot vector, and n");
	var dim = controlPoints[0][0].length;
	var knotSpan_index_u = verb_eval_Eval.knotSpanGivenN(n,degreeU,u,knotsU);
	var knotSpan_index_v = verb_eval_Eval.knotSpanGivenN(m,degreeV,v,knotsV);
	var u_basis_vals = verb_eval_Eval.basisFunctionsGivenKnotSpanIndex(knotSpan_index_u,u,degreeU,knotsU);
	var v_basis_vals = verb_eval_Eval.basisFunctionsGivenKnotSpanIndex(knotSpan_index_v,v,degreeV,knotsV);
	var uind = knotSpan_index_u - degreeU;
	var vind = knotSpan_index_v;
	var position = verb_core_Vec.zeros1d(dim);
	var temp = verb_core_Vec.zeros1d(dim);
	var _g1 = 0;
	var _g = degreeV + 1;
	while(_g1 < _g) {
		var l = _g1++;
		temp = verb_core_Vec.zeros1d(dim);
		vind = knotSpan_index_v - degreeV + l;
		var _g3 = 0;
		var _g2 = degreeU + 1;
		while(_g3 < _g2) {
			var k = _g3++;
			verb_core_Vec.addMulMutate(temp,u_basis_vals[k],controlPoints[uind + k][vind]);
		}
		verb_core_Vec.addMulMutate(position,v_basis_vals[l],temp);
	}
	return position;
};
verb_eval_Eval.curveRegularSamplePoints = function(crv,divs) {
	var derivs = verb_eval_Eval.curveDerivatives(crv,crv.knots[0],crv.degree);
	var t = 1.0 / divs;
	var temp = t * t;
	var f = derivs[0];
	var fd = verb_core_Vec.mul(t,derivs[1]);
	var fdd_per2 = verb_core_Vec.mul(temp * 0.5,derivs[2]);
	var fddd_per2 = verb_core_Vec.mul(temp * t * 0.5,derivs[3]);
	var fdd = verb_core_Vec.add(fdd_per2,fdd_per2);
	var fddd = verb_core_Vec.add(fddd_per2,fddd_per2);
	var fddd_per6 = verb_core_Vec.mul(0.333333333333333315,fddd_per2);
	var pts = [];
	var _g1 = 0;
	var _g = divs + 1;
	while(_g1 < _g) {
		var i = _g1++;
		pts.push(verb_eval_Eval.dehomogenize(f));
		verb_core_Vec.addAllMutate([f,fd,fdd_per2,fddd_per6]);
		verb_core_Vec.addAllMutate([fd,fdd,fddd_per2]);
		verb_core_Vec.addAllMutate([fdd,fddd]);
		verb_core_Vec.addAllMutate([fdd_per2,fddd_per2]);
	}
	return pts;
};
verb_eval_Eval.curveRegularSamplePoints2 = function(crv,divs) {
	var derivs = verb_eval_Eval.curveDerivatives(crv,crv.knots[0],crv.degree);
	var t = 1.0 / divs;
	var temp = t * t;
	var f = derivs[0];
	var fd = verb_core_Vec.mul(t,derivs[1]);
	var fdd_per2 = verb_core_Vec.mul(temp * 0.5,derivs[2]);
	var fddd_per2 = verb_core_Vec.mul(temp * t * 0.5,derivs[3]);
	var fdd = verb_core_Vec.add(fdd_per2,fdd_per2);
	var fddd = verb_core_Vec.add(fddd_per2,fddd_per2);
	var fddd_per6 = verb_core_Vec.mul(0.333333333333333315,fddd_per2);
	var pts = [];
	var _g1 = 0;
	var _g = divs + 1;
	while(_g1 < _g) {
		var i = _g1++;
		pts.push(verb_eval_Eval.dehomogenize(f));
		verb_core_Vec.addAllMutate([f,fd,fdd_per2,fddd_per6]);
		verb_core_Vec.addAllMutate([fd,fdd,fddd_per2]);
		verb_core_Vec.addAllMutate([fdd,fddd]);
		verb_core_Vec.addAllMutate([fdd_per2,fddd_per2]);
	}
	return pts;
};
verb_eval_Eval.rationalSurfaceRegularSampleDerivatives = function(surface,divsU,divsV,numDerivs) {
	var allders = verb_eval_Eval.surfaceRegularSampleDerivatives(surface,divsU,divsV,numDerivs);
	var allratders = [];
	var divsU1 = divsU + 1;
	var divsV1 = divsV + 1;
	var numDerivs1 = numDerivs + 1;
	var _g = 0;
	while(_g < divsU1) {
		var i = _g++;
		var rowders = [];
		allratders.push(rowders);
		var _g1 = 0;
		while(_g1 < divsV1) {
			var j = _g1++;
			var ders = allders[i][j];
			var Aders = verb_eval_Eval.rational2d(ders);
			var wders = verb_eval_Eval.weight2d(ders);
			var SKL = [];
			var dim = Aders[0][0].length;
			var _g2 = 0;
			while(_g2 < numDerivs1) {
				var k = _g2++;
				SKL.push([]);
				var _g4 = 0;
				var _g3 = numDerivs1 - k;
				while(_g4 < _g3) {
					var l = _g4++;
					var v = Aders[k][l];
					var _g6 = 1;
					var _g5 = l + 1;
					while(_g6 < _g5) {
						var j1 = _g6++;
						verb_core_Vec.subMulMutate(v,verb_core_Binomial.get(l,j1) * wders[0][j1],SKL[k][l - j1]);
					}
					var _g61 = 1;
					var _g51 = k + 1;
					while(_g61 < _g51) {
						var i1 = _g61++;
						verb_core_Vec.subMulMutate(v,verb_core_Binomial.get(k,i1) * wders[i1][0],SKL[k - i1][l]);
						var v2 = verb_core_Vec.zeros1d(dim);
						var _g8 = 1;
						var _g7 = l + 1;
						while(_g8 < _g7) {
							var j2 = _g8++;
							verb_core_Vec.addMulMutate(v2,verb_core_Binomial.get(l,j2) * wders[i1][j2],SKL[k - i1][l - j2]);
						}
						verb_core_Vec.subMulMutate(v,verb_core_Binomial.get(k,i1),v2);
					}
					verb_core_Vec.mulMutate(1 / wders[0][0],v);
					SKL[k].push(v);
				}
			}
			rowders.push(SKL);
		}
	}
	return allratders;
};
verb_eval_Eval.surfaceRegularSampleDerivatives = function(surface,divsU,divsV,numDerivs) {
	var degreeU = surface.degreeU;
	var degreeV = surface.degreeV;
	var controlPoints = surface.controlPoints;
	var knotsU = surface.knotsU;
	var knotsV = surface.knotsV;
	var dim = controlPoints[0][0].length;
	var spanU = (verb_core_ArrayExtensions.last(knotsU) - knotsU[0]) / divsU;
	var spanV = (verb_core_ArrayExtensions.last(knotsV) - knotsV[0]) / divsV;
	var knotSpansBasesU = verb_eval_Eval.regularlySpacedDerivativeBasisFunctions(degreeU,knotsU,divsU);
	var knotSpansU = knotSpansBasesU.item0;
	var basesU = knotSpansBasesU.item1;
	var knotSpansBasesV = verb_eval_Eval.regularlySpacedDerivativeBasisFunctions(degreeV,knotsV,divsV);
	var knotSpansV = knotSpansBasesV.item0;
	var basesV = knotSpansBasesV.item1;
	var pts = [];
	var divsU1 = divsU + 1;
	var divsV1 = divsV + 1;
	var _g = 0;
	while(_g < divsU1) {
		var i = _g++;
		var ptsi = [];
		pts.push(ptsi);
		var _g1 = 0;
		while(_g1 < divsV1) {
			var j = _g1++;
			ptsi.push(verb_eval_Eval.surfaceDerivativesGivenBasesKnotSpans(degreeU,degreeV,controlPoints,knotSpansU[i],knotSpansV[j],basesU[i],basesV[j],dim,numDerivs));
		}
	}
	return pts;
};
verb_eval_Eval.rationalSurfaceRegularSamplePoints = function(surface,divsU,divsV) {
	return verb_eval_Eval.dehomogenize2d(verb_eval_Eval.surfaceRegularSamplePoints(surface,divsU,divsV));
};
verb_eval_Eval.surfaceRegularSamplePoints = function(surface,divsU,divsV) {
	var degreeU = surface.degreeU;
	var degreeV = surface.degreeV;
	var controlPoints = surface.controlPoints;
	var knotsU = surface.knotsU;
	var knotsV = surface.knotsV;
	var dim = controlPoints[0][0].length;
	var spanU = (verb_core_ArrayExtensions.last(knotsU) - knotsU[0]) / divsU;
	var spanV = (verb_core_ArrayExtensions.last(knotsV) - knotsV[0]) / divsV;
	var knotSpansBasesU = verb_eval_Eval.regularlySpacedBasisFunctions(degreeU,knotsU,divsU);
	var knotSpansU = knotSpansBasesU.item0;
	var basesU = knotSpansBasesU.item1;
	var knotSpansBasesV = verb_eval_Eval.regularlySpacedBasisFunctions(degreeV,knotsV,divsV);
	var knotSpansV = knotSpansBasesV.item0;
	var basesV = knotSpansBasesV.item1;
	var pts = [];
	var divsU1 = divsU + 1;
	var divsV1 = divsV + 1;
	var _g = 0;
	while(_g < divsU1) {
		var i = _g++;
		var ptsi = [];
		pts.push(ptsi);
		var _g1 = 0;
		while(_g1 < divsV1) {
			var j = _g1++;
			ptsi.push(verb_eval_Eval.surfacePointGivenBasesKnotSpans(degreeU,degreeV,controlPoints,knotSpansU[i],knotSpansV[j],basesU[i],basesV[j],dim));
		}
	}
	return pts;
};
verb_eval_Eval.regularlySpacedBasisFunctions = function(degree,knots,divs) {
	var n = knots.length - degree - 2;
	var span = (verb_core_ArrayExtensions.last(knots) - knots[0]) / divs;
	var bases = [];
	var knotspans = [];
	var u = knots[0];
	var knotIndex = verb_eval_Eval.knotSpanGivenN(n,degree,u,knots);
	var div1 = divs + 1;
	var _g = 0;
	while(_g < div1) {
		var i = _g++;
		while(u >= knots[knotIndex + 1]) knotIndex++;
		knotspans.push(knotIndex);
		bases.push(verb_eval_Eval.basisFunctionsGivenKnotSpanIndex(knotIndex,u,degree,knots));
		u += span;
	}
	return new verb_core_Pair(knotspans,bases);
};
verb_eval_Eval.regularlySpacedDerivativeBasisFunctions = function(degree,knots,divs) {
	var n = knots.length - degree - 2;
	var span = (verb_core_ArrayExtensions.last(knots) - knots[0]) / divs;
	var bases = [];
	var knotspans = [];
	var u = knots[0];
	var knotIndex = verb_eval_Eval.knotSpanGivenN(n,degree,u,knots);
	var div1 = divs + 1;
	var _g = 0;
	while(_g < div1) {
		var i = _g++;
		while(u >= knots[knotIndex + 1]) knotIndex++;
		knotspans.push(knotIndex);
		bases.push(verb_eval_Eval.derivativeBasisFunctionsGivenNI(knotIndex,u,degree,n,knots));
		u += span;
	}
	return new verb_core_Pair(knotspans,bases);
};
verb_eval_Eval.surfacePointGivenBasesKnotSpans = function(degreeU,degreeV,controlPoints,knotSpanU,knotSpanV,basesU,basesV,dim) {
	var position = verb_core_Vec.zeros1d(dim);
	var temp;
	var uind = knotSpanU - degreeU;
	var vind = knotSpanV - degreeV;
	var _g1 = 0;
	var _g = degreeV + 1;
	while(_g1 < _g) {
		var l = _g1++;
		temp = verb_core_Vec.zeros1d(dim);
		var _g3 = 0;
		var _g2 = degreeU + 1;
		while(_g3 < _g2) {
			var k = _g3++;
			verb_core_Vec.addMulMutate(temp,basesU[k],controlPoints[uind + k][vind]);
		}
		vind++;
		verb_core_Vec.addMulMutate(position,basesV[l],temp);
	}
	return position;
};
verb_eval_Eval.surfaceDerivativesGivenBasesKnotSpans = function(degreeU,degreeV,controlPoints,knotSpanU,knotSpanV,basesU,basesV,dim,numDerivs) {
	var dim1 = controlPoints[0][0].length;
	var du;
	if(numDerivs < degreeU) du = numDerivs; else du = degreeU;
	var dv;
	if(numDerivs < degreeV) dv = numDerivs; else dv = degreeV;
	var SKL = verb_core_Vec.zeros3d(du + 1,dv + 1,dim1);
	var temp = verb_core_Vec.zeros2d(degreeV + 1,dim1);
	var dd = 0;
	var _g1 = 0;
	var _g = du + 1;
	while(_g1 < _g) {
		var k = _g1++;
		var _g3 = 0;
		var _g2 = degreeV + 1;
		while(_g3 < _g2) {
			var s = _g3++;
			temp[s] = verb_core_Vec.zeros1d(dim1);
			var _g5 = 0;
			var _g4 = degreeU + 1;
			while(_g5 < _g4) {
				var r = _g5++;
				verb_core_Vec.addMulMutate(temp[s],basesU[k][r],controlPoints[knotSpanU - degreeU + r][knotSpanV - degreeV + s]);
			}
		}
		var nk = numDerivs - k;
		if(nk < dv) dd = nk; else dd = dv;
		var _g31 = 0;
		var _g21 = dd + 1;
		while(_g31 < _g21) {
			var l = _g31++;
			SKL[k][l] = verb_core_Vec.zeros1d(dim1);
			var _g51 = 0;
			var _g41 = degreeV + 1;
			while(_g51 < _g41) {
				var s1 = _g51++;
				verb_core_Vec.addMulMutate(SKL[k][l],basesV[l][s1],temp[s1]);
			}
		}
	}
	return SKL;
};
verb_eval_Eval.curveDerivatives = function(crv,u,numDerivs) {
	var n = crv.knots.length - crv.degree - 2;
	return verb_eval_Eval.curveDerivativesGivenN(n,crv,u,numDerivs);
};
verb_eval_Eval.curveDerivativesGivenN = function(n,curve,u,numDerivs) {
	var degree = curve.degree;
	var controlPoints = curve.controlPoints;
	var knots = curve.knots;
	if(!verb_eval_Eval.areValidRelations(degree,controlPoints.length,knots.length)) throw new js__$Boot_HaxeError("Invalid relations between control points, knot vector, and n");
	var dim = controlPoints[0].length;
	var du;
	if(numDerivs < degree) du = numDerivs; else du = degree;
	var CK = verb_core_Vec.zeros2d(numDerivs + 1,dim);
	var knotSpan_index = verb_eval_Eval.knotSpanGivenN(n,degree,u,knots);
	var nders = verb_eval_Eval.derivativeBasisFunctionsGivenNI(knotSpan_index,u,degree,du,knots);
	var k = 0;
	var j = 0;
	var _g1 = 0;
	var _g = du + 1;
	while(_g1 < _g) {
		var k1 = _g1++;
		var _g3 = 0;
		var _g2 = degree + 1;
		while(_g3 < _g2) {
			var j1 = _g3++;
			verb_core_Vec.addMulMutate(CK[k1],nders[k1][j1],controlPoints[knotSpan_index - degree + j1]);
		}
	}
	return CK;
};
verb_eval_Eval.curvePoint = function(curve,u) {
	var n = curve.knots.length - curve.degree - 2;
	return verb_eval_Eval.curvePointGivenN(n,curve,u);
};
verb_eval_Eval.areValidRelations = function(degree,num_controlPoints,knots_length) {
	return num_controlPoints + degree + 1 - knots_length == 0;
};
verb_eval_Eval.curvePointGivenN = function(n,curve,u) {
	var degree = curve.degree;
	var controlPoints = curve.controlPoints;
	var knots = curve.knots;
	if(!verb_eval_Eval.areValidRelations(degree,controlPoints.length,knots.length)) {
		throw new js__$Boot_HaxeError("Invalid relations between control points, knot Array, and n");
		return null;
	}
	var knotSpan_index = verb_eval_Eval.knotSpanGivenN(n,degree,u,knots);
	var basis_values = verb_eval_Eval.basisFunctionsGivenKnotSpanIndex(knotSpan_index,u,degree,knots);
	var position = verb_core_Vec.zeros1d(controlPoints[0].length);
	var _g1 = 0;
	var _g = degree + 1;
	while(_g1 < _g) {
		var j = _g1++;
		verb_core_Vec.addMulMutate(position,basis_values[j],controlPoints[knotSpan_index - degree + j]);
	}
	return position;
};
verb_eval_Eval.volumePoint = function(volume,u,v,w) {
	var n = volume.knotsU.length - volume.degreeU - 2;
	var m = volume.knotsV.length - volume.degreeV - 2;
	var l = volume.knotsW.length - volume.degreeW - 2;
	return verb_eval_Eval.volumePointGivenNML(volume,n,m,l,u,v,w);
};
verb_eval_Eval.volumePointGivenNML = function(volume,n,m,l,u,v,w) {
	if(!verb_eval_Eval.areValidRelations(volume.degreeU,volume.controlPoints.length,volume.knotsU.length) || !verb_eval_Eval.areValidRelations(volume.degreeV,volume.controlPoints[0].length,volume.knotsV.length) || !verb_eval_Eval.areValidRelations(volume.degreeW,volume.controlPoints[0][0].length,volume.knotsW.length)) throw new js__$Boot_HaxeError("Invalid relations between control points and knot vector");
	var controlPoints = volume.controlPoints;
	var degreeU = volume.degreeU;
	var degreeV = volume.degreeV;
	var degreeW = volume.degreeW;
	var knotsU = volume.knotsU;
	var knotsV = volume.knotsV;
	var knotsW = volume.knotsW;
	var dim = controlPoints[0][0][0].length;
	var knotSpan_index_u = verb_eval_Eval.knotSpanGivenN(n,degreeU,u,knotsU);
	var knotSpan_index_v = verb_eval_Eval.knotSpanGivenN(m,degreeV,v,knotsV);
	var knotSpan_index_w = verb_eval_Eval.knotSpanGivenN(l,degreeW,w,knotsW);
	var u_basis_vals = verb_eval_Eval.basisFunctionsGivenKnotSpanIndex(knotSpan_index_u,u,degreeU,knotsU);
	var v_basis_vals = verb_eval_Eval.basisFunctionsGivenKnotSpanIndex(knotSpan_index_v,v,degreeV,knotsV);
	var w_basis_vals = verb_eval_Eval.basisFunctionsGivenKnotSpanIndex(knotSpan_index_w,w,degreeW,knotsW);
	var uind = knotSpan_index_u - degreeU;
	var position = verb_core_Vec.zeros1d(dim);
	var temp = verb_core_Vec.zeros1d(dim);
	var temp2 = verb_core_Vec.zeros1d(dim);
	var _g1 = 0;
	var _g = degreeW + 1;
	while(_g1 < _g) {
		var i = _g1++;
		temp2 = verb_core_Vec.zeros1d(dim);
		var wind = knotSpan_index_w - degreeW + i;
		var _g3 = 0;
		var _g2 = degreeV + 1;
		while(_g3 < _g2) {
			var j = _g3++;
			temp = verb_core_Vec.zeros1d(dim);
			var vind = knotSpan_index_v - degreeV + j;
			var _g5 = 0;
			var _g4 = degreeU + 1;
			while(_g5 < _g4) {
				var k = _g5++;
				verb_core_Vec.addMulMutate(temp,u_basis_vals[k],controlPoints[uind + k][vind][wind]);
			}
			verb_core_Vec.addMulMutate(temp2,v_basis_vals[j],temp);
		}
		verb_core_Vec.addMulMutate(position,w_basis_vals[i],temp2);
	}
	return position;
};
verb_eval_Eval.derivativeBasisFunctions = function(u,degree,knots) {
	var knotSpan_index = verb_eval_Eval.knotSpan(degree,u,knots);
	var m = knots.length - 1;
	var n = m - degree - 1;
	return verb_eval_Eval.derivativeBasisFunctionsGivenNI(knotSpan_index,u,degree,n,knots);
};
verb_eval_Eval.derivativeBasisFunctionsGivenNI = function(knotIndex,u,p,n,knots) {
	var ndu = verb_core_Vec.zeros2d(p + 1,p + 1);
	var left = verb_core_Vec.zeros1d(p + 1);
	var right = verb_core_Vec.zeros1d(p + 1);
	var saved = 0.0;
	var temp = 0.0;
	ndu[0][0] = 1.0;
	var _g1 = 1;
	var _g = p + 1;
	while(_g1 < _g) {
		var j = _g1++;
		left[j] = u - knots[knotIndex + 1 - j];
		right[j] = knots[knotIndex + j] - u;
		saved = 0.0;
		var _g2 = 0;
		while(_g2 < j) {
			var r = _g2++;
			ndu[j][r] = right[r + 1] + left[j - r];
			temp = ndu[r][j - 1] / ndu[j][r];
			ndu[r][j] = saved + right[r + 1] * temp;
			saved = left[j - r] * temp;
		}
		ndu[j][j] = saved;
	}
	var ders = verb_core_Vec.zeros2d(n + 1,p + 1);
	var a = verb_core_Vec.zeros2d(2,p + 1);
	var s1 = 0;
	var s2 = 1;
	var d = 0.0;
	var rk = 0;
	var pk = 0;
	var j1 = 0;
	var j2 = 0;
	var _g11 = 0;
	var _g3 = p + 1;
	while(_g11 < _g3) {
		var j3 = _g11++;
		ders[0][j3] = ndu[j3][p];
	}
	var _g12 = 0;
	var _g4 = p + 1;
	while(_g12 < _g4) {
		var r1 = _g12++;
		s1 = 0;
		s2 = 1;
		a[0][0] = 1.0;
		var _g31 = 1;
		var _g21 = n + 1;
		while(_g31 < _g21) {
			var k = _g31++;
			d = 0.0;
			rk = r1 - k;
			pk = p - k;
			if(r1 >= k) {
				a[s2][0] = a[s1][0] / ndu[pk + 1][rk];
				d = a[s2][0] * ndu[rk][pk];
			}
			if(rk >= -1) j1 = 1; else j1 = -rk;
			if(r1 - 1 <= pk) j2 = k - 1; else j2 = p - r1;
			var _g5 = j1;
			var _g41 = j2 + 1;
			while(_g5 < _g41) {
				var j4 = _g5++;
				a[s2][j4] = (a[s1][j4] - a[s1][j4 - 1]) / ndu[pk + 1][rk + j4];
				d += a[s2][j4] * ndu[rk + j4][pk];
			}
			if(r1 <= pk) {
				a[s2][k] = -a[s1][k - 1] / ndu[pk + 1][r1];
				d += a[s2][k] * ndu[r1][pk];
			}
			ders[k][r1] = d;
			var temp1 = s1;
			s1 = s2;
			s2 = temp1;
		}
	}
	var acc = p;
	var _g13 = 1;
	var _g6 = n + 1;
	while(_g13 < _g6) {
		var k1 = _g13++;
		var _g32 = 0;
		var _g22 = p + 1;
		while(_g32 < _g22) {
			var j5 = _g32++;
			ders[k1][j5] *= acc;
		}
		acc *= p - k1;
	}
	return ders;
};
verb_eval_Eval.basisFunctions = function(u,degree,knots) {
	var knotSpan_index = verb_eval_Eval.knotSpan(degree,u,knots);
	return verb_eval_Eval.basisFunctionsGivenKnotSpanIndex(knotSpan_index,u,degree,knots);
};
verb_eval_Eval.basisFunctionsGivenKnotSpanIndex = function(knotSpan_index,u,degree,knots) {
	var basisFunctions = verb_core_Vec.zeros1d(degree + 1);
	var left = verb_core_Vec.zeros1d(degree + 1);
	var right = verb_core_Vec.zeros1d(degree + 1);
	var saved = 0;
	var temp = 0;
	basisFunctions[0] = 1.0;
	var _g1 = 1;
	var _g = degree + 1;
	while(_g1 < _g) {
		var j = _g1++;
		left[j] = u - knots[knotSpan_index + 1 - j];
		right[j] = knots[knotSpan_index + j] - u;
		saved = 0.0;
		var _g2 = 0;
		while(_g2 < j) {
			var r = _g2++;
			temp = basisFunctions[r] / (right[r + 1] + left[j - r]);
			basisFunctions[r] = saved + right[r + 1] * temp;
			saved = left[j - r] * temp;
		}
		basisFunctions[j] = saved;
	}
	return basisFunctions;
};
verb_eval_Eval.knotSpan = function(degree,u,knots) {
	return verb_eval_Eval.knotSpanGivenN(knots.length - degree - 2,degree,u,knots);
};
verb_eval_Eval.knotSpanGivenN = function(n,degree,u,knots) {
	if(u > knots[n + 1] - verb_core_Constants.EPSILON) return n;
	if(u < knots[degree] + verb_core_Constants.EPSILON) return degree;
	var low = degree;
	var high = n + 1;
	var mid = Math.floor((low + high) / 2);
	while(u < knots[mid] || u >= knots[mid + 1]) {
		if(u < knots[mid]) high = mid; else low = mid;
		mid = Math.floor((low + high) / 2);
	}
	return mid;
};
verb_eval_Eval.dehomogenize = function(homoPoint) {
	var dim = homoPoint.length;
	var point = [];
	var wt = homoPoint[dim - 1];
	var l = homoPoint.length - 1;
	var _g = 0;
	while(_g < l) {
		var i = _g++;
		point.push(homoPoint[i] / wt);
	}
	return point;
};
verb_eval_Eval.rational1d = function(homoPoints) {
	var dim = homoPoints[0].length - 1;
	return homoPoints.map(function(x) {
		return x.slice(0,dim);
	});
};
verb_eval_Eval.rational2d = function(homoPoints) {
	return homoPoints.map(verb_eval_Eval.rational1d);
};
verb_eval_Eval.weight1d = function(homoPoints) {
	var dim = homoPoints[0].length - 1;
	return homoPoints.map(function(x) {
		return x[dim];
	});
};
verb_eval_Eval.weight2d = function(homoPoints) {
	return homoPoints.map(verb_eval_Eval.weight1d);
};
verb_eval_Eval.dehomogenize1d = function(homoPoints) {
	return homoPoints.map(verb_eval_Eval.dehomogenize);
};
verb_eval_Eval.dehomogenize2d = function(homoPoints) {
	return homoPoints.map(verb_eval_Eval.dehomogenize1d);
};
verb_eval_Eval.homogenize1d = function(controlPoints,weights) {
	var rows = controlPoints.length;
	var dim = controlPoints[0].length;
	var homo_controlPoints = [];
	var wt = 0.0;
	var ref_pt = [];
	var weights1;
	if(weights != null) weights1 = weights; else weights1 = verb_core_Vec.rep(controlPoints.length,1.0);
	var _g = 0;
	while(_g < rows) {
		var i = _g++;
		var pt = [];
		ref_pt = controlPoints[i];
		wt = weights1[i];
		var _g1 = 0;
		while(_g1 < dim) {
			var k = _g1++;
			pt.push(ref_pt[k] * wt);
		}
		pt.push(wt);
		homo_controlPoints.push(pt);
	}
	return homo_controlPoints;
};
verb_eval_Eval.homogenize2d = function(controlPoints,weights) {
	var rows = controlPoints.length;
	var homo_controlPoints = [];
	var weights1;
	if(weights != null) weights1 = weights; else {
		var _g = [];
		var _g1 = 0;
		while(_g1 < rows) {
			var i = _g1++;
			_g.push(verb_core_Vec.rep(controlPoints[0].length,1.0));
		}
		weights1 = _g;
	}
	var _g11 = 0;
	while(_g11 < rows) {
		var i1 = _g11++;
		homo_controlPoints.push(verb_eval_Eval.homogenize1d(controlPoints[i1],weights1[i1]));
	}
	return homo_controlPoints;
};
var verb_eval_Intersect = $hx_exports.eval.Intersect = function() { };
$hxClasses["verb.eval.Intersect"] = verb_eval_Intersect;
verb_eval_Intersect.__name__ = ["verb","eval","Intersect"];
verb_eval_Intersect.surfaces = function(surface0,surface1,tol) {
	var tess1 = verb_eval_Tess.rationalSurfaceAdaptive(surface0);
	var tess2 = verb_eval_Tess.rationalSurfaceAdaptive(surface1);
	var resApprox = verb_eval_Intersect.meshes(tess1,tess2);
	var exactPls = resApprox.map(function(pl) {
		return pl.map(function(inter) {
			return verb_eval_Intersect.surfacesAtPointWithEstimate(surface0,surface1,inter.uv0,inter.uv1,tol);
		});
	});
	return exactPls.map(function(x) {
		return verb_eval_Make.rationalInterpCurve(x.map(function(y) {
			return y.point;
		}),3);
	});
};
verb_eval_Intersect.surfacesAtPointWithEstimate = function(surface0,surface1,uv1,uv2,tol) {
	var pds;
	var p;
	var pn;
	var pu;
	var pv;
	var pd;
	var qds;
	var q;
	var qn;
	var qu;
	var qv;
	var qd;
	var dist;
	var maxits = 5;
	var its = 0;
	do {
		pds = verb_eval_Eval.rationalSurfaceDerivatives(surface0,uv1[0],uv1[1],1);
		p = pds[0][0];
		pu = pds[1][0];
		pv = pds[0][1];
		pn = verb_core_Vec.normalized(verb_core_Vec.cross(pu,pv));
		pd = verb_core_Vec.dot(pn,p);
		qds = verb_eval_Eval.rationalSurfaceDerivatives(surface1,uv2[0],uv2[1],1);
		q = qds[0][0];
		qu = qds[1][0];
		qv = qds[0][1];
		qn = verb_core_Vec.normalized(verb_core_Vec.cross(qu,qv));
		qd = verb_core_Vec.dot(qn,q);
		dist = verb_core_Vec.distSquared(p,q);
		if(dist < tol * tol) break;
		var fn = verb_core_Vec.normalized(verb_core_Vec.cross(pn,qn));
		var fd = verb_core_Vec.dot(fn,p);
		var x = verb_eval_Intersect.threePlanes(pn,pd,qn,qd,fn,fd);
		if(x == null) throw new js__$Boot_HaxeError("panic!");
		var pdif = verb_core_Vec.sub(x,p);
		var qdif = verb_core_Vec.sub(x,q);
		var rw = verb_core_Vec.cross(pu,pn);
		var rt = verb_core_Vec.cross(pv,pn);
		var su = verb_core_Vec.cross(qu,qn);
		var sv = verb_core_Vec.cross(qv,qn);
		var dw = verb_core_Vec.dot(rt,pdif) / verb_core_Vec.dot(rt,pu);
		var dt = verb_core_Vec.dot(rw,pdif) / verb_core_Vec.dot(rw,pv);
		var du = verb_core_Vec.dot(sv,qdif) / verb_core_Vec.dot(sv,qu);
		var dv = verb_core_Vec.dot(su,qdif) / verb_core_Vec.dot(su,qv);
		uv1 = verb_core_Vec.add([dw,dt],uv1);
		uv2 = verb_core_Vec.add([du,dv],uv2);
		its++;
	} while(its < maxits);
	return new verb_core_SurfaceSurfaceIntersectionPoint(uv1,uv2,p,dist);
};
verb_eval_Intersect.meshes = function(mesh0,mesh1,bbtree0,bbtree1) {
	if(bbtree0 == null) bbtree0 = new verb_core_LazyMeshBoundingBoxTree(mesh0);
	if(bbtree1 == null) bbtree1 = new verb_core_LazyMeshBoundingBoxTree(mesh1);
	var bbints = verb_eval_Intersect.boundingBoxTrees(bbtree0,bbtree1,0);
	var segments = verb_core_ArrayExtensions.unique(bbints.map(function(ids) {
		return verb_eval_Intersect.triangles(mesh0,ids.item0,mesh1,ids.item1);
	}).filter(function(x) {
		return x != null;
	}).filter(function(x1) {
		return verb_core_Vec.distSquared(x1.min.point,x1.max.point) > verb_core_Constants.EPSILON;
	}),function(a,b) {
		var s1 = verb_core_Vec.sub(a.min.uv0,b.min.uv0);
		var d1 = verb_core_Vec.dot(s1,s1);
		var s2 = verb_core_Vec.sub(a.max.uv0,b.max.uv0);
		var d2 = verb_core_Vec.dot(s2,s2);
		var s3 = verb_core_Vec.sub(a.min.uv0,b.max.uv0);
		var d3 = verb_core_Vec.dot(s3,s3);
		var s4 = verb_core_Vec.sub(a.max.uv0,b.min.uv0);
		var d4 = verb_core_Vec.dot(s4,s4);
		return d1 < verb_core_Constants.EPSILON && d2 < verb_core_Constants.EPSILON || d3 < verb_core_Constants.EPSILON && d4 < verb_core_Constants.EPSILON;
	});
	return verb_eval_Intersect.makeMeshIntersectionPolylines(segments);
};
verb_eval_Intersect.meshSlices = function(mesh,min,max,step) {
	var bbtree = new verb_core_MeshBoundingBoxTree(mesh);
	var bb = bbtree.boundingBox();
	var x0 = bb.min[0];
	var y0 = bb.min[1];
	var x1 = bb.max[0];
	var y1 = bb.max[1];
	var span = verb_core_Vec.span(min,max,step);
	var slices = [];
	var _g = 0;
	while(_g < span.length) {
		var z = span[_g];
		++_g;
		var pts = [[x0,y0,z],[x1,y0,z],[x1,y1,z],[x0,y1,z]];
		var uvs = [[0.0,0.0],[1.0,0.0],[1.0,1.0],[0.0,1.0]];
		var faces = [[0,1,2],[0,2,3]];
		var plane = new verb_core_MeshData(faces,pts,null,uvs);
		slices.push(verb_eval_Intersect.meshes(mesh,plane,bbtree));
	}
	return slices;
};
verb_eval_Intersect.makeMeshIntersectionPolylines = function(segments) {
	if(segments.length == 0) return [];
	var _g = 0;
	while(_g < segments.length) {
		var s = segments[_g];
		++_g;
		s.max.opp = s.min;
		s.min.opp = s.max;
	}
	var tree = verb_eval_Intersect.kdTreeFromSegments(segments);
	var ends = [];
	var _g1 = 0;
	while(_g1 < segments.length) {
		var seg = segments[_g1];
		++_g1;
		ends.push(seg.min);
		ends.push(seg.max);
	}
	var _g2 = 0;
	while(_g2 < ends.length) {
		var segEnd = ends[_g2];
		++_g2;
		if(segEnd.adj != null) continue;
		var adjEnd = verb_eval_Intersect.lookupAdjacentSegment(segEnd,tree,segments.length);
		if(adjEnd != null && adjEnd.adj == null) {
			segEnd.adj = adjEnd;
			adjEnd.adj = segEnd;
		}
	}
	var freeEnds = ends.filter(function(x) {
		return x.adj == null;
	});
	if(freeEnds.length == 0) freeEnds = ends;
	var pls = [];
	var numVisitedEnds = 0;
	var loopDetected = false;
	while(freeEnds.length != 0) {
		var end = freeEnds.pop();
		if(!end.visited) {
			var pl = [];
			var curEnd = end;
			while(curEnd != null) {
				if(curEnd.visited) break;
				curEnd.visited = true;
				curEnd.opp.visited = true;
				pl.push(curEnd);
				numVisitedEnds += 2;
				curEnd = curEnd.opp.adj;
				if(curEnd == end) break;
			}
			if(pl.length > 0) {
				pl.push(pl[pl.length - 1].opp);
				pls.push(pl);
			}
		}
		if(freeEnds.length == 0 && ends.length > 0 && (loopDetected || numVisitedEnds < ends.length)) {
			loopDetected = true;
			var e = ends.pop();
			freeEnds.push(e);
		}
	}
	return pls;
};
verb_eval_Intersect.kdTreeFromSegments = function(segments) {
	var treePoints = [];
	var _g = 0;
	while(_g < segments.length) {
		var seg = segments[_g];
		++_g;
		treePoints.push(new verb_core_KdPoint(seg.min.point,seg.min));
		treePoints.push(new verb_core_KdPoint(seg.max.point,seg.max));
	}
	return new verb_core_KdTree(treePoints,verb_core_Vec.distSquared);
};
verb_eval_Intersect.lookupAdjacentSegment = function(segEnd,tree,numResults) {
	var adj = tree.nearest(segEnd.point,numResults,verb_core_Constants.EPSILON).filter(function(r) {
		return segEnd != r.item0.obj;
	}).map(function(r1) {
		return r1.item0.obj;
	});
	if(adj.length == 1) return adj[0]; else return null;
};
verb_eval_Intersect.curveAndSurface = function(curve,surface,tol,crvBbTree,srfBbTree) {
	if(tol == null) tol = 1e-3;
	if(crvBbTree != null) crvBbTree = crvBbTree; else crvBbTree = new verb_core_LazyCurveBoundingBoxTree(curve);
	if(srfBbTree != null) srfBbTree = srfBbTree; else srfBbTree = new verb_core_LazySurfaceBoundingBoxTree(surface);
	var ints = verb_eval_Intersect.boundingBoxTrees(crvBbTree,srfBbTree,tol);
	return verb_core_ArrayExtensions.unique(ints.map(function(inter) {
		var crvSeg = inter.item0;
		var srfPart = inter.item1;
		var min = verb_core_ArrayExtensions.first(crvSeg.knots);
		var max = verb_core_ArrayExtensions.last(crvSeg.knots);
		var u = (min + max) / 2.0;
		var minu = verb_core_ArrayExtensions.first(srfPart.knotsU);
		var maxu = verb_core_ArrayExtensions.last(srfPart.knotsU);
		var minv = verb_core_ArrayExtensions.first(srfPart.knotsV);
		var maxv = verb_core_ArrayExtensions.last(srfPart.knotsV);
		var uv = [(minu + maxu) / 2.0,(minv + maxv) / 2.0];
		return verb_eval_Intersect.curveAndSurfaceWithEstimate(crvSeg,srfPart,[u].concat(uv),tol);
	}).filter(function(x) {
		return verb_core_Vec.distSquared(x.curvePoint,x.surfacePoint) < tol * tol;
	}),function(a,b) {
		return Math.abs(a.u - b.u) < 0.5 * tol;
	});
};
verb_eval_Intersect.curveAndSurfaceWithEstimate = function(curve,surface,start_params,tol) {
	if(tol == null) tol = 1e-3;
	var objective = function(x) {
		var p1 = verb_eval_Eval.rationalCurvePoint(curve,x[0]);
		var p2 = verb_eval_Eval.rationalSurfacePoint(surface,x[1],x[2]);
		var p1_p2 = verb_core_Vec.sub(p1,p2);
		return verb_core_Vec.dot(p1_p2,p1_p2);
	};
	var grad = function(x1) {
		var dc = verb_eval_Eval.rationalCurveDerivatives(curve,x1[0],1);
		var ds = verb_eval_Eval.rationalSurfaceDerivatives(surface,x1[1],x1[2],1);
		var r = verb_core_Vec.sub(ds[0][0],dc[0]);
		var drdt = verb_core_Vec.mul(-1.0,dc[1]);
		var drdu = ds[1][0];
		var drdv = ds[0][1];
		return [2.0 * verb_core_Vec.dot(drdt,r),2.0 * verb_core_Vec.dot(drdu,r),2.0 * verb_core_Vec.dot(drdv,r)];
	};
	var sol_obj = verb_core_Minimizer.uncmin(objective,start_params,tol * tol,grad);
	var $final = sol_obj.solution;
	return new verb_core_CurveSurfaceIntersection($final[0],[$final[1],$final[2]],verb_eval_Eval.rationalCurvePoint(curve,$final[0]),verb_eval_Eval.rationalSurfacePoint(surface,$final[1],$final[2]));
};
verb_eval_Intersect.polylineAndMesh = function(polyline,mesh,tol) {
	var res = verb_eval_Intersect.boundingBoxTrees(new verb_core_LazyPolylineBoundingBoxTree(polyline),new verb_core_LazyMeshBoundingBoxTree(mesh),tol);
	var finalResults = [];
	var _g = 0;
	while(_g < res.length) {
		var event = res[_g];
		++_g;
		var polid = event.item0;
		var faceid = event.item1;
		var inter = verb_eval_Intersect.segmentWithTriangle(polyline.points[polid],polyline.points[polid + 1],mesh.points,mesh.faces[faceid]);
		if(inter == null) continue;
		var pt = inter.point;
		var u = verb_core_Vec.lerp(inter.p,[polyline.params[polid]],[polyline.params[polid + 1]])[0];
		var uv = verb_core_Mesh.triangleUVFromPoint(mesh,faceid,pt);
		finalResults.push(new verb_core_PolylineMeshIntersection(pt,u,uv,polid,faceid));
	}
	return finalResults;
};
verb_eval_Intersect.boundingBoxTrees = function(ai,bi,tol) {
	if(tol == null) tol = 1e-9;
	var atrees = [];
	var btrees = [];
	atrees.push(ai);
	btrees.push(bi);
	var results = [];
	while(atrees.length > 0) {
		var a = atrees.pop();
		var b = btrees.pop();
		if(a.empty() || b.empty()) continue;
		if(!a.boundingBox().intersects(b.boundingBox(),tol)) continue;
		var ai1 = a.indivisible(tol);
		var bi1 = b.indivisible(tol);
		if(ai1 && bi1) {
			results.push(new verb_core_Pair(a["yield"](),b["yield"]()));
			continue;
		} else if(ai1 && !bi1) {
			var bs1 = b.split();
			atrees.push(a);
			btrees.push(bs1.item1);
			atrees.push(a);
			btrees.push(bs1.item0);
			continue;
		} else if(!ai1 && bi1) {
			var as1 = a.split();
			atrees.push(as1.item1);
			btrees.push(b);
			atrees.push(as1.item0);
			btrees.push(b);
			continue;
		}
		var $as = a.split();
		var bs = b.split();
		atrees.push($as.item1);
		btrees.push(bs.item1);
		atrees.push($as.item1);
		btrees.push(bs.item0);
		atrees.push($as.item0);
		btrees.push(bs.item1);
		atrees.push($as.item0);
		btrees.push(bs.item0);
	}
	return results;
};
verb_eval_Intersect.curves = function(curve1,curve2,tolerance) {
	var ints = verb_eval_Intersect.boundingBoxTrees(new verb_core_LazyCurveBoundingBoxTree(curve1),new verb_core_LazyCurveBoundingBoxTree(curve2),0);
	return verb_core_ArrayExtensions.unique(ints.map(function(x) {
		return verb_eval_Intersect.curvesWithEstimate(curve1,curve2,verb_core_ArrayExtensions.first(x.item0.knots),verb_core_ArrayExtensions.first(x.item1.knots),tolerance);
	}).filter(function(x1) {
		return verb_core_Vec.distSquared(x1.point0,x1.point1) < tolerance;
	}),function(a,b) {
		return Math.abs(a.u0 - b.u0) < tolerance * 5;
	});
};
verb_eval_Intersect.curvesWithEstimate = function(curve0,curve1,u0,u1,tolerance) {
	var objective = function(x) {
		var p1 = verb_eval_Eval.rationalCurvePoint(curve0,x[0]);
		var p2 = verb_eval_Eval.rationalCurvePoint(curve1,x[1]);
		var p1_p2 = verb_core_Vec.sub(p1,p2);
		return verb_core_Vec.dot(p1_p2,p1_p2);
	};
	var grad = function(x1) {
		var dc0 = verb_eval_Eval.rationalCurveDerivatives(curve0,x1[0],1);
		var dc1 = verb_eval_Eval.rationalCurveDerivatives(curve1,x1[1],1);
		var r = verb_core_Vec.sub(dc0[0],dc1[0]);
		var drdu = dc0[1];
		var drdt = verb_core_Vec.mul(-1.0,dc1[1]);
		return [2.0 * verb_core_Vec.dot(drdu,r),2.0 * verb_core_Vec.dot(drdt,r)];
	};
	var sol_obj = verb_core_Minimizer.uncmin(objective,[u0,u1],tolerance * tolerance,grad);
	var u11 = sol_obj.solution[0];
	var u2 = sol_obj.solution[1];
	var p11 = verb_eval_Eval.rationalCurvePoint(curve0,u11);
	var p21 = verb_eval_Eval.rationalCurvePoint(curve1,u2);
	return new verb_core_CurveCurveIntersection(p11,p21,u11,u2);
};
verb_eval_Intersect.triangles = function(mesh0,faceIndex0,mesh1,faceIndex1) {
	var tri0 = mesh0.faces[faceIndex0];
	var tri1 = mesh1.faces[faceIndex1];
	var n0 = verb_core_Mesh.getTriangleNorm(mesh0.points,tri0);
	var n1 = verb_core_Mesh.getTriangleNorm(mesh1.points,tri1);
	var o0 = mesh0.points[tri0[0]];
	var o1 = mesh1.points[tri1[0]];
	var ray = verb_eval_Intersect.planes(o0,n0,o1,n1);
	if(ray == null) return null;
	var clip1 = verb_eval_Intersect.clipRayInCoplanarTriangle(ray,mesh0,faceIndex0);
	if(clip1 == null) return null;
	var clip2 = verb_eval_Intersect.clipRayInCoplanarTriangle(ray,mesh1,faceIndex1);
	if(clip2 == null) return null;
	var merged = verb_eval_Intersect.mergeTriangleClipIntervals(clip1,clip2,mesh0,faceIndex0,mesh1,faceIndex1);
	if(merged == null) return null;
	return new verb_core_Interval(new verb_core_MeshIntersectionPoint(merged.min.uv0,merged.min.uv1,merged.min.point,faceIndex0,faceIndex1),new verb_core_MeshIntersectionPoint(merged.max.uv0,merged.max.uv1,merged.max.point,faceIndex0,faceIndex1));
};
verb_eval_Intersect.clipRayInCoplanarTriangle = function(ray,mesh,faceIndex) {
	var tri = mesh.faces[faceIndex];
	var o = [mesh.points[tri[0]],mesh.points[tri[1]],mesh.points[tri[2]]];
	var uvs = [mesh.uvs[tri[0]],mesh.uvs[tri[1]],mesh.uvs[tri[2]]];
	var uvd = [verb_core_Vec.sub(uvs[1],uvs[0]),verb_core_Vec.sub(uvs[2],uvs[1]),verb_core_Vec.sub(uvs[0],uvs[2])];
	var s = [verb_core_Vec.sub(o[1],o[0]),verb_core_Vec.sub(o[2],o[1]),verb_core_Vec.sub(o[0],o[2])];
	var d = s.map(verb_core_Vec.normalized);
	var l = s.map(verb_core_Vec.norm);
	var minU = null;
	var maxU = null;
	var _g = 0;
	while(_g < 3) {
		var i = _g++;
		var o0 = o[i];
		var d0 = d[i];
		var res = verb_eval_Intersect.rays(o0,d0,ray.origin,ray.dir);
		if(res == null) continue;
		var useg = res.u0;
		var uray = res.u1;
		if(useg < -verb_core_Constants.EPSILON || useg > l[i] + verb_core_Constants.EPSILON) continue;
		if(minU == null || uray < minU.u) minU = new verb_core_CurveTriPoint(uray,verb_core_Vec.onRay(ray.origin,ray.dir,uray),verb_core_Vec.onRay(uvs[i],uvd[i],useg / l[i]));
		if(maxU == null || uray > maxU.u) maxU = new verb_core_CurveTriPoint(uray,verb_core_Vec.onRay(ray.origin,ray.dir,uray),verb_core_Vec.onRay(uvs[i],uvd[i],useg / l[i]));
	}
	if(maxU == null || minU == null) return null;
	return new verb_core_Interval(minU,maxU);
};
verb_eval_Intersect.mergeTriangleClipIntervals = function(clip1,clip2,mesh1,faceIndex1,mesh2,faceIndex2) {
	if(clip2.min.u > clip1.max.u + verb_core_Constants.EPSILON || clip1.min.u > clip2.max.u + verb_core_Constants.EPSILON) return null;
	var min;
	if(clip1.min.u > clip2.min.u) min = new verb_core_Pair(clip1.min,0); else min = new verb_core_Pair(clip2.min,1);
	var max;
	if(clip1.max.u < clip2.max.u) max = new verb_core_Pair(clip1.max,0); else max = new verb_core_Pair(clip2.max,1);
	var res = new verb_core_Interval(new verb_core_MeshIntersectionPoint(null,null,min.item0.point,faceIndex1,faceIndex2),new verb_core_MeshIntersectionPoint(null,null,max.item0.point,faceIndex1,faceIndex2));
	if(min.item1 == 0) {
		res.min.uv0 = min.item0.uv;
		res.min.uv1 = verb_core_Mesh.triangleUVFromPoint(mesh2,faceIndex2,min.item0.point);
	} else {
		res.min.uv0 = verb_core_Mesh.triangleUVFromPoint(mesh1,faceIndex1,min.item0.point);
		res.min.uv1 = min.item0.uv;
	}
	if(max.item1 == 0) {
		res.max.uv0 = max.item0.uv;
		res.max.uv1 = verb_core_Mesh.triangleUVFromPoint(mesh2,faceIndex2,max.item0.point);
	} else {
		res.max.uv0 = verb_core_Mesh.triangleUVFromPoint(mesh1,faceIndex1,max.item0.point);
		res.max.uv1 = max.item0.uv;
	}
	return res;
};
verb_eval_Intersect.planes = function(origin0,normal0,origin1,normal1) {
	var d = verb_core_Vec.cross(normal0,normal1);
	if(verb_core_Vec.dot(d,d) < verb_core_Constants.EPSILON) return null;
	var li = 0;
	var mi = Math.abs(d[0]);
	var m1 = Math.abs(d[1]);
	var m2 = Math.abs(d[2]);
	if(m1 > mi) {
		li = 1;
		mi = m1;
	}
	if(m2 > mi) {
		li = 2;
		mi = m2;
	}
	var a1;
	var b1;
	var a2;
	var b2;
	if(li == 0) {
		a1 = normal0[1];
		b1 = normal0[2];
		a2 = normal1[1];
		b2 = normal1[2];
	} else if(li == 1) {
		a1 = normal0[0];
		b1 = normal0[2];
		a2 = normal1[0];
		b2 = normal1[2];
	} else {
		a1 = normal0[0];
		b1 = normal0[1];
		a2 = normal1[0];
		b2 = normal1[1];
	}
	var d1 = -verb_core_Vec.dot(origin0,normal0);
	var d2 = -verb_core_Vec.dot(origin1,normal1);
	var den = a1 * b2 - b1 * a2;
	var x = (b1 * d2 - d1 * b2) / den;
	var y = (d1 * a2 - a1 * d2) / den;
	var p;
	if(li == 0) p = [0,x,y]; else if(li == 1) p = [x,0,y]; else p = [x,y,0];
	return new verb_core_Ray(p,verb_core_Vec.normalized(d));
};
verb_eval_Intersect.threePlanes = function(n0,d0,n1,d1,n2,d2) {
	var u = verb_core_Vec.cross(n1,n2);
	var den = verb_core_Vec.dot(n0,u);
	if(Math.abs(den) < verb_core_Constants.EPSILON) return null;
	var diff = verb_core_Vec.sub(verb_core_Vec.mul(d2,n1),verb_core_Vec.mul(d1,n2));
	var num = verb_core_Vec.add(verb_core_Vec.mul(d0,u),verb_core_Vec.cross(n0,diff));
	return verb_core_Vec.mul(1 / den,num);
};
verb_eval_Intersect.polylines = function(polyline0,polyline1,tol) {
	var res = verb_eval_Intersect.boundingBoxTrees(new verb_core_LazyPolylineBoundingBoxTree(polyline0),new verb_core_LazyPolylineBoundingBoxTree(polyline1),tol);
	var finalResults = [];
	var _g = 0;
	while(_g < res.length) {
		var event = res[_g];
		++_g;
		var polid0 = event.item0;
		var polid1 = event.item1;
		var inter = verb_eval_Intersect.segments(polyline0.points[polid0],polyline0.points[polid0 + 1],polyline1.points[polid1],polyline1.points[polid1 + 1],tol);
		if(inter == null) continue;
		inter.u0 = verb_core_Vec.lerp(inter.u0,[polyline0.params[polid0]],[polyline0.params[polid0 + 1]])[0];
		inter.u1 = verb_core_Vec.lerp(inter.u1,[polyline1.params[polid1]],[polyline1.params[polid1 + 1]])[0];
		finalResults.push(inter);
	}
	return finalResults;
};
verb_eval_Intersect.segments = function(a0,a1,b0,b1,tol) {
	var a1ma0 = verb_core_Vec.sub(a1,a0);
	var aN = Math.sqrt(verb_core_Vec.dot(a1ma0,a1ma0));
	var a = verb_core_Vec.mul(1 / aN,a1ma0);
	var b1mb0 = verb_core_Vec.sub(b1,b0);
	var bN = Math.sqrt(verb_core_Vec.dot(b1mb0,b1mb0));
	var b = verb_core_Vec.mul(1 / bN,b1mb0);
	var int_params = verb_eval_Intersect.rays(a0,a,b0,b);
	if(int_params != null) {
		var u0 = Math.min(Math.max(0,int_params.u0 / aN),1.0);
		var u1 = Math.min(Math.max(0,int_params.u1 / bN),1.0);
		var point0 = verb_core_Vec.onRay(a0,a1ma0,u0);
		var point1 = verb_core_Vec.onRay(b0,b1mb0,u1);
		var dist = verb_core_Vec.distSquared(point0,point1);
		if(dist < tol * tol) return new verb_core_CurveCurveIntersection(point0,point1,u0,u1);
	}
	return null;
};
verb_eval_Intersect.rays = function(a0,a,b0,b) {
	var dab = verb_core_Vec.dot(a,b);
	var dab0 = verb_core_Vec.dot(a,b0);
	var daa0 = verb_core_Vec.dot(a,a0);
	var dbb0 = verb_core_Vec.dot(b,b0);
	var dba0 = verb_core_Vec.dot(b,a0);
	var daa = verb_core_Vec.dot(a,a);
	var dbb = verb_core_Vec.dot(b,b);
	var div = daa * dbb - dab * dab;
	if(Math.abs(div) < verb_core_Constants.EPSILON) return null;
	var num = dab * (dab0 - daa0) - daa * (dbb0 - dba0);
	var w = num / div;
	var t = (dab0 - daa0 + w * dab) / daa;
	var p0 = verb_core_Vec.onRay(a0,a,t);
	var p1 = verb_core_Vec.onRay(b0,b,w);
	return new verb_core_CurveCurveIntersection(p0,p1,t,w);
};
verb_eval_Intersect.segmentWithTriangle = function(p0,p1,points,tri) {
	var v0 = points[tri[0]];
	var v1 = points[tri[1]];
	var v2 = points[tri[2]];
	var u = verb_core_Vec.sub(v1,v0);
	var v = verb_core_Vec.sub(v2,v0);
	var n = verb_core_Vec.cross(u,v);
	var dir = verb_core_Vec.sub(p1,p0);
	var w0 = verb_core_Vec.sub(p0,v0);
	var a = -verb_core_Vec.dot(n,w0);
	var b = verb_core_Vec.dot(n,dir);
	if(Math.abs(b) < verb_core_Constants.EPSILON) return null;
	var r = a / b;
	if(r < 0 || r > 1) return null;
	var pt = verb_core_Vec.add(p0,verb_core_Vec.mul(r,dir));
	var uv = verb_core_Vec.dot(u,v);
	var uu = verb_core_Vec.dot(u,u);
	var vv = verb_core_Vec.dot(v,v);
	var w = verb_core_Vec.sub(pt,v0);
	var wu = verb_core_Vec.dot(w,u);
	var wv = verb_core_Vec.dot(w,v);
	var denom = uv * uv - uu * vv;
	if(Math.abs(denom) < verb_core_Constants.EPSILON) return null;
	var s = (uv * wv - vv * wu) / denom;
	var t = (uv * wu - uu * wv) / denom;
	if(s > 1.0 + verb_core_Constants.EPSILON || t > 1.0 + verb_core_Constants.EPSILON || t < -verb_core_Constants.EPSILON || s < -verb_core_Constants.EPSILON || s + t > 1.0 + verb_core_Constants.EPSILON) return null;
	return new verb_core_TriSegmentIntersection(pt,s,t,r);
};
verb_eval_Intersect.segmentAndPlane = function(p0,p1,v0,n) {
	var denom = verb_core_Vec.dot(n,verb_core_Vec.sub(p1,p0));
	if(Math.abs(denom) < verb_core_Constants.EPSILON) return null;
	var numer = verb_core_Vec.dot(n,verb_core_Vec.sub(v0,p0));
	var p = numer / denom;
	if(p > 1.0 + verb_core_Constants.EPSILON || p < -verb_core_Constants.EPSILON) return null;
	return { p : p};
};
var verb_eval_Make = $hx_exports.eval.Make = function() { };
$hxClasses["verb.eval.Make"] = verb_eval_Make;
verb_eval_Make.__name__ = ["verb","eval","Make"];
verb_eval_Make.rationalTranslationalSurface = function(profile,rail) {
	var pt0 = verb_eval_Eval.rationalCurvePoint(rail,verb_core_ArrayExtensions.first(rail.knots));
	var startu = verb_core_ArrayExtensions.first(rail.knots);
	var endu = verb_core_ArrayExtensions.last(rail.knots);
	var numSamples = 2 * rail.controlPoints.length;
	var span = (endu - startu) / (numSamples - 1);
	var crvs = [];
	var _g = 0;
	while(_g < numSamples) {
		var i = _g++;
		var pt = verb_core_Vec.sub(verb_eval_Eval.rationalCurvePoint(rail,startu + i * span),pt0);
		var crv = verb_eval_Modify.rationalCurveTransform(profile,[[1,0,0,pt[0]],[0,1,0,pt[1]],[0,0,1,pt[2]],[0,0,0,1]]);
		crvs.push(crv);
	}
	return verb_eval_Make.loftedSurface(crvs);
};
verb_eval_Make.surfaceBoundaryCurves = function(surface) {
	var crvs = [];
	var c0 = verb_eval_Make.surfaceIsocurve(surface,verb_core_ArrayExtensions.first(surface.knotsU),false);
	var c1 = verb_eval_Make.surfaceIsocurve(surface,verb_core_ArrayExtensions.last(surface.knotsU),false);
	var c2 = verb_eval_Make.surfaceIsocurve(surface,verb_core_ArrayExtensions.first(surface.knotsV),true);
	var c3 = verb_eval_Make.surfaceIsocurve(surface,verb_core_ArrayExtensions.last(surface.knotsV),true);
	return [c0,c1,c2,c3];
};
verb_eval_Make.surfaceIsocurve = function(surface,u,useV) {
	if(useV == null) useV = false;
	var knots;
	if(useV) knots = surface.knotsV; else knots = surface.knotsU;
	var degree;
	if(useV) degree = surface.degreeV; else degree = surface.degreeU;
	var knotMults = verb_eval_Analyze.knotMultiplicities(knots);
	var reqKnotIndex = -1;
	var _g1 = 0;
	var _g = knotMults.length;
	while(_g1 < _g) {
		var i = _g1++;
		if(Math.abs(u - knotMults[i].knot) < verb_core_Constants.EPSILON) {
			reqKnotIndex = i;
			break;
		}
	}
	var numKnotsToInsert = degree + 1;
	if(reqKnotIndex >= 0) numKnotsToInsert = numKnotsToInsert - knotMults[reqKnotIndex].mult;
	var newSrf;
	if(numKnotsToInsert > 0) newSrf = verb_eval_Modify.surfaceKnotRefine(surface,verb_core_Vec.rep(numKnotsToInsert,u),useV); else newSrf = surface;
	var span = verb_eval_Eval.knotSpan(degree,u,knots);
	if(Math.abs(u - verb_core_ArrayExtensions.first(knots)) < verb_core_Constants.EPSILON) span = 0; else if(Math.abs(u - verb_core_ArrayExtensions.last(knots)) < verb_core_Constants.EPSILON) span = (useV?newSrf.controlPoints[0].length:newSrf.controlPoints.length) - 1;
	if(useV) return new verb_core_NurbsCurveData(newSrf.degreeU,newSrf.knotsU,(function($this) {
		var $r;
		var _g2 = [];
		{
			var _g11 = 0;
			var _g21 = newSrf.controlPoints;
			while(_g11 < _g21.length) {
				var row = _g21[_g11];
				++_g11;
				_g2.push(row[span]);
			}
		}
		$r = _g2;
		return $r;
	}(this)));
	return new verb_core_NurbsCurveData(newSrf.degreeV,newSrf.knotsV,newSrf.controlPoints[span]);
};
verb_eval_Make.loftedSurface = function(curves,degreeV) {
	curves = verb_eval_Modify.unifyCurveKnotVectors(curves);
	var degreeU = curves[0].degree;
	if(degreeV == null) degreeV = 3;
	if(degreeV > curves.length - 1) degreeV = curves.length - 1;
	var knotsU = curves[0].knots;
	var knotsV = [];
	var controlPoints = [];
	var _g1 = 0;
	var _g = curves[0].controlPoints.length;
	while(_g1 < _g) {
		var i = [_g1++];
		var points = curves.map((function(i) {
			return function(x) {
				return x.controlPoints[i[0]];
			};
		})(i));
		var c = verb_eval_Make.rationalInterpCurve(points,degreeV,true);
		controlPoints.push(c.controlPoints);
		knotsV = c.knots;
	}
	return new verb_core_NurbsSurfaceData(degreeU,degreeV,knotsU,knotsV,controlPoints);
};
verb_eval_Make.clonedCurve = function(curve) {
	return new verb_core_NurbsCurveData(curve.degree,curve.knots.slice(),curve.controlPoints.map(function(x) {
		return x.slice();
	}));
};
verb_eval_Make.rationalBezierCurve = function(controlPoints,weights) {
	var degree = controlPoints.length - 1;
	var knots = [];
	var _g1 = 0;
	var _g = degree + 1;
	while(_g1 < _g) {
		var i = _g1++;
		knots.push(0.0);
	}
	var _g11 = 0;
	var _g2 = degree + 1;
	while(_g11 < _g2) {
		var i1 = _g11++;
		knots.push(1.0);
	}
	if(weights == null) weights = verb_core_Vec.rep(controlPoints.length,1.0);
	return new verb_core_NurbsCurveData(degree,knots,verb_eval_Eval.homogenize1d(controlPoints,weights));
};
verb_eval_Make.fourPointSurface = function(p1,p2,p3,p4,degree) {
	if(degree == null) degree = 3;
	var degreeFloat = degree;
	var pts = [];
	var _g1 = 0;
	var _g = degree + 1;
	while(_g1 < _g) {
		var i = _g1++;
		var row = [];
		var _g3 = 0;
		var _g2 = degree + 1;
		while(_g3 < _g2) {
			var j = _g3++;
			var l = 1.0 - i / degreeFloat;
			var p1p2 = verb_core_Vec.lerp(l,p1,p2);
			var p4p3 = verb_core_Vec.lerp(l,p4,p3);
			var res = verb_core_Vec.lerp(1.0 - j / degreeFloat,p1p2,p4p3);
			res.push(1.0);
			row.push(res);
		}
		pts.push(row);
	}
	var zeros = verb_core_Vec.rep(degree + 1,0.0);
	var ones = verb_core_Vec.rep(degree + 1,1.0);
	return new verb_core_NurbsSurfaceData(degree,degree,zeros.concat(ones),zeros.concat(ones),pts);
};
verb_eval_Make.ellipseArc = function(center,xaxis,yaxis,startAngle,endAngle) {
	var xradius = verb_core_Vec.norm(xaxis);
	var yradius = verb_core_Vec.norm(yaxis);
	xaxis = verb_core_Vec.normalized(xaxis);
	yaxis = verb_core_Vec.normalized(yaxis);
	if(endAngle < startAngle) endAngle = 2.0 * Math.PI + startAngle;
	var theta = endAngle - startAngle;
	var numArcs = 0;
	if(theta <= Math.PI / 2) numArcs = 1; else if(theta <= Math.PI) numArcs = 2; else if(theta <= 3 * Math.PI / 2) numArcs = 3; else numArcs = 4;
	var dtheta = theta / numArcs;
	var n = 2 * numArcs;
	var w1 = Math.cos(dtheta / 2);
	var P0 = verb_core_Vec.add(center,verb_core_Vec.add(verb_core_Vec.mul(xradius * Math.cos(startAngle),xaxis),verb_core_Vec.mul(yradius * Math.sin(startAngle),yaxis)));
	var T0 = verb_core_Vec.sub(verb_core_Vec.mul(Math.cos(startAngle),yaxis),verb_core_Vec.mul(Math.sin(startAngle),xaxis));
	var controlPoints = [];
	var knots = verb_core_Vec.zeros1d(2 * numArcs + 3);
	var index = 0;
	var angle = startAngle;
	var weights = verb_core_Vec.zeros1d(numArcs * 2);
	controlPoints[0] = P0;
	weights[0] = 1.0;
	var _g1 = 1;
	var _g = numArcs + 1;
	while(_g1 < _g) {
		var i = _g1++;
		angle += dtheta;
		var P2 = verb_core_Vec.add(center,verb_core_Vec.add(verb_core_Vec.mul(xradius * Math.cos(angle),xaxis),verb_core_Vec.mul(yradius * Math.sin(angle),yaxis)));
		weights[index + 2] = 1;
		controlPoints[index + 2] = P2;
		var T2 = verb_core_Vec.sub(verb_core_Vec.mul(Math.cos(angle),yaxis),verb_core_Vec.mul(Math.sin(angle),xaxis));
		var inters = verb_eval_Intersect.rays(P0,verb_core_Vec.mul(1 / verb_core_Vec.norm(T0),T0),P2,verb_core_Vec.mul(1 / verb_core_Vec.norm(T2),T2));
		var P1 = verb_core_Vec.add(P0,verb_core_Vec.mul(inters.u0,T0));
		weights[index + 1] = w1;
		controlPoints[index + 1] = P1;
		index += 2;
		if(i < numArcs) {
			P0 = P2;
			T0 = T2;
		}
	}
	var j = 2 * numArcs + 1;
	var _g2 = 0;
	while(_g2 < 3) {
		var i1 = _g2++;
		knots[i1] = 0.0;
		knots[i1 + j] = 1.0;
	}
	switch(numArcs) {
	case 2:
		knots[3] = knots[4] = 0.5;
		break;
	case 3:
		knots[3] = knots[4] = 0.333333333333333315;
		knots[5] = knots[6] = 0.66666666666666663;
		break;
	case 4:
		knots[3] = knots[4] = 0.25;
		knots[5] = knots[6] = 0.5;
		knots[7] = knots[8] = 0.75;
		break;
	}
	return new verb_core_NurbsCurveData(2,knots,verb_eval_Eval.homogenize1d(controlPoints,weights));
};
verb_eval_Make.arc = function(center,xaxis,yaxis,radius,startAngle,endAngle) {
	return verb_eval_Make.ellipseArc(center,verb_core_Vec.mul(radius,verb_core_Vec.normalized(xaxis)),verb_core_Vec.mul(radius,verb_core_Vec.normalized(yaxis)),startAngle,endAngle);
};
verb_eval_Make.polyline = function(pts) {
	var knots = [0.0,0.0];
	var lsum = 0.0;
	var _g1 = 0;
	var _g = pts.length - 1;
	while(_g1 < _g) {
		var i = _g1++;
		lsum += verb_core_Vec.dist(pts[i],pts[i + 1]);
		knots.push(lsum);
	}
	knots.push(lsum);
	knots = verb_core_Vec.mul(1 / lsum,knots);
	var weights;
	var _g2 = [];
	var _g21 = 0;
	var _g11 = pts.length;
	while(_g21 < _g11) {
		var i1 = _g21++;
		_g2.push(1.0);
	}
	weights = _g2;
	return new verb_core_NurbsCurveData(1,knots,verb_eval_Eval.homogenize1d(pts.slice(0),weights));
};
verb_eval_Make.extrudedSurface = function(axis,length,profile) {
	var controlPoints = [[],[],[]];
	var weights = [[],[],[]];
	var prof_controlPoints = verb_eval_Eval.dehomogenize1d(profile.controlPoints);
	var prof_weights = verb_eval_Eval.weight1d(profile.controlPoints);
	var translation = verb_core_Vec.mul(length,axis);
	var halfTranslation = verb_core_Vec.mul(0.5 * length,axis);
	var _g1 = 0;
	var _g = prof_controlPoints.length;
	while(_g1 < _g) {
		var j = _g1++;
		controlPoints[2][j] = prof_controlPoints[j];
		controlPoints[1][j] = verb_core_Vec.add(halfTranslation,prof_controlPoints[j]);
		controlPoints[0][j] = verb_core_Vec.add(translation,prof_controlPoints[j]);
		weights[0][j] = prof_weights[j];
		weights[1][j] = prof_weights[j];
		weights[2][j] = prof_weights[j];
	}
	return new verb_core_NurbsSurfaceData(2,profile.degree,[0,0,0,1,1,1],profile.knots,verb_eval_Eval.homogenize2d(controlPoints,weights));
};
verb_eval_Make.cylindricalSurface = function(axis,xaxis,base,height,radius) {
	var yaxis = verb_core_Vec.cross(axis,xaxis);
	var angle = 2.0 * Math.PI;
	var circ = verb_eval_Make.arc(base,xaxis,yaxis,radius,0.0,2 * Math.PI);
	return verb_eval_Make.extrudedSurface(axis,height,circ);
};
verb_eval_Make.revolvedSurface = function(profile,center,axis,theta) {
	var prof_controlPoints = verb_eval_Eval.dehomogenize1d(profile.controlPoints);
	var prof_weights = verb_eval_Eval.weight1d(profile.controlPoints);
	var narcs;
	var knotsU;
	var controlPoints;
	var weights;
	if(theta <= Math.PI / 2) {
		narcs = 1;
		knotsU = verb_core_Vec.zeros1d(6 + 2 * (narcs - 1));
	} else if(theta <= Math.PI) {
		narcs = 2;
		knotsU = verb_core_Vec.zeros1d(6 + 2 * (narcs - 1));
		knotsU[3] = knotsU[4] = 0.5;
	} else if(theta <= 3 * Math.PI / 2) {
		narcs = 3;
		knotsU = verb_core_Vec.zeros1d(6 + 2 * (narcs - 1));
		knotsU[3] = knotsU[4] = 0.333333333333333315;
		knotsU[5] = knotsU[6] = 0.66666666666666663;
	} else {
		narcs = 4;
		knotsU = verb_core_Vec.zeros1d(6 + 2 * (narcs - 1));
		knotsU[3] = knotsU[4] = 0.25;
		knotsU[5] = knotsU[6] = 0.5;
		knotsU[7] = knotsU[8] = 0.75;
	}
	var dtheta = theta / narcs;
	var j = 3 + 2 * (narcs - 1);
	var _g = 0;
	while(_g < 3) {
		var i = _g++;
		knotsU[i] = 0.0;
		knotsU[j + i] = 1.0;
	}
	var n = 2 * narcs;
	var wm = Math.cos(dtheta / 2.0);
	var angle = 0.0;
	var sines = verb_core_Vec.zeros1d(narcs + 1);
	var cosines = verb_core_Vec.zeros1d(narcs + 1);
	var controlPoints1 = verb_core_Vec.zeros3d(2 * narcs + 1,prof_controlPoints.length,3);
	var weights1 = verb_core_Vec.zeros2d(2 * narcs + 1,prof_controlPoints.length);
	var _g1 = 1;
	var _g2 = narcs + 1;
	while(_g1 < _g2) {
		var i1 = _g1++;
		angle += dtheta;
		cosines[i1] = Math.cos(angle);
		sines[i1] = Math.sin(angle);
	}
	var _g11 = 0;
	var _g3 = prof_controlPoints.length;
	while(_g11 < _g3) {
		var j1 = _g11++;
		var O = verb_core_Trig.rayClosestPoint(prof_controlPoints[j1],center,axis);
		var X = verb_core_Vec.sub(prof_controlPoints[j1],O);
		var r = verb_core_Vec.norm(X);
		var Y = verb_core_Vec.cross(axis,X);
		if(r > verb_core_Constants.EPSILON) {
			X = verb_core_Vec.mul(1 / r,X);
			Y = verb_core_Vec.mul(1 / r,Y);
		}
		controlPoints1[0][j1] = prof_controlPoints[j1];
		var P0 = prof_controlPoints[j1];
		weights1[0][j1] = prof_weights[j1];
		var T0 = Y;
		var index = 0;
		var angle1 = 0.0;
		var _g31 = 1;
		var _g21 = narcs + 1;
		while(_g31 < _g21) {
			var i2 = _g31++;
			var P2;
			if(r == 0) P2 = O; else P2 = verb_core_Vec.add(O,verb_core_Vec.add(verb_core_Vec.mul(r * cosines[i2],X),verb_core_Vec.mul(r * sines[i2],Y)));
			controlPoints1[index + 2][j1] = P2;
			weights1[index + 2][j1] = prof_weights[j1];
			var T2 = verb_core_Vec.sub(verb_core_Vec.mul(cosines[i2],Y),verb_core_Vec.mul(sines[i2],X));
			if(r == 0) controlPoints1[index + 1][j1] = O; else {
				var inters = verb_eval_Intersect.rays(P0,verb_core_Vec.mul(1 / verb_core_Vec.norm(T0),T0),P2,verb_core_Vec.mul(1 / verb_core_Vec.norm(T2),T2));
				var P1 = verb_core_Vec.add(P0,verb_core_Vec.mul(inters.u0,T0));
				controlPoints1[index + 1][j1] = P1;
			}
			weights1[index + 1][j1] = wm * prof_weights[j1];
			index += 2;
			if(i2 < narcs) {
				P0 = P2;
				T0 = T2;
			}
		}
	}
	return new verb_core_NurbsSurfaceData(2,profile.degree,knotsU,profile.knots,verb_eval_Eval.homogenize2d(controlPoints1,weights1));
};
verb_eval_Make.sphericalSurface = function(center,axis,xaxis,radius) {
	var arc = verb_eval_Make.arc(center,verb_core_Vec.mul(-1.0,axis),xaxis,radius,0.0,Math.PI);
	return verb_eval_Make.revolvedSurface(arc,center,axis,2 * Math.PI);
};
verb_eval_Make.conicalSurface = function(axis,xaxis,base,height,radius) {
	var angle = 2 * Math.PI;
	var prof_degree = 1;
	var prof_ctrl_pts = [verb_core_Vec.add(base,verb_core_Vec.mul(height,axis)),verb_core_Vec.add(base,verb_core_Vec.mul(radius,xaxis))];
	var prof_knots = [0.0,0.0,1.0,1.0];
	var prof_weights = [1.0,1.0];
	var prof = new verb_core_NurbsCurveData(prof_degree,prof_knots,verb_eval_Eval.homogenize1d(prof_ctrl_pts,prof_weights));
	return verb_eval_Make.revolvedSurface(prof,base,axis,angle);
};
verb_eval_Make.rationalInterpCurve = function(points,degree,homogeneousPoints,start_tangent,end_tangent) {
	if(homogeneousPoints == null) homogeneousPoints = false;
	if(degree == null) degree = 3;
	if(points.length < degree + 1) throw new js__$Boot_HaxeError("You need to supply at least degree + 1 points! You only supplied " + points.length + " points.");
	var us = [0.0];
	var _g1 = 1;
	var _g = points.length;
	while(_g1 < _g) {
		var i = _g1++;
		var chord = verb_core_Vec.norm(verb_core_Vec.sub(points[i],points[i - 1]));
		var last = us[us.length - 1];
		us.push(last + chord);
	}
	var max = us[us.length - 1];
	var _g11 = 0;
	var _g2 = us.length;
	while(_g11 < _g2) {
		var i1 = _g11++;
		us[i1] = us[i1] / max;
	}
	var knotsStart = verb_core_Vec.rep(degree + 1,0.0);
	var hasTangents = start_tangent != null && end_tangent != null;
	var start;
	if(hasTangents) start = 0; else start = 1;
	var end;
	if(hasTangents) end = us.length - degree + 1; else end = us.length - degree;
	var _g3 = start;
	while(_g3 < end) {
		var i2 = _g3++;
		var weightSums = 0.0;
		var _g12 = 0;
		while(_g12 < degree) {
			var j = _g12++;
			weightSums += us[i2 + j];
		}
		knotsStart.push(1 / degree * weightSums);
	}
	var knots = knotsStart.concat(verb_core_Vec.rep(degree + 1,1.0));
	var A = [];
	var n;
	if(hasTangents) n = points.length + 1; else n = points.length - 1;
	var lst;
	if(hasTangents) lst = 1; else lst = 0;
	var ld;
	if(hasTangents) ld = points.length - (degree - 1); else ld = points.length - (degree + 1);
	var _g4 = 0;
	while(_g4 < us.length) {
		var u = us[_g4];
		++_g4;
		var span = verb_eval_Eval.knotSpanGivenN(n,degree,u,knots);
		var basisFuncs = verb_eval_Eval.basisFunctionsGivenKnotSpanIndex(span,u,degree,knots);
		var ls = span - degree;
		var rowstart = verb_core_Vec.zeros1d(ls);
		var rowend = verb_core_Vec.zeros1d(ld - ls);
		A.push(rowstart.concat(basisFuncs).concat(rowend));
	}
	if(hasTangents) {
		var ln = A[0].length - 2;
		var tanRow0 = [-1.0,1.0].concat(verb_core_Vec.zeros1d(ln));
		var tanRow1 = verb_core_Vec.zeros1d(ln).concat([-1.0,1.0]);
		verb_core_ArrayExtensions.spliceAndInsert(A,1,0,tanRow0);
		verb_core_ArrayExtensions.spliceAndInsert(A,A.length - 1,0,tanRow1);
	}
	var dim = points[0].length;
	var xs = [];
	var mult1 = (1 - knots[knots.length - degree - 2]) / degree;
	var mult0 = knots[degree + 1] / degree;
	var _g5 = 0;
	while(_g5 < dim) {
		var i3 = [_g5++];
		var b;
		if(!hasTangents) b = points.map((function(i3) {
			return function(x1) {
				return x1[i3[0]];
			};
		})(i3)); else {
			b = [points[0][i3[0]]];
			b.push(mult0 * start_tangent[i3[0]]);
			var _g21 = 1;
			var _g13 = points.length - 1;
			while(_g21 < _g13) {
				var j1 = _g21++;
				b.push(points[j1][i3[0]]);
			}
			b.push(mult1 * end_tangent[i3[0]]);
			b.push(verb_core_ArrayExtensions.last(points)[i3[0]]);
		}
		var x = verb_core_Mat.solve(A,b);
		xs.push(x);
	}
	var controlPts = verb_core_Mat.transpose(xs);
	if(!homogeneousPoints) {
		var weights = verb_core_Vec.rep(controlPts.length,1.0);
		controlPts = verb_eval_Eval.homogenize1d(controlPts,weights);
	}
	return new verb_core_NurbsCurveData(degree,knots,controlPts);
};
var verb_eval_Modify = $hx_exports.eval.Modify = function() { };
$hxClasses["verb.eval.Modify"] = verb_eval_Modify;
verb_eval_Modify.__name__ = ["verb","eval","Modify"];
verb_eval_Modify.curveReverse = function(curve) {
	return new verb_core_NurbsCurveData(curve.degree,verb_eval_Modify.knotsReverse(curve.knots),verb_core_ArrayExtensions.reversed(curve.controlPoints));
};
verb_eval_Modify.surfaceReverse = function(surface,useV) {
	if(useV == null) useV = false;
	if(useV) return new verb_core_NurbsSurfaceData(surface.degreeU,surface.degreeV,surface.knotsU,verb_eval_Modify.knotsReverse(surface.knotsV),(function($this) {
		var $r;
		var _g = [];
		{
			var _g1 = 0;
			var _g2 = surface.controlPoints;
			while(_g1 < _g2.length) {
				var row = _g2[_g1];
				++_g1;
				_g.push(verb_core_ArrayExtensions.reversed(row));
			}
		}
		$r = _g;
		return $r;
	}(this)));
	return new verb_core_NurbsSurfaceData(surface.degreeU,surface.degreeV,verb_eval_Modify.knotsReverse(surface.knotsU),surface.knotsV,verb_core_ArrayExtensions.reversed(surface.controlPoints));
};
verb_eval_Modify.knotsReverse = function(knots) {
	var min = verb_core_ArrayExtensions.first(knots);
	var max = verb_core_ArrayExtensions.last(knots);
	var l = [min];
	var len = knots.length;
	var _g = 1;
	while(_g < len) {
		var i = _g++;
		l.push(l[i - 1] + (knots[len - i] - knots[len - i - 1]));
	}
	return l;
};
verb_eval_Modify.unifyCurveKnotVectors = function(curves) {
	curves = curves.map(verb_eval_Make.clonedCurve);
	var maxDegree = Lambda.fold(curves,function(x,a) {
		return verb_eval_Modify.imax(x.degree,a);
	},0);
	var _g1 = 0;
	var _g = curves.length;
	while(_g1 < _g) {
		var i = _g1++;
		if(curves[i].degree < maxDegree) curves[i] = verb_eval_Modify.curveElevateDegree(curves[i],maxDegree);
	}
	var knotIntervals;
	var _g2 = [];
	var _g11 = 0;
	while(_g11 < curves.length) {
		var c = curves[_g11];
		++_g11;
		_g2.push(new verb_core_Interval(verb_core_ArrayExtensions.first(c.knots),verb_core_ArrayExtensions.last(c.knots)));
	}
	knotIntervals = _g2;
	var _g21 = 0;
	var _g12 = curves.length;
	while(_g21 < _g12) {
		var i1 = _g21++;
		var min = [knotIntervals[i1].min];
		curves[i1].knots = curves[i1].knots.map((function(min) {
			return function(x4) {
				return x4 - min[0];
			};
		})(min));
	}
	var knotSpans = knotIntervals.map(function(x1) {
		return x1.max - x1.min;
	});
	var maxKnotSpan = Lambda.fold(knotSpans,function(x2,a1) {
		return Math.max(x2,a1);
	},0.0);
	var _g22 = 0;
	var _g13 = curves.length;
	while(_g22 < _g13) {
		var i2 = _g22++;
		var scale = [maxKnotSpan / knotSpans[i2]];
		curves[i2].knots = curves[i2].knots.map((function(scale) {
			return function(x5) {
				return x5 * scale[0];
			};
		})(scale));
	}
	var mergedKnots = Lambda.fold(curves,function(x3,a2) {
		return verb_core_Vec.sortedSetUnion(x3.knots,a2);
	},[]);
	var _g23 = 0;
	var _g14 = curves.length;
	while(_g23 < _g14) {
		var i3 = _g23++;
		var rem = verb_core_Vec.sortedSetSub(mergedKnots,curves[i3].knots);
		if(rem.length == 0) curves[i3] = curves[i3];
		curves[i3] = verb_eval_Modify.curveKnotRefine(curves[i3],rem);
	}
	return curves;
};
verb_eval_Modify.imin = function(a,b) {
	if(a < b) return a; else return b;
};
verb_eval_Modify.imax = function(a,b) {
	if(a > b) return a; else return b;
};
verb_eval_Modify.curveElevateDegree = function(curve,finalDegree) {
	if(finalDegree <= curve.degree) return curve;
	var n = curve.knots.length - curve.degree - 2;
	var newDegree = curve.degree;
	var knots = curve.knots;
	var controlPoints = curve.controlPoints;
	var degreeInc = finalDegree - curve.degree;
	var dim = curve.controlPoints[0].length;
	var bezalfs = verb_core_Vec.zeros2d(newDegree + degreeInc + 1,newDegree + 1);
	var bpts = [];
	var ebpts = [];
	var Nextbpts = [];
	var alphas = [];
	var m = n + newDegree + 1;
	var ph = finalDegree;
	var ph2 = Math.floor(ph / 2);
	var Qw = [];
	var Uh = [];
	var nh;
	bezalfs[0][0] = 1.0;
	bezalfs[ph][newDegree] = 1.0;
	var _g1 = 1;
	var _g = ph2 + 1;
	while(_g1 < _g) {
		var i = _g1++;
		var inv = 1.0 / verb_core_Binomial.get(ph,i);
		var mpi = verb_eval_Modify.imin(newDegree,i);
		var _g3 = verb_eval_Modify.imax(0,i - degreeInc);
		var _g2 = mpi + 1;
		while(_g3 < _g2) {
			var j = _g3++;
			bezalfs[i][j] = inv * verb_core_Binomial.get(newDegree,j) * verb_core_Binomial.get(degreeInc,i - j);
		}
	}
	var _g4 = ph2 + 1;
	while(_g4 < ph) {
		var i1 = _g4++;
		var mpi1 = verb_eval_Modify.imin(newDegree,i1);
		var _g21 = verb_eval_Modify.imax(0,i1 - degreeInc);
		var _g11 = mpi1 + 1;
		while(_g21 < _g11) {
			var j1 = _g21++;
			bezalfs[i1][j1] = bezalfs[ph - i1][newDegree - j1];
		}
	}
	var mh = ph;
	var kind = ph + 1;
	var r = -1;
	var a = newDegree;
	var b = newDegree + 1;
	var cind = 1;
	var ua = knots[0];
	Qw[0] = controlPoints[0];
	var _g12 = 0;
	var _g5 = ph + 1;
	while(_g12 < _g5) {
		var i2 = _g12++;
		Uh[i2] = ua;
	}
	var _g13 = 0;
	var _g6 = newDegree + 1;
	while(_g13 < _g6) {
		var i3 = _g13++;
		bpts[i3] = controlPoints[i3];
	}
	while(b < m) {
		var i4 = b;
		while(b < m && knots[b] == knots[b + 1]) b = b + 1;
		var mul = b - i4 + 1;
		var mh1 = mh + mul + degreeInc;
		var ub = knots[b];
		var oldr = r;
		r = newDegree - mul;
		var lbz;
		if(oldr > 0) lbz = Math.floor((oldr + 2) / 2); else lbz = 1;
		var rbz;
		if(r > 0) rbz = Math.floor(ph - (r + 1) / 2); else rbz = ph;
		if(r > 0) {
			var numer = ub - ua;
			var alfs = [];
			var k = newDegree;
			while(k > mul) {
				alfs[k - mul - 1] = numer / (knots[a + k] - ua);
				k--;
			}
			var _g14 = 1;
			var _g7 = r + 1;
			while(_g14 < _g7) {
				var j2 = _g14++;
				var save = r - j2;
				var s = mul + j2;
				var k1 = newDegree;
				while(k1 >= s) {
					bpts[k1] = verb_core_Vec.add(verb_core_Vec.mul(alfs[k1 - s],bpts[k1]),verb_core_Vec.mul(1.0 - alfs[k1 - s],bpts[k1 - 1]));
					k1--;
				}
				Nextbpts[save] = bpts[newDegree];
			}
		}
		var _g15 = lbz;
		var _g8 = ph + 1;
		while(_g15 < _g8) {
			var i5 = _g15++;
			ebpts[i5] = verb_core_Vec.zeros1d(dim);
			var mpi2 = verb_eval_Modify.imin(newDegree,i5);
			var _g31 = verb_eval_Modify.imax(0,i5 - degreeInc);
			var _g22 = mpi2 + 1;
			while(_g31 < _g22) {
				var j3 = _g31++;
				ebpts[i5] = verb_core_Vec.add(ebpts[i5],verb_core_Vec.mul(bezalfs[i5][j3],bpts[j3]));
			}
		}
		if(oldr > 1) {
			var first = kind - 2;
			var last = kind;
			var den = ub - ua;
			var bet = (ub - Uh[kind - 1]) / den;
			var _g9 = 1;
			while(_g9 < oldr) {
				var tr = _g9++;
				var i6 = first;
				var j4 = last;
				var kj = j4 - kind + 1;
				while(j4 - i6 > tr) {
					if(i6 < cind) {
						var alf = (ub - Uh[i6]) / (ua - Uh[i6]);
						Qw[i6] = verb_core_Vec.lerp(alf,Qw[i6],Qw[i6 - 1]);
					}
					if(j4 >= lbz) {
						if(j4 - tr <= kind - ph + oldr) {
							var gam = (ub - Uh[j4 - tr]) / den;
							ebpts[kj] = verb_core_Vec.lerp(gam,ebpts[kj],ebpts[kj + 1]);
						}
					} else ebpts[kj] = verb_core_Vec.lerp(bet,ebpts[kj],ebpts[kj + 1]);
					i6 = i6 + 1;
					j4 = j4 - 1;
					kj = kj - 1;
				}
				first = first - 1;
				last = last + 1;
			}
		}
		if(a != newDegree) {
			var _g16 = 0;
			var _g10 = ph - oldr;
			while(_g16 < _g10) {
				var i7 = _g16++;
				Uh[kind] = ua;
				kind = kind + 1;
			}
		}
		var _g17 = lbz;
		var _g18 = rbz + 1;
		while(_g17 < _g18) {
			var j5 = _g17++;
			Qw[cind] = ebpts[j5];
			cind = cind + 1;
		}
		if(b < m) {
			var _g19 = 0;
			while(_g19 < r) {
				var j6 = _g19++;
				bpts[j6] = Nextbpts[j6];
			}
			var _g110 = r;
			var _g20 = newDegree + 1;
			while(_g110 < _g20) {
				var j7 = _g110++;
				bpts[j7] = controlPoints[b - newDegree + j7];
			}
			a = b;
			b = b + 1;
			ua = ub;
		} else {
			var _g111 = 0;
			var _g23 = ph + 1;
			while(_g111 < _g23) {
				var i8 = _g111++;
				Uh[kind + i8] = ub;
			}
		}
	}
	nh = mh - ph - 1;
	return new verb_core_NurbsCurveData(finalDegree,Uh,Qw);
};
verb_eval_Modify.rationalSurfaceTransform = function(surface,mat) {
	var pts = verb_eval_Eval.dehomogenize2d(surface.controlPoints);
	var _g1 = 0;
	var _g = pts.length;
	while(_g1 < _g) {
		var i = _g1++;
		var _g3 = 0;
		var _g2 = pts[i].length;
		while(_g3 < _g2) {
			var j = _g3++;
			var homoPt = pts[i][j];
			homoPt.push(1.0);
			pts[i][j] = verb_core_Mat.dot(mat,homoPt).slice(0,homoPt.length - 1);
		}
	}
	return new verb_core_NurbsSurfaceData(surface.degreeU,surface.degreeV,surface.knotsU.slice(),surface.knotsV.slice(),verb_eval_Eval.homogenize2d(pts,verb_eval_Eval.weight2d(surface.controlPoints)));
};
verb_eval_Modify.rationalCurveTransform = function(curve,mat) {
	var pts = verb_eval_Eval.dehomogenize1d(curve.controlPoints);
	var _g1 = 0;
	var _g = pts.length;
	while(_g1 < _g) {
		var i = _g1++;
		var homoPt = pts[i];
		homoPt.push(1.0);
		pts[i] = verb_core_Mat.dot(mat,homoPt).slice(0,homoPt.length - 1);
	}
	return new verb_core_NurbsCurveData(curve.degree,curve.knots.slice(),verb_eval_Eval.homogenize1d(pts,verb_eval_Eval.weight1d(curve.controlPoints)));
};
verb_eval_Modify.surfaceKnotRefine = function(surface,knotsToInsert,useV) {
	var newPts = [];
	var knots;
	var degree;
	var ctrlPts;
	if(!useV) {
		ctrlPts = verb_core_Mat.transpose(surface.controlPoints);
		knots = surface.knotsU;
		degree = surface.degreeU;
	} else {
		ctrlPts = surface.controlPoints;
		knots = surface.knotsV;
		degree = surface.degreeV;
	}
	var c = null;
	var _g = 0;
	while(_g < ctrlPts.length) {
		var cptrow = ctrlPts[_g];
		++_g;
		c = verb_eval_Modify.curveKnotRefine(new verb_core_NurbsCurveData(degree,knots,cptrow),knotsToInsert);
		newPts.push(c.controlPoints);
	}
	var newknots = c.knots;
	if(!useV) {
		newPts = verb_core_Mat.transpose(newPts);
		return new verb_core_NurbsSurfaceData(surface.degreeU,surface.degreeV,newknots,surface.knotsV.slice(),newPts);
	} else return new verb_core_NurbsSurfaceData(surface.degreeU,surface.degreeV,surface.knotsU.slice(),newknots,newPts);
};
verb_eval_Modify.decomposeCurveIntoBeziers = function(curve) {
	var degree = curve.degree;
	var controlPoints = curve.controlPoints;
	var knots = curve.knots;
	var knotmults = verb_eval_Analyze.knotMultiplicities(knots);
	var reqMult = degree + 1;
	var _g = 0;
	while(_g < knotmults.length) {
		var knotmult = knotmults[_g];
		++_g;
		if(knotmult.mult < reqMult) {
			var knotsInsert = verb_core_Vec.rep(reqMult - knotmult.mult,knotmult.knot);
			var res = verb_eval_Modify.curveKnotRefine(new verb_core_NurbsCurveData(degree,knots,controlPoints),knotsInsert);
			knots = res.knots;
			controlPoints = res.controlPoints;
		}
	}
	var numCrvs = knots.length / reqMult - 1;
	var crvKnotLength = reqMult * 2;
	var crvs = [];
	var i = 0;
	while(i < controlPoints.length) {
		var kts = knots.slice(i,i + crvKnotLength);
		var pts = controlPoints.slice(i,i + reqMult);
		crvs.push(new verb_core_NurbsCurveData(degree,kts,pts));
		i += reqMult;
	}
	return crvs;
};
verb_eval_Modify.curveKnotRefine = function(curve,knotsToInsert) {
	if(knotsToInsert.length == 0) return verb_eval_Make.clonedCurve(curve);
	var degree = curve.degree;
	var controlPoints = curve.controlPoints;
	var knots = curve.knots;
	var n = controlPoints.length - 1;
	var m = n + degree + 1;
	var r = knotsToInsert.length - 1;
	var a = verb_eval_Eval.knotSpan(degree,knotsToInsert[0],knots);
	var b = verb_eval_Eval.knotSpan(degree,knotsToInsert[r],knots);
	var controlPoints_post = [];
	var knots_post = [];
	var _g1 = 0;
	var _g = a - degree + 1;
	while(_g1 < _g) {
		var i1 = _g1++;
		controlPoints_post[i1] = controlPoints[i1];
	}
	var _g11 = b - 1;
	var _g2 = n + 1;
	while(_g11 < _g2) {
		var i2 = _g11++;
		controlPoints_post[i2 + r + 1] = controlPoints[i2];
	}
	var _g12 = 0;
	var _g3 = a + 1;
	while(_g12 < _g3) {
		var i3 = _g12++;
		knots_post[i3] = knots[i3];
	}
	var _g13 = b + degree;
	var _g4 = m + 1;
	while(_g13 < _g4) {
		var i4 = _g13++;
		knots_post[i4 + r + 1] = knots[i4];
	}
	var i = b + degree - 1;
	var k = b + degree + r;
	var j = r;
	while(j >= 0) {
		while(knotsToInsert[j] <= knots[i] && i > a) {
			controlPoints_post[k - degree - 1] = controlPoints[i - degree - 1];
			knots_post[k] = knots[i];
			k = k - 1;
			i = i - 1;
		}
		controlPoints_post[k - degree - 1] = controlPoints_post[k - degree];
		var _g14 = 1;
		var _g5 = degree + 1;
		while(_g14 < _g5) {
			var l = _g14++;
			var ind = k - degree + l;
			var alfa = knots_post[k + l] - knotsToInsert[j];
			if(Math.abs(alfa) < verb_core_Constants.EPSILON) controlPoints_post[ind - 1] = controlPoints_post[ind]; else {
				alfa = alfa / (knots_post[k + l] - knots[i - degree + l]);
				controlPoints_post[ind - 1] = verb_core_Vec.add(verb_core_Vec.mul(alfa,controlPoints_post[ind - 1]),verb_core_Vec.mul(1.0 - alfa,controlPoints_post[ind]));
			}
		}
		knots_post[k] = knotsToInsert[j];
		k = k - 1;
		j--;
	}
	return new verb_core_NurbsCurveData(degree,knots_post,controlPoints_post);
};
verb_eval_Modify.curveKnotInsert = function(curve,u,r) {
	var degree = curve.degree;
	var controlPoints = curve.controlPoints;
	var knots = curve.knots;
	var s = 0;
	var num_pts = controlPoints.length;
	var k = verb_eval_Eval.knotSpan(degree,u,knots);
	var num_pts_post = num_pts + r;
	var controlPoints_temp = [];
	var knots_post = [];
	var controlPoints_post = [];
	var i = 0;
	var _g1 = 1;
	var _g = k + 1;
	while(_g1 < _g) {
		var i1 = _g1++;
		knots_post[i1] = knots[i1];
	}
	var _g11 = 1;
	var _g2 = r + 1;
	while(_g11 < _g2) {
		var i2 = _g11++;
		knots_post[k + i2] = u;
	}
	var _g12 = k + 1;
	var _g3 = knots.length;
	while(_g12 < _g3) {
		var i3 = _g12++;
		knots_post[i3 + r] = knots[i3];
	}
	var _g13 = 0;
	var _g4 = k - degree + 1;
	while(_g13 < _g4) {
		var i4 = _g13++;
		controlPoints_post[i4] = controlPoints[i4];
	}
	var _g5 = k - s;
	while(_g5 < num_pts) {
		var i5 = _g5++;
		controlPoints_post[i5 + r] = controlPoints[i5];
	}
	var _g14 = 0;
	var _g6 = degree - s + 1;
	while(_g14 < _g6) {
		var i6 = _g14++;
		controlPoints_temp[i6] = controlPoints[k - degree + i6];
	}
	var L = 0;
	var alpha = 0;
	var _g15 = 1;
	var _g7 = r + 1;
	while(_g15 < _g7) {
		var j = _g15++;
		L = k - degree + j;
		var _g31 = 0;
		var _g21 = degree - j - s + 1;
		while(_g31 < _g21) {
			var i7 = _g31++;
			alpha = (u - knots[L + i7]) / (knots[i7 + k + 1] - knots[L + i7]);
			controlPoints_temp[i7] = verb_core_Vec.add(verb_core_Vec.mul(alpha,controlPoints_temp[i7 + 1]),verb_core_Vec.mul(1.0 - alpha,controlPoints_temp[i7]));
		}
		controlPoints_post[L] = controlPoints_temp[0];
		controlPoints_post[k + r - j - s] = controlPoints_temp[degree - j - s];
	}
	var _g16 = L + 1;
	var _g8 = k - s;
	while(_g16 < _g8) {
		var i8 = _g16++;
		controlPoints_post[i8] = controlPoints_temp[i8 - L];
	}
	return new verb_core_NurbsCurveData(degree,knots_post,controlPoints_post);
};
var verb_eval_Tess = $hx_exports.eval.Tess = function() { };
$hxClasses["verb.eval.Tess"] = verb_eval_Tess;
verb_eval_Tess.__name__ = ["verb","eval","Tess"];
verb_eval_Tess.rationalCurveRegularSample = function(curve,numSamples,includeU) {
	return verb_eval_Tess.rationalCurveRegularSampleRange(curve,curve.knots[0],verb_core_ArrayExtensions.last(curve.knots),numSamples,includeU);
};
verb_eval_Tess.rationalCurveRegularSampleRange = function(curve,start,end,numSamples,includeU) {
	if(numSamples < 1) numSamples = 2;
	var p = [];
	var span = (end - start) / (numSamples - 1);
	var u = 0;
	var _g = 0;
	while(_g < numSamples) {
		var i = _g++;
		u = start + span * i;
		if(includeU) p.push([u].concat(verb_eval_Eval.rationalCurvePoint(curve,u))); else p.push(verb_eval_Eval.rationalCurvePoint(curve,u));
	}
	return p;
};
verb_eval_Tess.rationalCurveAdaptiveSample = function(curve,tol,includeU) {
	if(includeU == null) includeU = false;
	if(tol == null) tol = 1e-6;
	if(curve.degree == 1) {
		if(!includeU) return curve.controlPoints.map(verb_eval_Eval.dehomogenize); else {
			var _g = [];
			var _g2 = 0;
			var _g1 = curve.controlPoints.length;
			while(_g2 < _g1) {
				var i = _g2++;
				_g.push([curve.knots[i + 1]].concat(verb_eval_Eval.dehomogenize(curve.controlPoints[i])));
			}
			return _g;
		}
	}
	return verb_eval_Tess.rationalCurveAdaptiveSampleRange(curve,curve.knots[0],verb_core_ArrayExtensions.last(curve.knots),tol,includeU);
};
verb_eval_Tess.rationalCurveAdaptiveSampleRange = function(curve,start,end,tol,includeU) {
	var p1 = verb_eval_Eval.rationalCurvePoint(curve,start);
	var p3 = verb_eval_Eval.rationalCurvePoint(curve,end);
	var t = 0.5 + 0.2 * Math.random();
	var mid = start + (end - start) * t;
	var p2 = verb_eval_Eval.rationalCurvePoint(curve,mid);
	var diff = verb_core_Vec.sub(p1,p3);
	var diff2 = verb_core_Vec.sub(p1,p2);
	if(verb_core_Vec.dot(diff,diff) < tol && verb_core_Vec.dot(diff2,diff2) > tol || !verb_core_Trig.threePointsAreFlat(p1,p2,p3,tol)) {
		var exact_mid = start + (end - start) * 0.5;
		var left_pts = verb_eval_Tess.rationalCurveAdaptiveSampleRange(curve,start,exact_mid,tol,includeU);
		var right_pts = verb_eval_Tess.rationalCurveAdaptiveSampleRange(curve,exact_mid,end,tol,includeU);
		return left_pts.slice(0,-1).concat(right_pts);
	} else if(includeU) return [[start].concat(p1),[end].concat(p3)]; else return [p1,p3];
};
verb_eval_Tess.rationalSurfaceNaive = function(surface,divs_u,divs_v) {
	if(divs_u < 1) divs_u = 1;
	if(divs_v < 1) divs_v = 1;
	var degreeU = surface.degreeU;
	var degreeV = surface.degreeV;
	var controlPoints = surface.controlPoints;
	var knotsU = surface.knotsU;
	var knotsV = surface.knotsV;
	var u_span = verb_core_ArrayExtensions.last(knotsU) - knotsU[0];
	var v_span = verb_core_ArrayExtensions.last(knotsV) - knotsV[0];
	var span_u = u_span / divs_u;
	var span_v = v_span / divs_v;
	var points = [];
	var uvs = [];
	var normals = [];
	var _g1 = 0;
	var _g = divs_u + 1;
	while(_g1 < _g) {
		var i = _g1++;
		var _g3 = 0;
		var _g2 = divs_v + 1;
		while(_g3 < _g2) {
			var j = _g3++;
			var pt_u = i * span_u;
			var pt_v = j * span_v;
			uvs.push([pt_u,pt_v]);
			var derivs = verb_eval_Eval.rationalSurfaceDerivatives(surface,pt_u,pt_v,1);
			var pt = derivs[0][0];
			points.push(pt);
			var normal = verb_core_Vec.normalized(verb_core_Vec.cross(derivs[1][0],derivs[0][1]));
			normals.push(normal);
		}
	}
	var faces = [];
	var _g4 = 0;
	while(_g4 < divs_u) {
		var i1 = _g4++;
		var _g11 = 0;
		while(_g11 < divs_v) {
			var j1 = _g11++;
			var a_i = i1 * (divs_v + 1) + j1;
			var b_i = (i1 + 1) * (divs_v + 1) + j1;
			var c_i = b_i + 1;
			var d_i = a_i + 1;
			var abc = [a_i,b_i,c_i];
			var acd = [a_i,c_i,d_i];
			faces.push(abc);
			faces.push(acd);
		}
	}
	return new verb_core_MeshData(faces,points,normals,uvs);
};
verb_eval_Tess.divideRationalSurfaceAdaptive = function(surface,options) {
	if(options == null) options = new verb_eval_AdaptiveRefinementOptions();
	if(options.minDivsU != null) options.minDivsU = options.minDivsU; else options.minDivsU = 1;
	if(options.minDivsV != null) options.minDivsU = options.minDivsV; else options.minDivsU = 1;
	if(options.refine != null) options.refine = options.refine; else options.refine = true;
	var minU = (surface.controlPoints.length - 1) * 2;
	var minV = (surface.controlPoints[0].length - 1) * 2;
	var divsU;
	if(options.minDivsU > minU) divsU = options.minDivsU = options.minDivsU; else divsU = options.minDivsU = minU;
	var divsV;
	if(options.minDivsV > minV) divsV = options.minDivsV = options.minDivsV; else divsV = options.minDivsV = minV;
	var umax = verb_core_ArrayExtensions.last(surface.knotsU);
	var umin = surface.knotsU[0];
	var vmax = verb_core_ArrayExtensions.last(surface.knotsV);
	var vmin = surface.knotsV[0];
	var du = (umax - umin) / divsU;
	var dv = (vmax - vmin) / divsV;
	var divs = [];
	var pts = [];
	var _g1 = 0;
	var _g = divsV + 1;
	while(_g1 < _g) {
		var i = _g1++;
		var ptrow = [];
		var _g3 = 0;
		var _g2 = divsU + 1;
		while(_g3 < _g2) {
			var j = _g3++;
			var u = umin + du * j;
			var v = vmin + dv * i;
			var ds = verb_eval_Eval.rationalSurfaceDerivatives(surface,u,v,1);
			var norm = verb_core_Vec.normalized(verb_core_Vec.cross(ds[0][1],ds[1][0]));
			ptrow.push(new verb_core_SurfacePoint(ds[0][0],norm,[u,v],-1,verb_core_Vec.isZero(norm)));
		}
		pts.push(ptrow);
	}
	var _g4 = 0;
	while(_g4 < divsV) {
		var i1 = _g4++;
		var _g11 = 0;
		while(_g11 < divsU) {
			var j1 = _g11++;
			var corners = [pts[divsV - i1 - 1][j1],pts[divsV - i1 - 1][j1 + 1],pts[divsV - i1][j1 + 1],pts[divsV - i1][j1]];
			divs.push(new verb_eval_AdaptiveRefinementNode(surface,corners));
		}
	}
	if(!options.refine) return divs;
	var _g5 = 0;
	while(_g5 < divsV) {
		var i2 = _g5++;
		var _g12 = 0;
		while(_g12 < divsU) {
			var j2 = _g12++;
			var ci = i2 * divsU + j2;
			var n = verb_eval_Tess.north(ci,i2,j2,divsU,divsV,divs);
			var e = verb_eval_Tess.east(ci,i2,j2,divsU,divsV,divs);
			var s = verb_eval_Tess.south(ci,i2,j2,divsU,divsV,divs);
			var w = verb_eval_Tess.west(ci,i2,j2,divsU,divsV,divs);
			divs[ci].neighbors = [s,e,n,w];
			divs[ci].divide(options);
		}
	}
	return divs;
};
verb_eval_Tess.north = function(index,i,j,divsU,divsV,divs) {
	if(i == 0) return null;
	return divs[index - divsU];
};
verb_eval_Tess.south = function(index,i,j,divsU,divsV,divs) {
	if(i == divsV - 1) return null;
	return divs[index + divsU];
};
verb_eval_Tess.east = function(index,i,j,divsU,divsV,divs) {
	if(j == divsU - 1) return null;
	return divs[index + 1];
};
verb_eval_Tess.west = function(index,i,j,divsU,divsV,divs) {
	if(j == 0) return null;
	return divs[index - 1];
};
verb_eval_Tess.triangulateAdaptiveRefinementNodeTree = function(arrTree) {
	var mesh = verb_core_MeshData.empty();
	var _g = 0;
	while(_g < arrTree.length) {
		var x = arrTree[_g];
		++_g;
		x.triangulate(mesh);
	}
	return mesh;
};
verb_eval_Tess.rationalSurfaceAdaptive = function(surface,options) {
	if(options != null) options = options; else options = new verb_eval_AdaptiveRefinementOptions();
	var arrTrees = verb_eval_Tess.divideRationalSurfaceAdaptive(surface,options);
	return verb_eval_Tess.triangulateAdaptiveRefinementNodeTree(arrTrees);
};
var verb_eval_AdaptiveRefinementOptions = $hx_exports.core.AdaptiveRefinementOptions = function() {
	this.minDivsV = 1;
	this.minDivsU = 1;
	this.refine = true;
	this.maxDepth = 10;
	this.minDepth = 0;
	this.normTol = 2.5e-2;
};
$hxClasses["verb.eval.AdaptiveRefinementOptions"] = verb_eval_AdaptiveRefinementOptions;
verb_eval_AdaptiveRefinementOptions.__name__ = ["verb","eval","AdaptiveRefinementOptions"];
verb_eval_AdaptiveRefinementOptions.prototype = {
	__class__: verb_eval_AdaptiveRefinementOptions
};
var verb_eval_AdaptiveRefinementNode = $hx_exports.core.AdaptiveRefinementNode = function(srf,corners,neighbors) {
	this.srf = srf;
	if(neighbors == null) this.neighbors = [null,null,null,null]; else this.neighbors = neighbors;
	this.corners = corners;
	if(this.corners == null) {
		var u0 = srf.knotsU[0];
		var u1 = verb_core_ArrayExtensions.last(srf.knotsU);
		var v0 = srf.knotsV[0];
		var v1 = verb_core_ArrayExtensions.last(srf.knotsV);
		this.corners = [verb_core_SurfacePoint.fromUv(u0,v0),verb_core_SurfacePoint.fromUv(u1,v0),verb_core_SurfacePoint.fromUv(u1,v1),verb_core_SurfacePoint.fromUv(u0,v1)];
	}
};
$hxClasses["verb.eval.AdaptiveRefinementNode"] = verb_eval_AdaptiveRefinementNode;
verb_eval_AdaptiveRefinementNode.__name__ = ["verb","eval","AdaptiveRefinementNode"];
verb_eval_AdaptiveRefinementNode.prototype = {
	isLeaf: function() {
		return this.children == null;
	}
	,center: function() {
		if(this.centerPoint != null) return this.centerPoint; else return this.evalSrf(this.u05,this.v05);
	}
	,evalCorners: function() {
		this.u05 = (this.corners[0].uv[0] + this.corners[2].uv[0]) / 2;
		this.v05 = (this.corners[0].uv[1] + this.corners[2].uv[1]) / 2;
		var _g = 0;
		while(_g < 4) {
			var i = _g++;
			if(this.corners[i].point == null) {
				var c = this.corners[i];
				this.evalSrf(c.uv[0],c.uv[1],c);
			}
		}
	}
	,evalSrf: function(u,v,srfPt) {
		var derivs = verb_eval_Eval.rationalSurfaceDerivatives(this.srf,u,v,1);
		var pt = derivs[0][0];
		var norm = verb_core_Vec.cross(derivs[0][1],derivs[1][0]);
		var degen = verb_core_Vec.isZero(norm);
		if(!degen) norm = verb_core_Vec.normalized(norm);
		if(srfPt != null) {
			srfPt.degen = degen;
			srfPt.point = pt;
			srfPt.normal = norm;
			return srfPt;
		} else return new verb_core_SurfacePoint(pt,norm,[u,v],-1,degen);
	}
	,getEdgeCorners: function(edgeIndex) {
		if(this.isLeaf()) return [this.corners[edgeIndex]];
		if(this.horizontal) switch(edgeIndex) {
		case 0:
			return this.children[0].getEdgeCorners(0);
		case 1:
			return this.children[0].getEdgeCorners(1).concat(this.children[1].getEdgeCorners(1));
		case 2:
			return this.children[1].getEdgeCorners(2);
		case 3:
			return this.children[1].getEdgeCorners(3).concat(this.children[0].getEdgeCorners(3));
		}
		switch(edgeIndex) {
		case 0:
			return this.children[0].getEdgeCorners(0).concat(this.children[1].getEdgeCorners(0));
		case 1:
			return this.children[1].getEdgeCorners(1);
		case 2:
			return this.children[1].getEdgeCorners(2).concat(this.children[0].getEdgeCorners(2));
		case 3:
			return this.children[0].getEdgeCorners(3);
		}
		return null;
	}
	,getAllCorners: function(edgeIndex) {
		var baseArr = [this.corners[edgeIndex]];
		if(this.neighbors[edgeIndex] == null) return baseArr;
		var corners = this.neighbors[edgeIndex].getEdgeCorners((edgeIndex + 2) % 4);
		var funcIndex = edgeIndex % 2;
		var e = verb_core_Constants.EPSILON;
		var that = this;
		var rangeFuncMap = [function(c) {
			return c.uv[0] > that.corners[0].uv[0] + e && c.uv[0] < that.corners[2].uv[0] - e;
		},function(c1) {
			return c1.uv[1] > that.corners[0].uv[1] + e && c1.uv[1] < that.corners[2].uv[1] - e;
		}];
		var cornercopy = corners.filter(rangeFuncMap[funcIndex]);
		cornercopy.reverse();
		return baseArr.concat(cornercopy);
	}
	,midpoint: function(index) {
		if(this.midPoints == null) this.midPoints = [null,null,null,null];
		if(!(this.midPoints[index] == null)) return this.midPoints[index];
		switch(index) {
		case 0:
			this.midPoints[0] = this.evalSrf(this.u05,this.corners[0].uv[1]);
			break;
		case 1:
			this.midPoints[1] = this.evalSrf(this.corners[1].uv[0],this.v05);
			break;
		case 2:
			this.midPoints[2] = this.evalSrf(this.u05,this.corners[2].uv[1]);
			break;
		case 3:
			this.midPoints[3] = this.evalSrf(this.corners[0].uv[0],this.v05);
			break;
		}
		return this.midPoints[index];
	}
	,hasBadNormals: function() {
		return this.corners[0].degen || this.corners[1].degen || this.corners[2].degen || this.corners[3].degen;
	}
	,fixNormals: function() {
		var l = this.corners.length;
		var _g = 0;
		while(_g < l) {
			var i = _g++;
			var corn = this.corners[i];
			if(this.corners[i].degen) {
				var v1 = this.corners[(i + 1) % l];
				var v2 = this.corners[(i + 3) % l];
				if(v1.degen) this.corners[i].normal = v2.normal; else this.corners[i].normal = v1.normal;
			}
		}
	}
	,shouldDivide: function(options,currentDepth) {
		if(currentDepth < options.minDepth) return true;
		if(currentDepth >= options.maxDepth) return false;
		if(this.hasBadNormals()) {
			this.fixNormals();
			return false;
		}
		this.splitVert = verb_core_Vec.normSquared(verb_core_Vec.sub(this.corners[0].normal,this.corners[1].normal)) > options.normTol || verb_core_Vec.normSquared(verb_core_Vec.sub(this.corners[2].normal,this.corners[3].normal)) > options.normTol;
		this.splitHoriz = verb_core_Vec.normSquared(verb_core_Vec.sub(this.corners[1].normal,this.corners[2].normal)) > options.normTol || verb_core_Vec.normSquared(verb_core_Vec.sub(this.corners[3].normal,this.corners[0].normal)) > options.normTol;
		if(this.splitVert || this.splitHoriz) return true;
		var center = this.center();
		return verb_core_Vec.normSquared(verb_core_Vec.sub(center.normal,this.corners[0].normal)) > options.normTol || verb_core_Vec.normSquared(verb_core_Vec.sub(center.normal,this.corners[1].normal)) > options.normTol || verb_core_Vec.normSquared(verb_core_Vec.sub(center.normal,this.corners[2].normal)) > options.normTol || verb_core_Vec.normSquared(verb_core_Vec.sub(center.normal,this.corners[3].normal)) > options.normTol;
	}
	,divide: function(options) {
		if(options == null) options = new verb_eval_AdaptiveRefinementOptions();
		if(options.normTol == null) options.normTol = 8.5e-2;
		if(options.minDepth == null) options.minDepth = 0;
		if(options.maxDepth == null) options.maxDepth = 10;
		this._divide(options,0,true);
	}
	,_divide: function(options,currentDepth,horiz) {
		this.evalCorners();
		if(!this.shouldDivide(options,currentDepth)) return;
		currentDepth++;
		if(this.splitVert && !this.splitHoriz) horiz = false; else if(!this.splitVert && this.splitHoriz) horiz = true;
		this.horizontal = horiz;
		if(this.horizontal) {
			var bott = [this.corners[0],this.corners[1],this.midpoint(1),this.midpoint(3)];
			var top = [this.midpoint(3),this.midpoint(1),this.corners[2],this.corners[3]];
			this.children = [new verb_eval_AdaptiveRefinementNode(this.srf,bott),new verb_eval_AdaptiveRefinementNode(this.srf,top)];
			this.children[0].neighbors = [this.neighbors[0],this.neighbors[1],this.children[1],this.neighbors[3]];
			this.children[1].neighbors = [this.children[0],this.neighbors[1],this.neighbors[2],this.neighbors[3]];
		} else {
			var left = [this.corners[0],this.midpoint(0),this.midpoint(2),this.corners[3]];
			var right = [this.midpoint(0),this.corners[1],this.corners[2],this.midpoint(2)];
			this.children = [new verb_eval_AdaptiveRefinementNode(this.srf,left),new verb_eval_AdaptiveRefinementNode(this.srf,right)];
			this.children[0].neighbors = [this.neighbors[0],this.children[1],this.neighbors[2],this.neighbors[3]];
			this.children[1].neighbors = [this.neighbors[0],this.neighbors[1],this.neighbors[2],this.children[0]];
		}
		var _g = 0;
		var _g1 = this.children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			child._divide(options,currentDepth,!horiz);
		}
	}
	,triangulate: function(mesh) {
		if(mesh == null) mesh = verb_core_MeshData.empty();
		if(this.isLeaf()) return this.triangulateLeaf(mesh);
		var _g = 0;
		var _g1 = this.children;
		while(_g < _g1.length) {
			var x = _g1[_g];
			++_g;
			if(x == null) break;
			x.triangulate(mesh);
		}
		return mesh;
	}
	,triangulateLeaf: function(mesh) {
		var baseIndex = mesh.points.length;
		var uvs = [];
		var ids = [];
		var splitid = 0;
		var _g = 0;
		while(_g < 4) {
			var i1 = _g++;
			var edgeCorners = this.getAllCorners(i1);
			if(edgeCorners.length == 2) splitid = i1 + 1;
			var _g2 = 0;
			var _g1 = edgeCorners.length;
			while(_g2 < _g1) {
				var j1 = _g2++;
				uvs.push(edgeCorners[j1]);
			}
		}
		var _g3 = 0;
		while(_g3 < uvs.length) {
			var corner = uvs[_g3];
			++_g3;
			if(corner.id != -1) {
				ids.push(corner.id);
				continue;
			}
			mesh.uvs.push(corner.uv);
			mesh.points.push(corner.point);
			mesh.normals.push(corner.normal);
			corner.id = baseIndex;
			ids.push(baseIndex);
			baseIndex++;
		}
		if(uvs.length == 4) {
			mesh.faces.push([ids[0],ids[3],ids[1]]);
			mesh.faces.push([ids[3],ids[2],ids[1]]);
			return mesh;
		} else if(uvs.length == 5) {
			var il = ids.length;
			mesh.faces.push([ids[splitid],ids[(splitid + 2) % il],ids[(splitid + 1) % il]]);
			mesh.faces.push([ids[(splitid + 4) % il],ids[(splitid + 3) % il],ids[splitid]]);
			mesh.faces.push([ids[splitid],ids[(splitid + 3) % il],ids[(splitid + 2) % il]]);
			return mesh;
		}
		var center = this.center();
		mesh.uvs.push(center.uv);
		mesh.points.push(center.point);
		mesh.normals.push(center.normal);
		var centerIndex = mesh.points.length - 1;
		var i = 0;
		var j = uvs.length - 1;
		while(i < uvs.length) {
			mesh.faces.push([centerIndex,ids[i],ids[j]]);
			j = i++;
		}
		return mesh;
	}
	,__class__: verb_eval_AdaptiveRefinementNode
};
var verb_exe_Dispatcher = $hx_exports.exe.Dispatcher = function() { };
$hxClasses["verb.exe.Dispatcher"] = verb_exe_Dispatcher;
verb_exe_Dispatcher.__name__ = ["verb","exe","Dispatcher"];
verb_exe_Dispatcher.init = function() {
	if(verb_exe_Dispatcher._init) return;
	verb_exe_Dispatcher._workerPool = new verb_exe_WorkerPool(verb_exe_Dispatcher.THREADS);
	verb_exe_Dispatcher._init = true;
};
verb_exe_Dispatcher.dispatchMethod = function(classType,methodName,args) {
	verb_exe_Dispatcher.init();
	var def = new promhx_Deferred();
	var callback = function(x) {
		def.resolve(x);
	};
	verb_exe_Dispatcher._workerPool.addWork(Type.getClassName(classType),methodName,args,callback);
	return new promhx_Promise(def);
};
var verb_exe_WorkerPool = $hx_exports.exe.WorkerPool = function(numThreads,fileName) {
	if(fileName == null) fileName = "verb.js";
	if(numThreads == null) numThreads = 1;
	this._callbacks = new haxe_ds_IntMap();
	this._working = new haxe_ds_IntMap();
	this._pool = [];
	this._queue = [];
	var _g = 0;
	while(_g < numThreads) {
		var i = _g++;
		var w;
		try {
			w = new Worker(verb_exe_WorkerPool.basePath + fileName);
		} catch( e ) {
			if (e instanceof js__$Boot_HaxeError) e = e.val;
			w = new Worker(verb_exe_WorkerPool.basePath + fileName.substring(0,-3) + ".min.js");
		}
		this._pool.push(w);
	}
};
$hxClasses["verb.exe.WorkerPool"] = verb_exe_WorkerPool;
verb_exe_WorkerPool.__name__ = ["verb","exe","WorkerPool"];
verb_exe_WorkerPool.prototype = {
	addWork: function(className,methodName,args,callback) {
		var work = new verb_exe__$WorkerPool_Work(className,methodName,args);
		this._callbacks.set(work.id,callback);
		this._queue.push(work);
		this.processQueue();
	}
	,processQueue: function() {
		var _g = this;
		while(this._queue.length > 0 && this._pool.length > 0) {
			var work = this._queue.shift();
			var workId = [work.id];
			var worker = [this._pool.shift()];
			this._working.h[workId[0]] = worker[0];
			worker[0].onmessage = (function(worker,workId) {
				return function(e) {
					_g._working.remove(workId[0]);
					_g._pool.push(worker[0]);
					try {
						if(_g._callbacks.h.hasOwnProperty(workId[0])) {
							_g._callbacks.h[workId[0]](e.data.result);
							_g._callbacks.remove(workId[0]);
						}
					} catch( error ) {
						if (error instanceof js__$Boot_HaxeError) error = error.val;
						console.log(error);
					}
					_g.processQueue();
				};
			})(worker,workId);
			worker[0].postMessage(work);
		}
	}
	,__class__: verb_exe_WorkerPool
};
var verb_exe__$WorkerPool_Work = function(className,methodName,args) {
	this.className = className;
	this.methodName = methodName;
	this.args = args;
	this.id = verb_exe__$WorkerPool_Work.uuid++;
};
$hxClasses["verb.exe._WorkerPool.Work"] = verb_exe__$WorkerPool_Work;
verb_exe__$WorkerPool_Work.__name__ = ["verb","exe","_WorkerPool","Work"];
verb_exe__$WorkerPool_Work.prototype = {
	__class__: verb_exe__$WorkerPool_Work
};
var verb_geom_ICurve = function() { };
$hxClasses["verb.geom.ICurve"] = verb_geom_ICurve;
verb_geom_ICurve.__name__ = ["verb","geom","ICurve"];
verb_geom_ICurve.__interfaces__ = [verb_core_ISerializable];
verb_geom_ICurve.prototype = {
	__class__: verb_geom_ICurve
};
var verb_geom_NurbsCurve = $hx_exports.geom.NurbsCurve = function(data) {
	this._data = verb_eval_Check.isValidNurbsCurveData(data);
};
$hxClasses["verb.geom.NurbsCurve"] = verb_geom_NurbsCurve;
verb_geom_NurbsCurve.__name__ = ["verb","geom","NurbsCurve"];
verb_geom_NurbsCurve.__interfaces__ = [verb_geom_ICurve];
verb_geom_NurbsCurve.byKnotsControlPointsWeights = function(degree,knots,controlPoints,weights) {
	return new verb_geom_NurbsCurve(new verb_core_NurbsCurveData(degree,knots.slice(),verb_eval_Eval.homogenize1d(controlPoints,weights)));
};
verb_geom_NurbsCurve.byPoints = function(points,degree) {
	if(degree == null) degree = 3;
	return new verb_geom_NurbsCurve(verb_eval_Make.rationalInterpCurve(points,degree));
};
verb_geom_NurbsCurve.__super__ = verb_core_SerializableBase;
verb_geom_NurbsCurve.prototype = $extend(verb_core_SerializableBase.prototype,{
	degree: function() {
		return this._data.degree;
	}
	,knots: function() {
		return this._data.knots.slice(0);
	}
	,controlPoints: function() {
		return verb_eval_Eval.dehomogenize1d(this._data.controlPoints);
	}
	,weights: function() {
		return verb_eval_Eval.weight1d(this._data.controlPoints);
	}
	,asNurbs: function() {
		return new verb_core_NurbsCurveData(this.degree(),this.knots(),verb_eval_Eval.homogenize1d(this.controlPoints(),this.weights()));
	}
	,clone: function() {
		return new verb_geom_NurbsCurve(this._data);
	}
	,domain: function() {
		return new verb_core_Interval(verb_core_ArrayExtensions.first(this._data.knots),verb_core_ArrayExtensions.last(this._data.knots));
	}
	,transform: function(mat) {
		return new verb_geom_NurbsCurve(verb_eval_Modify.rationalCurveTransform(this._data,mat));
	}
	,transformAsync: function(mat) {
		return verb_exe_Dispatcher.dispatchMethod(verb_eval_Modify,"rationalCurveTransform",[this._data,mat]).then(function(x) {
			return new verb_geom_NurbsCurve(x);
		});
	}
	,point: function(u) {
		return verb_eval_Eval.rationalCurvePoint(this._data,u);
	}
	,pointAsync: function(u) {
		return verb_exe_Dispatcher.dispatchMethod(verb_eval_Eval,"rationalCurvePoint",[this._data,u]);
	}
	,tangent: function(u) {
		return verb_eval_Eval.rationalCurveTangent(this._data,u);
	}
	,tangentAsync: function(u) {
		return verb_exe_Dispatcher.dispatchMethod(verb_eval_Eval,"rationalCurveTangent",[this._data,u]);
	}
	,derivatives: function(u,numDerivs) {
		if(numDerivs == null) numDerivs = 1;
		return verb_eval_Eval.rationalCurveDerivatives(this._data,u,numDerivs);
	}
	,derivativesAsync: function(u,numDerivs) {
		if(numDerivs == null) numDerivs = 1;
		return verb_exe_Dispatcher.dispatchMethod(verb_eval_Eval,"rationalCurveDerivatives",[this._data,u,numDerivs]);
	}
	,closestPoint: function(pt) {
		return verb_eval_Analyze.rationalCurveClosestPoint(this._data,pt);
	}
	,closestPointAsync: function(pt) {
		return verb_exe_Dispatcher.dispatchMethod(verb_eval_Analyze,"rationalCurveClosestPoint",[this._data,pt]);
	}
	,closestParam: function(pt) {
		return verb_eval_Analyze.rationalCurveClosestParam(this._data,pt);
	}
	,closestParamAsync: function(pt) {
		return verb_exe_Dispatcher.dispatchMethod(verb_eval_Analyze,"rationalCurveClosestParam",[this._data,pt]);
	}
	,length: function() {
		return verb_eval_Analyze.rationalCurveArcLength(this._data);
	}
	,lengthAsync: function() {
		return verb_exe_Dispatcher.dispatchMethod(verb_eval_Analyze,"rationalCurveArcLength",[this._data]);
	}
	,lengthAtParam: function(u) {
		return verb_eval_Analyze.rationalCurveArcLength(this._data,u);
	}
	,lengthAtParamAsync: function() {
		return verb_exe_Dispatcher.dispatchMethod(verb_eval_Analyze,"rationalCurveArcLength",[this._data]);
	}
	,paramAtLength: function(len,tolerance) {
		return verb_eval_Analyze.rationalCurveParamAtArcLength(this._data,len,tolerance);
	}
	,paramAtLengthAsync: function(len,tolerance) {
		return verb_exe_Dispatcher.dispatchMethod(verb_eval_Analyze,"rationalCurveParamAtArcLength",[this._data,len,tolerance]);
	}
	,divideByEqualArcLength: function(divisions) {
		return verb_eval_Divide.rationalCurveByEqualArcLength(this._data,divisions);
	}
	,divideByEqualArcLengthAsync: function(divisions) {
		return verb_exe_Dispatcher.dispatchMethod(verb_eval_Divide,"rationalCurveByEqualArcLength",[this._data,divisions]);
	}
	,divideByArcLength: function(arcLength) {
		return verb_eval_Divide.rationalCurveByArcLength(this._data,arcLength);
	}
	,divideByArcLengthAsync: function(divisions) {
		return verb_exe_Dispatcher.dispatchMethod(verb_eval_Divide,"rationalCurveByArcLength",[this._data,divisions]);
	}
	,split: function(u) {
		return verb_eval_Divide.curveSplit(this._data,u).map(function(x) {
			return new verb_geom_NurbsCurve(x);
		});
	}
	,splitAsync: function(u) {
		return verb_exe_Dispatcher.dispatchMethod(verb_eval_Divide,"curveSplit",[this._data,u]).then(function(cs) {
			return cs.map(function(x) {
				return new verb_geom_NurbsCurve(x);
			});
		});
	}
	,reverse: function() {
		return new verb_geom_NurbsCurve(verb_eval_Modify.curveReverse(this._data));
	}
	,reverseAsync: function() {
		return verb_exe_Dispatcher.dispatchMethod(verb_eval_Modify,"curveReverse",[this._data]).then(function(c) {
			return new verb_geom_NurbsCurve(c);
		});
	}
	,tessellate: function(tolerance) {
		return verb_eval_Tess.rationalCurveAdaptiveSample(this._data,tolerance,false);
	}
	,tessellateAsync: function(tolerance) {
		return verb_exe_Dispatcher.dispatchMethod(verb_eval_Tess,"rationalCurveAdaptiveSample",[this._data,tolerance,false]);
	}
	,__class__: verb_geom_NurbsCurve
});
var verb_geom_Arc = $hx_exports.geom.Arc = function(center,xaxis,yaxis,radius,minAngle,maxAngle) {
	verb_geom_NurbsCurve.call(this,verb_eval_Make.arc(center,xaxis,yaxis,radius,minAngle,maxAngle));
	this._center = center;
	this._xaxis = xaxis;
	this._yaxis = yaxis;
	this._radius = radius;
	this._minAngle = minAngle;
	this._maxAngle = maxAngle;
};
$hxClasses["verb.geom.Arc"] = verb_geom_Arc;
verb_geom_Arc.__name__ = ["verb","geom","Arc"];
verb_geom_Arc.__super__ = verb_geom_NurbsCurve;
verb_geom_Arc.prototype = $extend(verb_geom_NurbsCurve.prototype,{
	center: function() {
		return this._center;
	}
	,xaxis: function() {
		return this._xaxis;
	}
	,yaxis: function() {
		return this._yaxis;
	}
	,radius: function() {
		return this._radius;
	}
	,minAngle: function() {
		return this._minAngle;
	}
	,maxAngle: function() {
		return this._maxAngle;
	}
	,__class__: verb_geom_Arc
});
var verb_geom_BezierCurve = $hx_exports.geom.BezierCurve = function(points,weights) {
	verb_geom_NurbsCurve.call(this,verb_eval_Make.rationalBezierCurve(points,weights));
};
$hxClasses["verb.geom.BezierCurve"] = verb_geom_BezierCurve;
verb_geom_BezierCurve.__name__ = ["verb","geom","BezierCurve"];
verb_geom_BezierCurve.__super__ = verb_geom_NurbsCurve;
verb_geom_BezierCurve.prototype = $extend(verb_geom_NurbsCurve.prototype,{
	__class__: verb_geom_BezierCurve
});
var verb_geom_Circle = $hx_exports.geom.Circle = function(center,xaxis,yaxis,radius) {
	verb_geom_Arc.call(this,center,xaxis,yaxis,radius,0,Math.PI * 2);
};
$hxClasses["verb.geom.Circle"] = verb_geom_Circle;
verb_geom_Circle.__name__ = ["verb","geom","Circle"];
verb_geom_Circle.__super__ = verb_geom_Arc;
verb_geom_Circle.prototype = $extend(verb_geom_Arc.prototype,{
	__class__: verb_geom_Circle
});
var verb_geom_ISurface = function() { };
$hxClasses["verb.geom.ISurface"] = verb_geom_ISurface;
verb_geom_ISurface.__name__ = ["verb","geom","ISurface"];
verb_geom_ISurface.__interfaces__ = [verb_core_ISerializable];
verb_geom_ISurface.prototype = {
	__class__: verb_geom_ISurface
};
var verb_geom_NurbsSurface = $hx_exports.geom.NurbsSurface = function(data) {
	this._data = verb_eval_Check.isValidNurbsSurfaceData(data);
};
$hxClasses["verb.geom.NurbsSurface"] = verb_geom_NurbsSurface;
verb_geom_NurbsSurface.__name__ = ["verb","geom","NurbsSurface"];
verb_geom_NurbsSurface.__interfaces__ = [verb_geom_ISurface];
verb_geom_NurbsSurface.byKnotsControlPointsWeights = function(degreeU,degreeV,knotsU,knotsV,controlPoints,weights) {
	return new verb_geom_NurbsSurface(new verb_core_NurbsSurfaceData(degreeU,degreeV,knotsU,knotsV,verb_eval_Eval.homogenize2d(controlPoints,weights)));
};
verb_geom_NurbsSurface.byCorners = function(point0,point1,point2,point3) {
	return new verb_geom_NurbsSurface(verb_eval_Make.fourPointSurface(point0,point1,point2,point3));
};
verb_geom_NurbsSurface.byLoftingCurves = function(curves,degreeV) {
	return new verb_geom_NurbsSurface(verb_eval_Make.loftedSurface((function($this) {
		var $r;
		var _g = [];
		{
			var _g1 = 0;
			while(_g1 < curves.length) {
				var c = curves[_g1];
				++_g1;
				_g.push(c.asNurbs());
			}
		}
		$r = _g;
		return $r;
	}(this)),degreeV));
};
verb_geom_NurbsSurface.__super__ = verb_core_SerializableBase;
verb_geom_NurbsSurface.prototype = $extend(verb_core_SerializableBase.prototype,{
	degreeU: function() {
		return this._data.degreeU;
	}
	,degreeV: function() {
		return this._data.degreeV;
	}
	,knotsU: function() {
		return this._data.knotsU.slice(0);
	}
	,knotsV: function() {
		return this._data.knotsV.slice(0);
	}
	,controlPoints: function() {
		return verb_eval_Eval.dehomogenize2d(this._data.controlPoints);
	}
	,weights: function() {
		return verb_eval_Eval.weight2d(this._data.controlPoints);
	}
	,asNurbs: function() {
		return new verb_core_NurbsSurfaceData(this.degreeU(),this.degreeV(),this.knotsU(),this.knotsV(),verb_eval_Eval.homogenize2d(this.controlPoints(),this.weights()));
	}
	,clone: function() {
		return new verb_geom_NurbsSurface(this.asNurbs());
	}
	,domainU: function() {
		return new verb_core_Interval(verb_core_ArrayExtensions.first(this._data.knotsU),verb_core_ArrayExtensions.last(this._data.knotsU));
	}
	,domainV: function() {
		return new verb_core_Interval(verb_core_ArrayExtensions.first(this._data.knotsV),verb_core_ArrayExtensions.last(this._data.knotsV));
	}
	,point: function(u,v) {
		return verb_eval_Eval.rationalSurfacePoint(this._data,u,v);
	}
	,pointAsync: function(u,v) {
		return verb_exe_Dispatcher.dispatchMethod(verb_eval_Eval,"rationalSurfacePoint",[this._data,u,v]);
	}
	,normal: function(u,v) {
		return verb_eval_Eval.rationalSurfaceNormal(this._data,u,v);
	}
	,normalAsync: function(u,v) {
		return verb_exe_Dispatcher.dispatchMethod(verb_eval_Eval,"rationalSurfaceNormal",[this._data,u,v]);
	}
	,derivatives: function(u,v,numDerivs) {
		if(numDerivs == null) numDerivs = 1;
		return verb_eval_Eval.rationalSurfaceDerivatives(this._data,u,v,numDerivs);
	}
	,derivativesAsync: function(u,v,numDerivs) {
		if(numDerivs == null) numDerivs = 1;
		return verb_exe_Dispatcher.dispatchMethod(verb_eval_Eval,"rationalSurfaceDerivatives",[this._data,u,v,numDerivs]);
	}
	,closestParam: function(pt) {
		return verb_eval_Analyze.rationalSurfaceClosestParam(this._data,pt);
	}
	,closestParamAsync: function(pt) {
		return verb_exe_Dispatcher.dispatchMethod(verb_eval_Analyze,"rationalSurfaceClosestParam",[this._data,pt]);
	}
	,closestPoint: function(pt) {
		return verb_eval_Analyze.rationalSurfaceClosestPoint(this._data,pt);
	}
	,closestPointAsync: function(pt) {
		return verb_exe_Dispatcher.dispatchMethod(verb_eval_Analyze,"rationalSurfaceClosestPoint",[this._data,pt]);
	}
	,split: function(u,useV) {
		if(useV == null) useV = false;
		return verb_eval_Divide.surfaceSplit(this._data,u,useV).map(function(x) {
			return new verb_geom_NurbsSurface(x);
		});
	}
	,splitAsync: function(u,useV) {
		if(useV == null) useV = false;
		return verb_exe_Dispatcher.dispatchMethod(verb_eval_Divide,"surfaceSplit",[this._data,u,useV]).then(function(s) {
			return s.map(function(x) {
				return new verb_geom_NurbsSurface(x);
			});
		});
	}
	,reverse: function(useV) {
		if(useV == null) useV = false;
		return new verb_geom_NurbsSurface(verb_eval_Modify.surfaceReverse(this._data,useV));
	}
	,reverseAsync: function(useV) {
		if(useV == null) useV = false;
		return verb_exe_Dispatcher.dispatchMethod(verb_eval_Modify,"surfaceReverse",[this._data,useV]).then(function(c) {
			return new verb_geom_NurbsSurface(c);
		});
	}
	,isocurve: function(u,useV) {
		if(useV == null) useV = false;
		return new verb_geom_NurbsCurve(verb_eval_Make.surfaceIsocurve(this._data,u,useV));
	}
	,isocurveAsync: function(u,useV) {
		if(useV == null) useV = false;
		return verb_exe_Dispatcher.dispatchMethod(verb_eval_Make,"surfaceIsocurve",[this._data,u,useV]).then(function(x) {
			return new verb_geom_NurbsCurve(x);
		});
	}
	,boundaries: function(options) {
		return verb_eval_Make.surfaceBoundaryCurves(this._data).map(function(x) {
			return new verb_geom_NurbsCurve(x);
		});
	}
	,boundariesAsync: function(options) {
		return verb_exe_Dispatcher.dispatchMethod(verb_eval_Make,"surfaceBoundaryCurves",[this._data]).then(function(cs) {
			return cs.map(function(x) {
				return new verb_geom_NurbsCurve(x);
			});
		});
	}
	,tessellate: function(options) {
		return verb_eval_Tess.rationalSurfaceAdaptive(this._data,options);
	}
	,tessellateAsync: function(options) {
		return verb_exe_Dispatcher.dispatchMethod(verb_eval_Tess,"rationalSurfaceAdaptive",[this._data,options]);
	}
	,transform: function(mat) {
		return new verb_geom_NurbsSurface(verb_eval_Modify.rationalSurfaceTransform(this._data,mat));
	}
	,transformAsync: function(mat) {
		return verb_exe_Dispatcher.dispatchMethod(verb_eval_Modify,"rationalSurfaceTransform",[this._data,mat]).then(function(x) {
			return new verb_geom_NurbsSurface(x);
		});
	}
	,__class__: verb_geom_NurbsSurface
});
var verb_geom_ConicalSurface = $hx_exports.geom.ConicalSurface = function(axis,xaxis,base,height,radius) {
	verb_geom_NurbsSurface.call(this,verb_eval_Make.conicalSurface(axis,xaxis,base,height,radius));
	this._axis = axis;
	this._xaxis = xaxis;
	this._base = base;
	this._height = height;
	this._radius = radius;
};
$hxClasses["verb.geom.ConicalSurface"] = verb_geom_ConicalSurface;
verb_geom_ConicalSurface.__name__ = ["verb","geom","ConicalSurface"];
verb_geom_ConicalSurface.__super__ = verb_geom_NurbsSurface;
verb_geom_ConicalSurface.prototype = $extend(verb_geom_NurbsSurface.prototype,{
	axis: function() {
		return this._axis;
	}
	,xaxis: function() {
		return this._xaxis;
	}
	,base: function() {
		return this._base;
	}
	,height: function() {
		return this._height;
	}
	,radius: function() {
		return this._radius;
	}
	,__class__: verb_geom_ConicalSurface
});
var verb_geom_CylindricalSurface = $hx_exports.geom.CylindricalSurface = function(axis,xaxis,base,height,radius) {
	verb_geom_NurbsSurface.call(this,verb_eval_Make.cylindricalSurface(axis,xaxis,base,height,radius));
	this._axis = axis;
	this._xaxis = xaxis;
	this._base = base;
	this._height = height;
	this._radius = radius;
};
$hxClasses["verb.geom.CylindricalSurface"] = verb_geom_CylindricalSurface;
verb_geom_CylindricalSurface.__name__ = ["verb","geom","CylindricalSurface"];
verb_geom_CylindricalSurface.__super__ = verb_geom_NurbsSurface;
verb_geom_CylindricalSurface.prototype = $extend(verb_geom_NurbsSurface.prototype,{
	axis: function() {
		return this._axis;
	}
	,xaxis: function() {
		return this._xaxis;
	}
	,base: function() {
		return this._base;
	}
	,height: function() {
		return this._height;
	}
	,radius: function() {
		return this._radius;
	}
	,__class__: verb_geom_CylindricalSurface
});
var verb_geom_EllipseArc = $hx_exports.geom.EllipseArc = function(center,xaxis,yaxis,minAngle,maxAngle) {
	verb_geom_NurbsCurve.call(this,verb_eval_Make.ellipseArc(center,xaxis,yaxis,minAngle,maxAngle));
	this._center = center;
	this._xaxis = xaxis;
	this._yaxis = yaxis;
	this._minAngle = minAngle;
	this._maxAngle = maxAngle;
};
$hxClasses["verb.geom.EllipseArc"] = verb_geom_EllipseArc;
verb_geom_EllipseArc.__name__ = ["verb","geom","EllipseArc"];
verb_geom_EllipseArc.__super__ = verb_geom_NurbsCurve;
verb_geom_EllipseArc.prototype = $extend(verb_geom_NurbsCurve.prototype,{
	center: function() {
		return this._center;
	}
	,xaxis: function() {
		return this._xaxis;
	}
	,yaxis: function() {
		return this._yaxis;
	}
	,minAngle: function() {
		return this._minAngle;
	}
	,maxAngle: function() {
		return this._maxAngle;
	}
	,__class__: verb_geom_EllipseArc
});
var verb_geom_Ellipse = $hx_exports.geom.Ellipse = function(center,xaxis,yaxis) {
	verb_geom_EllipseArc.call(this,center,xaxis,yaxis,0,Math.PI * 2);
};
$hxClasses["verb.geom.Ellipse"] = verb_geom_Ellipse;
verb_geom_Ellipse.__name__ = ["verb","geom","Ellipse"];
verb_geom_Ellipse.__super__ = verb_geom_EllipseArc;
verb_geom_Ellipse.prototype = $extend(verb_geom_EllipseArc.prototype,{
	__class__: verb_geom_Ellipse
});
var verb_geom_ExtrudedSurface = $hx_exports.geom.ExtrudedSurface = function(profile,direction) {
	verb_geom_NurbsSurface.call(this,verb_eval_Make.extrudedSurface(verb_core_Vec.normalized(direction),verb_core_Vec.norm(direction),profile.asNurbs()));
	this._profile = profile;
	this._direction = direction;
};
$hxClasses["verb.geom.ExtrudedSurface"] = verb_geom_ExtrudedSurface;
verb_geom_ExtrudedSurface.__name__ = ["verb","geom","ExtrudedSurface"];
verb_geom_ExtrudedSurface.__super__ = verb_geom_NurbsSurface;
verb_geom_ExtrudedSurface.prototype = $extend(verb_geom_NurbsSurface.prototype,{
	profile: function() {
		return this._profile;
	}
	,direction: function() {
		return this._direction;
	}
	,__class__: verb_geom_ExtrudedSurface
});
var verb_geom_Intersect = $hx_exports.geom.Intersect = function() { };
$hxClasses["verb.geom.Intersect"] = verb_geom_Intersect;
verb_geom_Intersect.__name__ = ["verb","geom","Intersect"];
verb_geom_Intersect.curves = function(first,second,tol) {
	if(tol == null) tol = 1e-3;
	return verb_eval_Intersect.curves(first.asNurbs(),second.asNurbs(),tol);
};
verb_geom_Intersect.curvesAsync = function(first,second,tol) {
	if(tol == null) tol = 1e-3;
	return verb_exe_Dispatcher.dispatchMethod(verb_eval_Intersect,"curves",[first.asNurbs(),second.asNurbs(),tol]);
};
verb_geom_Intersect.curveAndSurface = function(curve,surface,tol) {
	if(tol == null) tol = 1e-3;
	return verb_eval_Intersect.curveAndSurface(curve.asNurbs(),surface.asNurbs(),tol);
};
verb_geom_Intersect.curveAndSurfaceAsync = function(curve,surface,tol) {
	if(tol == null) tol = 1e-3;
	return verb_exe_Dispatcher.dispatchMethod(verb_eval_Intersect,"curveAndSurface",[curve.asNurbs(),surface.asNurbs(),tol]);
};
verb_geom_Intersect.surfaces = function(first,second,tol) {
	if(tol == null) tol = 1e-3;
	return verb_eval_Intersect.surfaces(first.asNurbs(),second.asNurbs(),tol).map(function(cd) {
		return new verb_geom_NurbsCurve(cd);
	});
};
verb_geom_Intersect.surfacesAsync = function(first,second,tol) {
	if(tol == null) tol = 1e-3;
	return verb_exe_Dispatcher.dispatchMethod(verb_eval_Intersect,"surfaces",[first.asNurbs(),second.asNurbs(),tol]).then(function(cds) {
		return cds.map(function(cd) {
			return new verb_geom_NurbsCurve(cd);
		});
	});
};
var verb_geom_Line = $hx_exports.geom.Line = function(start,end) {
	verb_geom_NurbsCurve.call(this,verb_eval_Make.polyline([start,end]));
	this._start = start;
	this._end = end;
};
$hxClasses["verb.geom.Line"] = verb_geom_Line;
verb_geom_Line.__name__ = ["verb","geom","Line"];
verb_geom_Line.__super__ = verb_geom_NurbsCurve;
verb_geom_Line.prototype = $extend(verb_geom_NurbsCurve.prototype,{
	start: function() {
		return this._start;
	}
	,end: function() {
		return this._end;
	}
	,__class__: verb_geom_Line
});
var verb_geom_RevolvedSurface = $hx_exports.geom.RevolvedSurface = function(profile,center,axis,angle) {
	verb_geom_NurbsSurface.call(this,verb_eval_Make.revolvedSurface(profile.asNurbs(),center,axis,angle));
	this._profile = profile;
	this._center = center;
	this._axis = axis;
	this._angle = angle;
};
$hxClasses["verb.geom.RevolvedSurface"] = verb_geom_RevolvedSurface;
verb_geom_RevolvedSurface.__name__ = ["verb","geom","RevolvedSurface"];
verb_geom_RevolvedSurface.__super__ = verb_geom_NurbsSurface;
verb_geom_RevolvedSurface.prototype = $extend(verb_geom_NurbsSurface.prototype,{
	profile: function() {
		return this._profile;
	}
	,center: function() {
		return this._center;
	}
	,axis: function() {
		return this._center;
	}
	,angle: function() {
		return this._angle;
	}
	,__class__: verb_geom_RevolvedSurface
});
var verb_geom_SphericalSurface = $hx_exports.geom.SphericalSurface = function(center,radius) {
	verb_geom_NurbsSurface.call(this,verb_eval_Make.sphericalSurface(center,[0,0,1],[1,0,0],radius));
	this._center = center;
	this._radius = radius;
};
$hxClasses["verb.geom.SphericalSurface"] = verb_geom_SphericalSurface;
verb_geom_SphericalSurface.__name__ = ["verb","geom","SphericalSurface"];
verb_geom_SphericalSurface.__super__ = verb_geom_NurbsSurface;
verb_geom_SphericalSurface.prototype = $extend(verb_geom_NurbsSurface.prototype,{
	center: function() {
		return this._center;
	}
	,radius: function() {
		return this._radius;
	}
	,__class__: verb_geom_SphericalSurface
});
var verb_geom_SweptSurface = $hx_exports.geom.SweptSurface = function(profile,rail) {
	verb_geom_NurbsSurface.call(this,verb_eval_Make.rationalTranslationalSurface(profile.asNurbs(),rail.asNurbs()));
	this._profile = profile;
	this._rail = rail;
};
$hxClasses["verb.geom.SweptSurface"] = verb_geom_SweptSurface;
verb_geom_SweptSurface.__name__ = ["verb","geom","SweptSurface"];
verb_geom_SweptSurface.__super__ = verb_geom_NurbsSurface;
verb_geom_SweptSurface.prototype = $extend(verb_geom_NurbsSurface.prototype,{
	profile: function() {
		return this._profile;
	}
	,rail: function() {
		return this._rail;
	}
	,__class__: verb_geom_SweptSurface
});
function $iterator(o) { if( o instanceof Array ) return function() { return HxOverrides.iter(o); }; return typeof(o.iterator) == 'function' ? $bind(o,o.iterator) : o.iterator; }
var $_, $fid = 0;
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $fid++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = function(){ return f.method.apply(f.scope, arguments); }; f.scope = o; f.method = m; o.hx__closures__[m.__id__] = f; } return f; }
$hxClasses.Math = Math;
String.prototype.__class__ = $hxClasses.String = String;
String.__name__ = ["String"];
$hxClasses.Array = Array;
Array.__name__ = ["Array"];
Date.prototype.__class__ = $hxClasses.Date = Date;
Date.__name__ = ["Date"];
var Int = $hxClasses.Int = { __name__ : ["Int"]};
var Dynamic = $hxClasses.Dynamic = { __name__ : ["Dynamic"]};
var Float = $hxClasses.Float = Number;
Float.__name__ = ["Float"];
var Bool = $hxClasses.Bool = Boolean;
Bool.__ename__ = ["Bool"];
var Class = $hxClasses.Class = { __name__ : ["Class"]};
var Enum = { };
if(Array.prototype.map == null) Array.prototype.map = function(f) {
	var a = [];
	var _g1 = 0;
	var _g = this.length;
	while(_g1 < _g) {
		var i = _g1++;
		a[i] = f(this[i]);
	}
	return a;
};
if(Array.prototype.filter == null) Array.prototype.filter = function(f1) {
	var a1 = [];
	var _g11 = 0;
	var _g2 = this.length;
	while(_g11 < _g2) {
		var i1 = _g11++;
		var e = this[i1];
		if(f1(e)) a1.push(e);
	}
	return a1;
};
var __map_reserved = {}
var ArrayBuffer = $global.ArrayBuffer || js_html_compat_ArrayBuffer;
if(ArrayBuffer.prototype.slice == null) ArrayBuffer.prototype.slice = js_html_compat_ArrayBuffer.sliceImpl;
var DataView = $global.DataView || js_html_compat_DataView;
var Uint8Array = $global.Uint8Array || js_html_compat_Uint8Array._new;
// var global = window;
(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var setImmediate;

    function addFromSetImmediateArguments(args) {
        tasksByHandle[nextHandle] = partiallyApplied.apply(undefined, args);
        return nextHandle++;
    }

    // This function accepts the same arguments as setImmediate, but
    // returns a function that requires no arguments.
    function partiallyApplied(handler) {
        var args = [].slice.call(arguments, 1);
        return function() {
            if (typeof handler === "function") {
                handler.apply(undefined, args);
            } else {
                (new Function("" + handler))();
            }
        };
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(partiallyApplied(runIfPresent, handle), 0);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    task();
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function installNextTickImplementation() {
        setImmediate = function() {
            var handle = addFromSetImmediateArguments(arguments);
            process.nextTick(partiallyApplied(runIfPresent, handle));
            return handle;
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        setImmediate = function() {
            var handle = addFromSetImmediateArguments(arguments);
            global.postMessage(messagePrefix + handle, "*");
            return handle;
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        setImmediate = function() {
            var handle = addFromSetImmediateArguments(arguments);
            channel.port2.postMessage(handle);
            return handle;
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        setImmediate = function() {
            var handle = addFromSetImmediateArguments(arguments);
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
            return handle;
        };
    }

    function installSetTimeoutImplementation() {
        setImmediate = function() {
            var handle = addFromSetImmediateArguments(arguments);
            setTimeout(partiallyApplied(runIfPresent, handle), 0);
            return handle;
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 6–8
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(new Function("return this")()));
;
haxe_Serializer.USE_CACHE = false;
haxe_Serializer.USE_ENUM_INDEX = false;
haxe_Serializer.BASE64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789%:";
haxe_Unserializer.DEFAULT_RESOLVER = Type;
haxe_Unserializer.BASE64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789%:";
haxe_ds_ObjectMap.count = 0;
haxe_io_FPHelper.i64tmp = (function($this) {
	var $r;
	var x = new haxe__$Int64__$_$_$Int64(0,0);
	$r = x;
	return $r;
}(this));
js_Boot.__toStr = {}.toString;
js_html_compat_Uint8Array.BYTES_PER_ELEMENT = 1;
promhx_base_EventLoop.queue = new List();
verb_core_Binomial.memo = new haxe_ds_IntMap();
verb_core_Constants.TOLERANCE = 1e-6;
verb_core_Constants.EPSILON = 1e-10;
verb_core_Constants.VERSION = "2.0.0";
verb_eval_Analyze.Tvalues = [[],[],[-0.5773502691896257645091487805019574556476,0.5773502691896257645091487805019574556476],[0,-0.7745966692414833770358530799564799221665,0.7745966692414833770358530799564799221665],[-0.3399810435848562648026657591032446872005,0.3399810435848562648026657591032446872005,-0.8611363115940525752239464888928095050957,0.8611363115940525752239464888928095050957],[0,-0.5384693101056830910363144207002088049672,0.5384693101056830910363144207002088049672,-0.9061798459386639927976268782993929651256,0.9061798459386639927976268782993929651256],[0.6612093864662645136613995950199053470064,-0.6612093864662645136613995950199053470064,-0.2386191860831969086305017216807119354186,0.2386191860831969086305017216807119354186,-0.9324695142031520278123015544939946091347,0.9324695142031520278123015544939946091347],[0,0.4058451513773971669066064120769614633473,-0.4058451513773971669066064120769614633473,-0.7415311855993944398638647732807884070741,0.7415311855993944398638647732807884070741,-0.9491079123427585245261896840478512624007,0.9491079123427585245261896840478512624007],[-0.1834346424956498049394761423601839806667,0.1834346424956498049394761423601839806667,-0.5255324099163289858177390491892463490419,0.5255324099163289858177390491892463490419,-0.7966664774136267395915539364758304368371,0.7966664774136267395915539364758304368371,-0.9602898564975362316835608685694729904282,0.9602898564975362316835608685694729904282],[0,-0.8360311073266357942994297880697348765441,0.8360311073266357942994297880697348765441,-0.9681602395076260898355762029036728700494,0.9681602395076260898355762029036728700494,-0.3242534234038089290385380146433366085719,0.3242534234038089290385380146433366085719,-0.6133714327005903973087020393414741847857,0.6133714327005903973087020393414741847857],[-0.1488743389816312108848260011297199846175,0.1488743389816312108848260011297199846175,-0.4333953941292471907992659431657841622000,0.4333953941292471907992659431657841622000,-0.6794095682990244062343273651148735757692,0.6794095682990244062343273651148735757692,-0.8650633666889845107320966884234930485275,0.8650633666889845107320966884234930485275,-0.9739065285171717200779640120844520534282,0.9739065285171717200779640120844520534282],[0,-0.2695431559523449723315319854008615246796,0.2695431559523449723315319854008615246796,-0.5190961292068118159257256694586095544802,0.5190961292068118159257256694586095544802,-0.7301520055740493240934162520311534580496,0.7301520055740493240934162520311534580496,-0.8870625997680952990751577693039272666316,0.8870625997680952990751577693039272666316,-0.9782286581460569928039380011228573907714,0.9782286581460569928039380011228573907714],[-0.1252334085114689154724413694638531299833,0.1252334085114689154724413694638531299833,-0.3678314989981801937526915366437175612563,0.3678314989981801937526915366437175612563,-0.5873179542866174472967024189405342803690,0.5873179542866174472967024189405342803690,-0.7699026741943046870368938332128180759849,0.7699026741943046870368938332128180759849,-0.9041172563704748566784658661190961925375,0.9041172563704748566784658661190961925375,-0.9815606342467192506905490901492808229601,0.9815606342467192506905490901492808229601],[0,-0.2304583159551347940655281210979888352115,0.2304583159551347940655281210979888352115,-0.4484927510364468528779128521276398678019,0.4484927510364468528779128521276398678019,-0.6423493394403402206439846069955156500716,0.6423493394403402206439846069955156500716,-0.8015780907333099127942064895828598903056,0.8015780907333099127942064895828598903056,-0.9175983992229779652065478365007195123904,0.9175983992229779652065478365007195123904,-0.9841830547185881494728294488071096110649,0.9841830547185881494728294488071096110649],[-0.1080549487073436620662446502198347476119,0.1080549487073436620662446502198347476119,-0.3191123689278897604356718241684754668342,0.3191123689278897604356718241684754668342,-0.5152486363581540919652907185511886623088,0.5152486363581540919652907185511886623088,-0.6872929048116854701480198030193341375384,0.6872929048116854701480198030193341375384,-0.8272013150697649931897947426503949610397,0.8272013150697649931897947426503949610397,-0.9284348836635735173363911393778742644770,0.9284348836635735173363911393778742644770,-0.9862838086968123388415972667040528016760,0.9862838086968123388415972667040528016760],[0,-0.2011940939974345223006283033945962078128,0.2011940939974345223006283033945962078128,-0.3941513470775633698972073709810454683627,0.3941513470775633698972073709810454683627,-0.5709721726085388475372267372539106412383,0.5709721726085388475372267372539106412383,-0.7244177313601700474161860546139380096308,0.7244177313601700474161860546139380096308,-0.8482065834104272162006483207742168513662,0.8482065834104272162006483207742168513662,-0.9372733924007059043077589477102094712439,0.9372733924007059043077589477102094712439,-0.9879925180204854284895657185866125811469,0.9879925180204854284895657185866125811469],[-0.0950125098376374401853193354249580631303,0.0950125098376374401853193354249580631303,-0.2816035507792589132304605014604961064860,0.2816035507792589132304605014604961064860,-0.4580167776572273863424194429835775735400,0.4580167776572273863424194429835775735400,-0.6178762444026437484466717640487910189918,0.6178762444026437484466717640487910189918,-0.7554044083550030338951011948474422683538,0.7554044083550030338951011948474422683538,-0.8656312023878317438804678977123931323873,0.8656312023878317438804678977123931323873,-0.9445750230732325760779884155346083450911,0.9445750230732325760779884155346083450911,-0.9894009349916499325961541734503326274262,0.9894009349916499325961541734503326274262],[0,-0.1784841814958478558506774936540655574754,0.1784841814958478558506774936540655574754,-0.3512317634538763152971855170953460050405,0.3512317634538763152971855170953460050405,-0.5126905370864769678862465686295518745829,0.5126905370864769678862465686295518745829,-0.6576711592166907658503022166430023351478,0.6576711592166907658503022166430023351478,-0.7815140038968014069252300555204760502239,0.7815140038968014069252300555204760502239,-0.8802391537269859021229556944881556926234,0.8802391537269859021229556944881556926234,-0.9506755217687677612227169578958030214433,0.9506755217687677612227169578958030214433,-0.9905754753144173356754340199406652765077,0.9905754753144173356754340199406652765077],[-0.0847750130417353012422618529357838117333,0.0847750130417353012422618529357838117333,-0.2518862256915055095889728548779112301628,0.2518862256915055095889728548779112301628,-0.4117511614628426460359317938330516370789,0.4117511614628426460359317938330516370789,-0.5597708310739475346078715485253291369276,0.5597708310739475346078715485253291369276,-0.6916870430603532078748910812888483894522,0.6916870430603532078748910812888483894522,-0.8037049589725231156824174550145907971032,0.8037049589725231156824174550145907971032,-0.8926024664975557392060605911271455154078,0.8926024664975557392060605911271455154078,-0.9558239495713977551811958929297763099728,0.9558239495713977551811958929297763099728,-0.9915651684209309467300160047061507702525,0.9915651684209309467300160047061507702525],[0,-0.1603586456402253758680961157407435495048,0.1603586456402253758680961157407435495048,-0.3165640999636298319901173288498449178922,0.3165640999636298319901173288498449178922,-0.4645707413759609457172671481041023679762,0.4645707413759609457172671481041023679762,-0.6005453046616810234696381649462392798683,0.6005453046616810234696381649462392798683,-0.7209661773352293786170958608237816296571,0.7209661773352293786170958608237816296571,-0.8227146565371428249789224867127139017745,0.8227146565371428249789224867127139017745,-0.9031559036148179016426609285323124878093,0.9031559036148179016426609285323124878093,-0.9602081521348300308527788406876515266150,0.9602081521348300308527788406876515266150,-0.9924068438435844031890176702532604935893,0.9924068438435844031890176702532604935893],[-0.0765265211334973337546404093988382110047,0.0765265211334973337546404093988382110047,-0.2277858511416450780804961953685746247430,0.2277858511416450780804961953685746247430,-0.3737060887154195606725481770249272373957,0.3737060887154195606725481770249272373957,-0.5108670019508270980043640509552509984254,0.5108670019508270980043640509552509984254,-0.6360536807265150254528366962262859367433,0.6360536807265150254528366962262859367433,-0.7463319064601507926143050703556415903107,0.7463319064601507926143050703556415903107,-0.8391169718222188233945290617015206853296,0.8391169718222188233945290617015206853296,-0.9122344282513259058677524412032981130491,0.9122344282513259058677524412032981130491,-0.9639719272779137912676661311972772219120,0.9639719272779137912676661311972772219120,-0.9931285991850949247861223884713202782226,0.9931285991850949247861223884713202782226],[0,-0.1455618541608950909370309823386863301163,0.1455618541608950909370309823386863301163,-0.2880213168024010966007925160646003199090,0.2880213168024010966007925160646003199090,-0.4243421202074387835736688885437880520964,0.4243421202074387835736688885437880520964,-0.5516188358872198070590187967243132866220,0.5516188358872198070590187967243132866220,-0.6671388041974123193059666699903391625970,0.6671388041974123193059666699903391625970,-0.7684399634756779086158778513062280348209,0.7684399634756779086158778513062280348209,-0.8533633645833172836472506385875676702761,0.8533633645833172836472506385875676702761,-0.9200993341504008287901871337149688941591,0.9200993341504008287901871337149688941591,-0.9672268385663062943166222149076951614246,0.9672268385663062943166222149076951614246,-0.9937521706203895002602420359379409291933,0.9937521706203895002602420359379409291933],[-0.0697392733197222212138417961186280818222,0.0697392733197222212138417961186280818222,-0.2078604266882212854788465339195457342156,0.2078604266882212854788465339195457342156,-0.3419358208920842251581474204273796195591,0.3419358208920842251581474204273796195591,-0.4693558379867570264063307109664063460953,0.4693558379867570264063307109664063460953,-0.5876404035069115929588769276386473488776,0.5876404035069115929588769276386473488776,-0.6944872631866827800506898357622567712673,0.6944872631866827800506898357622567712673,-0.7878168059792081620042779554083515213881,0.7878168059792081620042779554083515213881,-0.8658125777203001365364256370193787290847,0.8658125777203001365364256370193787290847,-0.9269567721871740005206929392590531966353,0.9269567721871740005206929392590531966353,-0.9700604978354287271239509867652687108059,0.9700604978354287271239509867652687108059,-0.9942945854823992920730314211612989803930,0.9942945854823992920730314211612989803930],[0,-0.1332568242984661109317426822417661370104,0.1332568242984661109317426822417661370104,-0.2641356809703449305338695382833096029790,0.2641356809703449305338695382833096029790,-0.3903010380302908314214888728806054585780,0.3903010380302908314214888728806054585780,-0.5095014778460075496897930478668464305448,0.5095014778460075496897930478668464305448,-0.6196098757636461563850973116495956533871,0.6196098757636461563850973116495956533871,-0.7186613631319501944616244837486188483299,0.7186613631319501944616244837486188483299,-0.8048884016188398921511184069967785579414,0.8048884016188398921511184069967785579414,-0.8767523582704416673781568859341456716389,0.8767523582704416673781568859341456716389,-0.9329710868260161023491969890384229782357,0.9329710868260161023491969890384229782357,-0.9725424712181152319560240768207773751816,0.9725424712181152319560240768207773751816,-0.9947693349975521235239257154455743605736,0.9947693349975521235239257154455743605736],[-0.0640568928626056260850430826247450385909,0.0640568928626056260850430826247450385909,-0.1911188674736163091586398207570696318404,0.1911188674736163091586398207570696318404,-0.3150426796961633743867932913198102407864,0.3150426796961633743867932913198102407864,-0.4337935076260451384870842319133497124524,0.4337935076260451384870842319133497124524,-0.5454214713888395356583756172183723700107,0.5454214713888395356583756172183723700107,-0.6480936519369755692524957869107476266696,0.6480936519369755692524957869107476266696,-0.7401241915785543642438281030999784255232,0.7401241915785543642438281030999784255232,-0.8200019859739029219539498726697452080761,0.8200019859739029219539498726697452080761,-0.8864155270044010342131543419821967550873,0.8864155270044010342131543419821967550873,-0.9382745520027327585236490017087214496548,0.9382745520027327585236490017087214496548,-0.9747285559713094981983919930081690617411,0.9747285559713094981983919930081690617411,-0.9951872199970213601799974097007368118745,0.9951872199970213601799974097007368118745]];
verb_eval_Analyze.Cvalues = [[],[],[1.0,1.0],[0.8888888888888888888888888888888888888888,0.5555555555555555555555555555555555555555,0.5555555555555555555555555555555555555555],[0.6521451548625461426269360507780005927646,0.6521451548625461426269360507780005927646,0.3478548451374538573730639492219994072353,0.3478548451374538573730639492219994072353],[0.5688888888888888888888888888888888888888,0.4786286704993664680412915148356381929122,0.4786286704993664680412915148356381929122,0.2369268850561890875142640407199173626432,0.2369268850561890875142640407199173626432],[0.3607615730481386075698335138377161116615,0.3607615730481386075698335138377161116615,0.4679139345726910473898703439895509948116,0.4679139345726910473898703439895509948116,0.1713244923791703450402961421727328935268,0.1713244923791703450402961421727328935268],[0.4179591836734693877551020408163265306122,0.3818300505051189449503697754889751338783,0.3818300505051189449503697754889751338783,0.2797053914892766679014677714237795824869,0.2797053914892766679014677714237795824869,0.1294849661688696932706114326790820183285,0.1294849661688696932706114326790820183285],[0.3626837833783619829651504492771956121941,0.3626837833783619829651504492771956121941,0.3137066458778872873379622019866013132603,0.3137066458778872873379622019866013132603,0.2223810344533744705443559944262408844301,0.2223810344533744705443559944262408844301,0.1012285362903762591525313543099621901153,0.1012285362903762591525313543099621901153],[0.3302393550012597631645250692869740488788,0.1806481606948574040584720312429128095143,0.1806481606948574040584720312429128095143,0.0812743883615744119718921581105236506756,0.0812743883615744119718921581105236506756,0.3123470770400028400686304065844436655987,0.3123470770400028400686304065844436655987,0.2606106964029354623187428694186328497718,0.2606106964029354623187428694186328497718],[0.2955242247147528701738929946513383294210,0.2955242247147528701738929946513383294210,0.2692667193099963550912269215694693528597,0.2692667193099963550912269215694693528597,0.2190863625159820439955349342281631924587,0.2190863625159820439955349342281631924587,0.1494513491505805931457763396576973324025,0.1494513491505805931457763396576973324025,0.0666713443086881375935688098933317928578,0.0666713443086881375935688098933317928578],[0.2729250867779006307144835283363421891560,0.2628045445102466621806888698905091953727,0.2628045445102466621806888698905091953727,0.2331937645919904799185237048431751394317,0.2331937645919904799185237048431751394317,0.1862902109277342514260976414316558916912,0.1862902109277342514260976414316558916912,0.1255803694649046246346942992239401001976,0.1255803694649046246346942992239401001976,0.0556685671161736664827537204425485787285,0.0556685671161736664827537204425485787285],[0.2491470458134027850005624360429512108304,0.2491470458134027850005624360429512108304,0.2334925365383548087608498989248780562594,0.2334925365383548087608498989248780562594,0.2031674267230659217490644558097983765065,0.2031674267230659217490644558097983765065,0.1600783285433462263346525295433590718720,0.1600783285433462263346525295433590718720,0.1069393259953184309602547181939962242145,0.1069393259953184309602547181939962242145,0.0471753363865118271946159614850170603170,0.0471753363865118271946159614850170603170],[0.2325515532308739101945895152688359481566,0.2262831802628972384120901860397766184347,0.2262831802628972384120901860397766184347,0.2078160475368885023125232193060527633865,0.2078160475368885023125232193060527633865,0.1781459807619457382800466919960979955128,0.1781459807619457382800466919960979955128,0.1388735102197872384636017768688714676218,0.1388735102197872384636017768688714676218,0.0921214998377284479144217759537971209236,0.0921214998377284479144217759537971209236,0.0404840047653158795200215922009860600419,0.0404840047653158795200215922009860600419],[0.2152638534631577901958764433162600352749,0.2152638534631577901958764433162600352749,0.2051984637212956039659240656612180557103,0.2051984637212956039659240656612180557103,0.1855383974779378137417165901251570362489,0.1855383974779378137417165901251570362489,0.1572031671581935345696019386238421566056,0.1572031671581935345696019386238421566056,0.1215185706879031846894148090724766259566,0.1215185706879031846894148090724766259566,0.0801580871597602098056332770628543095836,0.0801580871597602098056332770628543095836,0.0351194603317518630318328761381917806197,0.0351194603317518630318328761381917806197],[0.2025782419255612728806201999675193148386,0.1984314853271115764561183264438393248186,0.1984314853271115764561183264438393248186,0.1861610000155622110268005618664228245062,0.1861610000155622110268005618664228245062,0.1662692058169939335532008604812088111309,0.1662692058169939335532008604812088111309,0.1395706779261543144478047945110283225208,0.1395706779261543144478047945110283225208,0.1071592204671719350118695466858693034155,0.1071592204671719350118695466858693034155,0.0703660474881081247092674164506673384667,0.0703660474881081247092674164506673384667,0.0307532419961172683546283935772044177217,0.0307532419961172683546283935772044177217],[0.1894506104550684962853967232082831051469,0.1894506104550684962853967232082831051469,0.1826034150449235888667636679692199393835,0.1826034150449235888667636679692199393835,0.1691565193950025381893120790303599622116,0.1691565193950025381893120790303599622116,0.1495959888165767320815017305474785489704,0.1495959888165767320815017305474785489704,0.1246289712555338720524762821920164201448,0.1246289712555338720524762821920164201448,0.0951585116824927848099251076022462263552,0.0951585116824927848099251076022462263552,0.0622535239386478928628438369943776942749,0.0622535239386478928628438369943776942749,0.0271524594117540948517805724560181035122,0.0271524594117540948517805724560181035122],[0.1794464703562065254582656442618856214487,0.1765627053669926463252709901131972391509,0.1765627053669926463252709901131972391509,0.1680041021564500445099706637883231550211,0.1680041021564500445099706637883231550211,0.1540457610768102880814315948019586119404,0.1540457610768102880814315948019586119404,0.1351363684685254732863199817023501973721,0.1351363684685254732863199817023501973721,0.1118838471934039710947883856263559267358,0.1118838471934039710947883856263559267358,0.0850361483171791808835353701910620738504,0.0850361483171791808835353701910620738504,0.0554595293739872011294401653582446605128,0.0554595293739872011294401653582446605128,0.0241483028685479319601100262875653246916,0.0241483028685479319601100262875653246916],[0.1691423829631435918406564701349866103341,0.1691423829631435918406564701349866103341,0.1642764837458327229860537764659275904123,0.1642764837458327229860537764659275904123,0.1546846751262652449254180038363747721932,0.1546846751262652449254180038363747721932,0.1406429146706506512047313037519472280955,0.1406429146706506512047313037519472280955,0.1225552067114784601845191268002015552281,0.1225552067114784601845191268002015552281,0.1009420441062871655628139849248346070628,0.1009420441062871655628139849248346070628,0.0764257302548890565291296776166365256053,0.0764257302548890565291296776166365256053,0.0497145488949697964533349462026386416808,0.0497145488949697964533349462026386416808,0.0216160135264833103133427102664524693876,0.0216160135264833103133427102664524693876],[0.1610544498487836959791636253209167350399,0.1589688433939543476499564394650472016787,0.1589688433939543476499564394650472016787,0.1527660420658596667788554008976629984610,0.1527660420658596667788554008976629984610,0.1426067021736066117757461094419029724756,0.1426067021736066117757461094419029724756,0.1287539625393362276755157848568771170558,0.1287539625393362276755157848568771170558,0.1115666455473339947160239016817659974813,0.1115666455473339947160239016817659974813,0.0914900216224499994644620941238396526609,0.0914900216224499994644620941238396526609,0.0690445427376412265807082580060130449618,0.0690445427376412265807082580060130449618,0.0448142267656996003328381574019942119517,0.0448142267656996003328381574019942119517,0.0194617882297264770363120414644384357529,0.0194617882297264770363120414644384357529],[0.1527533871307258506980843319550975934919,0.1527533871307258506980843319550975934919,0.1491729864726037467878287370019694366926,0.1491729864726037467878287370019694366926,0.1420961093183820513292983250671649330345,0.1420961093183820513292983250671649330345,0.1316886384491766268984944997481631349161,0.1316886384491766268984944997481631349161,0.1181945319615184173123773777113822870050,0.1181945319615184173123773777113822870050,0.1019301198172404350367501354803498761666,0.1019301198172404350367501354803498761666,0.0832767415767047487247581432220462061001,0.0832767415767047487247581432220462061001,0.0626720483341090635695065351870416063516,0.0626720483341090635695065351870416063516,0.0406014298003869413310399522749321098790,0.0406014298003869413310399522749321098790,0.0176140071391521183118619623518528163621,0.0176140071391521183118619623518528163621],[0.1460811336496904271919851476833711882448,0.1445244039899700590638271665537525436099,0.1445244039899700590638271665537525436099,0.1398873947910731547221334238675831108927,0.1398873947910731547221334238675831108927,0.1322689386333374617810525744967756043290,0.1322689386333374617810525744967756043290,0.1218314160537285341953671771257335983563,0.1218314160537285341953671771257335983563,0.1087972991671483776634745780701056420336,0.1087972991671483776634745780701056420336,0.0934444234560338615532897411139320884835,0.0934444234560338615532897411139320884835,0.0761001136283793020170516533001831792261,0.0761001136283793020170516533001831792261,0.0571344254268572082836358264724479574912,0.0571344254268572082836358264724479574912,0.0369537897708524937999506682993296661889,0.0369537897708524937999506682993296661889,0.0160172282577743333242246168584710152658,0.0160172282577743333242246168584710152658],[0.1392518728556319933754102483418099578739,0.1392518728556319933754102483418099578739,0.1365414983460151713525738312315173965863,0.1365414983460151713525738312315173965863,0.1311735047870623707329649925303074458757,0.1311735047870623707329649925303074458757,0.1232523768105124242855609861548144719594,0.1232523768105124242855609861548144719594,0.1129322960805392183934006074217843191142,0.1129322960805392183934006074217843191142,0.1004141444428809649320788378305362823508,0.1004141444428809649320788378305362823508,0.0859416062170677274144436813727028661891,0.0859416062170677274144436813727028661891,0.0697964684245204880949614189302176573987,0.0697964684245204880949614189302176573987,0.0522933351526832859403120512732112561121,0.0522933351526832859403120512732112561121,0.0337749015848141547933022468659129013491,0.0337749015848141547933022468659129013491,0.0146279952982722006849910980471854451902,0.0146279952982722006849910980471854451902],[0.1336545721861061753514571105458443385831,0.1324620394046966173716424647033169258050,0.1324620394046966173716424647033169258050,0.1289057221880821499785953393997936532597,0.1289057221880821499785953393997936532597,0.1230490843067295304675784006720096548158,0.1230490843067295304675784006720096548158,0.1149966402224113649416435129339613014914,0.1149966402224113649416435129339613014914,0.1048920914645414100740861850147438548584,0.1048920914645414100740861850147438548584,0.0929157660600351474770186173697646486034,0.0929157660600351474770186173697646486034,0.0792814117767189549228925247420432269137,0.0792814117767189549228925247420432269137,0.0642324214085258521271696151589109980391,0.0642324214085258521271696151589109980391,0.0480376717310846685716410716320339965612,0.0480376717310846685716410716320339965612,0.0309880058569794443106942196418845053837,0.0309880058569794443106942196418845053837,0.0134118594871417720813094934586150649766,0.0134118594871417720813094934586150649766],[0.1279381953467521569740561652246953718517,0.1279381953467521569740561652246953718517,0.1258374563468282961213753825111836887264,0.1258374563468282961213753825111836887264,0.1216704729278033912044631534762624256070,0.1216704729278033912044631534762624256070,0.1155056680537256013533444839067835598622,0.1155056680537256013533444839067835598622,0.1074442701159656347825773424466062227946,0.1074442701159656347825773424466062227946,0.0976186521041138882698806644642471544279,0.0976186521041138882698806644642471544279,0.0861901615319532759171852029837426671850,0.0861901615319532759171852029837426671850,0.0733464814110803057340336152531165181193,0.0733464814110803057340336152531165181193,0.0592985849154367807463677585001085845412,0.0592985849154367807463677585001085845412,0.0442774388174198061686027482113382288593,0.0442774388174198061686027482113382288593,0.0285313886289336631813078159518782864491,0.0285313886289336631813078159518782864491,0.0123412297999871995468056670700372915759,0.0123412297999871995468056670700372915759]];
verb_exe_Dispatcher.THREADS = 1;
verb_exe_Dispatcher._init = false;
verb_exe_WorkerPool.basePath = "";
verb_exe__$WorkerPool_Work.uuid = 0;
verb_Verb.main();
})(typeof console != "undefined" ? console : {log:function(){}}, verb, typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);


    return verb;

});

/***/ }),

/***/ "./src/environments/environment.ts":
/*!*****************************************!*\
  !*** ./src/environments/environment.ts ***!
  \*****************************************/
/*! exports provided: environment */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "environment", function() { return environment; });
// This file can be replaced during build by using the `fileReplacements` array.
// `ng build --prod` replaces `environment.ts` with `environment.prod.ts`.
// The list of file replacements can be found in `angular.json`.
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};
const environment = {
    production: false
};
/*
 * For easier debugging in development mode, you can import the following file
 * to ignore zone related error stack frames such as `zone.run`, `zoneDelegate.invokeTask`.
 *
 * This import should be commented out in production mode because it will have a negative impact
 * on performance if an error is thrown.
 */
// import 'zone.js/dist/zone-error';  // Included with Angular CLI.


/***/ }),

/***/ "./src/main.ts":
/*!*********************!*\
  !*** ./src/main.ts ***!
  \*********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
/* harmony import */ var _angular_platform_browser_dynamic__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/platform-browser-dynamic */ "./node_modules/@angular/platform-browser-dynamic/fesm2015/platform-browser-dynamic.js");
/* harmony import */ var _app_app_module__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./app/app.module */ "./src/app/app.module.ts");
/* harmony import */ var _environments_environment__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./environments/environment */ "./src/environments/environment.ts");
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};




if (_environments_environment__WEBPACK_IMPORTED_MODULE_3__["environment"].production) {
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["enableProdMode"])();
}
window['CESIUM_BASE_URL'] = 'assets/cesium';
Object(_angular_platform_browser_dynamic__WEBPACK_IMPORTED_MODULE_1__["platformBrowserDynamic"])().bootstrapModule(_app_app_module__WEBPACK_IMPORTED_MODULE_2__["AppModule"])
    .catch(err => console.log(err));


/***/ }),

/***/ 0:
/*!***************************!*\
  !*** multi ./src/main.ts ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! C:\Users\akibdpt\Documents\Angular\mobius-viewer\src\main.ts */"./src/main.ts");


/***/ })

},[[0,"runtime","vendor"]]]);
//# sourceMappingURL=main-es2015.js.map